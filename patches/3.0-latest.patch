diff -uNr samba-3.0alpha21.orig/examples/LDAP/README samba-3.0alpha21/examples/LDAP/README
--- samba-3.0alpha21.orig/examples/LDAP/README	2003-02-16 19:06:30.000000000 -0600
+++ samba-3.0alpha21/examples/LDAP/README	2003-02-16 19:05:45.000000000 -0600
@@ -5,7 +5,7 @@
 !==
 
 This is a quick and dirty means of storing smbpasswd entries
-in smbpasswd.  Samba 2.2.x does not have any ability to grab
+in LDAP.  Samba 2.2.x does not have any ability to grab
 this information directly from LDAP so you will need to
 periodically generate an smbpasswd from an ldapsearch
 "(objectclass=smbPasswordEntry)".
diff -uNr samba-3.0alpha21.orig/examples/LDAP/samba.schema samba-3.0alpha21/examples/LDAP/samba.schema
--- samba-3.0alpha21.orig/examples/LDAP/samba.schema	2003-02-16 19:06:30.000000000 -0600
+++ samba-3.0alpha21/examples/LDAP/samba.schema	2003-02-16 19:05:45.000000000 -0600
@@ -142,11 +142,11 @@
 ##
 ## Used for Winbind experimentation
 ##
-objectclass ( 1.3.6.1.4.1.7165.1.2.2.3 NAME 'uidPool' SUP top AUXILIARY
-	DESC 'Pool for allocating UNIX uids'
-	MUST ( uidNumber $ cn ) )
+#objectclass ( 1.3.6.1.4.1.7165.1.2.2.3 NAME 'uidPool' SUP top AUXILIARY
+#	DESC 'Pool for allocating UNIX uids'
+#	MUST ( uidNumber $ cn ) )
 
-objectclass ( 1.3.6.1.4.1.7165.1.2.2.4 NAME 'gidPool' SUP top AUXILIARY
-	DESC 'Pool for allocating UNIX gids'
-	MUST ( gidNumber $ cn ) )
+#objectclass ( 1.3.6.1.4.1.7165.1.2.2.4 NAME 'gidPool' SUP top AUXILIARY
+#	DESC 'Pool for allocating UNIX gids'
+#	MUST ( gidNumber $ cn ) )
 
diff -uNr samba-3.0alpha21.orig/examples/VFS/Makefile.in samba-3.0alpha21/examples/VFS/Makefile.in
--- samba-3.0alpha21.orig/examples/VFS/Makefile.in	2003-02-16 19:06:30.000000000 -0600
+++ samba-3.0alpha21/examples/VFS/Makefile.in	2003-02-16 19:05:45.000000000 -0600
@@ -3,7 +3,7 @@
 CPPFLAGS	= @CPPFLAGS@
 LDFLAGS		= @LDFLAGS@
 LDSHFLAGS	= -shared
-srcdir		= @builddir@
+srcdir		= ../../source/
 FLAGS		=  $(CFLAGS) -Iinclude -I$(srcdir)/include -I$(srcdir)/ubiqx -I$(srcdir)/smbwrapper  -I. $(CPPFLAGS) -I$(srcdir)
 
 # Auto target
diff -uNr samba-3.0alpha21.orig/examples/genlogon/genlogon.pl samba-3.0alpha21/examples/genlogon/genlogon.pl
--- samba-3.0alpha21.orig/examples/genlogon/genlogon.pl	1969-12-31 18:00:00.000000000 -0600
+++ samba-3.0alpha21/examples/genlogon/genlogon.pl	2003-02-16 19:05:45.000000000 -0600
@@ -0,0 +1,71 @@
+#!/usr/bin/perl
+#
+# genlogon.pl
+#
+# Perl script to generate user logon scripts on the fly, when users
+# connect from a Windows client.  This script should be called from smb.conf
+# with the %U, %G and %L parameters. I.e:
+#
+#	root preexec = genlogon.pl %U %G %L
+#
+# The script generated will perform
+# the following:
+#
+# 1. Log the user connection to /var/log/samba/netlogon.log
+# 2. Set the PC's time to the Linux server time (which is maintained
+#    daily to the National Institute of Standard's Atomic clock on the
+#    internet.
+# 3. Connect the user's home drive to H: (H for Home).
+# 4. Connect common drives that everyone uses.
+# 5. Connect group-specific drives for certain user groups.
+# 6. Connect user-specific drives for certain users.
+# 7. Connect network printers.
+
+# Log client connection
+#($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime(time);
+($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime(time);
+open LOG, ">>/var/log/samba/netlogon.log";
+print LOG "$mon/$mday/$year $hour:$min:$sec - User $ARGV[0] logged into $ARGV[1]\n";
+close LOG;
+
+# Start generating logon script
+open LOGON, ">/shared/netlogon/$ARGV[0].bat";
+print LOGON "\@ECHO OFF\r\n";
+
+# Connect shares just use by Software Development group
+if ($ARGV[1] eq "SOFTDEV" || $ARGV[0] eq "softdev")
+{
+	print LOGON "NET USE M: \\\\$ARGV[2]\\SOURCE\r\n";
+}
+
+# Connect shares just use by Technical Support staff
+if ($ARGV[1] eq "SUPPORT" || $ARGV[0] eq "support")
+{
+	print LOGON "NET USE S: \\\\$ARGV[2]\\SUPPORT\r\n";
+}
+
+# Connect shares just used by Administration staff
+If ($ARGV[1] eq "ADMIN" || $ARGV[0] eq "admin")
+{
+	print LOGON "NET USE L: \\\\$ARGV[2]\\ADMIN\r\n";
+	print LOGON "NET USE K: \\\\$ARGV[2]\\MKTING\r\n";
+}
+
+# Now connect Printers.  We handle just two or three users a little
+# differently, because they are the exceptions that have desktop
+# printers on LPT1: - all other user's go to the LaserJet on the
+# server.
+if ($ARGV[0] eq 'jim'
+    || $ARGV[0] eq 'yvonne')
+{
+	print LOGON "NET UsE LPT2: \\\\$ARGV[2]\\LJET3\r\n";
+	print LOGON "NET USE LPT3: \\\\$ARGV[2]\\FAXQ\r\n";
+}
+else
+{
+	print LOGON "NET USE LPT1: \\\\$ARGV[2]\\LJET3\r\n";
+	print LOGON "NET USE LPT3: \\\\$ARGV[2]\\FAXQ\r\n";
+}
+
+# All done! Close the output file.
+close LOGON;
diff -uNr samba-3.0alpha21.orig/examples/libsmbclient/testsmbc.c samba-3.0alpha21/examples/libsmbclient/testsmbc.c
--- samba-3.0alpha21.orig/examples/libsmbclient/testsmbc.c	2003-02-16 19:06:30.000000000 -0600
+++ samba-3.0alpha21/examples/libsmbclient/testsmbc.c	2003-02-16 19:05:45.000000000 -0600
@@ -1,6 +1,5 @@
 /* 
-   Unix SMB/Netbios implementation.
-   Version 2.0
+   Unix SMB/CIFS implementation.
    SMB client library test program
    Copyright (C) Andrew Tridgell 1998
    Copyright (C) Richard Sharpe 2000
@@ -95,74 +94,10 @@
 
   if (argc > 1) {
 
-    /* Try to list the print jobs ... */
+    if ((dh1 = smbc_opendir(argv[1]))<1) {
 
-    if (smbc_list_print_jobs("smb://samba/pclp", print_list_fn) < 0) {
-
-      fprintf(stderr, "Could not list print jobs: %s, %d\n", strerror(errno), errno);
-      exit(1);
-
-    }
-
-    /* Try to delete the last job listed */
-
-    if (global_id > 0) {
-
-      fprintf(stdout, "Trying to delete print job %u\n", global_id);
-
-      if (smbc_unlink_print_job("smb://samba/pclp", global_id) < 0) {
-
-	fprintf(stderr, "Failed to unlink job id %u, %s, %u\n", global_id, 
-		strerror(errno), errno);
-
-	exit(1);
-
-      }
-
-    }
-
-    /* Try to print a file ... */
-
-    if (smbc_print_file("smb://samba/public/testfile2.txt", "smb://samba/pclp") < 0) {
-
-      fprintf(stderr, "Failed to print job: %s %u\n", strerror(errno), errno);
-      exit(1);
-
-    }
-
-    /* Try to delete argv[1] as a file ... */
-    
-    if (smbc_unlink(argv[1]) < 0) {
-
-      fprintf(stderr, "Could not unlink: %s, %s, %d\n",
-	      argv[1], strerror(errno), errno);
-
-      exit(0);
-
-    }
-
-    if ((dh1 = smbc_opendir("smb://"))<1) {
-
-      fprintf(stderr, "Could not open directory: smb://: %s\n",
-	      strerror(errno));
-
-      exit(1);
-
-    }
-
-    if ((dh2 = smbc_opendir("smb://sambanet")) < 0) {
-
-      fprintf(stderr, "Could not open directory: smb://sambanet: %s\n",
-	      strerror(errno));
-
-      exit(1);
-
-    }
-
-    if ((dh3 = smbc_opendir("smb://samba")) < 0) {
-
-      fprintf(stderr, "Could not open directory: smb://samba: %s\n",
-	      strerror(errno));
+      fprintf(stderr, "Could not open directory: %s: %s\n",
+	      argv[1], strerror(errno));
 
       exit(1);
 
@@ -203,62 +138,6 @@
 
     dirp = (char *)dirbuf;
 
-    if ((dirc = smbc_getdents(dh2, (struct smbc_dirent *)dirp, 
-			      sizeof(dirbuf))) < 0) {
-
-      fprintf(stderr, "Problems getting directory entries: %s\n",
-	      strerror(errno));
-
-      exit(1);
-
-    }
-
-    /* Now, process the list of names ... */
-
-    fprintf(stdout, "\nDirectory listing, size = %u\n", dirc);
-
-    while (dirc > 0) {
-
-      dsize = ((struct smbc_dirent *)dirp)->dirlen;
-      fprintf(stdout, "Dir Ent, Type: %u, Name: %s, Comment: %s\n",
-	      ((struct smbc_dirent *)dirp)->smbc_type, 
-	      ((struct smbc_dirent *)dirp)->name, 
-	      ((struct smbc_dirent *)dirp)->comment);
-
-      dirp += dsize;
-      (char *)dirc -= dsize;
-
-    }
-
-    dirp = (char *)dirbuf;
-
-    if ((dirc = smbc_getdents(dh3, (struct smbc_dirent *)dirp, 
-			      sizeof(dirbuf))) < 0) {
-
-      fprintf(stderr, "Problems getting directory entries: %s\n",
-	      strerror(errno));
-
-      exit(1);
-
-    }
-
-    /* Now, process the list of names ... */
-
-    fprintf(stdout, "Directory listing, size = %u\n", dirc);
-
-    while (dirc > 0) {
-
-      dsize = ((struct smbc_dirent *)dirp)->dirlen;
-      fprintf(stdout, "\nDir Ent, Type: %u, Name: %s, Comment: %s\n",
-	      ((struct smbc_dirent *)dirp)->smbc_type, 
-	      ((struct smbc_dirent *)dirp)->name, 
-	      ((struct smbc_dirent *)dirp)->comment);
-
-      (char *)dirp += dsize;
-      (char *)dirc -= dsize;
-
-    }
-
     exit(1);
 
   }
diff -uNr samba-3.0alpha21.orig/examples/libsmbclient/tree.c samba-3.0alpha21/examples/libsmbclient/tree.c
--- samba-3.0alpha21.orig/examples/libsmbclient/tree.c	2003-02-16 19:06:30.000000000 -0600
+++ samba-3.0alpha21/examples/libsmbclient/tree.c	2003-02-16 19:05:45.000000000 -0600
@@ -51,7 +51,8 @@
   /* Ensure that the dialog box is destroyed when the user clicks ok. */
      
   gtk_signal_connect_object (GTK_OBJECT (okay_button), "clicked",
-			     GTK_SIGNAL_FUNC (gtk_widget_destroy), dialog);
+			     GTK_SIGNAL_FUNC (gtk_widget_destroy), 
+			     GTK_OBJECT(dialog));
   gtk_container_add (GTK_CONTAINER (GTK_DIALOG(dialog)->action_area),
 		     okay_button);
 
@@ -744,8 +745,6 @@
 
   /* Now, get the items in smb:/// and add them to the tree */
 
-  dirp = (struct smbc_dirent *)dirbuf;
-
   while ((err = smbc_getdents(dh, (struct smbc_dirent *)dirbuf, 
 			      sizeof(dirbuf))) != 0) {
 
@@ -758,6 +757,8 @@
 
     }
 
+    dirp = (struct smbc_dirent *)dirbuf;
+
     fprintf(stdout, "Dir len: %u\n", err);
 
     while (err > 0) { /* Extract each entry and make a sub-tree */
diff -uNr samba-3.0alpha21.orig/source/Doxyfile samba-3.0alpha21/source/Doxyfile
--- samba-3.0alpha21.orig/source/Doxyfile	2003-02-16 19:06:30.000000000 -0600
+++ samba-3.0alpha21/source/Doxyfile	2003-02-16 19:05:45.000000000 -0600
@@ -5,7 +5,15 @@
 #---------------------------------------------------------------------------
 PROJECT_NAME           = Samba
 PROJECT_NUMBER         = HEAD
+
+# NOTE: By default, Doxygen writes into the dox/ subdirectory of the
+# invocation directory.  If you want to put it somewhere else, for
+# example, to write straight into a webserver directory, then override
+# this variable in a configuration concatenated to this one: Doxygen
+# doesn't mind variables being redefined.
+
 OUTPUT_DIRECTORY       = dox
+
 OUTPUT_LANGUAGE        = English
 EXTRACT_ALL            = YES
 EXTRACT_PRIVATE        = YES
@@ -41,12 +49,11 @@
 MAX_INITIALIZER_LINES  = 30
 OPTIMIZE_OUTPUT_FOR_C  = YES
 SHOW_USED_FILES        = YES
-REFERENCED_RELATION    = YES
 REFERENCED_BY_RELATION = YES
 #---------------------------------------------------------------------------
 # configuration options related to warning and progress messages
 #---------------------------------------------------------------------------
-QUIET                  = NO
+QUIET                  = YES
 WARNINGS               = NO
 WARN_IF_UNDOCUMENTED   = NO
 WARN_FORMAT            = "$file:$line: $text"
@@ -55,7 +62,7 @@
 # configuration options related to the input files
 #---------------------------------------------------------------------------
 INPUT                  = . \
-                         CodingSuggestions mainpage.dox
+                         mainpage.dox
 FILE_PATTERNS          = *.c \
                          *.h \
                          *.idl
@@ -78,7 +85,7 @@
 # configuration options related to the HTML output
 #---------------------------------------------------------------------------
 GENERATE_HTML          = YES
-HTML_OUTPUT            = html
+HTML_OUTPUT            = .
 HTML_HEADER            = 
 HTML_FOOTER            = 
 HTML_STYLESHEET        = 
@@ -145,7 +152,7 @@
 #---------------------------------------------------------------------------
 # configuration options related to the dot tool   
 #---------------------------------------------------------------------------
-HAVE_DOT               = YES
+HAVE_DOT               = NO
 CLASS_GRAPH            = YES
 COLLABORATION_GRAPH    = YES
 TEMPLATE_RELATIONS     = YES
diff -uNr samba-3.0alpha21.orig/source/Makefile.in samba-3.0alpha21/source/Makefile.in
--- samba-3.0alpha21.orig/source/Makefile.in	2003-02-16 19:06:30.000000000 -0600
+++ samba-3.0alpha21/source/Makefile.in	2003-02-16 19:05:45.000000000 -0600
@@ -3,6 +3,7 @@
 # Copyright Andrew Tridgell 1992-1998
 # Copyright (C) 2001 by Martin Pool <mbp@samba.org>
 # Copyright Andrew Barteltt 2002
+# Copyright (C) 2003 Anthony Liguori <aliguor@us.ibm.com>
 ###########################################################################
 
 prefix=@prefix@
@@ -14,6 +15,7 @@
 SHLD=@SHLD@
 CFLAGS=@CFLAGS@
 CPPFLAGS=@CPPFLAGS@
+EXEEXT=@EXEEXT@
 LDFLAGS=@LDFLAGS@
 LDSHFLAGS=@LDSHFLAGS@ @LDFLAGS@ @CFLAGS@
 AWK=@AWK@
@@ -28,6 +30,8 @@
 LINK=$(CC) $(FLAGS) $(LDFLAGS)
 
 INSTALLCMD=@INSTALL@
+INSTALLCLIENTCMD_SH=@INSTALLCLIENTCMD_SH@
+INSTALLCLIENTCMD_A=@INSTALLCLIENTCMD_A@
 
 VPATH=@srcdir@
 srcdir=@srcdir@
@@ -47,6 +51,8 @@
 SBINDIR = @sbindir@
 LIBDIR = @libdir@
 VFSLIBDIR = $(LIBDIR)/vfs
+PDBLIBDIR = $(LIBDIR)/pdb
+RPCLIBDIR = $(LIBDIR)/rpc
 CONFIGDIR = @configdir@
 VARDIR = @localstatedir@
 MANDIR = @mandir@
@@ -95,32 +101,38 @@
 PATH_FLAGS2 = $(PATH_FLAGS1) -DBINDIR=\"$(BINDIR)\" -DDRIVERFILE=\"$(DRIVERFILE)\" 
 PATH_FLAGS3 = $(PATH_FLAGS2) -DLMHOSTSFILE=\"$(LMHOSTSFILE)\" 
 PATH_FLAGS4 = $(PATH_FLAGS3) -DSWATDIR=\"$(SWATDIR)\"  -DLOCKDIR=\"$(LOCKDIR)\" -DPIDDIR=\"$(PIDDIR)\"
-PATH_FLAGS5 = $(PATH_FLAGS4) -DLIBDIR=\"$(LIBDIR)\" -DLOGFILEBASE=\"$(LOGFILEBASE)\" 
-PATH_FLAGS6 = $(PATH_FLAGS5) -DCONFIGDIR=\"$(CONFIGFIR)\"
+PATH_FLAGS5 = $(PATH_FLAGS4) -DLIBDIR=\"$(LIBDIR)\" \
+	      -DLOGFILEBASE=\"$(LOGFILEBASE)\" -DSHLIBEXT=\"@SHLIBEXT@\"
+PATH_FLAGS6 = $(PATH_FLAGS5) -DCONFIGDIR=\"$(CONFIGDIR)\"
 PATH_FLAGS = $(PATH_FLAGS6) $(PASSWD_FLAGS)
 
-WINBIND_PROGS = @WINBIND_TARGETS@
-WINBIND_SPROGS = @WINBIND_STARGETS@
-WINBIND_PAM_PROGS = @WINBIND_PAM_TARGETS@
-WINBIND_LPROGS = @WINBIND_LTARGETS@
-
-SPROGS = bin/smbd bin/nmbd bin/swat bin/wrepld @WINBIND_STARGETS@
-PROGS1 = bin/smbclient bin/net bin/smbspool bin/testparm bin/testprns bin/smbstatus bin/smbcontrol bin/smbtree bin/tdbbackup @RUNPROG@ @WINBIND_TARGETS@
-PROGS2 = bin/smbpasswd bin/rpcclient bin/smbcacls @WRAPPROG@ @WRAP@ @WRAP32@ @PAM_MOD@
-MPROGS = @MPROGS@
-LPROGS = $(WINBIND_PAM_PROGS) $(WINBIND_LPROGS)
-
-PROGS = $(PROGS1) $(PROGS2) $(MPROGS) bin/nmblookup bin/pdbedit bin/smbgroupedit
-TORTURE_PROGS = bin/smbtorture bin/msgtest bin/masktest bin/locktest \
-	bin/locktest2 bin/nsstest bin/vfstest
-SHLIBS = @LIBSMBCLIENT@
+# Note that all executable programs now provide for an optional executable suffix.
+
+SBIN_PROGS = bin/smbd@EXEEXT@ bin/nmbd@EXEEXT@ bin/swat@EXEEXT@ \
+	bin/wrepld@EXEEXT@ @EXTRA_SBIN_PROGS@
+
+BIN_PROGS1 = bin/smbclient@EXEEXT@ bin/net@EXEEXT@ bin/smbspool@EXEEXT@ \
+	bin/testparm@EXEEXT@ bin/testprns@EXEEXT@ bin/smbstatus@EXEEXT@ 
+BIN_PROGS2 = bin/smbcontrol@EXEEXT@ bin/smbtree@EXEEXT@ bin/tdbbackup@EXEEXT@ \
+	bin/nmblookup@EXEEXT@ bin/pdbedit@EXEEXT@
+BIN_PROGS3 = bin/smbpasswd@EXEEXT@ bin/rpcclient@EXEEXT@ bin/smbcacls@EXEEXT@ \
+	bin/profiles@EXEEXT@ bin/smbgroupedit@EXEEXT@ bin/ntlm_auth@EXEEXT@
+
+TORTURE_PROGS = bin/smbtorture@EXEEXT@ bin/msgtest@EXEEXT@ \
+	bin/masktest@EXEEXT@ bin/locktest@EXEEXT@ \
+	bin/locktest2@EXEEXT@ bin/nsstest@EXEEXT@ bin/vfstest@EXEEXT@
+
+BIN_PROGS = $(BIN_PROGS1) $(BIN_PROGS2) $(BIN_PROGS3) @EXTRA_BIN_PROGS@
+
+SHLIBS = @SHLIB_PROGS@ @LIBSMBCLIENT@
 
 SCRIPTS = $(srcdir)/script/smbtar $(srcdir)/script/addtosmbpass $(srcdir)/script/convert_smbpasswd \
 	  $(builddir)/script/findsmb
 
 QUOTAOBJS=@QUOTAOBJS@
 
-MODULES = bin/vfs_audit.@SHLIBEXT@ bin/vfs_recycle.@SHLIBEXT@ bin/vfs_netatalk.@SHLIBEXT@ @MODULE_MYSQL@ @MODULE_XML@
+VFS_MODULES = bin/vfs_audit.@SHLIBEXT@ bin/vfs_extd_audit.@SHLIBEXT@ bin/vfs_recycle.@SHLIBEXT@ bin/vfs_netatalk.@SHLIBEXT@ 
+PDB_MODULES = @MODULE_MYSQL@ @MODULE_XML@
 
 ######################################################################
 # object file lists
@@ -146,13 +158,14 @@
 	  lib/md5.o lib/hmacmd5.o lib/iconv.o lib/smbpasswd.o \
 	  nsswitch/wb_client.o nsswitch/wb_common.o \
 	  lib/pam_errors.o intl/lang_tdb.o lib/account_pol.o \
-	  lib/adt_tree.o lib/gencache.o $(TDB_OBJ) 
+	  lib/adt_tree.o lib/gencache.o $(TDB_OBJ) \
+	  lib/ldap_escape.o
 
 LIB_SMBD_OBJ = lib/system_smbd.o lib/util_smbd.o
 
 READLINE_OBJ = lib/readline.o
 
-POPT_LIB_OBJ = lib/popt_common.o
+POPT_LIB_OBJ = lib/popt_common.o 
 
 UBIQX_OBJ = ubiqx/ubi_BinTree.o ubiqx/ubi_Cache.o ubiqx/ubi_SplayTree.o \
             ubiqx/ubi_dLinkList.o ubiqx/ubi_sLinkList.o ubiqx/debugparse.o
@@ -179,31 +192,63 @@
              libsmb/smberr.o libsmb/credentials.o libsmb/pwd_cache.o \
 	     libsmb/clioplock.o libsmb/errormap.o libsmb/clirap2.o \
 	     libsmb/passchange.o libsmb/unexpected.o libsmb/doserr.o \
-	     libsmb/namecache.o $(RPC_PARSE_OBJ1)
+	     libsmb/namecache.o libsmb/ntlmssp.o \
+	     $(RPC_PARSE_OBJ1)
 
 LIBMSRPC_OBJ = rpc_client/cli_lsarpc.o rpc_client/cli_samr.o \
 	       rpc_client/cli_netlogon.o rpc_client/cli_srvsvc.o \
 	       rpc_client/cli_wkssvc.o rpc_client/cli_dfs.o \
 	       rpc_client/cli_reg.o rpc_client/cli_pipe.o \
 	       rpc_client/cli_spoolss.o rpc_client/cli_spoolss_notify.o  \
-		rpc_client/cli_ds.o
+	       rpc_client/cli_ds.o libsmb/namequery_dc.o
 
 LIBMSRPC_SERVER_OBJ = libsmb/trust_passwd.o
 
-LIBMSRPC_PICOBJ = $(LIBMSRPC_OBJ:.o=.po)
-
 REGOBJS_OBJ = registry/reg_objects.o
 REGISTRY_OBJ = registry/reg_frontend.o registry/reg_cachehook.o registry/reg_printing.o \
                registry/reg_db.o 
+RPC_LSA_OBJ = rpc_server/srv_lsa.o rpc_server/srv_lsa_nt.o
 
-RPC_SERVER_OBJ = rpc_server/srv_lsa.o rpc_server/srv_lsa_nt.o \
-                 rpc_server/srv_lsa_hnd.o rpc_server/srv_netlog.o rpc_server/srv_netlog_nt.o \
-                 rpc_server/srv_pipe_hnd.o rpc_server/srv_reg.o rpc_server/srv_reg_nt.o \
-                 rpc_server/srv_samr.o rpc_server/srv_samr_nt.o rpc_server/srv_samr_util.o \
-		 rpc_server/srv_srvsvc.o rpc_server/srv_srvsvc_nt.o \
-                 rpc_server/srv_util.o rpc_server/srv_wkssvc.o rpc_server/srv_wkssvc_nt.o \
-                 rpc_server/srv_pipe.o rpc_server/srv_dfs.o rpc_server/srv_dfs_nt.o \
-                 rpc_server/srv_spoolss.o rpc_server/srv_spoolss_nt.o 
+RPC_NETLOG_OBJ = rpc_server/srv_netlog.o rpc_server/srv_netlog_nt.o
+
+RPC_SAMR_OBJ = rpc_server/srv_samr.o rpc_server/srv_samr_nt.o \
+               rpc_server/srv_samr_util.o
+
+RPC_REG_OBJ =  rpc_server/srv_reg.o rpc_server/srv_reg_nt.o
+
+RPC_SVC_OBJ = rpc_server/srv_srvsvc.o rpc_server/srv_srvsvc_nt.o
+
+RPC_WKS_OBJ =  rpc_server/srv_wkssvc.o rpc_server/srv_wkssvc_nt.o
+
+RPC_DFS_OBJ =  rpc_server/srv_dfs.o rpc_server/srv_dfs_nt.o
+RPC_SPOOLSS_OBJ = rpc_server/srv_spoolss.o rpc_server/srv_spoolss_nt.o 
+
+RPC_PIPE_OBJ = rpc_server/srv_pipe_hnd.o rpc_server/srv_util.o \
+               rpc_server/srv_pipe.o rpc_server/srv_lsa_hnd.o
+
+# These are like they are to avoid a dependency on GNU MAKE
+@LSA_DYNAMIC_YES@RPC_MODULES1 = bin/librpc_lsarpc.@SHLIBEXT@
+@NETLOG_DYNAMIC_YES@RPC_MODULES2 = bin/librpc_NETLOGON.@SHLIBEXT@
+@SAMR_DYNAMIC_YES@RPC_MODULES3 = bin/librpc_samr.@SHLIBEXT@
+@SVC_DYNAMIC_YES@RPC_MODULES4 = bin/librpc_srvsvc.@SHLIBEXT@
+@WKS_DYNAMIC_YES@RPC_MODULES5 = bin/librpc_wkssvc.@SHLIBEXT@
+@REG_DYNAMIC_YES@RPC_MODULES6 = bin/librpc_winreg.@SHLIBEXT@
+@SPOOLSS_DYNAMIC_YES@RPC_MODULES7 = bin/librpc_spoolss.@SHLIBEXT@
+@DFS_DYNAMIC_YES@RPC_MODULES8 = bin/librpc_netdfs.@SHLIBEXT@
+RPC_MODULES = $(RPC_MODULES1) $(RPC_MODULES2) $(RPC_MODULES3) $(RPC_MODULES4) \
+	$(RPC_MODULES5) $(RPC_MODULES6) $(RPC_MODULES7) $(RPC_MODULES8)
+
+@LSA_DYNAMIC_NO@RPC_PIPE_OBJ1 = $(RPC_LSA_OBJ)
+@NETLOG_DYNAMIC_NO@RPC_PIPE_OBJ2 = $(RPC_NETLOG_OBJ)
+@SAMR_DYNAMIC_NO@RPC_PIPE_OBJ3 = $(RPC_SAMR_OBJ)
+@SVC_DYNAMIC_NO@RPC_PIPE_OBJ4 = $(RPC_SVC_OBJ)
+@WKS_DYNAMIC_NO@RPC_PIPE_OBJ5 = $(RPC_WKS_OBJ)
+@REG_DYNAMIC_NO@RPC_PIPE_OBJ6 = $(RPC_REG_OBJ)
+@SPOOLSS_DYNAMIC_NO@RPC_PIPE_OBJ7 = $(RPC_SPOOLSS_OBJ)
+@DFS_DYNAMIC_NO@RPC_PIPE_OBJ8 =	$(RPC_DFS_OBJ)
+RPC_SERVER_OBJ = $(RPC_PIPE_OBJ1) $(RPC_PIPE_OBJ2) $(RPC_PIPE_OBJ3) \
+	$(RPC_PIPE_OBJ4) $(RPC_PIPE_OBJ5) $(RPC_PIPE_OBJ6) $(RPC_PIPE_OBJ7) \
+	$(RPC_PIPE_OBJ8) $(RPC_PIPE_OBJ)
 
 # this includes only the low level parse code, not stuff
 # that requires knowledge of security contexts
@@ -249,7 +294,7 @@
 
 AUTH_OBJ = auth/auth.o auth/auth_sam.o auth/auth_server.o auth/auth_domain.o \
 	   auth/auth_rhosts.o auth/auth_unix.o auth/auth_util.o	auth/auth_winbind.o \
-	   auth/auth_builtin.o auth/auth_compat.o \
+	   auth/auth_builtin.o auth/auth_compat.o auth/auth_ntlmssp.o \
 	   $(PLAINTEXT_AUTH_OBJ) $(UNIGRP_OBJ)
 
 MANGLE_OBJ = smbd/mangle.o smbd/mangle_hash.o smbd/mangle_map.o smbd/mangle_hash2.o
@@ -382,6 +427,18 @@
 		   libsmb/libsmb_cache.o $(LIB_OBJ) \
 	  	   $(LIBSMB_OBJ) $(PARAM_OBJ) $(UBIQX_OBJ)
 
+# This shared library is intended for linking with unit test programs
+# to test Samba internals.  It's called libbigballofmud.so to
+# discourage casual usage.
+
+LIBBIGBALLOFMUD_MAJOR = 0
+
+LIBBIGBALLOFMUD_OBJ = $(LIB_OBJ) $(UBIQX_OBJ) $(PARAM_OBJ) $(SECRETS_OBJ) \
+	$(LIBSMB_OBJ) $(LIBMSRPC_OBJ) $(RPC_PARSE_OBJ) $(PASSDB_OBJ) \
+	$(GROUPDB_OBJ)
+
+LIBBIGBALLOFMUD_PICOBJS = $(LIBBIGBALLOFMUD_OBJ:.o=.po)
+
 CLIENT_OBJ1 = client/client.o client/clitar.o 
 
 CLIENT_OBJ = $(CLIENT_OBJ1) $(PARAM_OBJ) $(LIBSMB_OBJ) $(UBIQX_OBJ) $(LIB_OBJ) \
@@ -405,8 +462,7 @@
 
 MNT_OBJ = client/smbmnt.o             	
 
-UMOUNT_OBJ = client/smbumount.o \
-             $(PARAM_OBJ) $(UBIQX_OBJ) $(LIB_OBJ)
+UMOUNT_OBJ = client/smbumount.o
 
 NMBLOOKUP_OBJ = utils/nmblookup.o $(PARAM_OBJ) $(UBIQX_OBJ) \
                 $(LIBSMB_OBJ) $(LIB_OBJ)
@@ -432,6 +488,7 @@
 VFSTEST_OBJ = torture/cmd_vfs.o torture/vfstest.o $(SMBD_OBJ_BASE) $(READLINE_OBJ)
 
 VFS_AUDIT_OBJ = modules/vfs_audit.o
+VFS_EXTD_AUDIT_OBJ = modules/vfs_extd_audit.o
 VFS_RECYCLE_OBJ = modules/vfs_recycle.o
 VFS_NETATALK_OBJ = modules/vfs_netatalk.o
 
@@ -440,7 +497,7 @@
 
 SMBCACLS_OBJ = utils/smbcacls.o $(LOCKING_OBJ) $(LIBSMB_OBJ) $(PARAM_OBJ) \
                  $(UBIQX_OBJ) $(LIB_OBJ) $(RPC_PARSE_OBJ) $(PASSDB_GET_SET_OBJ) \
-		 $(LIBMSRPC_OBJ) 
+		 $(LIBMSRPC_OBJ) $(SECRETS_OBJ)
 
 TALLOCTORT_OBJ = lib/talloctort.o  $(LIB_OBJ) $(PARAM_OBJ) $(UBIQX_OBJ)
 
@@ -463,12 +520,14 @@
 	    $(SMBD_OBJ_SRV) $(NMBD_OBJ1) $(SWAT_OBJ1) $(LIB_OBJ) $(LIBSMB_OBJ) \
 	    $(SMBW_OBJ1) $(SMBWRAPPER_OBJ1) $(SMBTORTURE_OBJ1) $(RPCCLIENT_OBJ1) \
 	    $(LIBMSRPC_OBJ) $(LIBMSRPC_SERVER_OBJ) $(RPC_CLIENT_OBJ) \
-	    $(RPC_SERVER_OBJ) $(RPC_PARSE_OBJ) \
+	    $(RPC_PIPE_OBJ) $(RPC_PARSE_OBJ) \
 	    $(AUTH_OBJ) $(PARAM_OBJ) $(LOCKING_OBJ) $(SECRETS_OBJ) \
 	    $(PRINTING_OBJ) $(PRINTBACKEND_OBJ) $(OPLOCK_OBJ) $(NOTIFY_OBJ) \
 	    $(QUOTAOBJS) $(PASSDB_OBJ) $(GROUPDB_OBJ) $(MSDFS_OBJ) \
 	    $(READLINE_OBJ) $(PROFILE_OBJ) $(LIBADS_OBJ) $(LIBADS_SERVER_OBJ) \
-	    $(LIB_SMBD_OBJ) $(REGISTRY_OBJ) $(POPT_LIB_OBJ)
+	    $(LIB_SMBD_OBJ) $(REGISTRY_OBJ) $(POPT_LIB_OBJ) \
+	    $(RPC_LSA_OBJ) $(RPC_NETLOG_OBJ) $(RPC_SAMR_OBJ) $(RPC_REG_OBJ) \
+	    $(RPC_SVC_OBJ) $(RPC_WKS_OBJ) $(RPC_DFS_OBJ) $(RPC_SPOOLSS_OBJ)
 
 NSS_OBJ_0 = nsswitch/wins.o $(PARAM_OBJ) $(UBIQX_OBJ) $(LIBSMB_OBJ) \
 	    $(LIB_OBJ) $(NSSWINS_OBJ)
@@ -521,44 +580,46 @@
 
 TDBBACKUP_OBJ = tdb/tdbbackup.o $(TDBBASE_OBJ)
 
+NTLM_AUTH_OBJ = utils/ntlm_auth.o $(LIBSMB_OBJ) $(POPT_LIB_OBJ)
+
 ######################################################################
 # now the rules...
 ######################################################################
-all : SHOWFLAGS proto_exists $(SPROGS) $(PROGS) $(WINBIND_PROGS) $(WINBIND_SPROGS) $(LPROGS) $(SHLIBS)
+all : SHOWFLAGS proto_exists $(SBIN_PROGS) $(BIN_PROGS) $(SHLIBS) $(RPC_MODULES) @EXTRA_ALL_TARGETS@
 
 pam_smbpass : SHOWFLAGS bin/pam_smbpass.@SHLIBEXT@
 
-smbwrapper : SHOWFLAGS @WRAPPROG@ @WRAP@ @WRAP32@
+smbwrapper : SHOWFLAGS @SMBWRAPPER@
 
 torture : SHOWFLAGS $(TORTURE_PROGS)
 
-smbtorture : SHOWFLAGS bin/smbtorture
+smbtorture : SHOWFLAGS bin/smbtorture@EXEEXT@
 
-masktest : SHOWFLAGS bin/masktest
+masktest : SHOWFLAGS bin/masktest@EXEEXT@
 
-msgtest : SHOWFLAGS bin/msgtest
+msgtest : SHOWFLAGS bin/msgtest@EXEEXT@
 
-locktest : SHOWFLAGS bin/locktest
+locktest : SHOWFLAGS bin/locktest@EXEEXT@
 
-smbcacls : SHOWFLAGS bin/smbcacls
+smbcacls : SHOWFLAGS bin/smbcacls@EXEEXT@
 
-locktest2 : SHOWFLAGS bin/locktest2
+locktest2 : SHOWFLAGS bin/locktest2@EXEEXT@
 
-rpctorture : SHOWFLAGS bin/rpctorture
+rpctorture : SHOWFLAGS bin/rpctorture@EXEEXT@
 
-debug2html : SHOWFLAGS bin/debug2html
+debug2html : SHOWFLAGS bin/debug2html@EXEEXT@
 
-smbfilter : SHOWFLAGS bin/smbfilter
+smbfilter : SHOWFLAGS bin/smbfilter@EXEEXT@
 
-talloctort : SHOWFLAGS bin/talloctort
+talloctort : SHOWFLAGS bin/talloctort@EXEEXT@
 
-nsswitch : SHOWFLAGS $(WINBIND_PROGS) $(WINBIND_SPROGS) $(LPROGS)
+nsswitch : SHOWFLAGS bin/winbindd@EXEEXT@ bin/wbinfo@EXEEXT@ nsswitch/libnss_winbind.@SHLIBEXT@ nsswitch/pam_winbind.@SHLIBEXT@
 
 wins : SHOWFLAGS nsswitch/libnss_wins.@SHLIBEXT@
 
-modules: SHOWFLAGS $(MODULES)
+modules: SHOWFLAGS proto_exists $(VFS_MODULES) $(PDB_MODULES)
 
-everything: all libsmbclient debug2html smbfilter talloctort modules
+everything: all libsmbclient debug2html smbfilter talloctort modules torture
 
 .SUFFIXES:
 .SUFFIXES: .c .o .po .po32 .lo
@@ -627,141 +688,145 @@
 	  dir=bin $(MAKEDIR); fi
 	@: >> $@ || : > $@ # what a fancy emoticon!
 
-bin/smbd: $(SMBD_OBJ) @BUILD_POPT@ bin/.dummy
+bin/smbd@EXEEXT@: $(SMBD_OBJ) @BUILD_POPT@ bin/.dummy
 	@echo Linking $@
 	@$(CC) $(FLAGS) -o $@ $(SMBD_OBJ) $(LDFLAGS) $(DYNEXP) $(PRINTLIBS) \
 	  $(AUTHLIBS) $(LIBS) @BUILD_POPT@
 
-bin/nmbd: $(NMBD_OBJ) @BUILD_POPT@ bin/.dummy
+bin/nmbd@EXEEXT@: $(NMBD_OBJ) @BUILD_POPT@ bin/.dummy
 	@echo Linking $@
 	@$(CC) $(FLAGS) -o $@ $(NMBD_OBJ) $(LDFLAGS) $(LIBS) @BUILD_POPT@
 
-bin/wrepld: $(WREPL_OBJ) bin/.dummy
+bin/wrepld@EXEEXT@: $(WREPL_OBJ) bin/.dummy
 	@echo Linking $@
 	@$(CC) $(FLAGS) -o $@ $(WREPL_OBJ) $(LDFLAGS) $(LIBS) 
 
-bin/swat: $(SWAT_OBJ) bin/.dummy
+bin/swat@EXEEXT@: $(SWAT_OBJ) bin/.dummy
 	@echo Linking $@
 	@$(CC) $(FLAGS) -o $@ $(SWAT_OBJ) $(LDFLAGS) $(DYNEXP) $(PRINTLIBS) \
 	  $(AUTHLIBS) $(LIBS) 
 
-bin/rpcclient: $(RPCCLIENT_OBJ) @BUILD_POPT@ bin/.dummy
+bin/rpcclient@EXEEXT@: $(RPCCLIENT_OBJ) @BUILD_POPT@ bin/.dummy
 	@echo Linking $@
 	@$(CC) $(FLAGS) -o $@ $(RPCCLIENT_OBJ) $(LDFLAGS) $(DYNEXP) $(TERMLDFLAGS) $(TERMLIBS) $(LIBS) @BUILD_POPT@
 
-bin/smbclient: $(CLIENT_OBJ) @BUILD_POPT@ bin/.dummy
+bin/smbclient@EXEEXT@: $(CLIENT_OBJ) @BUILD_POPT@ bin/.dummy
 	@echo Linking $@
 	@$(CC) $(FLAGS) -o $@ $(CLIENT_OBJ) $(LDFLAGS) $(TERMLDFLAGS) $(TERMLIBS) $(LIBS) @BUILD_POPT@
 
-bin/net: $(NET_OBJ) @BUILD_POPT@ bin/.dummy
+bin/net@EXEEXT@: $(NET_OBJ) @BUILD_POPT@ bin/.dummy
 	@echo Linking $@
 	@$(CC) $(FLAGS) -o $@ $(NET_OBJ) $(DYNEXP) $(LDFLAGS) $(LIBS) @BUILD_POPT@
 
-bin/smbspool: $(CUPS_OBJ) bin/.dummy
+bin/profiles@EXEEXT@: utils/profiles.o bin/.dummy
+	@echo Linking $@
+	@$(CC) $(FLAGS) -o $@ utils/profiles.o $(LDFLAGS) $(LIBS)
+
+bin/smbspool@EXEEXT@: $(CUPS_OBJ) bin/.dummy
 	@echo Linking $@
 	@$(CC) $(FLAGS) -o $@ $(CUPS_OBJ) $(LDFLAGS) $(LIBS)
 
-bin/smbmount: $(MOUNT_OBJ) bin/.dummy
+bin/smbmount@EXEEXT@: $(MOUNT_OBJ) bin/.dummy
 	@echo Linking $@
 	@$(CC) $(FLAGS) -o $@ $(MOUNT_OBJ) $(LDFLAGS) $(LIBS)
 
-bin/smbmnt: $(MNT_OBJ) bin/.dummy
+bin/smbmnt@EXEEXT@: $(MNT_OBJ) bin/.dummy
 	@echo Linking $@
-	@$(CC) $(FLAGS) -o $@ $(MNT_OBJ) $(LDFLAGS) $(LIBS)
+	@$(CC) $(FLAGS) -o $@ $(MNT_OBJ) $(LDFLAGS) 
 
-bin/smbumount: $(UMOUNT_OBJ) bin/.dummy
+bin/smbumount@EXEEXT@: $(UMOUNT_OBJ) bin/.dummy
 	@echo Linking $@
-	@$(CC) $(FLAGS) -o $@ $(UMOUNT_OBJ) $(LDFLAGS) $(LIBS)
+	@$(CC) $(FLAGS) -o $@ $(UMOUNT_OBJ) $(LDFLAGS)
 
-bin/testparm: $(TESTPARM_OBJ) @BUILD_POPT@ bin/.dummy
+bin/testparm@EXEEXT@: $(TESTPARM_OBJ) @BUILD_POPT@ bin/.dummy
 	@echo Linking $@
 	@$(CC) $(FLAGS) -o $@ $(TESTPARM_OBJ) $(LDFLAGS) $(LIBS) @BUILD_POPT@
 
-bin/testprns: $(TESTPRNS_OBJ) bin/.dummy
+bin/testprns@EXEEXT@: $(TESTPRNS_OBJ) bin/.dummy
 	@echo Linking $@
 	@$(CC) $(FLAGS) -o $@ $(TESTPRNS_OBJ) $(LDFLAGS) $(PRINTLIBS) $(LIBS)
 
-bin/smbstatus: $(STATUS_OBJ) @BUILD_POPT@ bin/.dummy
+bin/smbstatus@EXEEXT@: $(STATUS_OBJ) @BUILD_POPT@ bin/.dummy
 	@echo Linking $@
 	@$(CC) $(FLAGS) -o $@ $(STATUS_OBJ) $(LDFLAGS) $(LIBS) @BUILD_POPT@
 
-bin/smbcontrol: $(SMBCONTROL_OBJ) bin/.dummy
+bin/smbcontrol@EXEEXT@: $(SMBCONTROL_OBJ) bin/.dummy
 	@echo Linking $@
 	@$(CC) -DUSING_SMBCONTROL $(FLAGS) -o $@ $(SMBCONTROL_OBJ) $(LDFLAGS) $(LIBS)
 
-bin/smbtree: $(SMBTREE_OBJ) bin/.dummy
+bin/smbtree@EXEEXT@: $(SMBTREE_OBJ) bin/.dummy
 	@echo Linking $@
 	@$(CC) $(FLAGS) -o $@ $(SMBTREE_OBJ) $(LDFLAGS) $(LIBS)
 
-bin/smbpasswd: $(SMBPASSWD_OBJ) bin/.dummy
+bin/smbpasswd@EXEEXT@: $(SMBPASSWD_OBJ) bin/.dummy
 	@echo Linking $@
 	@$(CC) $(FLAGS) -o $@ $(SMBPASSWD_OBJ) $(LDFLAGS) $(DYNEXP) $(LIBS)
 
-bin/pdbedit: $(PDBEDIT_OBJ) @BUILD_POPT@ bin/.dummy
+bin/pdbedit@EXEEXT@: $(PDBEDIT_OBJ) @BUILD_POPT@ bin/.dummy
 	@echo Linking $@
 	@$(CC) $(FLAGS) -o $@ $(PDBEDIT_OBJ) $(LDFLAGS) $(DYNEXP) $(LIBS) @BUILD_POPT@
 
-bin/smbgroupedit: $(SMBGROUPEDIT_OBJ) bin/.dummy
+bin/smbgroupedit@EXEEXT@: $(SMBGROUPEDIT_OBJ) bin/.dummy
 	@echo Linking $@
 	@$(CC) $(FLAGS) -o $@ $(SMBGROUPEDIT_OBJ) $(LDFLAGS) $(LIBS)
 
-bin/nmblookup: $(NMBLOOKUP_OBJ) bin/.dummy
+bin/nmblookup@EXEEXT@: $(NMBLOOKUP_OBJ) bin/.dummy
 	@echo Linking $@
 	@$(CC) $(FLAGS) -o $@ $(NMBLOOKUP_OBJ) $(LDFLAGS) $(LIBS)
 
-bin/smbtorture: $(SMBTORTURE_OBJ) bin/.dummy
+bin/smbtorture@EXEEXT@: $(SMBTORTURE_OBJ) bin/.dummy
 	@echo Linking $@
 	@$(CC) $(FLAGS) -o $@ $(SMBTORTURE_OBJ) $(LDFLAGS) $(LIBS)
 
-bin/talloctort: $(TALLOCTORT_OBJ) bin/.dummy
+bin/talloctort@EXEEXT@: $(TALLOCTORT_OBJ) bin/.dummy
 	@echo Linking $@
 	@$(CC) $(FLAGS) -o $@ $(TALLOCTORT_OBJ) $(LDFLAGS) $(LIBS)
 
-bin/masktest: $(MASKTEST_OBJ) bin/.dummy
+bin/masktest@EXEEXT@: $(MASKTEST_OBJ) bin/.dummy
 	@echo Linking $@
 	@$(CC) $(FLAGS) -o $@ $(MASKTEST_OBJ) $(LDFLAGS) $(LIBS)
 
-bin/msgtest: $(MSGTEST_OBJ) bin/.dummy
+bin/msgtest@EXEEXT@: $(MSGTEST_OBJ) bin/.dummy
 	@echo Linking $@
 	@$(CC) $(FLAGS) -o $@ $(MSGTEST_OBJ) $(LDFLAGS) $(LIBS)
 
-bin/smbcacls: $(SMBCACLS_OBJ) bin/.dummy
+bin/smbcacls@EXEEXT@: $(SMBCACLS_OBJ) bin/.dummy
 	@echo Linking $@
 	@$(CC) $(FLAGS) -o $@ $(SMBCACLS_OBJ) $(DYNEXP) $(LDFLAGS) $(LIBS)
 
-bin/locktest: $(LOCKTEST_OBJ) bin/.dummy
+bin/locktest@EXEEXT@: $(LOCKTEST_OBJ) bin/.dummy
 	@echo Linking $@
 	@$(CC) $(FLAGS) -o $@ $(LOCKTEST_OBJ) $(LDFLAGS) $(LIBS)
 
-bin/nsstest: $(NSSTEST_OBJ) bin/.dummy
+bin/nsstest@EXEEXT@: $(NSSTEST_OBJ) bin/.dummy
 	@echo Linking $@
 	@$(CC) $(FLAGS) -o $@ $(NSSTEST_OBJ) $(LDFLAGS) $(LIBS)
 
-bin/vfstest: $(VFSTEST_OBJ) @BUILD_POPT@ bin/.dummy
+bin/vfstest@EXEEXT@: $(VFSTEST_OBJ) @BUILD_POPT@ bin/.dummy
 	@echo Linking $@
 	@$(CC) $(FLAGS) -o $@ $(VFSTEST_OBJ) $(LDFLAGS) $(TERMLDFLAGS) $(TERMLIBS) $(DYNEXP) $(PRINTLIBS) $(AUTHLIBS) $(LIBS) @BUILD_POPT@
 
-bin/locktest2: $(LOCKTEST2_OBJ) bin/.dummy
+bin/locktest2@EXEEXT@: $(LOCKTEST2_OBJ) bin/.dummy
 	@echo Linking $@
 	@$(CC) $(FLAGS) -o $@ $(LOCKTEST2_OBJ) $(LDFLAGS) $(LIBS)
 
-bin/rpctorture: $(RPCTORTURE_OBJ) bin/.dummy
+bin/rpctorture@EXEEXT@: $(RPCTORTURE_OBJ) bin/.dummy
 	@echo Linking $@
 	@$(CC) $(FLAGS) -o $@ $(RPCTORTURE_OBJ) $(DYNEXP) $(LDFLAGS) $(LIBS)
 
-bin/debug2html: $(DEBUG2HTML_OBJ) bin/.dummy
+bin/debug2html@EXEEXT@: $(DEBUG2HTML_OBJ) bin/.dummy
 	@echo Linking $@
 	@$(CC) $(FLAGS) -o $@ $(DEBUG2HTML_OBJ) $(LDFLAGS) $(LIBS)
 
-bin/smbfilter: $(SMBFILTER_OBJ) bin/.dummy
+bin/smbfilter@EXEEXT@: $(SMBFILTER_OBJ) bin/.dummy
 	@echo Linking $@
 	@$(CC) $(FLAGS) -o $@ $(SMBFILTER_OBJ) $(LDFLAGS) $(LIBS)
 
-bin/smbw_sample: $(SMBW_OBJ) utils/smbw_sample.o bin/.dummy
+bin/smbw_sample@EXEEXT@: $(SMBW_OBJ) utils/smbw_sample.o bin/.dummy
 	@echo Linking $@
 	@$(CC) $(FLAGS) -o $@ $(SMBW_OBJ) utils/smbw_sample.o $(LDFLAGS) $(LIBS)
 
-bin/smbsh: $(SMBSH_OBJ) bin/.dummy
+bin/smbsh@EXEEXT@: $(SMBSH_OBJ) bin/.dummy
 	@echo Linking $@
 	@$(CC) $(FLAGS) -o $@ $(SMBSH_OBJ) $(LDFLAGS) $(LIBS)
 
@@ -776,23 +841,67 @@
 		@SONAMEFLAG@`basename $@`
 
 bin/libsmbclient.@SHLIBEXT@: $(LIBSMBCLIENT_PICOBJS)
-	echo Linking libsmbclient shared library $@
-	$(SHLD) $(LDSHFLAGS) -o $@ $(LIBSMBCLIENT_PICOBJS) $(LIBS) \
+	@echo Linking libsmbclient shared library $@
+	$(SHLD) $(LDSHFLAGS) -o $@ $(LIBSMBCLIENT_PICOBJS) $(LDFLAGS) $(LIBS) \
 		@SONAMEFLAG@`basename $@`.$(LIBSMBCLIENT_MAJOR)
 
 bin/libsmbclient.a: $(LIBSMBCLIENT_PICOBJS)
 	@echo Linking libsmbclient non-shared library $@
 	-$(AR) -rc $@ $(LIBSMBCLIENT_PICOBJS) 
 
-libsmbclient: bin/libsmbclient.a bin/libsmbclient.@SHLIBEXT@
+bin/libbigballofmud.@SHLIBEXT@: $(LIBBIGBALLOFMUD_PICOBJS)
+	@echo Linking bigballofmud shared library $@
+	$(SHLD) $(LDSHFLAGS) -o $@ $(LIBBIGBALLOFMUD_PICOBJS) $(LIBS) \
+		@SONAMEFLAG@`basename $@`.$(LIBBIGBALLOFMUD_MAJOR)
+
+libsmbclient: bin/libsmbclient.a @LIBSMBCLIENT_SHARED@
+
+bin/librpc_lsarpc.@SHLIBEXT@: $(RPC_LSA_OBJ)
+	@echo "Linking $@"
+	@$(SHLD) $(LDSHFLAGS) -o $@ $(RPC_LSA_OBJ) -lc \
+		@SONAMEFLAG@`basename $@`
+
+bin/librpc_samr.@SHLIBEXT@: $(RPC_SAMR_OBJ)
+	@echo "Linking $@"
+	@$(SHLD) $(LDSHFLAGS) -o $@ $(RPC_SAMR_OBJ) -lc \
+		@SONAMEFLAG@`basename $@`
+
+bin/librpc_srvsvc.@SHLIBEXT@: $(RPC_SVC_OBJ)
+	@echo "Linking $@"
+	@$(SHLD) $(LDSHFLAGS) -o $@ $(RPC_SVC_OBJ) -lc \
+		@SONAMEFLAG@`basename $@`
+
+bin/librpc_wkssvc.@SHLIBEXT@: $(RPC_WKS_OBJ)
+	@echo "Linking $@"
+	@$(SHLD) $(LDSHFLAGS) -o $@ $(RPC_WKS_OBJ) -lc \
+		@SONAMEFLAG@`basename $@`
+
+bin/librpc_NETLOGON.@SHLIBEXT@: $(RPC_NETLOG_OBJ)
+	@echo "Linking $@"
+	@$(SHLD) $(LDSHFLAGS) -o $@ $(RPC_NETLOG_OBJ) -lc \
+		@SONAMEFLAG@`basename $@`
+
+bin/librpc_winreg.@SHLIBEXT@: $(RPC_REG_OBJ)
+	@echo "Linking $@"
+	@$(SHLD) $(LDSHFLAGS) -o $@ $(RPC_REG_OBJ) -lc \
+		@SONAMEFLAG@`basename $@`
+
+bin/librpc_spoolss.@SHLIBEXT@: $(RPC_SPOOLSS_OBJ)
+	@echo "Linking $@"
+	@$(SHLD) $(LDSHFLAGS) -o $@ $(RPC_SPOOLSS_OBJ) -lc \
+		@SONAMEFLAG@`basename $@`
 
+bin/librpc_netdfs.@SHLIBEXT@: $(RPC_DFS_OBJ)
+	@echo "Linking $@"
+	@$(SHLD) $(LDSHFLAGS) -o $@ $(RPC_DFS_OBJ) -lc \
+		@SONAMEFLAG@`basename $@`
 
 nsswitch/libnss_wins.@SHLIBEXT@: $(NSS_OBJ)
 	@echo "Linking $@"
 	@$(SHLD) $(LDSHFLAGS) -o $@ $(NSS_OBJ) -lc \
 		@SONAMEFLAG@`basename $@`
 
-bin/winbindd: $(WINBINDD_OBJ) bin/.dummy
+bin/winbindd@EXEEXT@: $(WINBINDD_OBJ) bin/.dummy
 	@echo Linking $@
 	@$(LINK) -o $@ $(WINBINDD_OBJ) $(DYNEXP) $(LIBS)
 
@@ -826,6 +935,11 @@
 	@$(SHLD) $(LDSHFLAGS) -o $@ $(VFS_AUDIT_OBJ) \
 		@SONAMEFLAG@`basename $@`
 
+bin/vfs_extd_audit.@SHLIBEXT@: $(VFS_EXTD_AUDIT_OBJ)
+	@echo "Building plugin $@"
+	@$(SHLD) $(LDSHFLAGS) -o $@ $(VFS_AUDIT_OBJ) \
+		@SONAMEFLAG@`basename $@`
+
 bin/vfs_recycle.@SHLIBEXT@: $(VFS_RECYCLE_OBJ)
 	@echo "Building plugin $@"
 	@$(SHLD) $(LDSHFLAGS) -o $@ $(VFS_RECYCLE_OBJ) \
@@ -836,12 +950,18 @@
 	@$(SHLD) $(LDSHFLAGS) -o $@ $(VFS_NETATALK_OBJ) \
 		@SONAMEFLAG@`basename $@`
 
-bin/wbinfo: $(WBINFO_OBJ) $(PARAM_OBJ) $(LIB_OBJ) \
+bin/wbinfo@EXEEXT@: $(WBINFO_OBJ) $(PARAM_OBJ) $(LIB_OBJ) \
 		$(UBIQX_OBJ) $(SECRETS_OBJ) @BUILD_POPT@ bin/.dummy
 	@echo Linking $@
 	@$(LINK) -o $@ $(WBINFO_OBJ) $(PARAM_OBJ) $(LIB_OBJ) \
 		$(UBIQX_OBJ) $(SECRETS_OBJ) $(LIBS) @BUILD_POPT@
 
+bin/ntlm_auth@EXEEXT@: $(NTLM_AUTH_OBJ) $(PARAM_OBJ) $(LIB_OBJ) \
+		$(UBIQX_OBJ) @BUILD_POPT@ bin/.dummy
+	@echo Linking $@
+	@$(LINK) -o $@ $(NTLM_AUTH_OBJ) $(PARAM_OBJ) $(LIB_OBJ) \
+		$(UBIQX_OBJ) $(LIBS) @BUILD_POPT@
+
 bin/pam_smbpass.@SHLIBEXT@: $(PAM_SMBPASS_PICOOBJ)
 	@echo "Linking shared library $@"
 	$(SHLD) $(LDSHFLAGS) -o $@ $(PAM_SMBPASS_PICOOBJ) -lpam $(DYNEXP) $(LIBS) -lc
@@ -849,7 +969,7 @@
 bin/libmsrpc.a: $(LIBMSRPC_PICOBJ)
 	-$(AR) -rc $@ $(LIBMSRPC_PICOBJ) 
 
-bin/tdbbackup: $(TDBBACKUP_OBJ) bin/.dummy
+bin/tdbbackup@EXEEXT@: $(TDBBACKUP_OBJ) bin/.dummy
 	@echo Linking $@
 	@$(CC) $(FLAGS) -o $@ $(TDBBACKUP_OBJ)
 
@@ -857,32 +977,44 @@
 
 install-everything: install installmodules
 
+# DESTDIR is used here to prevent packagers wasting their time
+# duplicating the Makefile. Remove it and you will have the privelege
+# of package each samba release for muliple versions of multiple
+# distributions and operating systems, or at least supplying patches
+# to all the packaging files required for this, prior to committing
+# the removal of DESTDIR. Do not remove it even though you think it
+# is not used
+
 installdirs:
-	@$(SHELL) $(srcdir)/script/installdirs.sh $(BASEDIR) $(BINDIR) $(SBINDIR) $(LIBDIR) $(VARDIR) $(PRIVATEDIR) $(CONFIGDIR)
+	@$(SHELL) $(srcdir)/script/installdirs.sh $(DESTDIR)$(BASEDIR) $(DESTDIR)$(BINDIR) $(DESTDIR)$(SBINDIR) $(DESTDIR)$(LIBDIR) $(DESTDIR)$(VARDIR) $(DESTDIR)$(PRIVATEDIR) $(DESTDIR)$(VFSLIBDIR) $(DESTDIR)$(PDBLIBDIR) $(DESTDIR)$(PIDDIR) $(DESTDIR)$(LOCKDIR)
 
 installservers: all installdirs
-	@$(SHELL) $(srcdir)/script/installbin.sh $(INSTALLPERMS) $(BASEDIR) $(SBINDIR) $(LIBDIR) $(VARDIR) $(SPROGS)
+	@$(SHELL) $(srcdir)/script/installbin.sh $(INSTALLPERMS) $(DESTDIR)$(BASEDIR) $(DESTDIR)$(SBINDIR) $(DESTDIR)$(LIBDIR) $(DESTDIR)$(VARDIR) $(SBIN_PROGS)
 
 installbin: all installdirs
-	@$(SHELL) $(srcdir)/script/installbin.sh $(INSTALLPERMS) $(BASEDIR) $(SBINDIR) $(LIBDIR) $(VARDIR) $(SPROGS)
-	@$(SHELL) $(srcdir)/script/installbin.sh $(INSTALLPERMS) $(BASEDIR) $(BINDIR) $(LIBDIR) $(VARDIR) $(PROGS)
+	@$(SHELL) $(srcdir)/script/installbin.sh $(INSTALLPERMS) $(DESTDIR)$(BASEDIR) $(DESTDIR)$(SBINDIR) $(DESTDIR)$(LIBDIR) $(DESTDIR)$(VARDIR) $(SBIN_PROGS)
+	@$(SHELL) $(srcdir)/script/installbin.sh $(INSTALLPERMS) $(DESTDIR)$(BASEDIR) $(DESTDIR)$(BINDIR) $(DESTDIR)$(LIBDIR) $(DESTDIR)$(VARDIR) $(BIN_PROGS)
+
+	@$(SHELL) $(srcdir)/script/installmodules.sh $(INSTALLPERMS) $(DESTDIR)$(BASEDIR) $(DESTDIR)$(RPCLIBDIR) $(RPC_MODULES)
 
 installmodules: all installdirs
-	@$(SHELL) $(srcdir)/script/installmodules.sh $(INSTALLPERMS) $(BASEDIR) $(VFSLIBDIR) $(MODULES)
+	@$(SHELL) $(srcdir)/script/installmodules.sh $(INSTALLPERMS) $(DESTDIR)$(BASEDIR) $(DESTDIR)$(VFSLIBDIR) $(VFS_MODULES)
+	@$(SHELL) $(srcdir)/script/installmodules.sh $(INSTALLPERMS) $(DESTDIR)$(BASEDIR) $(DESTDIR)$(PDBLIBDIR) $(PDB_MODULES)
 
 installscripts: installdirs
-	@$(SHELL) $(srcdir)/script/installscripts.sh $(INSTALLPERMS) $(BINDIR) $(SCRIPTS)
+	@$(SHELL) $(srcdir)/script/installscripts.sh $(INSTALLPERMS) $(DESTDIR)$(BINDIR) $(SCRIPTS)
 
 installdat: installdirs
-	@$(SHELL) $(srcdir)/script/installdat.sh $(LIBDIR) $(srcdir)
+	@$(SHELL) $(srcdir)/script/installdat.sh $(DESTDIR)$(LIBDIR) $(srcdir)
 
 installswat: installdirs
-	@$(SHELL) $(srcdir)/script/installswat.sh $(SWATDIR) $(srcdir)
+	@$(SHELL) $(srcdir)/script/installswat.sh $(DESTDIR)$(SWATDIR) $(srcdir)
 
 installclientlib:
-	-$(INSTALLCMD) bin/libsmbclient.@SHLIBEXT@ ${prefix}/lib
-	-$(INSTALLCMD) -d ${prefix}/include
-	-$(INSTALLCMD) include/libsmbclient.h ${prefix}/include
+	-$(INSTALLCLIENTCMD_SH) bin/libsmbclient.@SHLIBEXT@ $(DESTDIR)${prefix}/lib
+	-$(INSTALLCLIENTCMD_A) bin/libsmbclient.a $(DESTDIR)${prefix}/lib
+	-$(INSTALLCMD) -d $(DESTDIR)${prefix}/include
+	-$(INSTALLCMD) include/libsmbclient.h $(DESTDIR)${prefix}/include
 
 # Python extensions
 
@@ -919,11 +1051,17 @@
 		$(PY_COMMON_PROTO_OBJ)
 
 python_ext: $(PYTHON_OBJS)
+	@if test -z "$(PYTHON)"; then \
+		echo Use the option --with-python to configure python; \
+		exit 1; fi
 	PYTHON_OBJS="$(PYTHON_OBJS)" PYTHON_CFLAGS="$(CFLAGS) $(CPPFLAGS) $(FLAGS)" \
 	LIBS="$(LIBS)" \
 		$(PYTHON) python/setup.py build
 
 python_install: $(PYTHON_OBJS)
+	@if test -z "$(PYTHON)"; then \
+		echo Use the option --with-python to configure python; \
+		exit 1; fi
 	PYTHON_OBJS="$(PYTHON_OBJS)" PYTHON_CFLAGS="$(CFLAGS) $(CPPFLAGS)" \
 	LIBS="$(LIBS)" \
 		$(PYTHON) python/setup.py install
@@ -933,11 +1071,11 @@
 
 # revert to the previously installed version
 revert:
-	@$(SHELL) $(srcdir)/script/revert.sh $(SBINDIR) $(SPROGS) 
-	@$(SHELL) $(srcdir)/script/revert.sh $(BINDIR) $(PROGS) $(SCRIPTS)
+	@$(SHELL) $(srcdir)/script/revert.sh $(SBINDIR) $(SBIN_PROGS) 
+	@$(SHELL) $(srcdir)/script/revert.sh $(BINDIR) $(BIN_PROGS) $(SCRIPTS)
 
 installman:
-	@$(SHELL) $(srcdir)/script/installman.sh $(MANDIR) $(srcdir) $(man_langs) "@ROFF@"
+	@$(SHELL) $(srcdir)/script/installman.sh $(DESTDIR)$(MANDIR) $(srcdir) $(man_langs) "@ROFF@"
 
 .PHONY: showlayout
 
@@ -954,24 +1092,26 @@
 uninstall: uninstallman uninstallbin uninstallscripts
 
 uninstallman:
-	@$(SHELL) $(srcdir)/script/uninstallman.sh $(MANDIR) $(srcdir) $(man_langs)
+	@$(SHELL) $(srcdir)/script/uninstallman.sh $(DESTDIR)$(MANDIR) $(srcdir) $(man_langs)
 
 uninstallbin:
-	@$(SHELL) $(srcdir)/script/uninstallbin.sh $(INSTALLPERMS) $(BASEDIR) $(SBINDIR) $(LIBDIR) $(VARDIR) $(SPROGS)
-	@$(SHELL) $(srcdir)/script/uninstallbin.sh $(INSTALLPERMS) $(BASEDIR) $(BINDIR) $(LIBDIR) $(VARDIR) $(PROGS)
+	@$(SHELL) $(srcdir)/script/uninstallbin.sh $(INSTALLPERMS) $(DESTDIR)$(BASEDIR) $(DESTDIR)$(SBINDIR) $(DESTDIR)$(LIBDIR) $(DESTDIR)$(VARDIR) $(DESTDIR)$(SBIN_PROGS)
+	@$(SHELL) $(srcdir)/script/uninstallbin.sh $(INSTALLPERMS) $(DESTDIR)$(BASEDIR) $(DESTDIR)$(BINDIR) $(DESTDIR)$(LIBDIR) $(DESTDIR)$(VARDIR) $(DESTDIR)$(BIN_PROGS)
+	@$(SHELL) $(srcdir)/script/uninstallmodules.sh $(INSTALLPERMS) $(DESTDIR)$(BASEDIR) $(DESTDIR)$(RPCLIBDIR) $(DESTDIR)$(RPC_MODULES)
 
 uninstallmodules:
-	@$(SHELL) $(srcdir)/script/uninstallmodules.sh $(INSTALLPERMS) $(BASEDIR) $(LIBDIR) $(MODULES)
+	@$(SHELL) $(srcdir)/script/uninstallmodules.sh $(INSTALLPERMS) $(DESTDIR)$(BASEDIR) $(DESTDIR)$(PDBLIBDIR) $(DESTDIR)$(VFS_MODULES)
+	@$(SHELL) $(srcdir)/script/uninstallmodules.sh $(INSTALLPERMS) $(DESTDIR)$(BASEDIR) $(DESTDIR)$(VFSLIBDIR) $(DESTDIR)$(PDB_MODULES)
 
 uninstallscripts:
-	@$(SHELL) $(srcdir)/script/uninstallscripts.sh $(INSTALLPERMS) $(BINDIR) $(SCRIPTS)
+	@$(SHELL) $(srcdir)/script/uninstallscripts.sh $(INSTALLPERMS) $(DESTDIR)$(BINDIR) $(SCRIPTS)
 
 # Toplevel clean files
 TOPFILES=dynconfig.o dynconfig.po
 
 clean: delheaders python_clean
 	-rm -f core */*~ *~ */*.o */*.po */*.po32 */*.@SHLIBEXT@ \
-		$(TOPFILES) $(PROGS) $(SPROGS) $(MODULES) .headers.stamp
+		$(TOPFILES) $(BIN_PROGS) $(SBIN_PROGS) $(VFS_MODULES) $(PDB_MODULES) $(RPC_MODULES) $(TORTURE_PROGS) .headers.stamp
 
 # Making this target will just make sure that the prototype files
 # exist, not necessarily that they are up to date.  Since they're
@@ -1032,10 +1172,14 @@
 # make sure these commands are executed in sequence even for a
 # parallel make.
 headers: 
-	$(MAKE) delheaders include/proto.h include/build_env.h \
-	include/wrepld_proto.h nsswitch/winbindd_proto.h \
-	web/swat_proto.h client/client_proto.h \
-	utils/net_proto.h
+	$(MAKE) delheaders; \
+	$(MAKE) include/proto.h; \
+	$(MAKE) include/build_env.h; \
+	$(MAKE) include/wrepld_proto.h; \
+	$(MAKE) nsswitch/winbindd_proto.h; \
+	$(MAKE) web/swat_proto.h; \
+	$(MAKE) client/client_proto.h; \
+	$(MAKE) utils/net_proto.h
 
 proto: headers 
 
@@ -1048,7 +1192,7 @@
 	ctags `find $(srcdir) -name "*.[ch]" | grep -v /CVS/`
 
 realclean: clean delheaders
-	-rm -f config.log $(PROGS) $(MODULES) $(SPROGS) bin/.dummy script/findsmb
+	-rm -f config.log $(BIN_PROGS) $(SBIN_PROGS) bin/.dummy script/findsmb
 
 distclean: realclean
 	-rm -f include/stamp-h
diff -uNr samba-3.0alpha21.orig/source/acconfig.h samba-3.0alpha21/source/acconfig.h
--- samba-3.0alpha21.orig/source/acconfig.h	1969-12-31 18:00:00.000000000 -0600
+++ samba-3.0alpha21/source/acconfig.h	2003-02-16 19:05:45.000000000 -0600
@@ -0,0 +1,235 @@
+#undef HAVE_VOLATILE
+#undef HAVE_BROKEN_READDIR
+#undef HAVE_C99_VSNPRINTF
+#undef HAVE_ERRNO_DECL
+#undef HAVE_LONGLONG
+#undef HAVE_OFF64_T
+#undef HAVE_REMSH
+#undef HAVE_UNSIGNED_CHAR
+#undef HAVE_UTIMBUF
+#undef HAVE_SIG_ATOMIC_T_TYPE
+#undef HAVE_SOCKLEN_T_TYPE
+#undef ssize_t
+#undef ino_t
+#undef ssize_t
+#undef loff_t
+#undef offset_t
+#undef aclent_t
+#undef wchar_t
+#undef HAVE_CONNECT
+#undef HAVE_SHORT_INO_T
+#undef WITH_SMBWRAPPER
+#undef WITH_AFS
+#undef WITH_DFS
+#undef SUNOS5
+#undef SUNOS4
+#undef LINUX
+#undef AIX
+#undef BSD
+#undef IRIX
+#undef UNIXWARE
+#undef SYSV
+#undef IRIX6
+#undef HPUX
+#undef QNX
+#undef SCO
+#undef OSF1
+#undef NEXT2
+#undef RELIANTUNIX
+#undef HAVE_MMAP
+#undef HAVE_FCNTL_LOCK
+#undef HAVE_FTRUNCATE_EXTEND
+#undef FTRUNCATE_NEEDS_ROOT
+#undef HAVE_TRAPDOOR_UID
+#undef HAVE_ROOT
+#undef HAVE_GETTIMEOFDAY_TZ
+#undef HAVE_SOCK_SIN_LEN
+#undef STAT_READ_FILSYS
+#undef STAT_STATFS2_BSIZE
+#undef STAT_STATFS2_FSIZE
+#undef STAT_STATFS2_FS_DATA
+#undef STAT_STATFS3_OSF1
+#undef STAT_STATFS4
+#undef STAT_STATVFS
+#undef STAT_STATVFS64
+#undef HAVE_IFACE_AIX
+#undef HAVE_IFACE_IFCONF
+#undef HAVE_IFACE_IFREQ
+#undef HAVE_CRYPT
+#undef HAVE_PUTPRPWNAM
+#undef HAVE_SET_AUTH_PARAMETERS
+#undef WITH_SYSLOG
+#undef WITH_PROFILE
+#undef WITH_PAM
+#undef WITH_NISPLUS_HOME
+#undef WITH_AUTOMOUNT
+#undef WITH_SMBMOUNT
+#undef WITH_QUOTAS
+#undef WITH_WINBIND
+#undef HAVE_BROKEN_GETGROUPS
+#undef REPLACE_GETPASS
+#undef REPLACE_INET_NTOA
+#undef HAVE_FUNCTION_MACRO
+#undef HAVE_VA_COPY
+#undef HAVE_SETRESUID_DECL
+#undef HAVE_SETRESUID
+#undef WITH_UTMP
+#undef WITH_MSDFS
+#undef WITH_LIBICONV
+#undef HAVE_INO64_T
+#undef HAVE_DEV64_T
+#undef HAVE_STRUCT_FLOCK64
+#undef SIZEOF_INO_T
+#undef SIZEOF_OFF_T
+#undef STAT_STATVFS64
+#undef HAVE_LIBREADLINE
+#undef HAVE_KERNEL_SHARE_MODES
+#undef HAVE_KERNEL_OPLOCKS_IRIX
+#undef HAVE_KERNEL_OPLOCKS_LINUX
+#undef HAVE_KERNEL_CHANGE_NOTIFY
+#undef HAVE_IRIX_SPECIFIC_CAPABILITIES
+#undef HAVE_INT16_FROM_RPC_RPC_H
+#undef HAVE_UINT16_FROM_RPC_RPC_H
+#undef HAVE_INT32_FROM_RPC_RPC_H
+#undef HAVE_UINT32_FROM_RPC_RPC_H
+#undef KRB4_AUTH
+#undef KRB5_AUTH
+#undef KRB4_DIR
+#undef KRB5_DIR
+#undef SEEKDIR_RETURNS_VOID
+#undef HAVE_DIRENT_D_OFF
+#undef HAVE_GETSPNAM
+#undef HAVE_BIGCRYPT
+#undef HAVE_GETPRPWNAM
+#undef HAVE_FSTAT64
+#undef HAVE_LSTAT64
+#undef HAVE_STAT64
+#undef HAVE_SETRESGID
+#undef HAVE_SETRESGID_DECL
+#undef HAVE_SHADOW_H
+#undef HAVE_CUPS
+#undef HAVE_MEMSET
+#undef HAVE_STRCASECMP
+#undef HAVE_STRUCT_DIRENT64
+#undef HAVE_TRUNCATED_SALT
+#undef BROKEN_NISPLUS_INCLUDE_FILES
+#undef HAVE_RPC_AUTH_ERROR_CONFLICT
+#undef HAVE_EXPLICIT_LARGEFILE_SUPPORT
+#undef USE_BOTH_CRYPT_CALLS
+#undef HAVE_BROKEN_FCNTL64_LOCKS
+#undef HAVE_SECURE_MKSTEMP
+#undef HAVE_FNMATCH
+#undef USE_SETEUID
+#undef USE_SETRESUID
+#undef USE_SETREUID
+#undef USE_SETUIDX
+#undef HAVE_DLOPEN
+#undef HAVE_DLCLOSE
+#undef HAVE_DLSYM
+#undef HAVE_DLERROR
+#undef SYSCONF_SC_NGROUPS_MAX
+#undef HAVE_UT_UT_NAME
+#undef HAVE_UT_UT_USER
+#undef HAVE_UT_UT_ID
+#undef HAVE_UT_UT_HOST
+#undef HAVE_UT_UT_TIME
+#undef HAVE_UT_UT_TV
+#undef HAVE_UT_UT_TYPE
+#undef HAVE_UT_UT_PID
+#undef HAVE_UT_UT_EXIT
+#undef HAVE_UT_UT_ADDR
+#undef HAVE_UX_UT_SYSLEN
+#undef PUTUTLINE_RETURNS_UTMP
+#undef COMPILER_SUPPORTS_LL
+#undef HAVE_YP_GET_DEFAULT_DOMAIN
+#undef USE_SPINLOCKS
+#undef SPARC_SPINLOCKS
+#undef INTEL_SPINLOCKS
+#undef MIPS_SPINLOCKS
+#undef POWERPC_SPINLOCKS
+#undef HAVE_POSIX_ACLS
+#undef HAVE_ACL_GET_PERM_NP
+#undef HAVE_UNIXWARE_ACLS
+#undef HAVE_SOLARIS_ACLS
+#undef HAVE_HPUX_ACLS
+#undef HAVE_IRIX_ACLS
+#undef HAVE_AIX_ACLS
+#undef HAVE_TRU64_ACLS
+#undef HAVE_NO_ACLS
+#undef HAVE_LIBPAM
+#undef HAVE_ASPRINTF_DECL
+#undef HAVE_VASPRINTF_DECL
+#undef HAVE_SNPRINTF_DECL
+#undef HAVE_VSNPRINTF_DECL
+#undef HAVE_NATIVE_ICONV
+#undef HAVE_UNIXSOCKET
+#undef MMAP_BLACKLIST
+#undef HAVE_IMMEDIATE_STRUCTURES
+#undef HAVE_CUPS
+#undef WITH_SAM
+#undef WITH_LDAP_SAMCONFIG
+#undef WITH_NISPLUS_SAM
+#undef WITH_TDB_SAM
+#undef LINUX_QUOTAS_1
+#undef LINUX_QUOTAS_2
+#undef PACKAGE
+#undef VERSION
+#undef HAVE_LC_MESSAGES
+#undef ENABLE_NLS
+#undef HAVE_CATGETS
+#undef HAVE_GETTEXT
+#undef HAVE_STPCPY
+#undef I18N_SWAT
+#undef I18N_DEFAULT_PREF_LANG
+#undef HAVE_KRB5
+#undef HAVE_GSSAPI
+#undef BROKEN_REDHAT_7_SYSTEM_HEADERS
+#undef HAVE_LDAP
+#undef HAVE_STAT_ST_BLOCKS
+#undef STAT_ST_BLOCKSIZE
+#undef HAVE_STAT_ST_BLKSIZE
+#undef HAVE_DEVICE_MAJOR_FN
+#undef HAVE_DEVICE_MINOR_FN
+#undef HAVE_PASSWD_PW_COMMENT
+#undef HAVE_PASSWD_PW_AGE
+/*
+ * Add these definitions to allow VFS modules to
+ * see the CPPFLAGS defines.
+ */
+#ifndef _HPUX_SOURCE
+#undef _HPUX_SOURCE
+#endif
+#ifndef _POSIX_SOURCE
+#undef _POSIX_SOURCE
+#endif
+#ifndef _LARGEFILE64_SOURCE
+#undef _LARGEFILE64_SOURCE
+#endif
+#ifndef _ALIGNMENT_REQUIRED
+#undef _ALIGNMENT_REQUIRED
+#endif
+#ifndef _MAX_ALIGNMENT
+#undef _MAX_ALIGNMENT
+#endif
+#ifndef _LARGE_FILES
+#undef _LARGE_FILES
+#endif
+#ifndef _FILE_OFFSET_BITS
+#undef _FILE_OFFSET_BITS
+#endif
+#ifndef _GNU_SOURCE
+#undef _GNU_SOURCE
+#endif
+
+#undef LDAP_SET_REBIND_PROC_ARGS
+#undef HAVE_SENDFILE
+#undef HAVE_SENDFILE64
+#undef LINUX_SENDFILE_API
+#undef LINUX_BROKEN_SENDFILE_API
+#undef WITH_SENDFILE
+#undef FREEBSD_SENDFILE_API
+#undef HPUX_SENDFILE_API
+#undef WITH_ADS
+#undef HAVE_SENDFILEV
+#undef HAVE_SENDFILEV64
+#undef SOLARIS_SENDFILE_API
diff -uNr samba-3.0alpha21.orig/source/aclocal.m4 samba-3.0alpha21/source/aclocal.m4
--- samba-3.0alpha21.orig/source/aclocal.m4	2003-02-16 19:06:30.000000000 -0600
+++ samba-3.0alpha21/source/aclocal.m4	2003-02-16 19:05:45.000000000 -0600
@@ -462,3 +462,26 @@
   rm -f conf.mysqltest
 ])
 
+dnl Removes -I/usr/include/? from given variable
+AC_DEFUN(CFLAGS_REMOVE_USR_INCLUDE,[
+  ac_new_flags=""
+  for i in [$]$1; do
+    case [$]i in
+    -I/usr/include|-I/usr/include/) ;;
+    *) ac_new_flags="[$]ac_new_flags [$]i" ;;
+    esac
+  done
+  $1=[$]ac_new_flags
+])
+    
+dnl Removes -L/usr/lib/? from given variable
+AC_DEFUN(LIB_REMOVE_USR_LIB,[
+  ac_new_flags=""
+  for i in [$]$1; do
+    case [$]i in
+    -L/usr/lib|-L/usr/lib/) ;;
+    *) ac_new_flags="[$]ac_new_flags [$]i" ;;
+    esac
+  done
+  $1=[$]ac_new_flags
+])
diff -uNr samba-3.0alpha21.orig/source/auth/auth.c samba-3.0alpha21/source/auth/auth.c
--- samba-3.0alpha21.orig/source/auth/auth.c	2003-02-16 19:06:30.000000000 -0600
+++ samba-3.0alpha21/source/auth/auth.c	2003-02-16 19:05:45.000000000 -0600
@@ -25,7 +25,7 @@
 
 /** List of various built-in authentication modules */
 
-const struct auth_init_function_entry builtin_auth_init_functions[] = {
+static const struct auth_init_function_entry builtin_auth_init_functions[] = {
 	{ "guest", auth_init_guest },
 	{ "rhosts", auth_init_rhosts },
 	{ "hostsequiv", auth_init_hostsequiv },
@@ -52,17 +52,17 @@
 static const uint8 *get_ntlm_challenge(struct auth_context *auth_context) 
 {
 	DATA_BLOB challenge = data_blob(NULL, 0);
-	char *challenge_set_by = NULL;
+	const char *challenge_set_by = NULL;
 	auth_methods *auth_method;
 	TALLOC_CTX *mem_ctx;
 
 	if (auth_context->challenge.length) {
-		DEBUG(5, ("get_ntlm_challenge (auth subsystem): returning previous challenge (normal)\n"));
+		DEBUG(5, ("get_ntlm_challenge (auth subsystem): returning previous challenge by module %s (normal)\n", 
+			  auth_context->challenge_set_by));
 		return auth_context->challenge.data;
 	}
 
-	for (auth_method = auth_context->auth_method_list; auth_method; auth_method = auth_method->next)
-	{
+	for (auth_method = auth_context->auth_method_list; auth_method; auth_method = auth_method->next) {
 		if (auth_method->get_chal == NULL) {
 			DEBUG(5, ("auth_get_challenge: module %s did not want to specify a challenge\n", auth_method->name));
 			continue;
@@ -75,9 +75,9 @@
 			continue;
 		}
 
-		mem_ctx = talloc_init_named("auth_get_challenge for module %s", auth_method->name);
+		mem_ctx = talloc_init("auth_get_challenge for module %s", auth_method->name);
 		if (!mem_ctx) {
-			smb_panic("talloc_init_named() failed!");
+			smb_panic("talloc_init() failed!");
 		}
 		
 		challenge = auth_method->get_chal(auth_context, &auth_method->private_data, mem_ctx);
@@ -183,18 +183,24 @@
 	auth_methods *auth_method;
 	TALLOC_CTX *mem_ctx;
 
-	if (!user_info || !auth_context || !server_info) {
+	if (!user_info || !auth_context || !server_info)
 		return NT_STATUS_LOGON_FAILURE;
-	}
 
-	DEBUG(3, ("check_password:  Checking password for unmapped user [%s]\\[%s]@[%s] with the new password interface\n", 
+	DEBUG(3, ("check_ntlm_password:  Checking password for unmapped user [%s]\\[%s]@[%s] with the new password interface\n", 
 		  user_info->client_domain.str, user_info->smb_name.str, user_info->wksta_name.str));
 
-	DEBUG(3, ("check_password:  mapped user is: [%s]\\[%s]@[%s]\n", 
+	DEBUG(3, ("check_ntlm_password:  mapped user is: [%s]\\[%s]@[%s]\n", 
 		  user_info->domain.str, user_info->internal_username.str, user_info->wksta_name.str));
-	if (auth_context->challenge_set_by) {
-		DEBUG(10, ("auth_context challenge created by %s\n", auth_context->challenge_set_by));
+
+	if (auth_context->challenge.length != 8) {
+		DEBUG(0, ("check_ntlm_password:  Invalid challenge stored for this auth context - cannot continue\n"));
+		return NT_STATUS_LOGON_FAILURE;
 	}
+
+	if (auth_context->challenge_set_by)
+		DEBUG(10, ("check_ntlm_password: auth_context challenge created by %s\n",
+					auth_context->challenge_set_by));
+
 	DEBUG(10, ("challenge is: \n"));
 	dump_data(5, auth_context->challenge.data, auth_context->challenge.length);
 
@@ -208,37 +214,33 @@
 #endif
 
 	/* This needs to be sorted:  If it doesn't match, what should we do? */
-  	if (!check_domain_match(user_info->smb_name.str, user_info->domain.str)) {
+  	if (!check_domain_match(user_info->smb_name.str, user_info->domain.str))
 		return NT_STATUS_LOGON_FAILURE;
-	}
 
-	for (auth_method = auth_context->auth_method_list;auth_method; auth_method = auth_method->next)
-	{
-		mem_ctx = talloc_init_named("%s authentication for user %s\\%s", auth_method->name, 
+	for (auth_method = auth_context->auth_method_list;auth_method; auth_method = auth_method->next) {
+		mem_ctx = talloc_init("%s authentication for user %s\\%s", auth_method->name, 
 					    user_info->domain.str, user_info->smb_name.str);
 
 		nt_status = auth_method->auth(auth_context, auth_method->private_data, mem_ctx, user_info, server_info);
 		if (NT_STATUS_IS_OK(nt_status)) {
-			DEBUG(3, ("check_password: %s authentication for user [%s] suceeded\n", 
+			DEBUG(3, ("check_ntlm_password: %s authentication for user [%s] suceeded\n", 
 				  auth_method->name, user_info->smb_name.str));
 		} else {
-			DEBUG(5, ("check_password: %s authentication for user [%s] FAILED with error %s\n", 
+			DEBUG(5, ("check_ntlm_password: %s authentication for user [%s] FAILED with error %s\n", 
 				  auth_method->name, user_info->smb_name.str, nt_errstr(nt_status)));
 		}
 
 		talloc_destroy(mem_ctx);
 
-		if (NT_STATUS_IS_OK(nt_status)) {
+		if (NT_STATUS_IS_OK(nt_status))
 			break;
-		}
 	}
 
 	/* This is one of the few places the *relies* (rather than just sets defaults
 	   on the value of lp_security().  This needs to change.  A new paramater 
 	   perhaps? */
-	if (lp_security() >= SEC_SERVER) {
+	if (lp_security() >= SEC_SERVER)
 		smb_user_control(user_info, *server_info, nt_status);
-	}
 
 	if (NT_STATUS_IS_OK(nt_status)) {
 		pdb_username = pdb_get_username((*server_info)->sam_account);
@@ -249,17 +251,17 @@
 			unbecome_root();
 			
 			if (NT_STATUS_IS_OK(nt_status)) {
-				DEBUG(5, ("check_password:  PAM Account for user [%s] suceeded\n", 
+				DEBUG(5, ("check_ntlm_password:  PAM Account for user [%s] suceeded\n", 
 					  pdb_username));
 			} else {
-				DEBUG(3, ("check_password:  PAM Account for user [%s] FAILED with error %s\n", 
+				DEBUG(3, ("check_ntlm_password:  PAM Account for user [%s] FAILED with error %s\n", 
 					  pdb_username, nt_errstr(nt_status)));
 			} 
 		}
 		
 		if (NT_STATUS_IS_OK(nt_status)) {
 			DEBUG((*server_info)->guest ? 5 : 2, 
-			      ("check_password:  %sauthentication for user [%s] -> [%s] -> [%s] suceeded\n", 
+			      ("check_ntlm_password:  %sauthentication for user [%s] -> [%s] -> [%s] suceeded\n", 
 			       (*server_info)->guest ? "guest " : "", 
 			       user_info->smb_name.str, 
 			       user_info->internal_username.str, 
@@ -268,7 +270,7 @@
 	}
 
 	if (!NT_STATUS_IS_OK(nt_status)) {
-		DEBUG(2, ("check_password:  Authentication for user [%s] -> [%s] FAILED with error %s\n", 
+		DEBUG(2, ("check_ntlm_password:  Authentication for user [%s] -> [%s] FAILED with error %s\n", 
 			  user_info->smb_name.str, user_info->internal_username.str, 
 			  nt_errstr(nt_status)));
 		ZERO_STRUCTP(server_info);
@@ -282,9 +284,8 @@
 
 static void free_auth_context(struct auth_context **auth_context)
 {
-	if (*auth_context != NULL) {
+	if (*auth_context != NULL)
 		talloc_destroy((*auth_context)->mem_ctx);
-	}
 	*auth_context = NULL;
 }
 
@@ -296,7 +297,7 @@
 {
 	TALLOC_CTX *mem_ctx;
 
-	mem_ctx = talloc_init_named("authentication context");
+	mem_ctx = talloc_init("authentication context");
 	
 	*auth_context = talloc(mem_ctx, sizeof(**auth_context));
 	if (!*auth_context) {
@@ -327,48 +328,43 @@
 	NTSTATUS nt_status;
 
 	if (!text_list) {
-		DEBUG(2,("No auth method list!?\n"));
+		DEBUG(2,("make_auth_context_text_list: No auth method list!?\n"));
 		return NT_STATUS_UNSUCCESSFUL;
 	}
 	
-	if (!NT_STATUS_IS_OK(nt_status = make_auth_context(auth_context))) {
+	if (!NT_STATUS_IS_OK(nt_status = make_auth_context(auth_context)))
 		return nt_status;
-	}
 	
-	for (;*text_list; text_list++)
-	{ 
-		DEBUG(5,("Attempting to find an auth method to match %s\n", *text_list));
-		for (i = 0; builtin_auth_init_functions[i].name; i++)
-		{
-			if (strequal(builtin_auth_init_functions[i].name, *text_list))
-			{
-				
-				char *module_name = smb_xstrdup(*text_list);
-				char *module_params = NULL;
-				char *p;
-				
-				p = strchr(module_name, ':');
-				
-				if (p) {
-					*p = 0;
-					
-					module_params = p+1;
-					
-					trim_string(module_params, " ", " ");
-				}
-				
-				trim_string(module_name, " ", " ");
+	for (;*text_list; text_list++) { 
+		DEBUG(5,("make_auth_context_text_list: Attempting to find an auth method to match %s\n",
+					*text_list));
+		for (i = 0; builtin_auth_init_functions[i].name; i++) {
+			char *module_name = smb_xstrdup(*text_list);
+			char *module_params = NULL;
+			char *p;
+
+			p = strchr(module_name, ':');
+			if (p) {
+				*p = 0;
+				module_params = p+1;
+				trim_string(module_params, " ", " ");
+			}
+
+			trim_string(module_name, " ", " ");
 
-				DEBUG(5,("Found auth method %s (at pos %d)\n", *text_list, i));
+			if (strequal(builtin_auth_init_functions[i].name, module_name)) {
+				DEBUG(5,("make_auth_context_text_list: Found auth method %s (at pos %d)\n", *text_list, i));
 				if (NT_STATUS_IS_OK(builtin_auth_init_functions[i].init(*auth_context, module_params, &t))) {
-					DEBUG(5,("auth method %s has a valid init\n", *text_list));
+					DEBUG(5,("make_auth_context_text_list: auth method %s has a valid init\n",
+								*text_list));
 					DLIST_ADD_END(list, t, tmp);
 				} else {
-					DEBUG(0,("auth method %s did not correctly init\n", *text_list));
+					DEBUG(0,("make_auth_context_text_list: auth method %s did not correctly init\n",
+								*text_list));
 				}
-				SAFE_FREE(module_name);
 				break;
 			}
+			SAFE_FREE(module_name);
 		}
 	}
 	
@@ -452,6 +448,7 @@
 	}
 	
 	(*auth_context)->challenge = data_blob(chal, 8);
+	(*auth_context)->challenge_set_by = "fixed";
 	return nt_status;
 }
 
diff -uNr samba-3.0alpha21.orig/source/auth/auth_builtin.c samba-3.0alpha21/source/auth/auth_builtin.c
--- samba-3.0alpha21.orig/source/auth/auth_builtin.c	2003-02-16 19:06:30.000000000 -0600
+++ samba-3.0alpha21/source/auth/auth_builtin.c	2003-02-16 19:05:45.000000000 -0600
@@ -41,18 +41,19 @@
 	NTSTATUS nt_status = NT_STATUS_LOGON_FAILURE;
 
 	if (!(user_info->internal_username.str 
-	      && *user_info->internal_username.str)) 
+	      && *user_info->internal_username.str)) {
 		nt_status = make_server_info_guest(server_info);
+	}
 
 	return nt_status;
 }
 
 /* Guest modules initialisation */
+
 NTSTATUS auth_init_guest(struct auth_context *auth_context, const char *options, auth_methods **auth_method) 
 {
-	if (!make_auth_methods(auth_context, auth_method)) {
+	if (!make_auth_methods(auth_context, auth_method))
 		return NT_STATUS_NO_MEMORY;
-	}
 
 	(*auth_method)->auth = check_guest_security;
 	(*auth_method)->name = "guest";
@@ -91,7 +92,7 @@
 	strlower(user);
 	error_num = strtoul(user, NULL, 16);
 	
-	DEBUG(5,("Error for user %s was %lx\n", user, error_num));
+	DEBUG(5,("check_name_to_ntstatus_security: Error for user %s was %lx\n", user, error_num));
 
 	nt_status = NT_STATUS(error_num);
 	
@@ -99,11 +100,11 @@
 }
 
 /** Module initailisation function */
+
 NTSTATUS auth_init_name_to_ntstatus(struct auth_context *auth_context, const char *param, auth_methods **auth_method) 
 {
-	if (!make_auth_methods(auth_context, auth_method)) {
+	if (!make_auth_methods(auth_context, auth_method))
 		return NT_STATUS_NO_MEMORY;
-	}
 
 	(*auth_method)->auth = check_name_to_ntstatus_security;
 	(*auth_method)->name = "name_to_ntstatus";
@@ -148,11 +149,11 @@
 
 
 /** Module initailisation function */
+
 NTSTATUS auth_init_fixed_challenge(struct auth_context *auth_context, const char *param, auth_methods **auth_method) 
 {
-	if (!make_auth_methods(auth_context, auth_method)) {
+	if (!make_auth_methods(auth_context, auth_method))
 		return NT_STATUS_NO_MEMORY;
-	}
 
 	(*auth_method)->auth = check_fixed_challenge_security;
 	(*auth_method)->get_chal = auth_get_fixed_challenge;
@@ -167,6 +168,7 @@
  **/
 
 /* Plugin modules initialisation */
+
 NTSTATUS auth_init_plugin(struct auth_context *auth_context, const char *param, auth_methods **auth_method) 
 {
 	void * dl_handle;
@@ -174,7 +176,7 @@
 	auth_init_function plugin_init;
 
 	if (param == NULL) {
-		DEBUG(0, ("The plugin module needs an argument!\n"));
+		DEBUG(0, ("auth_init_plugin: The plugin module needs an argument!\n"));
 		return NT_STATUS_UNSUCCESSFUL;
 	}
 
@@ -188,21 +190,21 @@
 
 	trim_string(plugin_name, " ", " ");
 
-	DEBUG(5, ("Trying to load auth plugin %s\n", plugin_name));
+	DEBUG(5, ("auth_init_plugin: Trying to load auth plugin %s\n", plugin_name));
 	dl_handle = sys_dlopen(plugin_name, RTLD_NOW );
 	if (!dl_handle) {
-		DEBUG(0, ("Failed to load auth plugin %s using sys_dlopen (%s)\n", plugin_name, sys_dlerror()));
+		DEBUG(0, ("auth_init_plugin: Failed to load auth plugin %s using sys_dlopen (%s)\n",
+					plugin_name, sys_dlerror()));
 		return NT_STATUS_UNSUCCESSFUL;
 	}
     
 	plugin_init = sys_dlsym(dl_handle, "auth_init");
 	if (!plugin_init){
-		DEBUG(0, ("Failed to find function 'pdb_init' using sys_dlsym in sam plugin %s (%s)\n", plugin_name, sys_dlerror()));	    
+		DEBUG(0, ("Failed to find function 'auth_init' using sys_dlsym in sam plugin %s (%s)\n",
+					plugin_name, sys_dlerror()));	    
 		return NT_STATUS_UNSUCCESSFUL;
 	}
 
 	DEBUG(5, ("Starting sam plugin %s with paramater %s\n", plugin_name, plugin_param?plugin_param:"(null)"));
 	return plugin_init(auth_context, plugin_param, auth_method);
 }
-
-
diff -uNr samba-3.0alpha21.orig/source/auth/auth_domain.c samba-3.0alpha21/source/auth/auth_domain.c
--- samba-3.0alpha21.orig/source/auth/auth_domain.c	2003-02-16 19:06:30.000000000 -0600
+++ samba-3.0alpha21/source/auth/auth_domain.c	2003-02-16 19:05:45.000000000 -0600
@@ -212,7 +212,7 @@
 	result = cli_nt_setup_creds(*cli, sec_chan, trust_passwd, &neg_flags, 2);
 
         if (!NT_STATUS_IS_OK(result)) {
-		DEBUG(0,("connect_to_domain_password_server: unable to setup the PDC credentials to machine \
+		DEBUG(0,("connect_to_domain_password_server: unable to setup the NETLOGON credentials to machine \
 %s. Error was : %s.\n", remote_machine, nt_errstr(result)));
 		cli_nt_session_close(*cli);
 		cli_ulogoff(*cli);
@@ -262,103 +262,23 @@
  We have been asked to dynamically determine the IP addresses of
  the PDC and BDC's for DOMAIN, and query them in turn.
 ************************************************************************/
-static NTSTATUS find_connect_pdc(struct cli_state **cli, 
+static NTSTATUS find_connect_dc(struct cli_state **cli, 
 				 const char *domain,
 				 const char *setup_creds_as,
 				 uint16 sec_chan,
 				 unsigned char *trust_passwd, 
 				 time_t last_change_time)
 {
-	struct in_addr *ip_list = NULL;
-	int count = 0;
-	int i;
-	NTSTATUS nt_status = NT_STATUS_NO_LOGON_SERVERS;
-	time_t time_now = time(NULL);
-	BOOL use_pdc_only = False;
-	BOOL list_ordered;
-
-	/*
-	 * If the time the machine password has changed
-	 * was less than an hour ago then we need to contact
-	 * the PDC only, as we cannot be sure domain replication
-	 * has yet taken place. Bug found by Gerald (way to go
-	 * Gerald !). JRA.
-	 */
-
-	if (time_now - last_change_time < 3600)
-		use_pdc_only = True;
-
-	if (use_pdc_only) {
-		struct in_addr pdc_ip;
-
-		if (!get_pdc_ip(domain, &pdc_ip))
-			return NT_STATUS_NO_LOGON_SERVERS;
-
-		if ((ip_list = (struct in_addr *)
-		     malloc(sizeof(struct in_addr))) == NULL) 
-			return NT_STATUS_NO_MEMORY;
-
-		ip_list[0] = pdc_ip;
-		count = 1;
-
-	} else {
-		if (!get_dc_list(domain, &ip_list, &count, &list_ordered))
-			return NT_STATUS_NO_LOGON_SERVERS;
-	}
-
-	/*
-	 * Firstly try and contact a PDC/BDC who has the same
-	 * network address as any of our interfaces.
-	 */
-	for(i = 0; i < count; i++) {
-		if( !list_ordered && !is_local_net(ip_list[i]) )
-			continue;
-
-		if(NT_STATUS_IS_OK(nt_status = 
-				   attempt_connect_to_dc(cli, domain, 
-							 &ip_list[i], setup_creds_as, 
-							 sec_chan, trust_passwd))) 
-			break;
-		
-		zero_ip(&ip_list[i]); /* Tried and failed. */
-	}
-
-	/*
-	 * Secondly try and contact a random PDC/BDC.
-	 */
-	if(!NT_STATUS_IS_OK(nt_status)) {
-		i = (sys_random() % count);
-
-		if (!is_zero_ip(ip_list[i])) {
-			if (!NT_STATUS_IS_OK(nt_status = 
-					     attempt_connect_to_dc(cli, domain, 
-								   &ip_list[i], setup_creds_as, 
-								   sec_chan, trust_passwd)))
-				zero_ip(&ip_list[i]); /* Tried and failed. */
-		}
-	}
+	struct in_addr dc_ip;
+	fstring srv_name;
 
-	/*
-	 * Finally go through the IP list in turn, ignoring any addresses
-	 * we have already tried.
-	 */
-	if(!NT_STATUS_IS_OK(nt_status)) {
-		/*
-		 * Try and connect to any of the other IP addresses in the PDC/BDC list.
-		 * Note that from a WINS server the #1 IP address is the PDC.
-		 */
-		for(i = 0; i < count; i++) {
-			if (is_zero_ip(ip_list[i]))
-				continue;
-
-			if (NT_STATUS_IS_OK(nt_status = attempt_connect_to_dc(cli, domain, 
-						  &ip_list[i], setup_creds_as, sec_chan, trust_passwd)))
-				break;
-		}
+	if ( !rpc_find_dc(lp_workgroup(), srv_name, &dc_ip) ) {
+		DEBUG(0,("find_connect_dc: Failed to find an DCs for %s\n", lp_workgroup()));
+		return NT_STATUS_NO_LOGON_SERVERS;
 	}
-
-	SAFE_FREE(ip_list);
-	return nt_status;
+	
+	return attempt_connect_to_dc( cli, domain, &dc_ip, setup_creds_as, 
+			sec_chan, trust_passwd );
 }
 
 /***********************************************************************
@@ -393,7 +313,7 @@
 	while (!NT_STATUS_IS_OK(nt_status) &&
 	       next_token(&server,remote_machine,LIST_SEP,sizeof(remote_machine))) {
 		if(lp_security() != SEC_ADS && strequal(remote_machine, "*")) {
-			nt_status = find_connect_pdc(&cli, domain, setup_creds_as, sec_chan, trust_passwd, last_change_time);
+			nt_status = find_connect_dc(&cli, domain, setup_creds_as, sec_chan, trust_passwd, last_change_time);
 		} else {
 			int i;
 			BOOL retry = True;
@@ -512,7 +432,8 @@
 
 	/* Test if machine password has expired and needs to be changed */
 	if (lp_machine_password_timeout()) {
-		if (time(NULL) > (last_change_time + 
+		if (last_change_time > 0 && 
+		    time(NULL) > (last_change_time + 
 				  lp_machine_password_timeout())) {
 			global_machine_password_needs_changing = True;
 		}
diff -uNr samba-3.0alpha21.orig/source/auth/auth_ntlmssp.c samba-3.0alpha21/source/auth/auth_ntlmssp.c
--- samba-3.0alpha21.orig/source/auth/auth_ntlmssp.c	1969-12-31 18:00:00.000000000 -0600
+++ samba-3.0alpha21/source/auth/auth_ntlmssp.c	2003-02-16 19:05:45.000000000 -0600
@@ -0,0 +1,138 @@
+/* 
+   Unix SMB/Netbios implementation.
+   Version 3.0
+   handle NLTMSSP, server side
+
+   Copyright (C) Andrew Tridgell      2001
+   Copyright (C) Andrew Bartlett 2001-2003
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+   
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+   
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*/
+
+#include "includes.h"
+
+static const uint8 *auth_ntlmssp_get_challenge(struct ntlmssp_state *ntlmssp_state)
+{
+	AUTH_NTLMSSP_STATE *auth_ntlmssp_state = ntlmssp_state->auth_context;
+	return auth_ntlmssp_state->auth_context->get_ntlm_challenge(auth_ntlmssp_state->auth_context);
+}
+
+static NTSTATUS auth_ntlmssp_check_password(struct ntlmssp_state *ntlmssp_state) 
+{
+	AUTH_NTLMSSP_STATE *auth_ntlmssp_state = ntlmssp_state->auth_context;
+	uint32 auth_flags = AUTH_FLAG_NONE;
+	auth_usersupplied_info *user_info = NULL;
+	DATA_BLOB plaintext_password = data_blob(NULL, 0);
+	NTSTATUS nt_status;
+
+	if (auth_ntlmssp_state->ntlmssp_state->lm_resp.length) {
+		auth_flags |= AUTH_FLAG_LM_RESP;
+	}
+
+	if (auth_ntlmssp_state->ntlmssp_state->nt_resp.length == 24) {
+		auth_flags |= AUTH_FLAG_NTLM_RESP;
+	} else 	if (auth_ntlmssp_state->ntlmssp_state->nt_resp.length > 24) {
+		auth_flags |= AUTH_FLAG_NTLMv2_RESP;
+	};
+
+	/* the client has given us its machine name (which we otherwise would not get on port 445).
+	   we need to possibly reload smb.conf if smb.conf includes depend on the machine name */
+
+	set_remote_machine_name(auth_ntlmssp_state->ntlmssp_state->workstation);
+
+	/* setup the string used by %U */
+	/* sub_set_smb_name checks for weird internally */
+	sub_set_smb_name(auth_ntlmssp_state->ntlmssp_state->user);
+
+	reload_services(True);
+
+	nt_status = make_user_info_map(&user_info, 
+				       auth_ntlmssp_state->ntlmssp_state->user, 
+				       auth_ntlmssp_state->ntlmssp_state->domain, 
+				       auth_ntlmssp_state->ntlmssp_state->workstation, 
+	                               auth_ntlmssp_state->ntlmssp_state->lm_resp, 
+				       auth_ntlmssp_state->ntlmssp_state->nt_resp, 
+				       plaintext_password, 
+	                               auth_flags, True);
+
+	if (!NT_STATUS_IS_OK(nt_status)) {
+		return nt_status;
+	}
+
+	nt_status = auth_ntlmssp_state->auth_context->check_ntlm_password(auth_ntlmssp_state->auth_context, user_info, &auth_ntlmssp_state->server_info); 
+			
+	free_user_info(&user_info);
+
+	return nt_status;
+}
+
+NTSTATUS auth_ntlmssp_start(AUTH_NTLMSSP_STATE **auth_ntlmssp_state)
+{
+	NTSTATUS nt_status;
+	TALLOC_CTX *mem_ctx;
+
+	mem_ctx = talloc_init("AUTH NTLMSSP context");
+	
+	*auth_ntlmssp_state = talloc_zero(mem_ctx, sizeof(**auth_ntlmssp_state));
+	if (!*auth_ntlmssp_state) {
+		DEBUG(0,("auth_ntlmssp_start: talloc failed!\n"));
+		talloc_destroy(mem_ctx);
+		return NT_STATUS_NO_MEMORY;
+	}
+
+	ZERO_STRUCTP(*auth_ntlmssp_state);
+
+	(*auth_ntlmssp_state)->mem_ctx = mem_ctx;
+
+	if (!NT_STATUS_IS_OK(nt_status = ntlmssp_server_start(&(*auth_ntlmssp_state)->ntlmssp_state))) {
+		return nt_status;
+	}
+
+	if (!NT_STATUS_IS_OK(nt_status = make_auth_context_subsystem(&(*auth_ntlmssp_state)->auth_context))) {
+		return nt_status;
+	}
+
+	(*auth_ntlmssp_state)->ntlmssp_state->auth_context = (*auth_ntlmssp_state);
+	(*auth_ntlmssp_state)->ntlmssp_state->get_challenge = auth_ntlmssp_get_challenge;
+	(*auth_ntlmssp_state)->ntlmssp_state->check_password = auth_ntlmssp_check_password;
+	(*auth_ntlmssp_state)->ntlmssp_state->server_role = lp_server_role();
+
+	return NT_STATUS_OK;
+}
+
+NTSTATUS auth_ntlmssp_end(AUTH_NTLMSSP_STATE **auth_ntlmssp_state)
+{
+	TALLOC_CTX *mem_ctx = (*auth_ntlmssp_state)->mem_ctx;
+
+	if ((*auth_ntlmssp_state)->ntlmssp_state) {
+		ntlmssp_server_end(&(*auth_ntlmssp_state)->ntlmssp_state);
+	}
+	if ((*auth_ntlmssp_state)->auth_context) {
+		((*auth_ntlmssp_state)->auth_context->free)(&(*auth_ntlmssp_state)->auth_context);
+	}
+	if ((*auth_ntlmssp_state)->server_info) {
+		free_server_info(&(*auth_ntlmssp_state)->server_info);
+	}
+	talloc_destroy(mem_ctx);
+	*auth_ntlmssp_state = NULL;
+	return NT_STATUS_OK;
+}
+
+NTSTATUS auth_ntlmssp_update(AUTH_NTLMSSP_STATE *auth_ntlmssp_state, 
+			     DATA_BLOB request, DATA_BLOB *reply) 
+{
+	return ntlmssp_server_update(auth_ntlmssp_state->ntlmssp_state, request, reply);
+}
+
diff -uNr samba-3.0alpha21.orig/source/auth/auth_sam.c samba-3.0alpha21/source/auth/auth_sam.c
--- samba-3.0alpha21.orig/source/auth/auth_sam.c	2003-02-16 19:06:30.000000000 -0600
+++ samba-3.0alpha21/source/auth/auth_sam.c	2003-02-16 19:05:45.000000000 -0600
@@ -73,8 +73,11 @@
   return (memcmp(p24, nt_response.data, 24) == 0);
 }
 
+
 /****************************************************************************
-core of smb password checking routine.
+core of smb password checking routine. (NTLMv2, LMv2)
+
+Note:  The same code works with both NTLMv2 and LMv2.
 ****************************************************************************/
 static BOOL smb_pwd_check_ntlmv2(const DATA_BLOB ntv2_response,
 				 const uchar *part_passwd,
@@ -104,6 +107,11 @@
 	}
 
 	client_key_data = data_blob(ntv2_response.data+16, ntv2_response.length-16);
+	/* 
+	   todo:  should we be checking this for anything?  We can't for LMv2, 
+	   but for NTLMv2 it is meant to contain the current time etc.
+	*/
+
 	memcpy(client_response, ntv2_response.data, sizeof(client_response));
 
 	if (!ntv2_owf_gen(part_passwd, user, domain, kr)) {
@@ -206,54 +214,71 @@
 			}
 		} else {
 			DEBUG(2,("sam_password_ok: NTLMv1 passwords NOT PERMITTED for user %s\n",pdb_get_username(sampass)));			
-				/* No return, we want to check the LM hash below in this case */
+			/* no return, becouse we might pick up LMv2 in the LM feild */
 		}
 	}
 	
-	if (IS_SAM_DEFAULT(sampass, PDB_LMPASSWD)) {
-		DEBUG(3,("sam_password_ok: NO LanMan password set for user %s (and no NT password supplied)\n",pdb_get_username(sampass)));
-		auth_flags &= (~AUTH_FLAG_LM_RESP);		
-	}
-	
 	if (auth_flags & AUTH_FLAG_LM_RESP) {
-		lm_pw = pdb_get_lanman_passwd(sampass);
-			
 		if (user_info->lm_resp.length != 24) {
 			DEBUG(2,("sam_password_ok: invalid LanMan password length (%d) for user %s\n", 
 				 user_info->nt_resp.length, pdb_get_username(sampass)));		
 		}
 		
 		if (!lp_lanman_auth()) {
-			DEBUG(3,("sam_password_ok: Lanman passwords NOT PERMITTED for user %s\n",pdb_get_username(sampass)));			
-			return NT_STATUS_LOGON_FAILURE;
+			DEBUG(3,("sam_password_ok: Lanman passwords NOT PERMITTED for user %s\n",pdb_get_username(sampass)));
+		} else if (IS_SAM_DEFAULT(sampass, PDB_LMPASSWD)) {
+			DEBUG(3,("sam_password_ok: NO LanMan password set for user %s (and no NT password supplied)\n",pdb_get_username(sampass)));
+		} else {
+			lm_pw = pdb_get_lanman_passwd(sampass);
+			
+			DEBUG(4,("sam_password_ok: Checking LM password\n"));
+			if (smb_pwd_check_ntlmv1(user_info->lm_resp, 
+						 lm_pw, auth_context->challenge,
+						 user_sess_key)) 
+			{
+				return NT_STATUS_OK;
+			}
 		}
+
+		if (IS_SAM_DEFAULT(sampass, PDB_NTPASSWD)) {
+			DEBUG(4,("sam_password_ok: LM password check failed for user, no NT password %s\n",pdb_get_username(sampass)));
+			return NT_STATUS_WRONG_PASSWORD;
+		} 
 		
-		DEBUG(4,("sam_password_ok: Checking LM password\n"));
-		if (smb_pwd_check_ntlmv1(user_info->lm_resp, 
-					 lm_pw, auth_context->challenge,
-					 user_sess_key)) 
+		nt_pw = pdb_get_nt_passwd(sampass);
+
+		/* This is for 'LMv2' authentication.  almost NTLMv2 but limited to 24 bytes.
+		   - related to Win9X, legacy NAS pass-though authentication
+		*/
+		DEBUG(4,("sam_password_ok: Checking LMv2 password\n"));
+		if (smb_pwd_check_ntlmv2( user_info->lm_resp, 
+					  nt_pw, auth_context->challenge, 
+					  user_info->smb_name.str, 
+					  user_info->client_domain.str,
+					  user_sess_key))
 		{
 			return NT_STATUS_OK;
-		} else {
-			if (lp_ntlm_auth() && (!IS_SAM_DEFAULT(sampass, PDB_NTPASSWD))) {				
-				nt_pw = pdb_get_nt_passwd(sampass);
-				/* Apparently NT accepts NT responses in the LM field
-				   - I think this is related to Win9X pass-though authentication
-				*/
-				DEBUG(4,("sam_password_ok: Checking NT MD4 password in LM field\n"));
-				if (smb_pwd_check_ntlmv1(user_info->lm_resp, 
-							 nt_pw, auth_context->challenge,
-							 user_sess_key)) 
-				{
-					return NT_STATUS_OK;
-				} else {
-					DEBUG(3,("sam_password_ok: NT MD4 password in LM field failed for user %s\n",pdb_get_username(sampass)));
-					return NT_STATUS_WRONG_PASSWORD;
-				}
+		}
+
+		/* Apparently NT accepts NT responses in the LM field
+		   - I think this is related to Win9X pass-though authentication
+		*/
+		DEBUG(4,("sam_password_ok: Checking NT MD4 password in LM field\n"));
+		if (lp_ntlm_auth()) 
+		{
+			if (smb_pwd_check_ntlmv1(user_info->lm_resp, 
+						 nt_pw, auth_context->challenge,
+						 user_sess_key)) 
+			{
+				return NT_STATUS_OK;
 			}
-			DEBUG(4,("sam_password_ok: LM password check failed for user %s\n",pdb_get_username(sampass)));
+			DEBUG(3,("sam_password_ok: LM password, NT MD4 password in LM field and LMv2 failed for user %s\n",pdb_get_username(sampass)));
 			return NT_STATUS_WRONG_PASSWORD;
-		} 
+		} else {
+			DEBUG(3,("sam_password_ok: LM password and LMv2 failed for user %s, and NT MD4 password in LM field not permitted\n",pdb_get_username(sampass)));
+			return NT_STATUS_WRONG_PASSWORD;
+		}
+			
 	}
 		
 	/* Should not be reached, but if they send nothing... */
@@ -395,13 +420,13 @@
 
 	nt_status = sam_account_ok(mem_ctx, sampass, user_info);
 	
-	nt_status = sam_password_ok(auth_context, mem_ctx, sampass, user_info, user_sess_key);
-
 	if (!NT_STATUS_IS_OK(nt_status)) {
 		pdb_free_sam(&sampass);
 		return nt_status;
 	}
 
+	nt_status = sam_password_ok(auth_context, mem_ctx, sampass, user_info, user_sess_key);
+
 	if (!NT_STATUS_IS_OK(nt_status)) {
 		pdb_free_sam(&sampass);
 		return nt_status;
diff -uNr samba-3.0alpha21.orig/source/auth/auth_unix.c samba-3.0alpha21/source/auth/auth_unix.c
--- samba-3.0alpha21.orig/source/auth/auth_unix.c	2003-02-16 19:06:30.000000000 -0600
+++ samba-3.0alpha21/source/auth/auth_unix.c	2003-02-16 19:05:45.000000000 -0600
@@ -106,7 +106,7 @@
 	
 	unbecome_root();
 
-	if NT_STATUS_IS_OK(nt_status) {
+	if (NT_STATUS_IS_OK(nt_status)) {
 		if (pass) {
 			make_server_info_pw(server_info, pass);
 		} else {
diff -uNr samba-3.0alpha21.orig/source/auth/auth_util.c samba-3.0alpha21/source/auth/auth_util.c
--- samba-3.0alpha21.orig/source/auth/auth_util.c	2003-02-16 19:06:30.000000000 -0600
+++ samba-3.0alpha21/source/auth/auth_util.c	2003-02-16 19:05:45.000000000 -0600
@@ -475,7 +475,7 @@
 void debug_nt_user_token(int dbg_class, int dbg_lev, NT_USER_TOKEN *token)
 {
 	fstring sid_str;
-	int     i;
+	size_t     i;
 	
 	if (!token) {
 		DEBUGC(dbg_class, dbg_lev, ("NT user token: (NULL)\n"));
@@ -564,7 +564,7 @@
 	sid_ndx = 5; /* next available spot */
 
 	for (i = 0; i < n_groupSIDs; i++) {
-		int check_sid_idx;
+		size_t check_sid_idx;
 		for (check_sid_idx = 1; check_sid_idx < ptoken->num_sids; check_sid_idx++) {
 			if (sid_equal(&ptoken->user_sids[check_sid_idx], 
 				      &groupSIDs[i])) {
@@ -671,17 +671,25 @@
 	};
 	
 	n_unix_groups = groups_max();
-	if ((*unix_groups = malloc( sizeof(gid_t) * groups_max() ) ) == NULL) {
+	if ((*unix_groups = malloc( sizeof(gid_t) * n_unix_groups ) ) == NULL) {
 		DEBUG(0, ("get_user_groups_from_local_sam: Out of memory allocating unix group list\n"));
 		passwd_free(&usr);
 		return NT_STATUS_NO_MEMORY;
 	}
 	
 	if (sys_getgrouplist(usr->pw_name, usr->pw_gid, *unix_groups, &n_unix_groups) == -1) {
-		*unix_groups = Realloc(unix_groups, sizeof(gid_t) * n_unix_groups);
+		gid_t *groups_tmp;
+		groups_tmp = Realloc(*unix_groups, sizeof(gid_t) * n_unix_groups);
+		if (!groups_tmp) {
+			SAFE_FREE(*unix_groups);
+			passwd_free(&usr);
+			return NT_STATUS_NO_MEMORY;
+		}
+		*unix_groups = groups_tmp;
+
 		if (sys_getgrouplist(usr->pw_name, usr->pw_gid, *unix_groups, &n_unix_groups) == -1) {
 			DEBUG(0, ("get_user_groups_from_local_sam: failed to get the unix group list\n"));
-			SAFE_FREE(unix_groups);
+			SAFE_FREE(*unix_groups);
 			passwd_free(&usr);
 			return NT_STATUS_NO_SUCH_USER; /* what should this return value be? */
 		}
@@ -695,7 +703,7 @@
 		*groups   = malloc(sizeof(DOM_SID) * n_unix_groups);
 		if (!*groups) {
 			DEBUG(0, ("get_user_group_from_local_sam: malloc() failed for DOM_SID list!\n"));
-			SAFE_FREE(unix_groups);
+			SAFE_FREE(*unix_groups);
 			return NT_STATUS_NO_MEMORY;
 		}
 	}
@@ -704,9 +712,9 @@
 
 	for (i = 0; i < *n_groups; i++) {
 		if (!gid_to_sid(&(*groups)[i], (*unix_groups)[i])) {
-			DEBUG(1, ("get_user_groups_from_local_sam: failed to convert gid %ld to a sid!\n", (long int)unix_groups[i+1]));
-			SAFE_FREE(groups);
-			SAFE_FREE(unix_groups);
+			DEBUG(1, ("get_user_groups_from_local_sam: failed to convert gid %ld to a sid!\n", (long int)(*unix_groups)[i+1]));
+			SAFE_FREE(*groups);
+			SAFE_FREE(*unix_groups);
 			return NT_STATUS_NO_SUCH_USER;
 		}
 	}
@@ -867,7 +875,7 @@
 	NT_USER_TOKEN *token;
 
 	DOM_SID *all_group_SIDs;
-	int i;
+	size_t i;
 
 	/* 
 	   Here is where we should check the list of
@@ -953,27 +961,27 @@
 		return NT_STATUS_NO_MEMORY;
 	}
 
-	if (!pdb_set_fullname(sam_account, pdb_unistr2_convert(&(info3->uni_full_name)), PDB_CHANGED)) {
+	if (!pdb_set_fullname(sam_account, unistr2_static(&(info3->uni_full_name)), PDB_CHANGED)) {
 		pdb_free_sam(&sam_account);
 		return NT_STATUS_NO_MEMORY;
 	}
 
-	if (!pdb_set_logon_script(sam_account, pdb_unistr2_convert(&(info3->uni_logon_script)), PDB_CHANGED)) {
+	if (!pdb_set_logon_script(sam_account, unistr2_static(&(info3->uni_logon_script)), PDB_CHANGED)) {
 		pdb_free_sam(&sam_account);
 		return NT_STATUS_NO_MEMORY;
 	}
 
-	if (!pdb_set_profile_path(sam_account, pdb_unistr2_convert(&(info3->uni_profile_path)), PDB_CHANGED)) {
+	if (!pdb_set_profile_path(sam_account, unistr2_static(&(info3->uni_profile_path)), PDB_CHANGED)) {
 		pdb_free_sam(&sam_account);
 		return NT_STATUS_NO_MEMORY;
 	}
 
-	if (!pdb_set_homedir(sam_account, pdb_unistr2_convert(&(info3->uni_home_dir)), PDB_CHANGED)) {
+	if (!pdb_set_homedir(sam_account, unistr2_static(&(info3->uni_home_dir)), PDB_CHANGED)) {
 		pdb_free_sam(&sam_account);
 		return NT_STATUS_NO_MEMORY;
 	}
 
-	if (!pdb_set_dir_drive(sam_account, pdb_unistr2_convert(&(info3->uni_dir_drive)), PDB_CHANGED)) {
+	if (!pdb_set_dir_drive(sam_account, unistr2_static(&(info3->uni_dir_drive)), PDB_CHANGED)) {
 		pdb_free_sam(&sam_account);
 		return NT_STATUS_NO_MEMORY;
 	}
diff -uNr samba-3.0alpha21.orig/source/auth/auth_winbind.c samba-3.0alpha21/source/auth/auth_winbind.c
--- samba-3.0alpha21.orig/source/auth/auth_winbind.c	2003-02-16 19:06:30.000000000 -0600
+++ samba-3.0alpha21/source/auth/auth_winbind.c	2003-02-16 19:05:45.000000000 -0600
@@ -36,8 +36,8 @@
 		if (!prs_init(&ps, len, mem_ctx, UNMARSHALL)) {
 			return NT_STATUS_NO_MEMORY;
 		}
-		prs_append_data(&ps, info3_ndr, len);
-		ps.data_offset = 0;
+		prs_copy_data_in(&ps, info3_ndr, len);
+		prs_set_offset(&ps,0);
 		if (!net_io_user_info3("", info3, &ps, 1, 3)) {
 			DEBUG(2, ("get_info3_from_ndr: could not parse info3 struct!\n"));
 			return NT_STATUS_UNSUCCESSFUL;
@@ -127,9 +127,8 @@
 /* module initialisation */
 NTSTATUS auth_init_winbind(struct auth_context *auth_context, const char *param, auth_methods **auth_method) 
 {
-	if (!make_auth_methods(auth_context, auth_method)) {
+	if (!make_auth_methods(auth_context, auth_method))
 		return NT_STATUS_NO_MEMORY;
-	}
 
 	(*auth_method)->name = "winbind";
 	(*auth_method)->auth = check_winbind_security;
diff -uNr samba-3.0alpha21.orig/source/auth/pampass.c samba-3.0alpha21/source/auth/pampass.c
--- samba-3.0alpha21.orig/source/auth/pampass.c	2003-02-16 19:06:30.000000000 -0600
+++ samba-3.0alpha21/source/auth/pampass.c	2003-02-16 19:05:45.000000000 -0600
@@ -65,7 +65,7 @@
  PAM error handler.
  *********************************************************************/
 
-static BOOL smb_pam_error_handler(pam_handle_t *pamh, int pam_error, char *msg, int dbglvl)
+static BOOL smb_pam_error_handler(pam_handle_t *pamh, int pam_error, const char *msg, int dbglvl)
 {
 
 	if( pam_error != PAM_SUCCESS) {
@@ -83,7 +83,7 @@
 *********************************************************************/
 
 static BOOL smb_pam_nt_status_error_handler(pam_handle_t *pamh, int pam_error,
-							char *msg, int dbglvl, 
+					    const char *msg, int dbglvl, 
 					    NTSTATUS *nt_status)
 {
 	*nt_status = pam_to_nt_status(pam_error);
diff -uNr samba-3.0alpha21.orig/source/auth/pass_check.c samba-3.0alpha21/source/auth/pass_check.c
--- samba-3.0alpha21.orig/source/auth/pass_check.c	2003-02-16 19:06:30.000000000 -0600
+++ samba-3.0alpha21/source/auth/pass_check.c	2003-02-16 19:05:45.000000000 -0600
@@ -579,7 +579,7 @@
 	}
 #endif /* HAVE_CRYPT */
 #endif /* HAVE_BIGCRYPT && HAVE_CRYPT && USE_BOTH_CRYPT_CALLS */
-#endif /* WITH_PAM || KRB4_AUTH || KRB5_AUTH */
+#endif /* WITH_PAM */
 }
 
 
diff -uNr samba-3.0alpha21.orig/source/autogen.sh samba-3.0alpha21/source/autogen.sh
--- samba-3.0alpha21.orig/source/autogen.sh	1969-12-31 18:00:00.000000000 -0600
+++ samba-3.0alpha21/source/autogen.sh	2003-02-16 19:05:45.000000000 -0600
@@ -0,0 +1,36 @@
+#! /bin/sh
+
+# Run this script to build samba from CVS.
+
+## first try the default names
+AUTOHEADER="autoheader"
+AUTOCONF="autoconf"
+
+if which $AUTOCONF > /dev/null
+then
+    :
+else
+    echo "$0: need autoconf 2.53 or later to build samba from CVS" >&2
+    exit 1
+fi
+
+##
+## what version do we need?
+##
+if [ `$AUTOCONF --version | head -1 | cut -d.  -f 2` -lt 53 ]; then
+
+	## maybe it's installed under a different name (e.g. RedHat 7.3)
+
+	AUTOCONF="autoconf-2.53"
+	AUTOHEADER="autoheader-2.53"
+
+fi
+
+echo "$0: running $AUTOHEADER"
+$AUTOHEADER || exit 1
+
+echo "$0: running $AUTOCONF"
+$AUTOCONF || exit 1
+
+echo "Now run ./configure and then make."
+exit 0
diff -uNr samba-3.0alpha21.orig/source/client/client.c samba-3.0alpha21/source/client/client.c
--- samba-3.0alpha21.orig/source/client/client.c	2003-02-16 19:06:30.000000000 -0600
+++ samba-3.0alpha21/source/client/client.c	2003-02-16 19:05:45.000000000 -0600
@@ -73,8 +73,6 @@
 /* clitar bits end */
  
 
-static mode_t myumask = 0755;
-
 static BOOL prompt = True;
 
 static int printmode = 1;
@@ -1062,7 +1060,7 @@
 	int fnum;
 	XFILE *f;
 	int start = 0;
-	int nread = 0;
+	off_t nread = 0;
 	char *buf = NULL;
 	int maxwrite = io_bufsize;
 	int rc = 0;
@@ -2057,9 +2055,9 @@
  */
 static struct
 {
-  char *name;
+  const char *name;
   int (*fn)(void);
-  char *description;
+  const char *description;
   char compl_args[2];      /* Completion argument info */
 } commands[] = 
 {
@@ -2756,8 +2754,6 @@
 	pstrcpy(workgroup,lp_workgroup());
 
 	load_interfaces();
-	myumask = umask(0);
-	umask(myumask);
 
 	if (getenv("USER")) {
 		pstrcpy(username,getenv("USER"));
@@ -2839,11 +2835,17 @@
 			pstrcpy(new_name_resolve_order, optarg);
 			break;
 		case 'M':
-			name_type = 0x03; /* messages are sent to NetBIOS name type 0x3 */
+			/* Messages are sent to NetBIOS name type 0x3
+			 * (Messenger Service).  Make sure we default
+			 * to port 139 instead of port 445. srl,crh
+			 */
+			name_type = 0x03; 
 			pstrcpy(desthost,optarg);
-			message = True;
-			break;
-		case 'i':
+			if( 0 == port )
+				port = 139;
+ 			message = True;
+ 			break;
+ 		case 'i':
 			set_global_scope(optarg);
 			break;
 		case 'N':
@@ -2972,7 +2974,7 @@
 			}
 			break;
 		case 'D':
-			pstrcpy(base_directory,optarg);
+			fstrcpy(base_directory,optarg);
 			break;
 		case 'c':
 			cmdstr = optarg;
diff -uNr samba-3.0alpha21.orig/source/client/clitar.c samba-3.0alpha21/source/client/clitar.c
--- samba-3.0alpha21.orig/source/client/clitar.c	2003-02-16 19:06:31.000000000 -0600
+++ samba-3.0alpha21/source/client/clitar.c	2003-02-16 19:05:45.000000000 -0600
@@ -45,10 +45,10 @@
 
 struct file_info_struct
 {
-  size_t size;
+  SMB_BIG_UINT size;
   uint16 mode;
-  int uid;
-  int gid;
+  uid_t uid;
+  gid_t gid;
   /* These times are normally kept in GMT */
   time_t mtime;
   time_t atime;
@@ -121,12 +121,12 @@
 static int blocksize=20;
 static int tarhandle;
 
-static void writetarheader(int f,  char *aname, int size, time_t mtime,
-			   char *amode, unsigned char ftype);
+static void writetarheader(int f,  const char *aname, SMB_BIG_UINT size, time_t mtime,
+			   const char *amode, unsigned char ftype);
 static void do_atar(char *rname,char *lname,file_info *finfo1);
 static void do_tar(file_info *finfo);
-static void oct_it(long value, int ndgs, char *p);
-static void fixtarname(char *tptr, char *fp, int l);
+static void oct_it(SMB_BIG_UINT value, int ndgs, char *p);
+static void fixtarname(char *tptr, const char *fp, int l);
 static int dotarbuf(int f, char *b, int n);
 static void dozerobuf(int f, int n);
 static void dotareof(int f);
@@ -164,14 +164,14 @@
 /****************************************************************************
 Write a tar header to buffer
 ****************************************************************************/
-static void writetarheader(int f,  char *aname, int size, time_t mtime,
-			   char *amode, unsigned char ftype)
+static void writetarheader(int f, const char *aname, SMB_BIG_UINT size, time_t mtime,
+			   const char *amode, unsigned char ftype)
 {
   union hblock hb;
   int i, chk, l;
   char *jp;
 
-  DEBUG(5, ("WriteTarHdr, Type = %c, Size= %i, Name = %s\n", ftype, size, aname));
+  DEBUG(5, ("WriteTarHdr, Type = %c, Size= %.0f, Name = %s\n", ftype, (double)size, aname));
 
   memset(hb.dummy, 0, sizeof(hb.dummy));
   
@@ -203,17 +203,17 @@
 
   hb.dbuf.name[NAMSIZ-1]='\0';
   safe_strcpy(hb.dbuf.mode, amode, strlen(amode));
-  oct_it(0L, 8, hb.dbuf.uid);
-  oct_it(0L, 8, hb.dbuf.gid);
-  oct_it((long) size, 13, hb.dbuf.size);
-  oct_it((long) mtime, 13, hb.dbuf.mtime);
+  oct_it((SMB_BIG_UINT)0, 8, hb.dbuf.uid);
+  oct_it((SMB_BIG_UINT)0, 8, hb.dbuf.gid);
+  oct_it((SMB_BIG_UINT) size, 13, hb.dbuf.size);
+  oct_it((SMB_BIG_UINT) mtime, 13, hb.dbuf.mtime);
   memcpy(hb.dbuf.chksum, "        ", sizeof(hb.dbuf.chksum));
   memset(hb.dbuf.linkname, 0, NAMSIZ);
   hb.dbuf.linkflag=ftype;
   
   for (chk=0, i=sizeof(hb.dummy), jp=hb.dummy; --i>=0;) chk+=(0xFF & *jp++);
 
-  oct_it((long) chk, 8, hb.dbuf.chksum);
+  oct_it((SMB_BIG_UINT) chk, 8, hb.dbuf.chksum);
   hb.dbuf.chksum[6] = '\0';
 
   (void) dotarbuf(f, hb.dummy, sizeof(hb.dummy));
@@ -414,7 +414,7 @@
 /****************************************************************************
 (Un)mangle DOS pathname, make nonabsolute
 ****************************************************************************/
-static void fixtarname(char *tptr, char *fp, int l)
+static void fixtarname(char *tptr, const char *fp, int l)
 {
 	/* add a '.' to start of file name, convert from ugly dos \'s in path
 	 * to lovely unix /'s :-} */
@@ -427,7 +427,7 @@
 /****************************************************************************
 Convert from decimal to octal string
 ****************************************************************************/
-static void oct_it (long value, int ndgs, char *p)
+static void oct_it (SMB_BIG_UINT value, int ndgs, char *p)
 {
   /* Converts long to octal string, pads with leading zeros */
 
@@ -598,7 +598,7 @@
 static void do_atar(char *rname,char *lname,file_info *finfo1)
 {
   int fnum;
-  uint32 nread=0;
+  SMB_BIG_UINT nread=0;
   char ftype;
   file_info2 finfo;
   BOOL close_done = False;
@@ -620,6 +620,7 @@
     finfo.mtime = finfo1 -> mtime;
     finfo.atime = finfo1 -> atime;
     finfo.ctime = finfo1 -> ctime;
+    finfo.name  = finfo1 -> name;
   }
   else {
     finfo.size  = def_finfo.size;
@@ -629,13 +630,14 @@
     finfo.mtime = def_finfo.mtime;
     finfo.atime = def_finfo.atime;
     finfo.ctime = def_finfo.ctime;
+    finfo.name  = def_finfo.name;
   }
 
   if (dry_run)
     {
-      DEBUG(3,("skipping file %s of size %d bytes\n",
+      DEBUG(3,("skipping file %s of size %12.0f bytes\n",
 	       finfo.name,
-	       (int)finfo.size));
+	       (double)finfo.size));
       shallitime=0;
       ttarf+=finfo.size + TBLOCK - (finfo.size % TBLOCK);
       ntarf++;
@@ -686,9 +688,9 @@
     }
   else
     {
-      DEBUG(3,("getting file %s of size %d bytes as a tar file %s",
+      DEBUG(3,("getting file %s of size %.0f bytes as a tar file %s",
 	       finfo.name,
-	       (int)finfo.size,
+	       (double)finfo.size,
 	       lname));
       
       /* write a tar header, don't bother with mode - just set to 100644 */
@@ -696,7 +698,7 @@
 
       while (nread < finfo.size && !close_done)	{
 	      
-	      DEBUG(3,("nread=%d\n",nread));
+	      DEBUG(3,("nread=%.0f\n",(double)nread));
 	      
 	      datalen = cli_read(cli, fnum, data, nread, read_size);
 	      
@@ -713,7 +715,7 @@
 
 		  if (nread > finfo.size) {
 			datalen -= nread - finfo.size;
-			DEBUG(0,("File size change - truncating %s to %d bytes\n", finfo.name, (int)finfo.size));
+			DEBUG(0,("File size change - truncating %s to %.0f bytes\n", finfo.name, (double)finfo.size));
 		  }
 
 	      /* add received bits of file to buffer - dotarbuf will
@@ -733,7 +735,7 @@
 
       /* pad tar file with zero's if we couldn't get entire file */
       if (nread < finfo.size) {
-	      DEBUG(0, ("Didn't get entire file. size=%d, nread=%d\n", (int)finfo.size, (int)nread));
+	      DEBUG(0, ("Didn't get entire file. size=%.0f, nread=%d\n", (double)finfo.size, (int)nread));
 	      if (padit(data, sizeof(data), finfo.size - nread))
 		      DEBUG(0,("Error writing tar file - %s\n", strerror(errno)));
       }
@@ -766,8 +768,8 @@
 
       if (tar_noisy)
 	{
-	  DEBUG(0, ("%10d (%7.1f kb/s) %s\n",
-	       (int)finfo.size, finfo.size / MAX(0.001, (1.024*this_time)),
+	  DEBUG(0, ("%12.0f (%7.1f kb/s) %s\n",
+	       (double)finfo.size, finfo.size / MAX(0.001, (1.024*this_time)),
                finfo.name));
 	}
 
@@ -1833,7 +1835,7 @@
     if (tar_type=='c' && (dry_run || strcmp(argv[Optind], "/dev/null")==0))
       {
 	if (!dry_run) {
-	  DEBUG(0,("Output is /dev/null, assuming dry_run"));
+	  DEBUG(0,("Output is /dev/null, assuming dry_run\n"));
 	  dry_run = True;
 	}
 	tarhandle=-1;
diff -uNr samba-3.0alpha21.orig/source/client/smbmount.c samba-3.0alpha21/source/client/smbmount.c
--- samba-3.0alpha21.orig/source/client/smbmount.c	2003-02-16 19:06:31.000000000 -0600
+++ samba-3.0alpha21/source/client/smbmount.c	2003-02-16 19:05:45.000000000 -0600
@@ -78,8 +78,12 @@
 			}
 			break;
 		}
+
 		/* If we get here - the child exited with some error status */
-		exit(status);
+		if (WIFSIGNALED(status))
+			exit(128 + WTERMSIG(status));
+		else
+			exit(WEXITSTATUS(status));
 	}
 
 	signal( SIGTERM, SIG_DFL );
diff -uNr samba-3.0alpha21.orig/source/client/smbspool.c samba-3.0alpha21/source/client/smbspool.c
--- samba-3.0alpha21.orig/source/client/smbspool.c	2003-02-16 19:06:31.000000000 -0600
+++ samba-3.0alpha21/source/client/smbspool.c	2003-02-16 19:05:45.000000000 -0600
@@ -52,8 +52,8 @@
   int		copies;		/* Number of copies */
   char		uri[1024],	/* URI */
 		*sep,		/* Pointer to separator */
-		*username,	/* Username */
-		*password,	/* Password */
+		*password;	/* Password */
+  const char	*username,	/* Username */
 		*server,	/* Server name */
 		*printer;	/* Printer name */
   const char	*workgroup;	/* Workgroup */
@@ -205,12 +205,12 @@
     {
       if (getenv("CLASS") == NULL)
       {
-        perror("ERROR: Unable to connect to SAMBA host, will retry in 60 seconds...");
+        fprintf(stderr, "ERROR: Unable to connect to SAMBA host, will retry in 60 seconds...");
         sleep (60);
       }
       else
       {
-        perror("ERROR: Unable to connect to SAMBA host, trying next printer...");
+        fprintf(stderr, "ERROR: Unable to connect to SAMBA host, trying next printer...");
         return (1);
       }
     }
diff -uNr samba-3.0alpha21.orig/source/client/smbumount.c samba-3.0alpha21/source/client/smbumount.c
--- samba-3.0alpha21.orig/source/client/smbumount.c	2003-02-16 19:06:31.000000000 -0600
+++ samba-3.0alpha21/source/client/smbumount.c	2003-02-16 19:05:45.000000000 -0600
@@ -90,7 +90,8 @@
 	if (realpath (path, canonical))
 		return canonical;
 
-	pstrcpy (canonical, path);
+	strncpy (canonical, path, PATH_MAX);
+	canonical[PATH_MAX] = '\0';
 	return canonical;
 }
 
diff -uNr samba-3.0alpha21.orig/source/configure.in samba-3.0alpha21/source/configure.in
--- samba-3.0alpha21.orig/source/configure.in	2003-02-16 19:06:30.000000000 -0600
+++ samba-3.0alpha21/source/configure.in	2003-02-16 19:07:14.000000000 -0600
@@ -1,5 +1,8 @@
 dnl -*- mode: m4-mode -*-
 dnl Process this file with autoconf to produce a configure script.
+
+dnl We must use autotools 2.53 or above
+AC_PREREQ(2.53)
 AC_INIT(include/includes.h)
 AC_CONFIG_HEADER(include/config.h)
 
@@ -132,24 +135,60 @@
 
 dnl Unique-to-Samba variables we'll be playing with.
 AC_SUBST(SHELL)
-AC_SUBST(RUNPROG)
-AC_SUBST(MPROGS)
 AC_SUBST(LDSHFLAGS)
 AC_SUBST(SONAMEFLAG)
 AC_SUBST(SHLD)
 AC_SUBST(HOST_OS)
-AC_SUBST(PAM_MOD)
-AC_SUBST(WRAP)
-AC_SUBST(WRAP32)
-AC_SUBST(WRAPPROG)
 AC_SUBST(PICFLAG)
 AC_SUBST(PICSUFFIX)
 AC_SUBST(POBAD_CC)
 AC_SUBST(SHLIBEXT)
+AC_SUBST(INSTALLCLIENTCMD_SH)
+AC_SUBST(INSTALLCLIENTCMD_A)
 AC_SUBST(LIBSMBCLIENT_SHARED)
 AC_SUBST(LIBSMBCLIENT)
 AC_SUBST(PRINTLIBS)
 AC_SUBST(AUTHLIBS)
+AC_SUBST(SHLIB_PROGS)
+AC_SUBST(SMBWRAPPER)
+AC_SUBST(EXTRA_BIN_PROGS)
+AC_SUBST(EXTRA_SBIN_PROGS)
+AC_SUBST(EXTRA_ALL_TARGETS)
+dnl For the DYNAMIC RPC stuff
+dnl The complicated _YES and _NO stuff allows us to avoid a dependency
+dnl on GNU Make.
+AC_SUBST(LSA_DYNAMIC_YES)
+AC_SUBST(LSA_DYNAMIC_NO)
+LSA_DYNAMIC_YES="#"
+LSA_DYNAMIC_NO=
+AC_SUBST(NETLOG_DYNAMIC_YES)
+AC_SUBST(NETLOG_DYNAMIC_NO)
+NETLOG_DYNAMIC_YES="#"
+NETLOG_DYNAMIC_NO=
+AC_SUBST(SAMR_DYNAMIC_YES)
+AC_SUBST(SAMR_DYNAMIC_NO)
+SAMR_DYNAMIC_YES="#"
+SAMR_DYNAMIC_NO=
+AC_SUBST(SVC_DYNAMIC_YES)
+AC_SUBST(SVC_DYNAMIC_NO)
+SVC_DYNAMIC_YES="#"
+SVC_DYNAMIC_NO=
+AC_SUBST(WKS_DYNAMIC_YES)
+AC_SUBST(WKS_DYNAMIC_NO)
+WKS_DYNAMIC_YES="#"
+WKS_DYNAMIC_NO=
+AC_SUBST(REG_DYNAMIC_YES)
+AC_SUBST(REG_DYNAMIC_NO)
+REG_DYNAMIC_YES="#"
+REG_DYNAMIC_NO=
+AC_SUBST(SPOOLSS_DYNAMIC_YES)
+AC_SUBST(SPOOLSS_DYNAMIC_NO)
+SPOOLSS_DYNAMIC_YES="#"
+SPOOLSS_DYNAMIC_NO=
+AC_SUBST(DFS_DYNAMIC_YES)
+AC_SUBST(DFS_DYNAMIC_NO)
+DFS_DYNAMIC_YES="#"
+DFS_DYNAMIC_NO=
 
 # compile with optimization and without debugging by default
 CFLAGS="-O ${CFLAGS}"
@@ -180,6 +219,60 @@
 	LIBS="$LIBS -ldmalloc"	
 fi
 
+AC_ARG_ENABLE(dynrpc,  [  --enable-dynrpc         Enable dynamic RPC modules [default=no]])
+
+if test x$enable_dynrpc = xyes
+then
+	enable_dynrpc=lsa,samr,reg,wks,netlog,dfs
+fi
+
+if test x$enable_dynrpc != xno
+then
+	for i in `echo $enable_dynrpc | sed -e's/,/ /g'` 
+         do case $i in lsa)
+	  LSA_DYNAMIC_YES=
+	  LSA_DYNAMIC_NO="#"
+          AC_DEFINE(RPC_LSA_DYNAMIC, 1,
+                    [Define to make the LSA pipe dynamic])
+	 ;; samr)
+          SAMR_DYNAMIC_YES=
+          SAMR_DYNAMIC_NO="#"
+	  AC_DEFINE(RPC_SAMR_DYNAMIC, 1, 
+	            [Define to make the SAMR pipe dynamic])
+	 ;; svc)
+          SVC_DYNAMIC_YES=
+          SVC_DYNAMIC_NO="#"
+	  AC_DEFINE(RPC_SVC_DYNAMIC, 1, 
+	            [Define to make the SRVSVC pipe dynamic])
+	 ;; wks)
+          WKS_DYNAMIC_YES=
+          WKS_DYNAMIC_NO="#"
+	  AC_DEFINE(RPC_WKS_DYNAMIC, 1, 
+	            [Define to make the WKSSVC pipe dynamic])
+	 ;; netlog)
+          NETLOG_DYNAMIC_YES=
+          NETLOG_DYNAMIC_NO="#"
+	  AC_DEFINE(RPC_NETLOG_DYNAMIC, 1, 
+	            [Define to make the NETLOGON pipe dynamic])
+	 ;; reg)
+          REG_DYNAMIC_YES=
+          REG_DYNAMIC_NO="#"
+	  AC_DEFINE(RPC_REG_DYNAMIC, 1, 
+	            [Define to make the WINREG pipe dynamic])
+	 ;; spoolss)
+          SPOOLSS_DYNAMIC_YES=
+          SPOOLSS_DYNAMIC_NO="#"
+	  AC_DEFINE(RPC_SPOOLSS_DYNAMIC, 1, 
+	            [Define to make the SPOOLSS pipe dynamic])
+	 ;; dfs)
+          DFS_DYNAMIC_YES=
+          DFS_DYNAMIC_NO="#"
+	  AC_DEFINE(RPC_DFS_DYNAMIC, 1, 
+	            [Define to make the NETDFS pipe dynamic])
+	 ;; esac
+         done
+fi
+
 dnl Checks for programs.
 AC_PROG_CC
 AC_PROG_INSTALL
@@ -192,6 +285,9 @@
 dnl needed before AC_TRY_COMPILE
 AC_ISC_POSIX
 
+dnl look for executable suffix
+AC_EXEEXT
+
 dnl Check if C compiler understands -c and -o at the same time
 AC_PROG_CC_C_O
 if eval "test \"`echo '$ac_cv_prog_cc_'${ac_cc}_c_o`\" = no"; then
@@ -243,7 +339,7 @@
 #
       case `uname -r` in
 			*9*|*10*)
-				CPPFLAGS="$CPPFLAGS -D_HPUX_SOURCE -D_POSIX_SOURCE -D_ALIGNMENT_REQUIRED=1 -D_MAX_ALIGNMENT=4"
+				CPPFLAGS="$CPPFLAGS -D_HPUX_SOURCE -D_POSIX_SOURCE -D_ALIGNMENT_REQUIRED=1 -D_MAX_ALIGNMENT=4 -DMAX_POSITIVE_LOCK_OFFSET=0x1ffffffffffLL"
 		   		AC_DEFINE(USE_BOTH_CRYPT_CALLS, 1, [Whether to use both of HPUX' crypt calls])
 				AC_DEFINE(_HPUX_SOURCE, 1, [Whether to use HPUX extensions])
 				AC_DEFINE(_POSIX_SOURCE, 1, [Whether to use POSIX compatible functions])
@@ -251,7 +347,7 @@
 				AC_DEFINE(_MAX_ALIGNMENT,4,[Maximum alignment])
 				;;
 			*11*)
-				CPPFLAGS="$CPPFLAGS -D_HPUX_SOURCE -D_POSIX_SOURCE -D_LARGEFILE64_SOURCE -D_ALIGNMENT_REQUIRED=1 -D_MAX_ALIGNMENT=4"
+				CPPFLAGS="$CPPFLAGS -D_HPUX_SOURCE -D_POSIX_SOURCE -D_LARGEFILE64_SOURCE -D_ALIGNMENT_REQUIRED=1 -D_MAX_ALIGNMENT=4 -DMAX_POSITIVE_LOCK_OFFSET=0x1ffffffffffLL"
 		   		AC_DEFINE(USE_BOTH_CRYPT_CALLS, 1, [Whether to use both of HPUX' crypt calls])
 				AC_DEFINE(_HPUX_SOURCE, 1, [Whether to use HPUX extensions])
 				AC_DEFINE(_POSIX_SOURCE, 1, [Whether to use POSIX compatible functions])
@@ -318,6 +414,26 @@
 		esac
 		;;
 #
+# VOS may need to have POSIX support and System V compatibility enabled.
+#
+    *vos*)
+    case "$CPPFLAGS" in
+	  *-D_POSIX_C_SOURCE*)
+		;;
+	  *)
+		CPPFLAGS="$CPPFLAGS -D_POSIX_C_SOURCE=199506L"
+		AC_DEFINE(_POSIX_C_SOURCE, 199506L, [Whether to enable POSIX support])
+		;;
+    esac
+    case "$CPPFLAGS" in
+	  *-D_SYSV*|*-D_SVID_SOURCE*)
+		;;
+	  *)
+		CPPFLAGS="$CPPFLAGS -D_SYSV"
+		AC_DEFINE(_SYSV, 1, [Whether to enable System V compatibility])
+    esac
+    ;;
+#
 # Tests needed for SINIX large file support.
 #
     *sysv4*)
@@ -507,11 +623,7 @@
 
 ############################################
 # we need dlopen/dlclose/dlsym/dlerror for PAM, the password database plugins and the plugin loading code
-AC_CHECK_FUNCS(dlopen)
-if test x"$ac_cv_func_dlopen" = x"no"; then
-    AC_CHECK_LIB(dl, dlopen, [LIBS="$LIBS -ldl";
-	AC_DEFINE(HAVE_DLOPEN,1,[Whether we have dlopen()])])
-fi
+AC_SEARCH_LIBS(dlopen, [dl])
 # dlopen/dlclose/dlsym/dlerror will be checked again later and defines will be set then
 
 ############################################
@@ -614,12 +726,8 @@
 
 ###############################################
 # test for where we get crypt() from
-AC_CHECK_FUNCS(crypt)
-if test x"$ac_cv_func_crypt" = x"no"; then
-    AC_CHECK_LIB(crypt, crypt, [AUTHLIBS="$AUTHLIBS -lcrypt";
+AC_SEARCH_LIBS(crypt, [crypt], [AUTHLIBS="$AUTHLIBS -lcrypt";
 	AC_DEFINE(HAVE_CRYPT,1,[Whether the system has the crypt() function])])
-fi
-
 
 ###############################################
 # Readline included by default unless explicitly asked not to
@@ -637,7 +745,7 @@
     AC_CHECK_HEADERS(readline/history.h)
 
     AC_CHECK_HEADERS(readline.h readline/readline.h,[
-      for termlib in ncurses curses termcap terminfo termlib; do
+      for termlib in ncurses curses termcap terminfo termlib tinfo; do
        AC_CHECK_LIB(${termlib}, tgetent, [TERMLIBS="-l${termlib}"; break])
       done
       AC_CHECK_LIB(readline, rl_callback_handler_install,
@@ -727,19 +835,14 @@
 fi
 
 ###############################################
-# test for where we get get_yp_default_domain() from
+# test for where we get yp_get_default_domain() from
+AC_SEARCH_LIBS(yp_get_default_domain, [nsl])
 AC_CHECK_FUNCS(yp_get_default_domain)
-if test x"$ac_cv_func_yp_get_default_domain" = x"no"; then
-	AC_CHECK_LIB(nsl, yp_get_default_domain, [LIBS="$LIBS -lnsl";
-	AC_DEFINE(HAVE_YP_GET_DEFAULT_DOMAIN,1,[Whether the system has yp_get_default_domain()])]) 
-fi
 
 # Check if we have execl, if not we need to compile smbrun.
 AC_CHECK_FUNCS(execl)
 if test x"$ac_cv_func_execl" = x"no"; then
-    RUNPROG="bin/smbrun"
-else
-    RUNPROG=""
+    EXTRA_BIN_PROGS="$EXTRA_BIN_PROGS bin/smbrun\$(EXEEXT)"
 fi
 
 AC_CHECK_FUNCS(dlopen dlclose dlsym dlerror waitpid getcwd strdup strndup strnlen strtoul strerror chown fchown chmod fchmod chroot link mknod mknod64)
@@ -752,8 +855,8 @@
 AC_CHECK_FUNCS(fseek64 fseeko64 ftell64 ftello64 setluid getpwanam setlinebuf)
 AC_CHECK_FUNCS(srandom random srand rand setenv usleep strcasecmp fcvt fcvtl symlink readlink)
 AC_CHECK_FUNCS(syslog vsyslog getgrouplist timegm)
-# setbuffer is needed for smbtorture
-AC_CHECK_FUNCS(setbuffer)
+# setbuffer, shmget, shm_open are needed for smbtorture
+AC_CHECK_FUNCS(setbuffer shmget shm_open)
 
 # syscall() is needed for smbwrapper.
 AC_CHECK_FUNCS(syscall)
@@ -766,7 +869,7 @@
 AC_CHECK_FUNCS(_acl __acl _facl __facl _open __open _chdir __chdir)
 AC_CHECK_FUNCS(_close __close _fchdir __fchdir _fcntl __fcntl)
 AC_CHECK_FUNCS(getdents _getdents __getdents _lseek __lseek _read __read)
-AC_CHECK_FUNCS(_write __write _fork __fork)
+AC_CHECK_FUNCS(getdirentries _write __write _fork __fork)
 AC_CHECK_FUNCS(_stat64 __stat64 _fstat64 __fstat64 _lstat64 __lstat64)
 AC_CHECK_FUNCS(__sys_llseek llseek _llseek __llseek readdir64 _readdir64 __readdir64)
 AC_CHECK_FUNCS(pread _pread __pread pread64 _pread64 __pread64)
@@ -873,7 +976,7 @@
 			PICFLAG="-fPIC"
 			SONAMEFLAG="-Wl,-soname="
 			AC_DEFINE(STAT_ST_BLOCKSIZE,512)
-		;;
+			;;
 		*solaris*) AC_DEFINE(SUNOS5,1,[Whether the host os is solaris])
 			BLDSHARED="true"
 			LDSHFLAGS="-G"
@@ -892,27 +995,28 @@
 				PICSUFFIX="po.o"
 			fi
 			AC_DEFINE(STAT_ST_BLOCKSIZE,512,[The size of a block])
-		;;
+			;;
 		*sunos*) AC_DEFINE(SUNOS4,1,[Whether the host os is sunos4])
 			BLDSHARED="true"
 			LDSHFLAGS="-G"
 			SONAMEFLAG="-Wl,-h,"
 			PICFLAG="-KPIC"   # Is this correct for SunOS
-		;;
-		*freebsd*)  BLDSHARED="true"
+			AC_DEFINE(STAT_ST_BLOCKSIZE,512)
+			;;
+		*netbsd* | *freebsd*)  BLDSHARED="true"
 			LDSHFLAGS="-shared"
 			DYNEXP="-Wl,--export-dynamic"
 			SONAMEFLAG="-Wl,-soname,"
 			PICFLAG="-fPIC -DPIC"
 			AC_DEFINE(STAT_ST_BLOCKSIZE,512,[The size of a block])
-		;;
+			;;
 		*openbsd*)  BLDSHARED="true"
 			LDSHFLAGS="-shared"
 			DYNEXP="-Wl,-Bdynamic"
 			SONAMEFLAG="-Wl,-soname,"
 			PICFLAG="-fPIC"
 			AC_DEFINE(STAT_ST_BLOCKSIZE,512,[The size of a block])
-		;;
+			;;
 		*irix*) AC_DEFINE(IRIX,1,[Whether the host os is irix])
 			case "$host_os" in
 			*irix6*) AC_DEFINE(IRIX6,1,[Whether the host os is irix6])
@@ -929,7 +1033,7 @@
 				PICFLAG="-KPIC"
 			fi
 			AC_DEFINE(STAT_ST_BLOCKSIZE,512,[The size of a block])
-		;;
+			;;
 		*aix*) AC_DEFINE(AIX,1,[Whether the host os is aix])
 			BLDSHARED="true"
 			LDSHFLAGS="-Wl,-bexpall,-bM:SRE,-bnoentry"
@@ -941,7 +1045,7 @@
 			fi
 
 			AC_DEFINE(STAT_ST_BLOCKSIZE,DEV_BSIZE,[The size of a block])
-		;;
+			;;
 		*hpux*) AC_DEFINE(HPUX,1,[Whether the host os is HPUX])
 			SHLIBEXT="sl"
 			# Use special PIC flags for the native HP-UX compiler.
@@ -954,23 +1058,33 @@
 			fi
 			DYNEXP="-Wl,-E"
 			AC_DEFINE(STAT_ST_BLOCKSIZE,8192,[The size of a block])
-		;;
-		*qnx*) AC_DEFINE(QNX,1,[Whether the host os is qnx]);;
+			;;
+		*qnx*) AC_DEFINE(QNX,1,[Whether the host os is qnx])
+			AC_DEFINE(STAT_ST_BLOCKSIZE,512)
+			;;
 		*osf*) AC_DEFINE(OSF1,1,[Whether the host os is osf1])
 			BLDSHARED="true"
 			LDSHFLAGS="-shared"
 			SONAMEFLAG="-Wl,-soname,"
 			PICFLAG="-fPIC"
-		;;
-		*sco*) AC_DEFINE(SCO,1,[Whether the host os is sco unix]);;
+			AC_DEFINE(STAT_ST_BLOCKSIZE,512)
+			;;
+		*sco*) AC_DEFINE(SCO,1,[Whether the host os is sco unix])
+			AC_DEFINE(STAT_ST_BLOCKSIZE,512)
+			;;
 		*unixware*) AC_DEFINE(UNIXWARE,1,[Whether the host os is unixware])
 			BLDSHARED="true"
 			LDSHFLAGS="-shared"
 			SONAMEFLAG="-Wl,-soname,"
 			PICFLAG="-KPIC"
-		;;
-		*next2*) AC_DEFINE(NEXT2,1,[Whether the host os is NeXT v2]);;
-		*dgux*) AC_CHECK_PROG( ROFF, groff, [groff -etpsR -Tascii -man]);;
+			AC_DEFINE(STAT_ST_BLOCKSIZE,512)
+			;;
+		*next2*) AC_DEFINE(NEXT2,1,[Whether the host os is NeXT v2])
+			AC_DEFINE(STAT_ST_BLOCKSIZE,512)
+			;;
+		*dgux*) AC_CHECK_PROG( ROFF, groff, [groff -etpsR -Tascii -man])
+			AC_DEFINE(STAT_ST_BLOCKSIZE,512)
+			;;
 		*sysv4*) AC_DEFINE(SYSV,1,[Whether this is a system V system])
 			case "$host" in
 				*-univel-*)     if [ test "$GCC" != yes ]; then
@@ -981,14 +1095,23 @@
 				;;
 				*mips-sni-sysv4*) AC_DEFINE(RELIANTUNIX,1,[Whether the host os is reliantunix]);;
 			esac
-		;;
+			AC_DEFINE(STAT_ST_BLOCKSIZE,512)
+			;;
 
 		*sysv5*) AC_DEFINE(SYSV,1,[Whether this is a system V system])
 			if [ test "$GCC" != yes ]; then
 				AC_DEFINE(HAVE_MEMSET,1,[Whether memset() is available])
 			fi
 			LDSHFLAGS="-G"
-		;;
+			AC_DEFINE(STAT_ST_BLOCKSIZE,512)
+			;;
+		*vos*) AC_DEFINE(STAT_ST_BLOCKSIZE,4096)
+			BLDSHARED="false"
+			LDSHFLAGS=""
+			;;
+		*)
+			AC_DEFINE(STAT_ST_BLOCKSIZE,512)
+			;;
 esac
 AC_SUBST(DYNEXP)
 AC_MSG_RESULT($BLDSHARED)
@@ -1021,14 +1144,6 @@
 fi
 fi
 
-
-# this updates our target list if we can build shared libs
-if test $BLDSHARED = true; then
-   LIBSMBCLIENT_SHARED=bin/libsmbclient.$SHLIBEXT
-else
-   LIBSMBCLIENT_SHARED=
-fi
-
 ################
 
 AC_CACHE_CHECK([for long long],samba_cv_have_longlong,[
@@ -1172,13 +1287,6 @@
     AC_DEFINE(SEEKDIR_RETURNS_VOID,1,[Whether seekdir returns void])
 fi
 
-AC_CACHE_CHECK([for __FILE__ macro],samba_cv_HAVE_FILE_MACRO,[
-AC_TRY_COMPILE([#include <stdio.h>], [printf("%s\n", __FILE__);],
-samba_cv_HAVE_FILE_MACRO=yes,samba_cv_HAVE_FILE_MACRO=no)])
-if test x"$samba_cv_HAVE_FILE_MACRO" = x"yes"; then
-    AC_DEFINE(HAVE_FILE_MACRO,1,[Whether there is a __FILE__ macro])
-fi
-
 AC_CACHE_CHECK([for __FUNCTION__ macro],samba_cv_HAVE_FUNCTION_MACRO,[
 AC_TRY_COMPILE([#include <stdio.h>], [printf("%s\n", __FUNCTION__);],
 samba_cv_HAVE_FUNCTION_MACRO=yes,samba_cv_HAVE_FUNCTION_MACRO=no)])
@@ -1886,7 +1994,7 @@
   yes)
     AC_MSG_RESULT(yes)
     AC_DEFINE(WITH_SMBWRAPPER,1,[Whether to include smbwrapper support])
-	WRAPPROG="bin/smbsh"
+	WRAPPROG="bin/smbsh\$(EXEEXT)"
 	WRAP="bin/smbwrapper.$SHLIBEXT"
 
 	if test x$ATTEMPT_WRAP32_BUILD = x; then
@@ -1908,6 +2016,8 @@
 	   WRAP=""
 	   WRAP32=""
 	fi
+	EXTRA_ALL_TARGETS="$EXTRA_ALL_TARGETS $WRAPPROG $WRAP $WRAP32"
+	SMBWRAPPER="$WRAPPROG $WRAP $WRAP32"
     ;;
   *)
     AC_MSG_RESULT(no)
@@ -1958,7 +2068,7 @@
 AC_MSG_CHECKING([whether to use Active Directory])
 
 AC_ARG_WITH(ads,
-[  --with-ads              Active Directory support (default yes)],
+[   --with-ads  Active Directory support (default yes)],
 [ case "$withval" in
     no)
 	with_ads_support=no
@@ -1975,6 +2085,21 @@
 if test x"$with_ads_support" = x"yes"; then
 
   #################################################
+  # check for krb5-config from recent MIT and Heimdal kerberos 5
+  AC_PATH_PROG(KRB5_CONFIG, krb5-config)
+  AC_MSG_CHECKING(for working krb5-config)
+  if test -x "$KRB5_CONFIG"; then
+    LIBS="$LIBS `$KRB5_CONFIG --libs`"
+    CFLAGS="$CFLAGS `$KRB5_CONFIG --cflags`" 
+    CPPFLAGS="$CPPFLAGS `$KRB5_CONFIG --cflags`"
+    FOUND_KRB5=yes
+    AC_MSG_RESULT(yes)
+  else
+    AC_MSG_RESULT(no. Fallback to previous krb5 detection strategy)
+  fi
+  
+  if test x$FOUND_KRB5 = x"no"; then
+  #################################################
   # check for location of Kerberos 5 install
   AC_MSG_CHECKING(for kerberos 5 install path)
   AC_ARG_WITH(krb5,
@@ -1994,16 +2119,26 @@
     esac ],
     AC_MSG_RESULT(no)
   )
-
+  fi
 
 if test x$FOUND_KRB5 = x"no"; then
 #################################################
 # see if this box has the SuSE location for the heimdal kerberos implementation
 AC_MSG_CHECKING(for /usr/include/heimdal)
 if test -d /usr/include/heimdal; then
-    CFLAGS="$CFLAGS -I/usr/include/heimdal"
-    CPPFLAGS="$CPPFLAGS -I/usr/include/heimdal"
-    AC_MSG_RESULT(yes)
+    if test -f /usr/lib/heimdal/lib/libkrb5.a; then
+        LIBS="$LIBS -lkrb5"
+        CFLAGS="$CFLAGS -I/usr/include/heimdal"
+        CPPFLAGS="$CPPFLAGS -I/usr/include/heimdal"
+        LDFLAGS="$LDFLAGS -L/usr/lib/heimdal/lib"
+        AC_MSG_RESULT(yes)
+    else
+        LIBS="$LIBS -lkrb5"
+        CFLAGS="$CFLAGS -I/usr/include/heimdal"
+        CPPFLAGS="$CPPFLAGS -I/usr/include/heimdal"
+        AC_MSG_RESULT(yes)
+ 
+    fi
 else
     AC_MSG_RESULT(no)
 fi
@@ -2014,7 +2149,8 @@
 #################################################
 # see if this box has the RedHat location for kerberos
 AC_MSG_CHECKING(for /usr/kerberos)
-if test -d /usr/kerberos; then
+if test -d /usr/kerberos -a -f /usr/kerberos/lib/libkrb5.a; then
+    LIBS="$LIBS -lkrb5"
     LDFLAGS="$LDFLAGS -L/usr/kerberos/lib"
     CFLAGS="$CFLAGS -I/usr/kerberos/include"
     CPPFLAGS="$CPPFLAGS -I/usr/kerberos/include"
@@ -2024,7 +2160,6 @@
 fi
 fi
 
-
   # now check for krb5.h. Some systems have the libraries without the headers!
   # note that this check is done here to allow for different kerberos
   # include paths
@@ -2032,23 +2167,67 @@
 
   # now check for gssapi headers.  This is also done here to allow for
   # different kerberos include paths
-  AC_CHECK_HEADERS(gssapi/gssapi_generic.h gssapi/gssapi.h)
+  AC_CHECK_HEADERS(gssapi.h gssapi/gssapi_generic.h gssapi/gssapi.h com_err.h)
 
   ##################################################################
   # we might need the k5crypto and com_err libraries on some systems
   AC_CHECK_LIB(com_err, _et_list, [LIBS="$LIBS -lcom_err"])
   AC_CHECK_LIB(k5crypto, krb5_encrypt_data, [LIBS="$LIBS -lk5crypto"])
+  # Heimdal checks.
+  AC_CHECK_LIB(crypto, des_set_key, [LIBS="$LIBS -lcrypto"])
+  AC_CHECK_LIB(asn1, copy_Authenticator, [LIBS="$LIBS -lasn1 -lroken"])
+  # Heimdal checks. On static Heimdal gssapi must be linked before krb5.
+  AC_CHECK_LIB(gssapi, gss_display_status, [LIBS="$LIBS -lgssapi -lkrb5 -lasn1";
+        AC_DEFINE(HAVE_GSSAPI,1,[Whether GSSAPI is available])])
+
+  AC_CHECK_LIB(krb5, krb5_set_real_time, [AC_DEFINE(HAVE_KRB5_SET_REAL_TIME,1,[Whether krb5_set_real_time is available])])
+  AC_CHECK_LIB(krb5, krb5_set_default_in_tkt_etypes, [AC_DEFINE(HAVE_KRB5_SET_DEFAULT_IN_TKT_ETYPES,1,[Whether krb5_set_default_in_tkt_etypes, is available])])
+  AC_CHECK_LIB(krb5, krb5_set_default_tgs_ktypes, [AC_DEFINE(HAVE_KRB5_SET_DEFAULT_TGS_KTYPES,1,[Whether krb5_set_default_tgs_ktypes is available])])
+
+  AC_CHECK_LIB(krb5, krb5_principal2salt, [AC_DEFINE(HAVE_KRB5_PRINCIPAL2SALT,1,[Whether krb5_principal2salt is available])])
+  AC_CHECK_LIB(krb5, krb5_use_enctype, [AC_DEFINE(HAVE_KRB5_USE_ENCTYPE,1,[Whether krb5_use_enctype is available])])
+  AC_CHECK_LIB(krb5, krb5_string_to_key, [AC_DEFINE(HAVE_KRB5_STRING_TO_KEY,1,[Whether krb5_string_to_key is available])])
+  AC_CHECK_LIB(krb5, krb5_get_pw_salt, [AC_DEFINE(HAVE_KRB5_GET_PW_SALT,1,[Whether krb5_get_pw_salt is available])])
+  AC_CHECK_LIB(krb5, krb5_string_to_key_salt, [AC_DEFINE(HAVE_KRB5_STRING_TO_KEY_SALT,1,[Whether krb5_string_to_key_salt is available])])
+  AC_CHECK_LIB(krb5, krb5_auth_con_setkey, [AC_DEFINE(HAVE_KRB5_AUTH_CON_SETKEY,1,[Whether krb5_auth_con_setkey is available])])
+  AC_CHECK_LIB(krb5, krb5_auth_con_setuseruserkey, [AC_DEFINE(HAVE_KRB5_AUTH_CON_SETUSERUSERKEY,1,[Whether krb5_auth_con_setuseruserkey is available])])
+  AC_CHECK_LIB(krb5, krb5_locate_kdc, [AC_DEFINE(HAVE_KRB5_LOCATE_KDC,1,[Whether krb5_locate_kdc is available])])
+
+AC_CACHE_CHECK([for addrtype in krb5_address],samba_cv_HAVE_ADDRTYPE_IN_KRB5_ADDRESS,[
+AC_TRY_COMPILE([#include <krb5.h>],
+[krb5_address kaddr; kaddr.addrtype = ADDRTYPE_INET;],
+samba_cv_HAVE_ADDRTYPE_IN_KRB5_ADDRESS=yes,samba_cv_HAVE_ADDRTYPE_IN_KRB5_ADDRESS=no)])
+if test x"$samba_cv_HAVE_ADDRTYPE_IN_KRB5_ADDRESS" = x"yes"; then
+    AC_DEFINE(HAVE_ADDRTYPE_IN_KRB5_ADDRESS,1,[Whether the krb5_address struct has a addrtype property])
+fi
+
+AC_CACHE_CHECK([for addr_type in krb5_address],samba_cv_HAVE_ADDR_TYPE_IN_KRB5_ADDRESS,[
+AC_TRY_COMPILE([#include <krb5.h>],
+[krb5_address kaddr; kaddr.addr_type = KRB5_ADDRESS_INET;],
+samba_cv_HAVE_ADDR_TYPE_IN_KRB5_ADDRESS=yes,samba_cv_HAVE_ADDR_TYPE_IN_KRB5_ADDRESS=no)])
+if test x"$samba_cv_HAVE_ADDR_TYPE_IN_KRB5_ADDRESS" = x"yes"; then
+    AC_DEFINE(HAVE_ADDR_TYPE_IN_KRB5_ADDRESS,1,[Whether the krb5_address struct has a addr_type property])
+fi
+
+AC_CACHE_CHECK([for enc_part2 in krb5_ticket],samba_cv_HAVE_KRB5_TKT_ENC_PART2,[
+AC_TRY_COMPILE([#include <krb5.h>],
+[krb5_ticket tkt; tkt.enc_part2->authorization_data[0]->contents = NULL;],
+samba_cv_HAVE_KRB5_TKT_ENC_PART2=yes,samba_cv_HAVE_KRB5_TKT_ENC_PART2=no)])
+if test x"$samba_cv_HAVE_KRB5_TKT_ENC_PART2" = x"yes"; then
+    AC_DEFINE(HAVE_KRB5_TKT_ENC_PART2,1,[Whether the krb5_ticket struct has a enc_part2 property])
+fi
 
   ########################################################
   # now see if we can find the krb5 libs in standard paths
   # or as specified above
   AC_CHECK_LIB(krb5, krb5_mk_req_extended, [LIBS="$LIBS -lkrb5";
-	AC_DEFINE(HAVE_KRB5,1,[Whether KRB5 is available])])
+        AC_DEFINE(HAVE_KRB5,1,[Whether KRB5 is available])])
 
   ########################################################
   # now see if we can find the gssapi libs in standard paths
   AC_CHECK_LIB(gssapi_krb5, gss_display_status, [LIBS="$LIBS -lgssapi_krb5";
-	AC_DEFINE(HAVE_GSSAPI,1,[Whether GSSAPI is available])])
+        AC_DEFINE(HAVE_GSSAPI,1,[Whether GSSAPI is available])])
+
 fi
 
 ########################################################
@@ -2058,7 +2237,7 @@
 AC_MSG_CHECKING([whether to use LDAP])
 
 AC_ARG_WITH(ldap,
-[  --with-ldap             LDAP support (default yes)],
+[   --with-ldap  LDAP support (default yes)],
 [ case "$withval" in
     no)
 	with_ldap_support=no
@@ -2106,9 +2285,9 @@
 
 #################################################
 # check for automount support
-AC_MSG_CHECKING(whether to use AUTOMOUNT)
+AC_MSG_CHECKING(whether to use automount)
 AC_ARG_WITH(automount,
-[  --with-automount        Include AUTOMOUNT support (default=no)],
+[  --with-automount        Include automount support (default=no)],
 [ case "$withval" in
   yes)
     AC_MSG_RESULT(yes)
@@ -2123,16 +2302,16 @@
 
 #################################################
 # check for smbmount support
-AC_MSG_CHECKING(whether to use SMBMOUNT)
+AC_MSG_CHECKING(whether to use smbmount)
 AC_ARG_WITH(smbmount,
-[  --with-smbmount         Include SMBMOUNT (Linux only) support (default=no)],
+[  --with-smbmount         Include smbmount (Linux only) support (default=no)],
 [ case "$withval" in
   yes)
 	case "$host_os" in
 	*linux*)
 		AC_MSG_RESULT(yes)
 		AC_DEFINE(WITH_SMBMOUNT,1,[Whether to build smbmount])
-		MPROGS="bin/smbmount bin/smbmnt bin/smbumount"
+		EXTRA_BIN_PROGS="$EXTRA_BIN_PROGS bin/smbmount bin/smbmnt bin/smbumount"
 		;;
 	*)
 		AC_MSG_ERROR(not on a linux system!)
@@ -2141,11 +2320,9 @@
     ;;
   *)
     AC_MSG_RESULT(no)
-    MPROGS=
     ;;
   esac ],
   AC_MSG_RESULT(no)
-  MPROGS=
 )
 
 
@@ -2185,12 +2362,10 @@
 
        if test x$PICFLAG = x; then
           AC_MSG_RESULT([No support for PIC code - disabling pam_smbpass])
-          PAM_MOD=""
        elif test x$ac_cv_lib_pam_pam_get_data = xno; then
           AC_MSG_RESULT([No libpam found -- disabling pam_smbpass])
-          PAM_MOD=""
        else
-          PAM_MOD="bin/pam_smbpass.so"
+          SHLIB_PROGS="$SHLIB_PROGS bin/pam_smbpass.so"
        fi
     ;;
   *)
@@ -2240,7 +2415,7 @@
 # check for a LDAP password database configuration backwards compatibility
 AC_MSG_CHECKING(whether to use LDAP SAM 2.2 compatible configuration)
 AC_ARG_WITH(ldapsam,
-[  --with-ldapsam          Include LDAP SAM 2.2 compatible configuration (default=no)],
+[  --with-ldapsam           Include LDAP SAM 2.2 compatible configuration (default=no)],
 [ case "$withval" in
   yes)
     AC_MSG_RESULT(yes)
@@ -2431,26 +2606,42 @@
 #################################################
 # should we build libsmbclient?
 
+INSTALLCLIENTCMD_SH=:
+INSTALLCLIENTCMD_A=:
 LIBSMBCLIENT_SHARED=
 LIBSMBCLIENT=
 AC_MSG_CHECKING(whether to build the libsmbclient shared library)
 AC_ARG_WITH(libsmbclient,
-[  --with-libsmbclient     Build the libsmbclient shared library (default=yes)],
+[  --with-libsmbclient     Build the libsmbclient shared library (default=yes if shared libs supported)],
 [ case "$withval" in
   no) 
      AC_MSG_RESULT(no)
      ;;
   *)
      if test $BLDSHARED = true; then
+        INSTALLCLIENTCMD_SH="\$(INSTALLCMD)"
         LIBSMBCLIENT_SHARED=bin/libsmbclient.$SHLIBEXT
         LIBSMBCLIENT=libsmbclient
         AC_MSG_RESULT(yes)
      else
-        AC_MSG_RESULT(no shared library support)
+        INSTALLCLIENTCMD_A="\$(INSTALLCMD)"
+        LIBSMBCLIENT=libsmbclient
+        AC_MSG_RESULT(no shared library support -- will supply static library)
      fi
      ;;
   esac ],
-  AC_MSG_RESULT(yes)
+[
+# if unspecified, default is to built it iff possible.
+  if test $BLDSHARED = true; then
+     INSTALLCLIENTCMD_SH="\$(INSTALLCMD)"
+     LIBSMBCLIENT_SHARED=bin/libsmbclient.$SHLIBEXT
+     LIBSMBCLIENT=libsmbclient
+     AC_MSG_RESULT(yes)
+  else
+     INSTALLCLIENTCMD_A="\$(INSTALLCMD)"
+     LIBSMBCLIENT=libsmbclient
+     AC_MSG_RESULT(no shared library support -- will supply static library)
+  fi]
 )
 
 
@@ -2757,7 +2948,7 @@
 with_sendfile_support=yes
 AC_MSG_CHECKING(whether to check to support sendfile)
 AC_ARG_WITH(sendfile-support,
-[  --with-sendfile-support Check for sendfile support (default=yes)],
+[  --with-sendfile-support      Check for sendfile support (default=yes)],
 [ case "$withval" in
   yes)
 
@@ -2820,20 +3011,21 @@
 		AC_CACHE_CHECK([for freebsd sendfile support],samba_cv_HAVE_SENDFILE,[
 		AC_TRY_LINK([\
 #include <sys/types.h>
+#include <unistd.h>
 #include <sys/socket.h>
 #include <sys/uio.h>],
 [\
-	int fromfd, tofd;
+	int fromfd, tofd, ret, total=0;
 	off_t offset, nwritten;
 	struct sf_hdtr hdr;
 	struct iovec hdtrl;
-	hdr->headers = &hdtrl;
-	hdr->hdr_cnt = 1;
-	hdr->trailers = NULL;
-	hdr->trl_cnt = 0;
+	hdr.headers = &hdtrl;
+	hdr.hdr_cnt = 1;
+	hdr.trailers = NULL;
+	hdr.trl_cnt = 0;
 	hdtrl.iov_base = NULL;
 	hdtrl.iov_len = 0;
-	int ret = sendfile(fromfd, tofd, offset, total, &hdr, &nwritten, 0);
+	ret = sendfile(fromfd, tofd, offset, total, &hdr, &nwritten, 0);
 ],
 samba_cv_HAVE_SENDFILE=yes,samba_cv_HAVE_SENDFILE=no)])
 
@@ -2981,8 +3173,7 @@
 
 #################################################
 # Check whether winbind is supported on this platform.  If so we need to
-# build and install client programs (WINBIND_TARGETS), sbin programs
-# (WINBIND_STARGETS) and shared libraries (WINBIND_LTARGETS).
+# build and install client programs, sbin programs and shared libraries
 
 AC_MSG_CHECKING(whether to build winbind)
 
@@ -3007,6 +3198,9 @@
 		;;
 esac
 
+AC_SUBST(WINBIND_NSS_EXTRA_OBJS)
+AC_SUBST(WINBIND_NSS_EXTRA_LIBS)
+
 # Check the setting of --with-winbindd
 
 AC_ARG_WITH(winbind,
@@ -3034,37 +3228,29 @@
 
 # Display test results
 
-WINBIND_TARGETS=""
-WINBIND_STARGETS=""
-WINBIND_LTARGETS=""
-WINBIND_PAM_PROGS=""
-
 if test x"$HAVE_WINBIND" = x"yes"; then
         AC_MSG_RESULT(yes)
 	AC_DEFINE(WITH_WINBIND,1,[Whether to build winbind])
 
-	WINBIND_TARGETS="bin/wbinfo"
-	WINBIND_STARGETS="bin/winbindd"
+	EXTRA_BIN_PROGS="$EXTRA_BIN_PROGS bin/wbinfo\$(EXEEXT)"
+	EXTRA_SBIN_PROGS="$EXTRA_SBIN_PROGS bin/winbindd\$(EXEEXT)"
         if test x"$BLDSHARED" = x"true"; then
-		WINBIND_LTARGETS="nsswitch/libnss_winbind.so"
+		case "$host_os" in
+		*irix*)
+			SHLIB_PROGS="$SHLIB_PROGS nsswitch/libns_winbind.so"
+			;;
+		*)
+			SHLIB_PROGS="$SHLIB_PROGS nsswitch/libnss_winbind.so"
+			;;
+		esac
 		if test x"$with_pam" = x"yes"; then
-			WINBIND_PAM_TARGETS="nsswitch/pam_winbind.so"
+			SHLIB_PROGS="$SHLIB_PROGS nsswitch/pam_winbind.so"
 		fi
 	fi
 else
         AC_MSG_RESULT(no$winbind_no_reason)
 fi
 
-
-# Substitution time!
-
-AC_SUBST(WINBIND_TARGETS)
-AC_SUBST(WINBIND_STARGETS)
-AC_SUBST(WINBIND_LTARGETS)
-AC_SUBST(WINBIND_PAM_TARGETS)
-AC_SUBST(WINBIND_NSS_EXTRA_OBJS)
-AC_SUBST(WINBIND_NSS_EXTRA_LIBS)
-
 # Solaris has some extra fields in struct passwd that need to be
 # initialised otherwise nscd crashes.  Unfortunately autoconf < 2.50
 # doesn't have the AC_CHECK_MEMBER macro which would be handy for checking
@@ -3132,11 +3318,19 @@
 # though they can coexist in different directories.)  In the future
 # this might make the Python stuff be built by default.
 
+# Defaulting python breaks the clean target if python isn't installed
+
+PYTHON=
+
 AC_ARG_WITH(python,
 [  --with-python=PYTHONNAME  build Python libraries],
 [ case "${withval-python}" in
   yes)
 	PYTHON=python
+	EXTRA_ALL_TARGETS="$EXTRA_ALL_TARGETS python_ext"
+	;;
+  no)
+	PYTHON=
 	;;
   *)
 	PYTHON=${withval-python}
@@ -3163,6 +3357,14 @@
 builddir=`pwd`
 AC_SUBST(builddir)
 
+dnl Remove -L/usr/lib/? from LDFLAGS and LIBS
+LIB_REMOVE_USR_LIB(LDFLAGS)
+LIB_REMOVE_USR_LIB(LIBS)
+
+dnl Remove -I/usr/include/? from CFLAGS and CPPFLAGS
+CFLAGS_REMOVE_USR_INCLUDE(CFLAGS)
+CFLAGS_REMOVE_USR_INCLUDE(CPPFLAGS)
+
 AC_OUTPUT(include/stamp-h Makefile script/findsmb)
 
 #################################################
diff -uNr samba-3.0alpha21.orig/source/dynconfig.c samba-3.0alpha21/source/dynconfig.c
--- samba-3.0alpha21.orig/source/dynconfig.c	2003-02-16 19:06:30.000000000 -0600
+++ samba-3.0alpha21/source/dynconfig.c	2003-02-16 19:05:45.000000000 -0600
@@ -1,6 +1,7 @@
 /* 
    Unix SMB/CIFS implementation.
    Copyright (C) 2001 by Martin Pool <mbp@samba.org>
+   Copyright (C) 2003 by Anthony Liguori <aliguor@us.ibm.com>
    
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -56,7 +57,8 @@
  *
  * @sa lib_path() to get the path to a file inside the LIBDIR.
  **/
-pstring dyn_LIBDIR = LIBDIR;  
+pstring dyn_LIBDIR = LIBDIR;
+const fstring dyn_SHLIBEXT = SHLIBEXT;
 
 /**
  * @brief Directory holding lock files.
@@ -66,9 +68,5 @@
 const pstring dyn_LOCKDIR = LOCKDIR;
 const pstring dyn_PIDDIR  = PIDDIR;
 
-const pstring dyn_DRIVERFILE = DRIVERFILE;
-
 const pstring dyn_SMB_PASSWD_FILE = SMB_PASSWD_FILE;
 const pstring dyn_PRIVATE_DIR = PRIVATE_DIR;
-
-
diff -uNr samba-3.0alpha21.orig/source/groupdb/mapping.c samba-3.0alpha21/source/groupdb/mapping.c
--- samba-3.0alpha21.orig/source/groupdb/mapping.c	2003-02-16 19:06:31.000000000 -0600
+++ samba-3.0alpha21/source/groupdb/mapping.c	2003-02-16 19:05:45.000000000 -0600
@@ -209,7 +209,7 @@
 static BOOL init_group_mapping(void)
 {
 	static pid_t local_pid;
-	char *vstring = "INFO/version";
+	const char *vstring = "INFO/version";
 	int32 vers_id;
 	
 	if (tdb && local_pid == sys_getpid())
@@ -293,8 +293,8 @@
 /****************************************************************************
 initialise first time the mapping list
 ****************************************************************************/
-BOOL add_initial_entry(gid_t gid, fstring sid, enum SID_NAME_USE sid_name_use,
-			      fstring nt_name, fstring comment, PRIVILEGE_SET priv_set, uint32 systemaccount)
+BOOL add_initial_entry(gid_t gid, const char *sid, enum SID_NAME_USE sid_name_use,
+		       const char *nt_name, const char *comment, PRIVILEGE_SET priv_set, uint32 systemaccount)
 {
 	GROUP_MAP map;
 
diff -uNr samba-3.0alpha21.orig/source/include/asn_1.h samba-3.0alpha21/source/include/asn_1.h
--- samba-3.0alpha21.orig/source/include/asn_1.h	2003-02-16 19:06:31.000000000 -0600
+++ samba-3.0alpha21/source/include/asn_1.h	2003-02-16 19:05:45.000000000 -0600
@@ -55,4 +55,8 @@
 #define OID_KERBEROS5_OLD "1 2 840 48018 1 2 2"
 #define OID_KERBEROS5 "1 2 840 113554 1 2 2"
 
+#define SPNGEO_NEG_RESULT_ACCEPT 0
+#define SPNGEO_NEG_RESULT_INCOMPLETE 1
+#define SPNGEO_NEG_RESULT_REJECT 2
+
 #endif /* _ASN_1_H */
diff -uNr samba-3.0alpha21.orig/source/include/auth.h samba-3.0alpha21/source/include/auth.h
--- samba-3.0alpha21.orig/source/include/auth.h	2003-02-16 19:06:31.000000000 -0600
+++ samba-3.0alpha21/source/include/auth.h	2003-02-16 19:05:45.000000000 -0600
@@ -100,7 +100,7 @@
 	DATA_BLOB challenge; 
 
 	/* Who set this up in the first place? */ 
-	char *challenge_set_by; 
+	const char *challenge_set_by; 
 
 	struct auth_methods *challenge_set_method; 
 	/* What order are the various methods in?   Try to stop it changing under us */ 
@@ -118,7 +118,7 @@
 typedef struct auth_methods
 {
 	struct auth_methods *prev, *next;
-	char *name; /* What name got this module */
+	const char *name; /* What name got this module */
 
 	NTSTATUS (*auth)(const struct auth_context *auth_context,
 			 void *my_private_data, 
@@ -144,9 +144,18 @@
 typedef NTSTATUS (*auth_init_function)(struct auth_context *, const char *, struct auth_methods **);
 
 struct auth_init_function_entry {
-	char *name;
+	const char *name;
 	/* Function to create a member of the authmethods list */
 
 	auth_init_function init;
 };
+
+typedef struct auth_ntlmssp_state
+{
+	TALLOC_CTX *mem_ctx;
+	struct auth_context *auth_context;
+	struct auth_serversupplied_info *server_info;
+	struct ntlmssp_state *ntlmssp_state;
+} AUTH_NTLMSSP_STATE;
+
 #endif /* _SMBAUTH_H_ */
diff -uNr samba-3.0alpha21.orig/source/include/client.h samba-3.0alpha21/source/include/client.h
--- samba-3.0alpha21.orig/source/include/client.h	2003-02-16 19:06:31.000000000 -0600
+++ samba-3.0alpha21/source/include/client.h	2003-02-16 19:05:45.000000000 -0600
@@ -35,7 +35,7 @@
 
 typedef struct file_info
 {
-	SMB_OFF_T size;
+	SMB_BIG_UINT size;
 	uint16 mode;
 	uid_t uid;
 	gid_t gid;
diff -uNr samba-3.0alpha21.orig/source/include/debug.h samba-3.0alpha21/source/include/debug.h
--- samba-3.0alpha21.orig/source/include/debug.h	2003-02-16 19:06:31.000000000 -0600
+++ samba-3.0alpha21/source/include/debug.h	2003-02-16 19:05:45.000000000 -0600
@@ -44,11 +44,6 @@
 extern pstring debugf;
 
 /* If we have these macros, we can add additional info to the header. */
-#ifdef HAVE_FILE_MACRO
-#define FILE_MACRO (__FILE__)
-#else
-#define FILE_MACRO ("")
-#endif
 
 #ifdef HAVE_FUNCTION_MACRO
 #define FUNCTION_MACRO  (__FUNCTION__)
@@ -157,7 +152,7 @@
      ((DEBUGLEVEL_CLASS[ DBGC_CLASS ] >= (level))||  \
      (!DEBUGLEVEL_CLASS_ISSET[ DBGC_CLASS ] && \
       DEBUGLEVEL_CLASS[ DBGC_ALL   ] >= (level))  ) \
-   && dbghdr( level, FILE_MACRO, FUNCTION_MACRO, (__LINE__) ) )
+   && dbghdr( level, __FILE__, FUNCTION_MACRO, (__LINE__) ) )
 
 
 #define DEBUGLVLC( dbgc_class, level ) \
@@ -165,7 +160,7 @@
      ((DEBUGLEVEL_CLASS[ dbgc_class ] >= (level))||  \
      (!DEBUGLEVEL_CLASS_ISSET[ dbgc_class ] && \
       DEBUGLEVEL_CLASS[ DBGC_ALL   ] >= (level))  ) \
-   && dbghdr( level, FILE_MACRO, FUNCTION_MACRO, (__LINE__) ) )
+   && dbghdr( level, __FILE__, FUNCTION_MACRO, (__LINE__) ) )
 
 
 #define DEBUG( level, body ) \
@@ -173,7 +168,7 @@
            ((DEBUGLEVEL_CLASS[ DBGC_CLASS ] >= (level))||  \
            (!DEBUGLEVEL_CLASS_ISSET[ DBGC_CLASS ] && \
             DEBUGLEVEL_CLASS[ DBGC_ALL   ] >= (level))  ) \
-       && (dbghdr( level, FILE_MACRO, FUNCTION_MACRO, (__LINE__) )) \
+       && (dbghdr( level, __FILE__, FUNCTION_MACRO, (__LINE__) )) \
        && (dbgtext body) )
 
 #define DEBUGC( dbgc_class, level, body ) \
@@ -181,7 +176,7 @@
            ((DEBUGLEVEL_CLASS[ dbgc_class ] >= (level))||  \
            (!DEBUGLEVEL_CLASS_ISSET[ dbgc_class ] && \
 	    DEBUGLEVEL_CLASS[ DBGC_ALL   ] >= (level))  ) \
-       && (dbghdr( level, FILE_MACRO, FUNCTION_MACRO, (__LINE__) )) \
+       && (dbghdr( level, __FILE__, FUNCTION_MACRO, (__LINE__) )) \
        && (dbgtext body) )
 
 #define DEBUGADD( level, body ) \
diff -uNr samba-3.0alpha21.orig/source/include/dynconfig.h samba-3.0alpha21/source/include/dynconfig.h
--- samba-3.0alpha21.orig/source/include/dynconfig.h	2003-02-16 19:06:31.000000000 -0600
+++ samba-3.0alpha21/source/include/dynconfig.h	2003-02-16 19:05:45.000000000 -0600
@@ -1,6 +1,7 @@
 /* 
    Unix SMB/CIFS implementation.
    Copyright (C) 2001 by Martin Pool <mbp@samba.org>
+   Copyright (C) 2003 by Anthony Liguori <aliguor@us.ibm.com>
    
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -30,8 +31,8 @@
 extern pstring dyn_CONFIGFILE;
 extern pstring dyn_LOGFILEBASE, dyn_LMHOSTSFILE;
 extern pstring dyn_LIBDIR;
+extern const fstring dyn_SHLIBEXT;
 extern const pstring dyn_LOCKDIR; 
 extern const pstring dyn_PIDDIR;
-extern const pstring dyn_DRIVERFILE; 
 extern const pstring dyn_SMB_PASSWD_FILE;
 extern const pstring dyn_PRIVATE_DIR;
diff -uNr samba-3.0alpha21.orig/source/include/includes.h samba-3.0alpha21/source/include/includes.h
--- samba-3.0alpha21.orig/source/include/includes.h	2003-02-16 19:06:31.000000000 -0600
+++ samba-3.0alpha21/source/include/includes.h	2003-02-16 19:05:45.000000000 -0600
@@ -412,6 +412,10 @@
 #undef HAVE_LDAP
 #endif
 
+#if HAVE_GSSAPI_H
+#include <gssapi.h>
+#endif
+
 #if HAVE_GSSAPI_GSSAPI_H
 #include <gssapi/gssapi.h>
 #endif
@@ -420,6 +424,10 @@
 #include <gssapi/gssapi_generic.h>
 #endif
 
+#if HAVE_COM_ERR_H
+#include <com_err.h>
+#endif
+
 /* we support ADS if we want it and have krb5 and ldap libs */
 #if defined(WITH_ADS) && defined(HAVE_KRB5) && defined(HAVE_LDAP)
 #define HAVE_ADS
@@ -589,9 +597,15 @@
 #ifdef LARGE_SMB_OFF_T
 #define SOFF_T(p, ofs, v) (SIVAL(p,ofs,(v)&0xFFFFFFFF), SIVAL(p,(ofs)+4,(v)>>32))
 #define SOFF_T_R(p, ofs, v) (SIVAL(p,(ofs)+4,(v)&0xFFFFFFFF), SIVAL(p,ofs,(v)>>32))
+#define IVAL_TO_SMB_OFF_T(buf,off) ((SMB_OFF_T)(( ((SMB_BIG_UINT)(IVAL((buf),(off)))) & ((SMB_BIG_UINT)0xFFFFFFFF) )))
+#define IVAL2_TO_SMB_BIG_UINT(buf,off) ( (((SMB_BIG_UINT)(IVAL((buf),(off)))) & ((SMB_BIG_UINT)0xFFFFFFFF)) | \
+		(( ((SMB_BIG_UINT)(IVAL((buf),(off+4)))) & ((SMB_BIG_UINT)0xFFFFFFFF) ) << 32 ) )
 #else 
 #define SOFF_T(p, ofs, v) (SIVAL(p,ofs,v),SIVAL(p,(ofs)+4,0))
 #define SOFF_T_R(p, ofs, v) (SIVAL(p,(ofs)+4,v),SIVAL(p,ofs,0))
+#define IVAL_TO_SMB_OFF_T(buf,off) ((SMB_OFF_T)(( ((uint32)(IVAL((buf),(off)))) & 0xFFFFFFFF )))
+#define IVAL2_TO_SMB_BIG_UINT(buf,off) ( (((SMB_BIG_UINT)(IVAL((buf),(off)))) & ((SMB_BIG_UINT)0xFFFFFFFF)) | \
+		                (( ((SMB_BIG_UINT)(IVAL((buf),(off+4)))) & ((SMB_BIG_UINT)0xFFFFFFFF) ) << 32 ) )
 #endif
 
 /*
@@ -748,6 +762,8 @@
 #include "md5.h"
 #include "hmacmd5.h"
 
+#include "ntlmssp.h"
+
 #include "auth.h"
 
 #include "passdb.h"
@@ -787,7 +803,7 @@
 
 /* used in net.c */
 struct functable {
-	char *funcname;
+	const char *funcname;
 	int (*fn)(int argc, const char **argv);
 };
 
@@ -1150,6 +1166,15 @@
 int asprintf(char **,const char *, ...) PRINTF_ATTRIBUTE(2,3);
 #endif
 
+void sys_adminlog(int priority, const char *format_str, ...) PRINTF_ATTRIBUTE(2,3);
+
+int pstr_sprintf(pstring s, const char *fmt, ...) PRINTF_ATTRIBUTE(2,3);
+int fstr_sprintf(fstring s, const char *fmt, ...) PRINTF_ATTRIBUTE(2,3);
+
+int d_vfprintf(FILE *f, const char *format, va_list ap) PRINTF_ATTRIBUTE(2,0);
+
+int smb_xvasprintf(char **ptr, const char *format, va_list ap) PRINTF_ATTRIBUTE(2,0);
+
 /* we used to use these fns, but now we have good replacements
    for snprintf and vsnprintf */
 #define slprintf snprintf
@@ -1167,5 +1192,40 @@
 time_t timegm(struct tm *tm);
 #endif
 
+#if defined(VALGRIND)
+#define strlen(x) valgrind_strlen(x)
+#endif
+
+/*
+ * Veritas File System.  Often in addition to native.
+ * Quotas different.
+ */
+#if defined(HAVE_SYS_FS_VX_QUOTA_H)
+#define VXFS_QUOTA
+#endif
+
+#if defined(HAVE_KRB5)
+
+#ifndef KRB5_SET_REAL_TIME
+krb5_error_code krb5_set_real_time(krb5_context context, int32_t seconds, int32_t microseconds);
+#endif
+
+#ifndef HAVE_KRB5_SET_DEFAULT_TGS_KTYPES
+krb5_error_code krb5_set_default_tgs_ktypes(krb5_context ctx, const krb5_enctype *enc);
+#endif
+
+#if defined(HAVE_KRB5_AUTH_CON_SETKEY) && !defined(HAVE_KRB5_AUTH_CON_SETUSERUSERKEY)
+krb5_error_code krb5_auth_con_setuseruserkey(krb5_context context, krb5_auth_context auth_context, krb5_keyblock *keyblock);
+#endif
+
+/* Samba wrapper function for krb5 functionality. */
+void setup_kaddr( krb5_address *pkaddr, struct sockaddr *paddr);
+int create_kerberos_key_from_string(krb5_context context, krb5_principal host_princ, krb5_data *password, krb5_keyblock *key);
+void get_auth_data_from_tkt(DATA_BLOB *auth_data, krb5_ticket *tkt);
+krb5_const_principal get_principal_from_tkt(krb5_ticket *tkt);
+krb5_error_code krb5_locate_kdc(krb5_context ctx, const krb5_data *realm, struct sockaddr **addr_pp, int *naddrs, int get_masters);
+
+#endif /* HAVE_KRB5 */
+
 #endif /* _INCLUDES_H */
 
diff -uNr samba-3.0alpha21.orig/source/include/libsmb_internal.h samba-3.0alpha21/source/include/libsmb_internal.h
--- samba-3.0alpha21.orig/source/include/libsmb_internal.h	1969-12-31 18:00:00.000000000 -0600
+++ samba-3.0alpha21/source/include/libsmb_internal.h	2003-02-16 19:05:45.000000000 -0600
@@ -0,0 +1,67 @@
+#ifndef _LIBSMB_INTERNAL_H_
+#define _LIBSMB_INTERNAL_H_
+
+#define SMBC_MAX_NAME  1023
+#define SMBC_FILE_MODE (S_IFREG | 0444)
+#define SMBC_DIR_MODE  (S_IFDIR | 0555)
+
+
+#include "../include/libsmbclient.h"
+
+
+struct _SMBCSRV {
+	struct cli_state cli;
+	dev_t dev;
+	BOOL no_pathinfo2;
+	int server_fd;
+
+	SMBCSRV *next, *prev;
+	
+};
+
+/* 
+ * Keep directory entries in a list 
+ */
+struct smbc_dir_list {
+	struct smbc_dir_list *next;
+	struct smbc_dirent *dirent;
+};
+
+
+/*
+ * Structure for open file management
+ */ 
+struct _SMBCFILE {
+	int cli_fd; 
+	char *fname;
+	off_t offset;
+	struct _SMBCSRV *srv;
+	BOOL file;
+	struct smbc_dir_list *dir_list, *dir_end, *dir_next;
+	int dir_type, dir_error;
+
+	SMBCFILE *next, *prev;
+};
+
+
+struct smbc_internal_data {
+
+	/** INTERNAL: is this handle initialized ? 
+	 */
+	int     _initialized;
+
+	/** INTERNAL: dirent pointer location 
+	 */
+	char    _dirent[512];  
+
+	/** INTERNAL: server connection list
+	 */
+	SMBCSRV * _servers;
+	
+	/** INTERNAL: open file/dir list
+	 */
+	SMBCFILE * _files;
+};	
+
+
+#endif
diff -uNr samba-3.0alpha21.orig/source/include/libsmbclient.h samba-3.0alpha21/source/include/libsmbclient.h
--- samba-3.0alpha21.orig/source/include/libsmbclient.h	2003-02-16 19:06:31.000000000 -0600
+++ samba-3.0alpha21/source/include/libsmbclient.h	2003-02-16 19:05:45.000000000 -0600
@@ -35,6 +35,10 @@
 *   \ingroup libsmbclient
 *   Data structures, types, and constants
 */
+/** \defgroup callback Callback function types
+*   \ingroup libsmbclient
+*   Callback functions
+*/
 /** \defgroup file File Functions
 *   \ingroup libsmbclient
 *   Functions used to access individual file contents
@@ -51,7 +55,7 @@
 *   \ingroup libsmbclient
 *   Functions used to access printing functionality
 */
-/** \defgroup attribute Miscellaneous Functions
+/** \defgroup misc Miscellaneous Functions
 *   \ingroup libsmbclient
 *   Functions that don't fit in to other categories
 */
@@ -62,7 +66,6 @@
 #include <sys/stat.h>
 #include <fcntl.h>
 
-#define SMBC_MAX_NAME       1023
 #define SMBC_WORKGROUP      1
 #define SMBC_SERVER         2
 #define SMBC_FILE_SHARE     3
@@ -73,12 +76,6 @@
 #define SMBC_FILE           8
 #define SMBC_LINK           9
 
-#define SMBC_FILE_MODE (S_IFREG | 0444)
-#define SMBC_DIR_MODE  (S_IFDIR | 0555)
-
-#define SMBC_MAX_FD         10000
-
-
 /**@ingroup structure
  * Structure that represents a directory entry.
  *
@@ -116,12 +113,12 @@
 	char name[1];
 };
 
-#ifndef _CLIENT_H
 
 /**@ingroup structure
  * Structure that represents a print job.
  *
  */
+#ifndef _CLIENT_H
 struct print_job_info 
 {
 	/** numeric ID of the print job
@@ -149,9 +146,29 @@
 	 */
 	time_t t;
 };
-#endif /* ifndef _CLIENT_H */
+#endif /* _CLIENT_H */
+
+
+/**@ingroup structure
+ * Server handle 
+ */
+typedef struct _SMBCSRV  SMBCSRV;
 
 /**@ingroup structure
+ * File or directory handle 
+ */
+typedef struct _SMBCFILE SMBCFILE;
+
+/**@ingroup structure
+ * File or directory handle 
+ */
+typedef struct _SMBCCTX SMBCCTX;
+
+
+
+
+
+/**@ingroup callback
  * Authentication callback function type.
  * 
  * Type for the the authentication function called by the library to
@@ -187,51 +204,114 @@
                                       char *pw, int pwlen);
 
 
-/**@ingroup structure
+/**@ingroup callback
  * Print job info callback function type.
  *
  * @param i         pointer to print job information structure
  *
  */ 
-typedef void (*smbc_get_print_job_info)(struct print_job_info *i);
+typedef void (*smbc_list_print_job_fn)(struct print_job_info *i);
+		
 
-typedef struct _SMBCSRV {
-	struct cli_state cli;
-	dev_t dev;
-	BOOL no_pathinfo2;
-	int server_fd;
+/**@ingroup callback
+ * Check if a server is still good
+ *
+ * @param c         pointer to smb context
+ *
+ * @param srv       pointer to server to check
+ *
+ * @return          0 when connection is good. 1 on error.
+ *
+ */ 
+typedef int (*smbc_check_server_fn)(SMBCCTX * c, SMBCSRV *srv);
 
-	struct _SMBCSRV *next, *prev;
-	
-} SMBCSRV;
+/**@ingroup callback
+ * Remove a server if unused
+ *
+ * @param c         pointer to smb context
+ *
+ * @param srv       pointer to server to remove
+ *
+ * @return          0 on success. 1 on failure.
+ *
+ */ 
+typedef int (*smbc_remove_unused_server_fn)(SMBCCTX * c, SMBCSRV *srv);
+
+
+/**@ingroup callback
+ * Add a server to the cache system
+ *
+ * @param c         pointer to smb context
+ *
+ * @param srv       pointer to server to add
+ *
+ * @param server    server name 
+ *
+ * @param share     share name
+ *
+ * @param workgroup workgroup used to connect
+ *
+ * @param username  username used to connect
+ *
+ * @return          0 on success. 1 on failure.
+ *
+ */ 
+typedef int (*smbc_add_cached_srv_fn)   (SMBCCTX * c, SMBCSRV *srv, 
+				    char * server, char * share, 
+				    char * workgroup, char * username);
+
+
+/**@ingroup callback
+ * Look up a server in the cache system
+ *
+ * @param c         pointer to smb context
+ *
+ * @param server    server name to match
+ *
+ * @param share     share name to match
+ *
+ * @param workgroup workgroup to match
+ *
+ * @param username  username to match
+ *
+ * @return          pointer to SMBCSRV on success. NULL on failure.
+ *
+ */ 
+typedef SMBCSRV * (*smbc_get_cached_srv_fn)   (SMBCCTX * c, char * server, 
+					       char * share, char * workgroup, char * username);
+
+
+/**@ingroup callback
+ * Check if a server is still good
+ *
+ * @param c         pointer to smb context
+ *
+ * @param srv       pointer to server to remove
+ *
+ * @return          0 when found and removed. 1 on failure.
+ *
+ */ 
+typedef int (*smbc_remove_cached_srv_fn)(SMBCCTX * c, SMBCSRV *srv);
 
-/* 
- * Keep directory entries in a list 
- */
-struct smbc_dir_list {
-	struct smbc_dir_list *next;
-	struct smbc_dirent *dirent;
-};
 
-/*
- * Structure for open file management
+/**@ingroup callback
+ * Try to remove all servers from the cache system and disconnect
+ *
+ * @param c         pointer to smb context
+ *
+ * @return          0 when found and removed. 1 on failure.
+ *
  */ 
-typedef struct _SMBCFILE {
-	int cli_fd; 
-	char *fname;
-	off_t offset;
-	SMBCSRV *srv;
-	BOOL file;
-	struct smbc_dir_list *dir_list, *dir_end, *dir_next;
-	int dir_type, dir_error;
+typedef int (*smbc_purge_cached_fn)     (SMBCCTX * c);
+
+
 
-	struct _SMBCFILE *next, *prev;
-} SMBCFILE;
 
 /**@ingroup structure
  * Structure that contains a client context information 
+ * This structure is know as SMBCCTX
  */
-typedef struct _SMBCCTX {
+struct _SMBCCTX {
 	/** debug level 
 	 */
 	int     debug;
@@ -255,42 +335,42 @@
 	/** callable functions for files:
 	 * For usage and return values see the smbc_* functions
 	 */ 
-	SMBCFILE * (*open)    (struct _SMBCCTX *c, const char *fname, int flags, mode_t mode);
-	SMBCFILE * (*creat)   (struct _SMBCCTX *c, const char *path, mode_t mode);
-	ssize_t    (*read)    (struct _SMBCCTX *c, SMBCFILE *file, void *buf, size_t count);
-	ssize_t    (*write)   (struct _SMBCCTX *c, SMBCFILE *file, void *buf, size_t count);
-	int        (*unlink)  (struct _SMBCCTX *c, const char *fname);
-	int        (*rename)  (struct _SMBCCTX *ocontext, const char *oname, 
-			       struct _SMBCCTX *ncontext, const char *nname);
-	off_t      (*lseek)   (struct _SMBCCTX *c, SMBCFILE * file, off_t offset, int whence);
-	int        (*stat)    (struct _SMBCCTX *c, const char *fname, struct stat *st);
-	int        (*fstat)   (struct _SMBCCTX *c, SMBCFILE *file, struct stat *st);
-	int        (*close)   (struct _SMBCCTX *c, SMBCFILE *file);
+	SMBCFILE * (*open)    (SMBCCTX *c, const char *fname, int flags, mode_t mode);
+	SMBCFILE * (*creat)   (SMBCCTX *c, const char *path, mode_t mode);
+	ssize_t    (*read)    (SMBCCTX *c, SMBCFILE *file, void *buf, size_t count);
+	ssize_t    (*write)   (SMBCCTX *c, SMBCFILE *file, void *buf, size_t count);
+	int        (*unlink)  (SMBCCTX *c, const char *fname);
+	int        (*rename)  (SMBCCTX *ocontext, const char *oname, 
+			       SMBCCTX *ncontext, const char *nname);
+	off_t      (*lseek)   (SMBCCTX *c, SMBCFILE * file, off_t offset, int whence);
+	int        (*stat)    (SMBCCTX *c, const char *fname, struct stat *st);
+	int        (*fstat)   (SMBCCTX *c, SMBCFILE *file, struct stat *st);
+	int        (*close)   (SMBCCTX *c, SMBCFILE *file);
 
 	/** callable functions for dirs
 	 */ 
-	SMBCFILE * (*opendir) (struct _SMBCCTX *c, const char *fname);
-	int        (*closedir)(struct _SMBCCTX *c, SMBCFILE *dir);
-	struct smbc_dirent * (*readdir)(struct _SMBCCTX *c, SMBCFILE *dir);
-	int        (*getdents)(struct _SMBCCTX *c, SMBCFILE *dir, 
+	SMBCFILE * (*opendir) (SMBCCTX *c, const char *fname);
+	int        (*closedir)(SMBCCTX *c, SMBCFILE *dir);
+	struct smbc_dirent * (*readdir)(SMBCCTX *c, SMBCFILE *dir);
+	int        (*getdents)(SMBCCTX *c, SMBCFILE *dir, 
 			       struct smbc_dirent *dirp, int count);
-	int        (*mkdir)   (struct _SMBCCTX *c, const char *fname, mode_t mode);
-	int        (*rmdir)   (struct _SMBCCTX *c, const char *fname);
-	off_t      (*telldir) (struct _SMBCCTX *c, SMBCFILE *dir);
-	int        (*lseekdir)(struct _SMBCCTX *c, SMBCFILE *dir, off_t offset);
-	int        (*fstatdir)(struct _SMBCCTX *c, SMBCFILE *dir, struct stat *st);
+	int        (*mkdir)   (SMBCCTX *c, const char *fname, mode_t mode);
+	int        (*rmdir)   (SMBCCTX *c, const char *fname);
+	off_t      (*telldir) (SMBCCTX *c, SMBCFILE *dir);
+	int        (*lseekdir)(SMBCCTX *c, SMBCFILE *dir, off_t offset);
+	int        (*fstatdir)(SMBCCTX *c, SMBCFILE *dir, struct stat *st);
 
 	/** callable functions for printing
 	 */ 
-	int        (*print_file)(struct _SMBCCTX *c_file, const char *fname, 
-				 struct _SMBCCTX *c_print, const char *printq);
-	SMBCFILE * (*open_print_job)(struct _SMBCCTX *c, const char *fname);
-	int        (*list_print_jobs)(struct _SMBCCTX *c, const char *fname, void (*fn)(struct print_job_info *));
-	int        (*unlink_print_job)(struct _SMBCCTX *c, const char *fname, int id);
+	int        (*print_file)(SMBCCTX *c_file, const char *fname, 
+				 SMBCCTX *c_print, const char *printq);
+	SMBCFILE * (*open_print_job)(SMBCCTX *c, const char *fname);
+	int        (*list_print_jobs)(SMBCCTX *c, const char *fname, smbc_list_print_job_fn fn);
+	int        (*unlink_print_job)(SMBCCTX *c, const char *fname, int id);
 
 
 	/** Callbacks
-	 * These callbacks _always_ have to be intialized because they will not be checked
+	 * These callbacks _always_ have to be initialized because they will not be checked
 	 * at dereference for increased speed.
 	 */
 	struct _smbc_callbacks {
@@ -300,11 +380,11 @@
 		
 		/** check if a server is still good
 		 */
-		int (*check_server_fn)(struct _SMBCCTX * c, SMBCSRV *srv);
+		smbc_check_server_fn check_server_fn;
 
 		/** remove a server if unused
 		 */
-		int (*remove_unused_server_fn)(struct _SMBCCTX * c, SMBCSRV *srv);
+		smbc_remove_unused_server_fn remove_unused_server_fn;
 
 		/** Cache subsystem
 		 * For an example cache system see samba/source/libsmb/libsmb_cache.c
@@ -313,21 +393,19 @@
 
 		/** server cache addition 
 		 */
-		int (*add_cached_srv_fn)   (struct _SMBCCTX * c, SMBCSRV *srv, 
-					    char * server, char * share, 
-					    char * workgroup, char * username);
+		smbc_add_cached_srv_fn add_cached_srv_fn;
+
 		/** server cache lookup 
 		 */
-		SMBCSRV * (*get_cached_srv_fn)   (struct _SMBCCTX * c, char * server, 
-					    char * share, char * workgroup, char * username);
+		smbc_get_cached_srv_fn get_cached_srv_fn;
+
 		/** server cache removal
 		 */
-		int (*remove_cached_srv_fn)(struct _SMBCCTX * c, SMBCSRV *srv);
+		smbc_remove_cached_srv_fn remove_cached_srv_fn;
 		
 		/** server cache purging, try to remove all cached servers (disconnect)
 		 */
-		int (*purge_cached_fn)     (struct _SMBCCTX * c);
-		
+		smbc_purge_cached_fn purge_cached_fn;
 	} callbacks;
 
 
@@ -335,27 +413,12 @@
 	 */
 	struct smbc_server_cache * server_cache;
 
-	/** INTERNAL functions
-	 * do _NOT_ touch these from your program !
-	 */
-
-	/** INTERNAL: is this handle initialized ? 
-	 */
-	int     _initialized;
-
-	/** INTERNAL: dirent pointer location 
+	/** INTERNAL DATA
+	 * do _NOT_ touch this from your program !
 	 */
-	char    _dirent[512];  
-
-	/** INTERNAL: server connection list
-	 */
-	SMBCSRV * _servers;
+	struct smbc_internal_data * internal;
 	
-	/** INTERNAL: open file/dir list
-	 */
-	SMBCFILE * _files;
-	
-} SMBCCTX;
+};
 
 
 /**@ingroup misc
@@ -990,7 +1053,7 @@
  *                  - EINVAL fname was NULL or smbc_init not called
  *                  - EACCES ???
  */
-int smbc_list_print_jobs(const char *purl, smbc_get_print_job_info fn);
+int smbc_list_print_jobs(const char *purl, smbc_list_print_job_fn fn);
 
 /**@ingroup print
  * Delete a print job 
diff -uNr samba-3.0alpha21.orig/source/include/local.h samba-3.0alpha21/source/include/local.h
--- samba-3.0alpha21.orig/source/include/local.h	2003-02-16 19:06:31.000000000 -0600
+++ samba-3.0alpha21/source/include/local.h	2003-02-16 19:05:45.000000000 -0600
@@ -166,9 +166,6 @@
    it are worked out */
 #define USE_READ_PREDICTION 0
 
-/* name of directory that netatalk uses to store macintosh resource forks */
-#define APPLEDOUBLE ".AppleDouble/"
-
 /*
  * Default passwd chat script.
  */
@@ -216,4 +213,12 @@
 /* Max number of open RPC pipes. */
 #define MAX_OPEN_PIPES 2048
 
+/* Tuning for server auth mutex. */
+#define CLI_AUTH_TIMEOUT 5000 /* In milli-seconds. */
+#define NUM_CLI_AUTH_CONNECT_RETRIES 3
+/* Number in seconds to wait for the mutex. This must be less than 30 seconds. */
+#define SERVER_MUTEX_WAIT_TIME ( ((NUM_CLI_AUTH_CONNECT_RETRIES) * ((CLI_AUTH_TIMEOUT)/1000)) + 5)
+/* Number in seconds for winbindd to wait for the mutex. Make this 2 * smbd wait time. */
+#define WINBIND_SERVER_MUTEX_WAIT_TIME (( ((NUM_CLI_AUTH_CONNECT_RETRIES) * ((CLI_AUTH_TIMEOUT)/1000)) + 5)*2)
+
 #endif
diff -uNr samba-3.0alpha21.orig/source/include/mapping.h samba-3.0alpha21/source/include/mapping.h
--- samba-3.0alpha21.orig/source/include/mapping.h	2003-02-16 19:06:31.000000000 -0600
+++ samba-3.0alpha21/source/include/mapping.h	2003-02-16 19:05:45.000000000 -0600
@@ -55,7 +55,7 @@
 
 typedef struct _PRIVS {
 	uint32 se_priv;
-	char *priv;
-	char *description;
+	const char *priv;
+	const char *description;
 } PRIVS;
 
diff -uNr samba-3.0alpha21.orig/source/include/messages.h samba-3.0alpha21/source/include/messages.h
--- samba-3.0alpha21.orig/source/include/messages.h	2003-02-16 19:06:31.000000000 -0600
+++ samba-3.0alpha21/source/include/messages.h	2003-02-16 19:05:45.000000000 -0600
@@ -43,6 +43,10 @@
 
 #define MSG_SHUTDOWN		13
 
+/* Dump out the talloc useage. */
+#define MSG_REQ_TALLOC_USAGE      14
+#define MSG_TALLOC_USAGE          15
+
 /* nmbd messages */
 #define MSG_FORCE_ELECTION 1001
 #define MSG_WINS_NEW_ENTRY 1002
diff -uNr samba-3.0alpha21.orig/source/include/nt_printing.h samba-3.0alpha21/source/include/nt_printing.h
--- samba-3.0alpha21.orig/source/include/nt_printing.h	2003-02-16 19:06:31.000000000 -0600
+++ samba-3.0alpha21/source/include/nt_printing.h	2003-02-16 19:05:45.000000000 -0600
@@ -183,6 +183,64 @@
 #define SPOOL_PNPDATA_KEY		"PnPData"
 #define SPOOL_OID_KEY			"OID"
 
+/* predefined value names for printer data */
+#define SPOOL_REG_ASSETNUMBER		"assetNumber"
+#define SPOOL_REG_BYTESPERMINUTE	"bytesPerMinute"
+#define SPOOL_REG_DEFAULTPRIORITY	"defaultPriority"
+#define SPOOL_REG_DESCRIPTION		"description"
+#define SPOOL_REG_DRIVERNAME		"driverName"
+#define SPOOL_REG_DRIVERVERSION		"driverVersion"
+#define SPOOL_REG_FLAGS			"flags"
+#define SPOOL_REG_LOCATION		"location"
+#define SPOOL_REG_OPERATINGSYSTEM	"operatingSystem"
+#define SPOOL_REG_OPERATINGSYSTEMHOTFIX	"operatingSystemHotfix"
+#define SPOOL_REG_OPERATINGSYSTEMSERVICEPACK "operatingSystemServicePack"
+#define SPOOL_REG_OPERATINGSYSTEMVERSION "operatingSystemVersion"
+#define SPOOL_REG_PORTNAME		"portName"
+#define SPOOL_REG_PRINTATTRIBUTES	"printAttributes"
+#define SPOOL_REG_PRINTBINNAMES		"printBinNames"
+#define SPOOL_REG_PRINTCOLLATE		"printCollate"
+#define SPOOL_REG_PRINTCOLOR		"printColor"
+#define SPOOL_REG_PRINTDUPLEXSUPPORTED	"printDuplexSupported"
+#define SPOOL_REG_PRINTENDTIME		"printEndTime"
+#define SPOOL_REG_PRINTERNAME		"printerName"
+#define SPOOL_REG_PRINTFORMNAME		"printFormName"
+#define SPOOL_REG_PRINTKEEPPRINTEDJOBS	"printKeepPrintedJobs"
+#define SPOOL_REG_PRINTLANGUAGE		"printLanguage"
+#define SPOOL_REG_PRINTMACADDRESS	"printMACAddress"
+#define SPOOL_REG_PRINTMAXCOPIES	"printMaxCopies"
+#define SPOOL_REG_PRINTMAXRESOLUTIONSUPPORTED "printMaxResolutionSupported"
+#define SPOOL_REG_PRINTMAXXEXTENT	"printMaxXExtent"
+#define SPOOL_REG_PRINTMAXYEXTENT	"printMaxYExtent"
+#define SPOOL_REG_PRINTMEDIAREADY	"printMediaReady"
+#define SPOOL_REG_PRINTMEDIASUPPORTED	"printMediaSupported"
+#define SPOOL_REG_PRINTMEMORY		"printMemory"
+#define SPOOL_REG_PRINTMINXEXTENT	"printMinXExtent"
+#define SPOOL_REG_PRINTMINYEXTENT	"printMinYExtent"
+#define SPOOL_REG_PRINTNETWORKADDRESS	"printNetworkAddress"
+#define SPOOL_REG_PRINTNOTIFY		"printNotify"
+#define SPOOL_REG_PRINTNUMBERUP		"printNumberUp"
+#define SPOOL_REG_PRINTORIENTATIONSSUPPORTED "printOrientationsSupported"
+#define SPOOL_REG_PRINTOWNER		"printOwner"
+#define SPOOL_REG_PRINTPAGESPERMINUTE	"printPagesPerMinute"
+#define SPOOL_REG_PRINTRATE		"printRate"
+#define SPOOL_REG_PRINTRATEUNIT		"printRateUnit"
+#define SPOOL_REG_PRINTSEPARATORFILE	"printSeparatorFile"
+#define SPOOL_REG_PRINTSHARENAME	"printShareName"
+#define SPOOL_REG_PRINTSPOOLING		"printSpooling"
+#define SPOOL_REGVAL_PRINTWHILESPOOLING	"PrintWhileSpooling"
+#define SPOOL_REGVAL_PRINTAFTERSPOOLED	"PrintAfterSpooled"
+#define SPOOL_REGVAL_PRINTDIRECT	"PrintDirect"
+#define SPOOL_REG_PRINTSTAPLINGSUPPORTED "printStaplingSupported"
+#define SPOOL_REG_PRINTSTARTTIME	"printStartTime"
+#define SPOOL_REG_PRINTSTATUS		"printStatus"
+#define SPOOL_REG_PRIORITY		"priority"
+#define SPOOL_REG_SERVERNAME		"serverName"
+#define SPOOL_REG_SHORTSERVERNAME	"shortServerName"
+#define SPOOL_REG_UNCNAME		"uNCName"
+#define SPOOL_REG_URL			"url"
+#define SPOOL_REG_VERSIONNUMBER		"versionNumber"
+
 /* container for a single registry key */
 
 typedef struct {
diff -uNr samba-3.0alpha21.orig/source/include/ntdomain.h samba-3.0alpha21/source/include/ntdomain.h
--- samba-3.0alpha21.orig/source/include/ntdomain.h	2003-02-16 19:06:31.000000000 -0600
+++ samba-3.0alpha21/source/include/ntdomain.h	2003-02-16 19:05:45.000000000 -0600
@@ -331,7 +331,7 @@
 
 struct api_struct
 {  
-  char *name;
+  const char *name;
   uint8 opnum;
   BOOL (*fn) (pipes_struct *);
 };
@@ -339,7 +339,7 @@
 typedef struct
 {  
 	uint32 rid;
-	char *name;
+	const char *name;
 
 } rid_name;
 
diff -uNr samba-3.0alpha21.orig/source/include/ntlmssp.h samba-3.0alpha21/source/include/ntlmssp.h
--- samba-3.0alpha21.orig/source/include/ntlmssp.h	1969-12-31 18:00:00.000000000 -0600
+++ samba-3.0alpha21/source/include/ntlmssp.h	2003-02-16 19:05:45.000000000 -0600
@@ -0,0 +1,90 @@
+/* 
+   Unix SMB/CIFS implementation.
+   SMB parameters and setup
+   Copyright (C) Andrew Tridgell 1992-1997
+   Copyright (C) Luke Kenneth Casson Leighton 1996-1997
+   Copyright (C) Paul Ashton 1997
+   
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+   
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+   
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*/
+
+/* NTLMSSP mode */
+enum NTLMSSP_ROLE
+{
+	NTLMSSP_SERVER,
+	NTLMSSP_CLIENT
+};
+
+/* NTLMSSP message types */
+enum NTLM_MESSAGE_TYPE
+{
+	NTLMSSP_NEGOTIATE = 1,
+	NTLMSSP_CHALLENGE = 2,
+	NTLMSSP_AUTH      = 3,
+	NTLMSSP_UNKNOWN   = 4
+};
+
+/* NTLMSSP negotiation flags */
+#define NTLMSSP_NEGOTIATE_UNICODE          0x00000001
+#define NTLMSSP_NEGOTIATE_OEM              0x00000002
+#define NTLMSSP_REQUEST_TARGET             0x00000004
+#define NTLMSSP_NEGOTIATE_SIGN             0x00000010 /* Message integrity */
+#define NTLMSSP_NEGOTIATE_SEAL             0x00000020 /* Message confidentiality */
+#define NTLMSSP_NEGOTIATE_DATAGRAM_STYLE   0x00000040
+#define NTLMSSP_NEGOTIATE_LM_KEY           0x00000080
+#define NTLMSSP_NEGOTIATE_NETWARE          0x00000100
+#define NTLMSSP_NEGOTIATE_NTLM             0x00000200
+#define NTLMSSP_NEGOTIATE_DOMAIN_SUPPLIED  0x00001000
+#define NTLMSSP_NEGOTIATE_WORKSTATION_SUPPLIED 0x00002000
+#define NTLMSSP_NEGOTIATE_THIS_IS_LOCAL_CALL  0x00004000
+#define NTLMSSP_NEGOTIATE_ALWAYS_SIGN      0x00008000
+#define NTLMSSP_TARGET_TYPE_DOMAIN            0x10000
+#define NTLMSSP_TARGET_TYPE_SERVER            0x20000
+#define NTLMSSP_CHAL_INIT_RESPONSE         0x00010000
+
+#define NTLMSSP_CHAL_ACCEPT_RESPONSE       0x00020000
+#define NTLMSSP_CHAL_NON_NT_SESSION_KEY    0x00040000
+#define NTLMSSP_NEGOTIATE_NTLM2            0x00080000
+#define NTLMSSP_CHAL_TARGET_INFO           0x00800000
+#define NTLMSSP_NEGOTIATE_128              0x20000000 /* 128-bit encryption */
+#define NTLMSSP_NEGOTIATE_KEY_EXCH         0x40000000
+#define NTLMSSP_NEGOTIATE_080000000        0x80000000
+
+#define NTLMSSP_NAME_TYPE_DOMAIN      0x01
+#define NTLMSSP_NAME_TYPE_SERVER      0x02
+#define NTLMSSP_NAME_TYPE_DOMAIN_DNS  0x03
+#define NTLMSSP_NAME_TYPE_SERVER_DNS  0x04
+
+typedef struct ntlmssp_state 
+{
+	TALLOC_CTX *mem_ctx;
+	enum NTLMSSP_ROLE role;
+	BOOL unicode;
+	char *user;
+	char *domain;
+	char *workstation;
+ 	DATA_BLOB lm_resp;
+	DATA_BLOB nt_resp;
+	DATA_BLOB chal;
+	void *auth_context;
+	const uint8 *(*get_challenge)(struct ntlmssp_state *ntlmssp_state);
+	NTSTATUS (*check_password)(struct ntlmssp_state *ntlmssp_state);
+
+	const char *(*get_global_myname)(void);
+	const char *(*get_domain)(void);
+
+	int server_role;
+} NTLMSSP_STATE;
+
diff -uNr samba-3.0alpha21.orig/source/include/passdb.h samba-3.0alpha21/source/include/passdb.h
--- samba-3.0alpha21.orig/source/include/passdb.h	2003-02-16 19:06:31.000000000 -0600
+++ samba-3.0alpha21/source/include/passdb.h	2003-02-16 19:05:45.000000000 -0600
@@ -153,7 +153,7 @@
 			 const char *);
 
 struct pdb_init_function_entry {
-	char *name;
+	const char *name;
 	/* Function to create a member of the pdb_methods list */
 	pdb_init_function init;
 };
diff -uNr samba-3.0alpha21.orig/source/include/rpc_dce.h samba-3.0alpha21/source/include/rpc_dce.h
--- samba-3.0alpha21.orig/source/include/rpc_dce.h	2003-02-16 19:06:31.000000000 -0600
+++ samba-3.0alpha21/source/include/rpc_dce.h	2003-02-16 19:05:45.000000000 -0600
@@ -46,38 +46,6 @@
 #define RPC_FLG_LAST  0x02
 #define RPC_FLG_NOCALL 0x20
 
-/* NTLMSSP message types */
-enum NTLM_MESSAGE_TYPE
-{
-	NTLMSSP_NEGOTIATE = 1,
-	NTLMSSP_CHALLENGE = 2,
-	NTLMSSP_AUTH      = 3,
-	NTLMSSP_UNKNOWN   = 4
-};
-
-/* NTLMSSP negotiation flags */
-#define NTLMSSP_NEGOTIATE_UNICODE          0x00000001
-#define NTLMSSP_NEGOTIATE_OEM              0x00000002
-#define NTLMSSP_REQUEST_TARGET             0x00000004
-#define NTLMSSP_NEGOTIATE_SIGN             0x00000010 /* Message integrity */
-#define NTLMSSP_NEGOTIATE_SEAL             0x00000020 /* Message confidentiality */
-#define NTLMSSP_NEGOTIATE_DATAGRAM_STYLE   0x00000040
-#define NTLMSSP_NEGOTIATE_LM_KEY           0x00000080
-#define NTLMSSP_NEGOTIATE_NETWARE          0x00000100
-#define NTLMSSP_NEGOTIATE_NTLM             0x00000200
-#define NTLMSSP_NEGOTIATE_DOMAIN_SUPPLIED  0x00001000
-#define NTLMSSP_NEGOTIATE_WORKSTATION_SUPPLIED 0x00002000
-#define NTLMSSP_NEGOTIATE_THIS_IS_LOCAL_CALL  0x00004000
-#define NTLMSSP_NEGOTIATE_ALWAYS_SIGN      0x00008000
-#define NTLMSSP_CHAL_INIT_RESPONSE         0x00010000
-#define NTLMSSP_CHAL_ACCEPT_RESPONSE       0x00020000
-#define NTLMSSP_CHAL_NON_NT_SESSION_KEY    0x00040000
-#define NTLMSSP_NEGOTIATE_NTLM2            0x00080000
-#define NTLMSSP_CHAL_TARGET_INFO           0x00800000
-#define NTLMSSP_NEGOTIATE_128              0x20000000 /* 128-bit encryption */
-#define NTLMSSP_NEGOTIATE_KEY_EXCH         0x40000000
-#define NTLMSSP_NEGOTIATE_080000000        0x80000000
-
 #define SMBD_NTLMSSP_NEG_FLAGS 0x000082b1 /* ALWAYS_SIGN|NEG_NTLM|NEG_LM|NEG_SEAL|NEG_SIGN|NEG_UNICODE */
 
 /* NTLMSSP signature version */
@@ -119,10 +87,10 @@
 {
 	/* the names appear not to matter: the syntaxes _do_ matter */
 
-	char *client_pipe;
+	const char *client_pipe;
 	RPC_IFACE abstr_syntax; /* this one is the abstract syntax id */
 
-	char *server_pipe;  /* this one is the secondary syntax name */
+	const char *server_pipe;  /* this one is the secondary syntax name */
 	RPC_IFACE trans_syntax; /* this one is the primary syntax id */
 };
 
diff -uNr samba-3.0alpha21.orig/source/include/rpc_lsa.h samba-3.0alpha21/source/include/rpc_lsa.h
--- samba-3.0alpha21.orig/source/include/rpc_lsa.h	2003-02-16 19:06:31.000000000 -0600
+++ samba-3.0alpha21/source/include/rpc_lsa.h	2003-02-16 19:05:45.000000000 -0600
@@ -515,6 +515,55 @@
 	NTSTATUS status;
 } LSA_R_ENUM_PRIVS;
 
+/* LSA_Q_ENUM_ACCT_RIGHTS - LSA enum account rights */
+typedef struct
+{
+	POLICY_HND pol; /* policy handle */
+	DOM_SID2 sid;
+} LSA_Q_ENUM_ACCT_RIGHTS;
+
+/* LSA_R_ENUM_ACCT_RIGHTS - LSA enum account rights */
+typedef struct
+{
+	uint32 count;
+	UNISTR2_ARRAY rights;
+	NTSTATUS status;
+} LSA_R_ENUM_ACCT_RIGHTS;
+
+
+/* LSA_Q_ADD_ACCT_RIGHTS - LSA add account rights */
+typedef struct
+{
+	POLICY_HND pol; /* policy handle */
+	DOM_SID2 sid;
+	UNISTR2_ARRAY rights;
+	uint32 count;
+} LSA_Q_ADD_ACCT_RIGHTS;
+
+/* LSA_R_ADD_ACCT_RIGHTS - LSA add account rights */
+typedef struct
+{
+	NTSTATUS status;
+} LSA_R_ADD_ACCT_RIGHTS;
+
+
+/* LSA_Q_REMOVE_ACCT_RIGHTS - LSA remove account rights */
+typedef struct
+{
+	POLICY_HND pol; /* policy handle */
+	DOM_SID2 sid;
+	uint32 removeall;
+	UNISTR2_ARRAY rights;
+	uint32 count;
+} LSA_Q_REMOVE_ACCT_RIGHTS;
+
+/* LSA_R_REMOVE_ACCT_RIGHTS - LSA remove account rights */
+typedef struct
+{
+	NTSTATUS status;
+} LSA_R_REMOVE_ACCT_RIGHTS;
+
+
 /* LSA_Q_PRIV_GET_DISPNAME - LSA get privilege display name */
 typedef struct lsa_q_priv_get_dispname
 {
diff -uNr samba-3.0alpha21.orig/source/include/rpc_misc.h samba-3.0alpha21/source/include/rpc_misc.h
--- samba-3.0alpha21.orig/source/include/rpc_misc.h	2003-02-16 19:06:31.000000000 -0600
+++ samba-3.0alpha21/source/include/rpc_misc.h	2003-02-16 19:05:45.000000000 -0600
@@ -210,6 +210,22 @@
 
 } UNISTR3;
 
+/* an element in a unicode string array */
+typedef struct
+{
+	uint16 length;
+	uint16 size;
+	uint32 ref_id;
+	UNISTR2 string;
+} UNISTR2_ARRAY_EL;
+
+/* an array of unicode strings */
+typedef struct 
+{
+	uint32 ref_id;
+	uint32 count;
+	UNISTR2_ARRAY_EL *strings;
+} UNISTR2_ARRAY;
 
 /* DOM_RID2 - domain RID structure for ntlsa pipe */
 typedef struct domrid2_info
diff -uNr samba-3.0alpha21.orig/source/include/rpc_reg.h samba-3.0alpha21/source/include/rpc_reg.h
--- samba-3.0alpha21.orig/source/include/rpc_reg.h	2003-02-16 19:06:31.000000000 -0600
+++ samba-3.0alpha21/source/include/rpc_reg.h	2003-02-16 19:05:45.000000000 -0600
@@ -85,10 +85,6 @@
 #define REG_FULL_RESOURCE_DESCRIPTOR   9
 #define REG_RESOURCE_REQUIREMENTS_LIST 10
 
-/* Shutdown options */
-#define REG_FORCE_SHUTDOWN 0x001
-#define REG_REBOOT_ON_SHUTDOWN 0x100
-
 /* structure to contain registry values */
 
 typedef struct {
@@ -129,7 +125,7 @@
 } REGISTRY_OPS;
 
 typedef struct {
-	char		*keyname;	/* full path to name of key */
+	const char	*keyname;	/* full path to name of key */
 	REGISTRY_OPS	*ops;		/* registry function hooks */
 } REGISTRY_HOOK;
 
@@ -616,7 +612,8 @@
 	UNIHDR hdr_msg;		/* shutdown message */
 	UNISTR2 uni_msg;	/* seconds */
 	uint32 timeout;		/* seconds */
-	uint16 flags;
+	uint8 force;		/* boolean: force shutdown */
+	uint8 reboot;		/* boolean: reboot on shutdown */
 		
 } REG_Q_SHUTDOWN;
 
diff -uNr samba-3.0alpha21.orig/source/include/rpc_spoolss.h samba-3.0alpha21/source/include/rpc_spoolss.h
--- samba-3.0alpha21.orig/source/include/rpc_spoolss.h	2003-02-16 19:06:31.000000000 -0600
+++ samba-3.0alpha21/source/include/rpc_spoolss.h	2003-02-16 19:05:45.000000000 -0600
@@ -371,6 +371,11 @@
 #define PRINTER_ATTRIBUTE_ENABLE_BIDI		0x00000800
 
 #define PRINTER_ATTRIBUTE_RAW_ONLY		0x00001000
+#define PRINTER_ATTRIBUTE_PUBLISHED		0x00002000
+
+#define PRINTER_ATTRIBUTE_SAMBA			(PRINTER_ATTRIBUTE_RAW_ONLY|\
+						 PRINTER_ATTRIBUTE_SHARED|\
+						 PRINTER_ATTRIBUTE_NETWORK)
 
 #define NO_PRIORITY	 0
 #define MAX_PRIORITY	99
@@ -989,6 +994,18 @@
 }
 PRINTER_INFO_5;
 
+#define SPOOL_DS_PUBLISH	1
+#define SPOOL_DS_UPDATE		2
+#define SPOOL_DS_UNPUBLISH	4
+#define SPOOL_DS_PENDING        0x80000000
+
+typedef struct printer_info_7
+{
+	UNISTR guid; /* text form of printer guid */
+	uint32 action;
+}
+PRINTER_INFO_7;
+
 typedef struct spool_q_enumprinters
 {
 	uint32 flags;
@@ -1480,6 +1497,14 @@
 }
 SPOOL_PRINTER_INFO_LEVEL_3;
 
+typedef struct spool_printer_info_level_7
+{
+	uint32 guid_ptr;
+	uint32 action;
+	UNISTR2 guid;
+}
+SPOOL_PRINTER_INFO_LEVEL_7;
+
 typedef struct spool_printer_info_level
 {
 	uint32 level;
@@ -1487,6 +1512,7 @@
 	SPOOL_PRINTER_INFO_LEVEL_1 *info_1;
 	SPOOL_PRINTER_INFO_LEVEL_2 *info_2;
 	SPOOL_PRINTER_INFO_LEVEL_3 *info_3;
+	SPOOL_PRINTER_INFO_LEVEL_7 *info_7;
 }
 SPOOL_PRINTER_INFO_LEVEL;
 
diff -uNr samba-3.0alpha21.orig/source/include/safe_string.h samba-3.0alpha21/source/include/safe_string.h
--- samba-3.0alpha21.orig/source/include/safe_string.h	2003-02-16 19:06:31.000000000 -0600
+++ samba-3.0alpha21/source/include/safe_string.h	2003-02-16 19:05:45.000000000 -0600
@@ -48,6 +48,25 @@
 
 #endif /* !_SPLINT_ */
 
+char * __unsafe_string_function_usage_here__(void);
+
+#if 0 && defined __GNUC__ && __GNUC__ >= 2 && defined __OPTIMIZE__
+
+#define pstrcpy(d,s) ((sizeof(d) != sizeof(pstring) && sizeof(d) != sizeof(char *)) ? __unsafe_string_function_usage_here__() : safe_strcpy((d), (s),sizeof(pstring)-1))
+#define pstrcat(d,s) ((sizeof(d) != sizeof(pstring) && sizeof(d) != sizeof(char *)) ? __unsafe_string_function_usage_here__() : safe_strcat((d), (s),sizeof(pstring)-1))
+#define fstrcpy(d,s) ((sizeof(d) != sizeof(fstring) && sizeof(d) != sizeof(char *)) ? __unsafe_string_function_usage_here__() : safe_strcpy((d),(s),sizeof(fstring)-1))
+#define fstrcat(d,s) ((sizeof(d) != sizeof(fstring) && sizeof(d) != sizeof(char *)) ? __unsafe_string_function_usage_here__() : safe_strcat((d),(s),sizeof(fstring)-1))
+
+#define fstrterminate(d) ((sizeof(d) != sizeof(fstring) && sizeof(d) != sizeof(char *)) ? __unsafe_string_function_usage_here__() : (((d)[sizeof(fstring)-1]) = '\0'))
+#define pstrterminate(d) ((sizeof(d) != sizeof(pstring) && sizeof(d) != sizeof(char *)) ? __unsafe_string_function_usage_here__() : (((d)[sizeof(pstring)-1]) = '\0'))
+
+#define wpstrcpy(d,s) ((sizeof(d) != sizeof(wpstring) && sizeof(d) != sizeof(smb_ucs2_t *)) ? __unsafe_string_function_usage_here__() : safe_strcpy_w((d),(s),sizeof(wpstring)))
+#define wpstrcat(d,s) ((sizeof(d) != sizeof(wpstring) && sizeof(d) != sizeof(smb_ucs2_t *)) ? __unsafe_string_function_usage_here__() : safe_strcat_w((d),(s),sizeof(wpstring)))
+#define wfstrcpy(d,s) ((sizeof(d) != sizeof(wfstring) && sizeof(d) != sizeof(smb_ucs2_t *)) ? __unsafe_string_function_usage_here__() : safe_strcpy_w((d),(s),sizeof(wfstring)))
+#define wfstrcat(d,s) ((sizeof(d) != sizeof(wfstring) && sizeof(d) != sizeof(smb_ucs2_t *)) ? __unsafe_string_function_usage_here__() : safe_strcat_w((d),(s),sizeof(wfstring)))
+
+#else
+
 #define pstrcpy(d,s) safe_strcpy((d), (s),sizeof(pstring)-1)
 #define pstrcat(d,s) safe_strcat((d), (s),sizeof(pstring)-1)
 #define fstrcpy(d,s) safe_strcpy((d),(s),sizeof(fstring)-1)
@@ -61,6 +80,8 @@
 #define wfstrcpy(d,s) safe_strcpy_w((d),(s),sizeof(wfstring))
 #define wfstrcat(d,s) safe_strcat_w((d),(s),sizeof(wfstring))
 
+#endif
+
 /* replace some string functions with multi-byte
    versions */
 #define strlower(s) strlower_m(s)
diff -uNr samba-3.0alpha21.orig/source/include/smb.h samba-3.0alpha21/source/include/smb.h
--- samba-3.0alpha21.orig/source/include/smb.h	2003-02-16 19:06:31.000000000 -0600
+++ samba-3.0alpha21/source/include/smb.h	2003-02-16 19:05:45.000000000 -0600
@@ -221,6 +221,14 @@
  
 #define MAX_HOURS_LEN 32
 
+/* 
+ * window during which we must talk to the PDC to avoid
+ * sam sync delays; expressed in seconds (15 minutes is the 
+ * default period for SAM replication under Windows NT 4.0
+ */
+#define SAM_SYNC_WINDOW		900
+
+
 #ifndef MAXSUBAUTHS
 #define MAXSUBAUTHS 15 /* max sub authorities in a SID */
 #endif
@@ -360,13 +368,13 @@
 	int fnum;
 	struct connection_struct *conn;
 	int fd;
-	uint32 print_jobid;
+	uint16 rap_print_jobid;
 	SMB_DEV_T dev;
 	SMB_INO_T inode;
 	BOOL delete_on_close;
 	SMB_OFF_T pos;
-	SMB_OFF_T size;
-	SMB_OFF_T initial_allocation_size; /* Faked up initial allocation on disk. */
+	SMB_BIG_UINT size;
+	SMB_BIG_UINT initial_allocation_size; /* Faked up initial allocation on disk. */
 	mode_t mode;
 	uint16 vuid;
 	write_bmpx_struct *wbmpx_ptr;
@@ -384,6 +392,7 @@
 	BOOL print_file;
 	BOOL modified;
 	BOOL is_directory;
+	BOOL is_stat;
 	BOOL directory_delete_on_close;
 	char *fsp_name;
 } files_struct;
@@ -643,19 +652,19 @@
 		time_t pass_can_change_time;  /* password can change time */
 		time_t pass_must_change_time; /* password must change time */
 		
-		char * username;     /* UNIX username string */
-		char * domain;       /* Windows Domain name */
-		char * nt_username;  /* Windows username string */
-		char * full_name;    /* user's full name string */
-		char * unix_home_dir;     /* UNIX home directory string */
-		char * home_dir;     /* home directory string */
-		char * dir_drive;    /* home directory drive string */
-		char * logon_script; /* logon script string */
-		char * profile_path; /* profile path string */
-		char * acct_desc  ;  /* user description string */
-		char * workstations; /* login from workstations string */
-		char * unknown_str ; /* don't know what this is, yet. */
-		char * munged_dial ; /* munged path name and dial-back tel number */
+		const char * username;     /* UNIX username string */
+		const char * domain;       /* Windows Domain name */
+		const char * nt_username;  /* Windows username string */
+		const char * full_name;    /* user's full name string */
+		const char * unix_home_dir;     /* UNIX home directory string */
+		const char * home_dir;     /* home directory string */
+		const char * dir_drive;    /* home directory drive string */
+		const char * logon_script; /* logon script string */
+		const char * profile_path; /* profile path string */
+		const char * acct_desc  ;  /* user description string */
+		const char * workstations; /* login from workstations string */
+		const char * unknown_str ; /* don't know what this is, yet. */
+		const char * munged_dial ; /* munged path name and dial-back tel number */
 		
 		uid_t uid;          /* this is a unix uid_t */
 		gid_t gid;          /* this is a unix gid_t */
@@ -767,7 +776,7 @@
 
 struct enum_list {
 	int value;
-	char *name;
+	const char *name;
 };
 
 #define BRLOCK_FN_CAST() \
@@ -780,12 +789,12 @@
 				 br_off start, br_off size)
 struct parm_struct
 {
-	char *label;
+	const char *label;
 	parm_type type;
 	parm_class class;
 	void *ptr;
-	BOOL (*special)(char *, char **);
-	struct enum_list *enum_list;
+	BOOL (*special)(const char *, char **);
+	const struct enum_list *enum_list;
 	unsigned flags;
 	union {
 		BOOL bvalue;
@@ -798,7 +807,7 @@
 
 struct bitmap {
 	uint32 *b;
-	int n;
+	unsigned int n;
 };
 
 #define FLAG_BASIC 	0x0001 /* fundamental options */
@@ -953,7 +962,7 @@
 #define SMBntcancel      0xA4   /* NT cancel */
 
 /* These are the trans subcommands */
-#define TRANSACT_SETNAMEDPIPEHANDLESTATE  0x01
+#define TRANSACT_SETNAMEDPIPEHANDLESTATE  0x01 
 #define TRANSACT_DCERPCCMD                0x26
 #define TRANSACT_WAITNAMEDPIPEHANDLESTATE 0x53
 
@@ -1503,15 +1512,17 @@
  *  +----+--------+-------+--------+---------+
  */
 
-#define OPLOCK_BREAK_CMD 0x1
 #define OPLOCK_BREAK_PID_OFFSET 2
 #define OPLOCK_BREAK_DEV_OFFSET (OPLOCK_BREAK_PID_OFFSET + sizeof(pid_t))
 #define OPLOCK_BREAK_INODE_OFFSET (OPLOCK_BREAK_DEV_OFFSET + sizeof(SMB_DEV_T))
 #define OPLOCK_BREAK_FILEID_OFFSET (OPLOCK_BREAK_INODE_OFFSET + sizeof(SMB_INO_T))
 #define OPLOCK_BREAK_MSG_LEN (OPLOCK_BREAK_FILEID_OFFSET + sizeof(unsigned long))
 
+/* Message types */
+#define OPLOCK_BREAK_CMD 0x1
 #define KERNEL_OPLOCK_BREAK_CMD 0x2
 #define LEVEL_II_OPLOCK_BREAK_CMD 0x3
+#define ASYNC_LEVEL_II_OPLOCK_BREAK_CMD 0x4
 
 /*
  * Capabilities abstracted for different systems.
diff -uNr samba-3.0alpha21.orig/source/include/smb_macros.h samba-3.0alpha21/source/include/smb_macros.h
--- samba-3.0alpha21.orig/source/include/smb_macros.h	2003-02-16 19:06:31.000000000 -0600
+++ samba-3.0alpha21/source/include/smb_macros.h	2003-02-16 19:05:45.000000000 -0600
@@ -100,8 +100,6 @@
 
 /* access various service details */
 #define SERVICE(snum)      (lp_servicename(snum))
-#define PRINTCAP           (lp_printcapname())
-#define PRINTCOMMAND(snum) (lp_printcommand(snum))
 #define PRINTERNAME(snum)  (lp_printername(snum))
 #define CAN_WRITE(conn)    (!conn->read_only)
 #define VALID_SNUM(snum)   (lp_snum_ok(snum))
diff -uNr samba-3.0alpha21.orig/source/include/talloc.h samba-3.0alpha21/source/include/talloc.h
--- samba-3.0alpha21.orig/source/include/talloc.h	2003-02-16 19:06:31.000000000 -0600
+++ samba-3.0alpha21/source/include/talloc.h	2003-02-16 19:05:45.000000000 -0600
@@ -32,7 +32,7 @@
  **/
 typedef struct talloc_ctx TALLOC_CTX;
 
-TALLOC_CTX *talloc_init_named(char const *fmt, ...) PRINTF_ATTRIBUTE(1, 2);
+TALLOC_CTX *talloc_init(char const *fmt, ...) PRINTF_ATTRIBUTE(1, 2);
 
 char *talloc_vasprintf(TALLOC_CTX *t, const char *fmt, va_list ap)
 	PRINTF_ATTRIBUTE(2, 0);
diff -uNr samba-3.0alpha21.orig/source/include/xfile.h samba-3.0alpha21/source/include/xfile.h
--- samba-3.0alpha21.orig/source/include/xfile.h	2003-02-16 19:06:31.000000000 -0600
+++ samba-3.0alpha21/source/include/xfile.h	2003-02-16 19:05:45.000000000 -0600
@@ -44,4 +44,6 @@
 
 #define x_getc(f) x_fgetc(f)
 
+int x_vfprintf(XFILE *f, const char *format, va_list ap) PRINTF_ATTRIBUTE(2, 0);
+int x_fprintf(XFILE *f, const char *format, ...) PRINTF_ATTRIBUTE(2, 3);
 #endif /* _XFILE_H_ */
diff -uNr samba-3.0alpha21.orig/source/intl/lang_tdb.c samba-3.0alpha21/source/intl/lang_tdb.c
--- samba-3.0alpha21.orig/source/intl/lang_tdb.c	2003-02-16 19:06:31.000000000 -0600
+++ samba-3.0alpha21/source/intl/lang_tdb.c	2003-02-16 19:05:45.000000000 -0600
@@ -75,9 +75,9 @@
 
 
 /* work out what language to use from locale variables */
-static char *get_lang(void)
+static const char *get_lang(void)
 {
-	char *vars[] = {"LANGUAGE", "LC_ALL", "LC_LANG", "LANG", NULL};
+	const char *vars[] = {"LANGUAGE", "LC_ALL", "LC_LANG", "LANG", NULL};
 	int i;
 	char *p;
 
@@ -123,7 +123,7 @@
 	/* if no lang then we don't translate */
 	if (!lang) return True;
 
-	asprintf(&msg_path, "%s.msg", lib_path((char *)lang));
+	asprintf(&msg_path, "%s.msg", lib_path((const char *)lang));
 	if (stat(msg_path, &st) != 0) {
 		/* the msg file isn't available */
 		free(msg_path);
diff -uNr samba-3.0alpha21.orig/source/lib/account_pol.c samba-3.0alpha21/source/lib/account_pol.c
--- samba-3.0alpha21.orig/source/lib/account_pol.c	2003-02-16 19:06:31.000000000 -0600
+++ samba-3.0alpha21/source/lib/account_pol.c	2003-02-16 19:05:45.000000000 -0600
@@ -31,7 +31,7 @@
 BOOL init_account_policy(void)
 {
 	static pid_t local_pid;
-	char *vstring = "INFO/version";
+	const char *vstring = "INFO/version";
 	uint32 version;
 
 	if (tdb && local_pid == sys_getpid())
@@ -67,7 +67,7 @@
 
 static const struct {
 	int field;
-	char *string;
+	const char *string;
 } account_policy_names[] = {
 	{AP_MIN_PASSWORD_LEN, "min password length"},
 	{AP_PASSWORD_HISTORY, "password history"},
diff -uNr samba-3.0alpha21.orig/source/lib/adt_tree.c samba-3.0alpha21/source/lib/adt_tree.c
--- samba-3.0alpha21.orig/source/lib/adt_tree.c	2003-02-16 19:06:31.000000000 -0600
+++ samba-3.0alpha21/source/lib/adt_tree.c	2003-02-16 19:05:45.000000000 -0600
@@ -325,7 +325,7 @@
  Recursive routine to print out all children of a TREE_NODE
  *************************************************************************/
 
-static void sorted_tree_print_children( TREE_NODE *node, int debug, char *path )
+static void sorted_tree_print_children( TREE_NODE *node, int debug, const char *path )
 {
 	int i;
 	int num_children;
diff -uNr samba-3.0alpha21.orig/source/lib/bitmap.c samba-3.0alpha21/source/lib/bitmap.c
--- samba-3.0alpha21.orig/source/lib/bitmap.c	2003-02-16 19:06:31.000000000 -0600
+++ samba-3.0alpha21/source/lib/bitmap.c	2003-02-16 19:05:45.000000000 -0600
@@ -129,7 +129,7 @@
 ****************************************************************************/
 int bitmap_find(struct bitmap *bm, unsigned ofs)
 {
-	int i, j;
+	unsigned int i, j;
 
 	if (ofs > bm->n) ofs = 0;
 
diff -uNr samba-3.0alpha21.orig/source/lib/charcnv.c samba-3.0alpha21/source/lib/charcnv.c
--- samba-3.0alpha21.orig/source/lib/charcnv.c	2003-02-16 19:06:31.000000000 -0600
+++ samba-3.0alpha21/source/lib/charcnv.c	2003-02-16 19:05:45.000000000 -0600
@@ -30,9 +30,9 @@
  Return the name of a charset to give to iconv().
 ****************************************************************************/
 
-static char *charset_name(charset_t ch)
+static const char *charset_name(charset_t ch)
 {
-	char *ret = NULL;
+	const char *ret = NULL;
 
 	if (ch == CH_UCS2) ret = "UCS-2LE";
 	else if (ch == CH_UNIX) ret = lp_unix_charset();
@@ -75,8 +75,8 @@
 
 	for (c1=0;c1<NUM_CHARSETS;c1++) {
 		for (c2=0;c2<NUM_CHARSETS;c2++) {
-			char *n1 = charset_name((charset_t)c1);
-			char *n2 = charset_name((charset_t)c2);
+			const char *n1 = charset_name((charset_t)c1);
+			const char *n2 = charset_name((charset_t)c2);
 			if (conv_handles[c1][c2] &&
 			    strcmp(n1, conv_handles[c1][c2]->from_name) == 0 &&
 			    strcmp(n2, conv_handles[c1][c2]->to_name) == 0)
@@ -139,8 +139,8 @@
 	i_len=srclen;
 	o_len=destlen;
 	retval = smb_iconv(descriptor,  &inbuf, &i_len, &outbuf, &o_len);
-	if(retval==-1) {
-	    	char *reason="unknown error";
+	if(retval==(size_t)-1) {
+	    	const char *reason="unknown error";
 		switch(errno) {
 			case EINVAL:
 				reason="Incomplete multibyte sequence";
@@ -214,8 +214,8 @@
 	retval = smb_iconv(descriptor,
 			   &inbuf, &i_len,
 			   &outbuf, &o_len);
-	if(retval == -1) 		{
-	    	char *reason="unknown error";
+	if(retval == (size_t)-1) 		{
+	    	const char *reason="unknown error";
 		switch(errno) {
 			case EINVAL:
 				reason="Incomplete multibyte sequence";
@@ -605,11 +605,11 @@
  * @retval The number of bytes occupied by the string in the destination
  **/
 
-size_t pull_ucs2_talloc(TALLOC_CTX *ctx, void **dest, const smb_ucs2_t *src)
+size_t pull_ucs2_talloc(TALLOC_CTX *ctx, char **dest, const smb_ucs2_t *src)
 {
 	size_t src_len = (strlen_w(src)+1) * sizeof(smb_ucs2_t);
 	*dest = NULL;
-	return convert_string_talloc(ctx, CH_UCS2, CH_UNIX, src, src_len, dest);	
+	return convert_string_talloc(ctx, CH_UCS2, CH_UNIX, src, src_len, (void **)dest);
 }
 
 /**
diff -uNr samba-3.0alpha21.orig/source/lib/data_blob.c samba-3.0alpha21/source/lib/data_blob.c
--- samba-3.0alpha21.orig/source/lib/data_blob.c	2003-02-16 19:06:31.000000000 -0600
+++ samba-3.0alpha21/source/lib/data_blob.c	2003-02-16 19:05:45.000000000 -0600
@@ -84,7 +84,6 @@
 		if (d->free) {
 			(d->free)(d);
 		}
-		ZERO_STRUCTP(d);
 	}
 }
 
diff -uNr samba-3.0alpha21.orig/source/lib/debug.c samba-3.0alpha21/source/lib/debug.c
--- samba-3.0alpha21.orig/source/lib/debug.c	2003-02-16 19:06:31.000000000 -0600
+++ samba-3.0alpha21/source/lib/debug.c	2003-02-16 19:05:45.000000000 -0600
@@ -467,23 +467,18 @@
 			 False);
 }
 
-
 /****************************************************************************
  Return current debug level.
 ****************************************************************************/
 
 static void debuglevel_message(int msg_type, pid_t src, void *buf, size_t len)
 {
-	char *debug_level_classes;
+	char *message = debug_list_class_names_and_levels();
+
 	DEBUG(1,("INFO: Received REQ_DEBUGLEVEL message from PID %u\n",(unsigned int)src));
+	message_send_pid(src, MSG_DEBUGLEVEL, message, strlen(message) + 1, True);
 
-	if ((debug_level_classes = debug_list_class_names_and_levels())) {
-	/*{ debug_level_classes = "test:1000";*/
-		message_send_pid(src, MSG_DEBUGLEVEL, debug_level_classes, strlen(debug_level_classes) + 1, True);
-		SAFE_FREE(debug_level_classes);
-	} else {
-		DEBUG(0, ("debuglevel_message: error retrieving class levels!\n"));
-	}
+	SAFE_FREE(message);
 }
 
 /****************************************************************************
@@ -525,6 +520,7 @@
 	if (interactive) {
 		stdout_logging = True;
 		dbf = x_stdout;
+		x_setbuf( x_stdout, NULL );
 	}
 #ifdef WITH_SYSLOG
 	else {
@@ -555,6 +551,7 @@
 	pstring fname;
 	mode_t oldumask;
 	XFILE *new_dbf = NULL;
+	XFILE *old_dbf = NULL;
 	BOOL ret = True;
 
 	if (stdout_logging)
@@ -584,9 +581,10 @@
 		ret = False;
 	} else {
 		x_setbuf(new_dbf, NULL);
-		if (dbf)
-			(void) x_fclose(dbf);
+		old_dbf = dbf;
 		dbf = new_dbf;
+		if (old_dbf)
+			(void) x_fclose(old_dbf);
 	}
 
 	/* Fix from klausr@ITAP.Physik.Uni-Stuttgart.De
@@ -622,7 +620,7 @@
 {
 	int maxlog;
 
-	if( debug_count++ < 100 )
+	if( debug_count < 100 )
 		return( False );
 
 	maxlog = lp_max_log_size() * 1024;
@@ -707,6 +705,8 @@
   va_list ap;  
   int old_errno = errno;
 
+  debug_count++;
+
   if( stdout_logging )
     {
     va_start( ap, format_str );
diff -uNr samba-3.0alpha21.orig/source/lib/dprintf.c samba-3.0alpha21/source/lib/dprintf.c
--- samba-3.0alpha21.orig/source/lib/dprintf.c	2003-02-16 19:06:31.000000000 -0600
+++ samba-3.0alpha21/source/lib/dprintf.c	2003-02-16 19:05:45.000000000 -0600
@@ -31,7 +31,7 @@
 
 #include "includes.h"
 
-int d_vfprintf(FILE *f, const char *format, va_list ap)
+ int d_vfprintf(FILE *f, const char *format, va_list ap)
 {
 	char *p, *p2;
 	int ret, maxlen, clen;
diff -uNr samba-3.0alpha21.orig/source/lib/gencache.c samba-3.0alpha21/source/lib/gencache.c
--- samba-3.0alpha21.orig/source/lib/gencache.c	2003-02-16 19:06:31.000000000 -0600
+++ samba-3.0alpha21/source/lib/gencache.c	2003-02-16 19:05:45.000000000 -0600
@@ -67,7 +67,7 @@
 
 	SAFE_FREE(cache_fname);
 	if (!cache) {
-		DEBUG(0, ("Attempt to open the cache file has failed.\n"));
+		DEBUG(5, ("Attempt to open gencache.tdb has failed.\n"));
 		return False;
 	}
 	return True;
@@ -91,8 +91,8 @@
 
 
 /**
- * Add one entry to the cache file.
- * (it part of tridge's proposed API)
+ * Set an entry in the cache file. If there's no such
+ * one, then add it.
  *
  * @param key string that represents a key of this entry
  * @param value text representation value being cached
@@ -102,7 +102,7 @@
  *         false on the attempt's failure
  **/
  
-BOOL gencache_add(const char *keystr, const char *value, time_t timeout)
+BOOL gencache_set(const char *keystr, const char *value, time_t timeout)
 {
 	int ret;
 	TDB_DATA keybuf, databuf;
@@ -122,7 +122,7 @@
 	           = %s (%d seconds %s)\n", keybuf.dptr, value, ctime(&timeout),
 	           (int)(timeout - time(NULL)), timeout > time(NULL) ? "ahead" : "in the past"));
 		
-	ret = tdb_store(cache, keybuf, databuf, TDB_INSERT);
+	ret = tdb_store(cache, keybuf, databuf, 0);
 	SAFE_FREE(valstr);
 	SAFE_FREE(keybuf.dptr);
 	SAFE_FREE(databuf.dptr);
@@ -133,7 +133,6 @@
 
 /**
  * Set existing entry to the cache file.
- * (it part of tridge's proposed API)
  *
  * @param key string that represents a key of this entry
  * @param value text representation value being cached
@@ -143,7 +142,7 @@
  *         false on the attempt's failure
  **/
 
-BOOL gencache_set(const char *keystr, const char *valstr, time_t timeout)
+BOOL gencache_set_only(const char *keystr, const char *valstr, time_t timeout)
 {
 	int ret = -1;
 	TDB_DATA keybuf, databuf;
@@ -189,7 +188,6 @@
 
 /**
  * Delete one entry from the cache file.
- * (it part of tridge's proposed API)
  *
  * @param key string that represents a key of this entry
  *
@@ -219,11 +217,10 @@
 
 /**
  * Get existing entry from the cache file.
- * (it part of tridge's proposed API)
  *
  * @param key string that represents a key of this entry
  * @param value buffer that is allocated and filled with the entry value
- *        buffer's disposing is done outside
+ *        buffer's disposing must be done outside
  * @param timeout pointer to a time_t that is filled with entry's
  *        timeout
  *
@@ -236,7 +233,7 @@
 	TDB_DATA keybuf, databuf;
 
 	/* fail completely if get null pointers passed */
-	SMB_ASSERT(keystr && valstr && timeout);
+	SMB_ASSERT(keystr);
 
 	if (!gencache_init())
 		return False;
@@ -247,21 +244,42 @@
 	
 	if (databuf.dptr && databuf.dsize > TIMEOUT_LEN) {
 		char* entry_buf = strndup(databuf.dptr, databuf.dsize);
-		*valstr = (char*)malloc(sizeof(char) * (databuf.dsize - TIMEOUT_LEN));
+		char *v;
+		time_t t;
+
+		v = (char*)malloc(sizeof(char) * 
+				  (databuf.dsize - TIMEOUT_LEN));
 				
 		SAFE_FREE(databuf.dptr);
-		sscanf(entry_buf, CACHE_DATA_FMT, (int*)timeout, *valstr);
+		sscanf(entry_buf, CACHE_DATA_FMT, (int*)&t, v);
 		SAFE_FREE(entry_buf);
 
-		DEBUG(10, ("Returning %s cache entry: key = %s, value = %s, timeout = %s\n",
-		           *timeout > time(NULL) ? "valid" : "expired", keystr, *valstr,
-		           ctime(timeout)));
-		return *timeout > time(NULL);
+		DEBUG(10, ("Returning %s cache entry: key = %s, value = %s, "
+			   "timeout = %s\n", t > time(NULL) ? "valid" :
+			   "expired", keystr, v, ctime(&t)));
+
+		if (valstr)
+			*valstr = v;
+		else
+			SAFE_FREE(v);
+
+		if (timeout)
+			*timeout = t;
+
+		return t > time(NULL);
+
 	} else {
 		SAFE_FREE(databuf.dptr);
-		*valstr = NULL;
-		timeout = NULL;
-		DEBUG(10, ("Cache entry with key = %s couldn't be found\n", keystr));
+
+		if (valstr)
+			*valstr = NULL;
+
+		if (timeout)
+			timeout = NULL;
+
+		DEBUG(10, ("Cache entry with key = %s couldn't be found\n", 
+			   keystr));
+
 		return False;
 	}
 }
@@ -272,12 +290,14 @@
  *
  * @param fn pointer to the function that will be supplied with each single
  *        matching cache entry (key, value and timeout) as an arguments
+ * @param data void pointer to an arbitrary data that is passed directly to the fn
+ *        function on each call
  * @param keystr_pattern pattern the existing entries' keys are matched to
  *
  **/
 
-void gencache_iterate(void (*fn)(const char* key, const char *value, time_t timeout),
-                      const char* keystr_pattern)
+void gencache_iterate(void (*fn)(const char* key, const char *value, time_t timeout, void* dptr),
+                      void* data, const char* keystr_pattern)
 {
 	TDB_LIST_NODE *node, *first_node;
 	TDB_DATA databuf;
@@ -289,7 +309,7 @@
 
 	if (!gencache_init()) return;
 
-	DEBUG(5, ("Searching cache keys with pattern %s", keystr_pattern));
+	DEBUG(5, ("Searching cache keys with pattern %s\n", keystr_pattern));
 	node = tdb_search_keys(cache, keystr_pattern);
 	first_node = node;
 	
@@ -314,7 +334,7 @@
 		
 		DEBUG(10, ("Calling function with arguments (key = %s, value = %s, timeout = %s)\n",
 		           keystr, valstr, ctime(&timeout)));
-		fn(keystr, valstr, timeout);
+		fn(keystr, valstr, timeout, data);
 		
 		SAFE_FREE(valstr);
 		SAFE_FREE(entry);
diff -uNr samba-3.0alpha21.orig/source/lib/genrand.c samba-3.0alpha21/source/lib/genrand.c
--- samba-3.0alpha21.orig/source/lib/genrand.c	2003-02-16 19:06:31.000000000 -0600
+++ samba-3.0alpha21/source/lib/genrand.c	2003-02-16 19:05:45.000000000 -0600
@@ -101,7 +101,7 @@
  Note that the hash is not initialised.
 *****************************************************************/
 
-static void do_filehash(char *fname, unsigned char *the_hash)
+static void do_filehash(const char *fname, unsigned char *the_hash)
 {
 	unsigned char buf[1011]; /* deliberate weird size */
 	unsigned char tmp_md4[16];
diff -uNr samba-3.0alpha21.orig/source/lib/ldap_escape.c samba-3.0alpha21/source/lib/ldap_escape.c
--- samba-3.0alpha21.orig/source/lib/ldap_escape.c	1969-12-31 18:00:00.000000000 -0600
+++ samba-3.0alpha21/source/lib/ldap_escape.c	2003-02-16 19:05:45.000000000 -0600
@@ -0,0 +1,90 @@
+/* 
+   Unix SMB/CIFS implementation.
+   ldap filter argument escaping
+
+   Copyright (C) 1998, 1999, 2000 Luke Howard <lukeh@padl.com>,
+   Copyright (C) 2003 Andrew Bartlett <abartlet@samba.org>
+
+  
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+   
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+   
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*/
+
+#include "includes.h"
+
+/**
+ * Escape a parameter to an LDAP filter string, so they cannot contain
+ * embeded ( ) * or \ chars which may cause it not to parse correctly. 
+ *
+ * @param s The input string
+ *
+ * @return A string allocated with malloc(), containing the escaped string, 
+ * and to be free()ed by the caller.
+ **/
+
+char *escape_ldap_string_alloc(const char *s)
+{
+	size_t len = strlen(s)+1;
+	char *output = malloc(len);
+	char *output_tmp;
+	const char *sub;
+	int i = 0;
+	char *p = output;
+	
+	while (*s)
+	{
+		switch (*s)
+		{
+		case '*':
+			sub = "\\2a";
+			break;
+		case '(':
+			sub = "\\28";
+			break;
+		case ')':
+			sub = "\\29";
+			break;
+		case '\\':
+			sub = "\\5c";
+			break;
+		default:
+			sub = NULL;
+			break;
+		}
+		
+		if (sub) {
+			len = len + 3;
+			output_tmp = realloc(output, len);
+			if (!output_tmp) { 
+				SAFE_FREE(output);
+				return NULL;
+			}
+			output = output_tmp;
+			
+			p = &output[i];
+			strncpy (p, sub, 3);
+			p += 3;
+			i += 3;
+
+		} else {
+			*p = *s;
+			p++;
+			i++;
+		}
+		s++;
+	}
+	
+	*p = '\0';
+	return output;
+}
diff -uNr samba-3.0alpha21.orig/source/lib/messages.c samba-3.0alpha21/source/lib/messages.c
--- samba-3.0alpha21.orig/source/lib/messages.c	2003-02-16 19:06:31.000000000 -0600
+++ samba-3.0alpha21/source/lib/messages.c	2003-02-16 19:05:45.000000000 -0600
@@ -3,6 +3,7 @@
    Samba internal messaging functions
    Copyright (C) Andrew Tridgell 2000
    Copyright (C) 2001 by Martin Pool
+   Copyright (C) 2002 by Jeremy Allison
    
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -35,6 +36,9 @@
    use that to reply by message_send_pid().  See ping_message() for a
    simple example.
 
+   *NOTE*: Dispatch functions must be able to cope with incoming
+   messages on an *odd* byte boundary.
+
    This system doesn't have any inherent size limitations but is not
    very efficient for large messages or when messages are sent in very
    quick succession.
@@ -81,7 +85,7 @@
 
 static void ping_message(int msg_type, pid_t src, void *buf, size_t len)
 {
-	char *msg = buf ? buf : "none";
+	const char *msg = buf ? buf : "none";
 	DEBUG(1,("INFO: Received PING message from PID %u [%s]\n",(unsigned int)src, msg));
 	message_send_pid(src, MSG_PONG, buf, len, True);
 }
@@ -133,9 +137,13 @@
 
 static BOOL message_notify(pid_t pid)
 {
-	/* Doing kill with a non-positive pid causes messages to be
-	 * sent to places we don't want. */
+	/*
+	 * Doing kill with a non-positive pid causes messages to be
+	 * sent to places we don't want.
+	 */
+
 	SMB_ASSERT(pid > 0);
+
 	if (kill(pid, SIGUSR1) == -1) {
 		if (errno == ESRCH) {
 			DEBUG(2,("pid %d doesn't exist - deleting messages record\n", (int)pid));
@@ -152,13 +160,22 @@
  Send a message to a particular pid.
 ****************************************************************************/
 
-BOOL message_send_pid(pid_t pid, int msg_type, const void *buf, size_t len,
-		      BOOL duplicates_allowed)
+static BOOL message_send_pid_internal(pid_t pid, int msg_type, const void *buf, size_t len,
+		      BOOL duplicates_allowed, unsigned int timeout)
 {
 	TDB_DATA kbuf;
 	TDB_DATA dbuf;
+	TDB_DATA old_dbuf;
 	struct message_rec rec;
-	void *p;
+	char *ptr;
+	struct message_rec prec;
+
+	/*
+	 * Doing kill with a non-positive pid causes messages to be
+	 * sent to places we don't want.
+	 */
+
+	SMB_ASSERT(pid > 0);
 
 	rec.msg_version = MESSAGE_VERSION;
 	rec.msg_type = msg_type;
@@ -166,186 +183,246 @@
 	rec.src = sys_getpid();
 	rec.len = len;
 
-	/* Doing kill with a non-positive pid causes messages to be
-	 * sent to places we don't want. */
-	SMB_ASSERT(pid > 0);
-
 	kbuf = message_key_pid(pid);
 
+	dbuf.dptr = (void *)malloc(len + sizeof(rec));
+	if (!dbuf.dptr)
+		return False;
+
+	memcpy(dbuf.dptr, &rec, sizeof(rec));
+	if (len > 0)
+		memcpy((void *)((char*)dbuf.dptr+sizeof(rec)), buf, len);
+
+	dbuf.dsize = len + sizeof(rec);
+
+	if (duplicates_allowed) {
+
+		/* If duplicates are allowed we can just append the message and return. */
+
+		/* lock the record for the destination */
+		if (timeout) {
+			if (tdb_chainlock_with_timeout(tdb, kbuf, timeout) == -1) {
+				DEBUG(0,("message_send_pid_internal: failed to get chainlock with timeout %ul.\n", timeout));
+				return False;
+			}
+		} else {
+			if (tdb_chainlock(tdb, kbuf) == -1) {
+				DEBUG(0,("message_send_pid_internal: failed to get chainlock.\n"));
+				return False;
+			}
+		}	
+		tdb_append(tdb, kbuf, dbuf);
+		tdb_chainunlock(tdb, kbuf);
+
+		SAFE_FREE(dbuf.dptr);
+		errno = 0;                    /* paranoia */
+		return message_notify(pid);
+	}
+
 	/* lock the record for the destination */
-	tdb_chainlock(tdb, kbuf);
+	if (timeout) {
+		if (tdb_chainlock_with_timeout(tdb, kbuf, timeout) == -1) {
+			DEBUG(0,("message_send_pid_internal: failed to get chainlock with timeout %ul.\n", timeout));
+			return False;
+		}
+	} else {
+		if (tdb_chainlock(tdb, kbuf) == -1) {
+			DEBUG(0,("message_send_pid_internal: failed to get chainlock.\n"));
+			return False;
+		}
+	}	
 
-	dbuf = tdb_fetch(tdb, kbuf);
+	old_dbuf = tdb_fetch(tdb, kbuf);
 
-	if (!dbuf.dptr) {
+	if (!old_dbuf.dptr) {
 		/* its a new record */
-		p = (void *)malloc(len + sizeof(rec));
-		if (!p)
-			goto failed;
-
-		memcpy(p, &rec, sizeof(rec));
-		if (len > 0)
-			memcpy((void *)((char*)p+sizeof(rec)), buf, len);
 
-		dbuf.dptr = p;
-		dbuf.dsize = len + sizeof(rec);
 		tdb_store(tdb, kbuf, dbuf, TDB_REPLACE);
-		SAFE_FREE(p);
-		goto ok;
+		tdb_chainunlock(tdb, kbuf);
+
+		SAFE_FREE(dbuf.dptr);
+		errno = 0;                    /* paranoia */
+		return message_notify(pid);
 	}
 
-	if (!duplicates_allowed) {
-		char *ptr;
-		struct message_rec prec;
-		
-		for(ptr = (char *)dbuf.dptr; ptr < dbuf.dptr + dbuf.dsize; ) {
-			/*
-			 * First check if the message header matches, then, if it's a non-zero
-			 * sized message, check if the data matches. If so it's a duplicate and
-			 * we can discard it. JRA.
-			 */
-
-			if (!memcmp(ptr, &rec, sizeof(rec))) {
-				if (!len || (len && !memcmp( ptr + sizeof(rec), buf, len))) {
-					DEBUG(10,("message_send_pid: discarding duplicate message.\n"));
-					SAFE_FREE(dbuf.dptr);
-					tdb_chainunlock(tdb, kbuf);
-					return True;
-				}
+	/* Not a new record. Check for duplicates. */
+
+	for(ptr = (char *)old_dbuf.dptr; ptr < old_dbuf.dptr + old_dbuf.dsize; ) {
+		/*
+		 * First check if the message header matches, then, if it's a non-zero
+		 * sized message, check if the data matches. If so it's a duplicate and
+		 * we can discard it. JRA.
+		 */
+
+		if (!memcmp(ptr, &rec, sizeof(rec))) {
+			if (!len || (len && !memcmp( ptr + sizeof(rec), buf, len))) {
+				tdb_chainunlock(tdb, kbuf);
+				DEBUG(10,("message_send_pid_internal: discarding duplicate message.\n"));
+				SAFE_FREE(dbuf.dptr);
+				SAFE_FREE(old_dbuf.dptr);
+				return True;
 			}
-			memcpy(&prec, ptr, sizeof(prec));
-			ptr += sizeof(rec) + prec.len;
 		}
+		memcpy(&prec, ptr, sizeof(prec));
+		ptr += sizeof(rec) + prec.len;
 	}
 
 	/* we're adding to an existing entry */
-	p = (void *)malloc(dbuf.dsize + len + sizeof(rec));
-	if (!p)
-		goto failed;
 
-	memcpy(p, dbuf.dptr, dbuf.dsize);
-	memcpy((void *)((char*)p+dbuf.dsize), &rec, sizeof(rec));
-	if (len > 0)
-		memcpy((void *)((char*)p+dbuf.dsize+sizeof(rec)), buf, len);
+	tdb_append(tdb, kbuf, dbuf);
+	tdb_chainunlock(tdb, kbuf);
 
-	SAFE_FREE(dbuf.dptr);
-	dbuf.dptr = p;
-	dbuf.dsize += len + sizeof(rec);
-	tdb_store(tdb, kbuf, dbuf, TDB_REPLACE);
+	SAFE_FREE(old_dbuf.dptr);
 	SAFE_FREE(dbuf.dptr);
 
- ok:
-	tdb_chainunlock(tdb, kbuf);
 	errno = 0;                    /* paranoia */
 	return message_notify(pid);
+}
 
- failed:
-	tdb_chainunlock(tdb, kbuf);
-	errno = 0;                    /* paranoia */
-	return False;
+/****************************************************************************
+ Send a message to a particular pid - no timeout.
+****************************************************************************/
+
+BOOL message_send_pid(pid_t pid, int msg_type, const void *buf, size_t len, BOOL duplicates_allowed)
+{
+	return message_send_pid_internal(pid, msg_type, buf, len, duplicates_allowed, 0);
 }
 
 /****************************************************************************
- Retrieve the next message for the current process.
+ Send a message to a particular pid, with timeout in seconds.
 ****************************************************************************/
 
-static BOOL message_recv(int *msg_type, pid_t *src, void **buf, size_t *len)
+BOOL message_send_pid_with_timeout(pid_t pid, int msg_type, const void *buf, size_t len,
+		BOOL duplicates_allowed, unsigned int timeout)
+{
+	return message_send_pid_internal(pid, msg_type, buf, len, duplicates_allowed, timeout);
+}
+
+/****************************************************************************
+ Retrieve all messages for the current process.
+****************************************************************************/
+
+static BOOL retrieve_all_messages(char **msgs_buf, size_t *total_len)
 {
 	TDB_DATA kbuf;
 	TDB_DATA dbuf;
-	struct message_rec rec;
+	TDB_DATA null_dbuf;
+
+	ZERO_STRUCT(null_dbuf);
+
+	*msgs_buf = NULL;
+	*total_len = 0;
 
 	kbuf = message_key_pid(sys_getpid());
 
 	tdb_chainlock(tdb, kbuf);
-	
 	dbuf = tdb_fetch(tdb, kbuf);
-	if (dbuf.dptr == NULL || dbuf.dsize == 0)
-		goto failed;
+	/*
+	 * Replace with an empty record to keep the allocated
+	 * space in the tdb.
+	 */
+	tdb_store(tdb, kbuf, null_dbuf, TDB_REPLACE);
+	tdb_chainunlock(tdb, kbuf);
+
+	if (dbuf.dptr == NULL || dbuf.dsize == 0) {
+		SAFE_FREE(dbuf.dptr);
+		return False;
+	}
+
+	*msgs_buf = dbuf.dptr;
+	*total_len = dbuf.dsize;
+
+	return True;
+}
+
+/****************************************************************************
+ Parse out the next message for the current process.
+****************************************************************************/
 
-	memcpy(&rec, dbuf.dptr, sizeof(rec));
+static BOOL message_recv(char *msgs_buf, size_t total_len, int *msg_type, pid_t *src, char **buf, size_t *len)
+{
+	struct message_rec rec;
+	char *ret_buf = *buf;
+
+	*buf = NULL;
+	*len = 0;
+
+	if (total_len - (ret_buf - msgs_buf) < sizeof(rec))
+		return False;
+
+	memcpy(&rec, ret_buf, sizeof(rec));
+	ret_buf += sizeof(rec);
 
 	if (rec.msg_version != MESSAGE_VERSION) {
 		DEBUG(0,("message version %d received (expected %d)\n", rec.msg_version, MESSAGE_VERSION));
-		goto failed;
+		return False;
 	}
 
 	if (rec.len > 0) {
-		(*buf) = (void *)malloc(rec.len);
-		if (!(*buf))
-			goto failed;
-
-		memcpy(*buf, dbuf.dptr+sizeof(rec), rec.len);
-	} else {
-		*buf = NULL;
+		if (total_len - (ret_buf - msgs_buf) < rec.len)
+			return False;
 	}
 
 	*len = rec.len;
 	*msg_type = rec.msg_type;
 	*src = rec.src;
+	*buf = ret_buf;
 
-	if (dbuf.dsize - (sizeof(rec)+rec.len) > 0)
-		memmove(dbuf.dptr, dbuf.dptr+sizeof(rec)+rec.len, dbuf.dsize - (sizeof(rec)+rec.len));
-	dbuf.dsize -= sizeof(rec)+rec.len;
-
-	if (dbuf.dsize == 0)
-		tdb_delete(tdb, kbuf);
-	else
-		tdb_store(tdb, kbuf, dbuf, TDB_REPLACE);
-
-	SAFE_FREE(dbuf.dptr);
-	tdb_chainunlock(tdb, kbuf);
 	return True;
-
- failed:
-	tdb_chainunlock(tdb, kbuf);
-	SAFE_FREE(dbuf.dptr);
-	return False;
 }
 
 /****************************************************************************
  Receive and dispatch any messages pending for this process.
  Notice that all dispatch handlers for a particular msg_type get called,
  so you can register multiple handlers for a message.
+ *NOTE*: Dispatch functions must be able to cope with incoming
+ messages on an *odd* byte boundary.
 ****************************************************************************/
 
 void message_dispatch(void)
 {
 	int msg_type;
 	pid_t src;
-	void *buf;
-	size_t len;
+	char *buf;
+	char *msgs_buf;
+	size_t len, total_len;
 	struct dispatch_fns *dfn;
 	int n_handled;
 
-	if (!received_signal) return;
+	if (!received_signal)
+		return;
 
 	DEBUG(10,("message_dispatch: received_signal = %d\n", received_signal));
 
 	received_signal = 0;
 
-	while (message_recv(&msg_type, &src, &buf, &len)) {
-		DEBUG(10,("message_dispatch: received msg_type=%d src_pid=%d\n",
-			  msg_type, (int) src));
+	if (!retrieve_all_messages(&msgs_buf, &total_len))
+		return;
+
+	for (buf = msgs_buf; message_recv(msgs_buf, total_len, &msg_type, &src, &buf, &len); buf += len) {
+		DEBUG(10,("message_dispatch: received msg_type=%d src_pid=%u\n",
+			  msg_type, (unsigned int) src));
 		n_handled = 0;
 		for (dfn = dispatch_fns; dfn; dfn = dfn->next) {
 			if (dfn->msg_type == msg_type) {
 				DEBUG(10,("message_dispatch: processing message of type %d.\n", msg_type));
-				dfn->fn(msg_type, src, buf, len);
+				dfn->fn(msg_type, src, len ? (void *)buf : NULL, len);
 				n_handled++;
 			}
 		}
 		if (!n_handled) {
-			DEBUG(5,("message_dispatch: warning: no handlers registered for "
-				 "msg_type %d in pid %d\n",
-				 msg_type, sys_getpid()));
+			DEBUG(5,("message_dispatch: warning: no handlers registed for "
+				 "msg_type %d in pid %u\n",
+				 msg_type, (unsigned int)sys_getpid()));
 		}
-		SAFE_FREE(buf);
 	}
+	SAFE_FREE(msgs_buf);
 }
 
 /****************************************************************************
  Register a dispatch function for a particular message type.
+ *NOTE*: Dispatch functions must be able to cope with incoming
+ messages on an *odd* byte boundary.
 ****************************************************************************/
 
 void message_register(int msg_type, 
diff -uNr samba-3.0alpha21.orig/source/lib/pam_errors.c samba-3.0alpha21/source/lib/pam_errors.c
--- samba-3.0alpha21.orig/source/lib/pam_errors.c	2003-02-16 19:06:31.000000000 -0600
+++ samba-3.0alpha21/source/lib/pam_errors.c	2003-02-16 19:05:45.000000000 -0600
@@ -28,7 +28,7 @@
 #endif	
 
 /* PAM -> NT_STATUS map */
-const static struct {
+static const struct {
 	int pam_code;
 	NTSTATUS ntstatus;
 } pam_to_nt_status_map[] = {
@@ -58,7 +58,7 @@
 };
 
 /* NT_STATUS -> PAM map */
-const static struct {
+static const struct {
 	NTSTATUS ntstatus;
 	int pam_code;
 } nt_status_to_pam_map[] = {
diff -uNr samba-3.0alpha21.orig/source/lib/pidfile.c samba-3.0alpha21/source/lib/pidfile.c
--- samba-3.0alpha21.orig/source/lib/pidfile.c	2003-02-16 19:06:31.000000000 -0600
+++ samba-3.0alpha21/source/lib/pidfile.c	2003-02-16 19:05:45.000000000 -0600
@@ -28,7 +28,7 @@
 
 /* return the pid in a pidfile. return 0 if the process (or pidfile)
    does not exist */
-pid_t pidfile_pid(char *name)
+pid_t pidfile_pid(const char *name)
 {
 	int fd;
 	char pidstr[20];
@@ -69,7 +69,7 @@
 }
 
 /* create a pid file in the pid directory. open it and leave it locked */
-void pidfile_create(char *name)
+void pidfile_create(const char *name)
 {
 	int     fd;
 	char    buf[20];
diff -uNr samba-3.0alpha21.orig/source/lib/readline.c samba-3.0alpha21/source/lib/readline.c
--- samba-3.0alpha21.orig/source/lib/readline.c	2003-02-16 19:06:31.000000000 -0600
+++ samba-3.0alpha21/source/lib/readline.c	2003-02-16 19:05:45.000000000 -0600
@@ -56,7 +56,7 @@
 	fd_set fds;
 	static pstring line;
 	struct timeval timeout;
-	int fd = fileno(stdin);
+	int fd = x_fileno(x_stdin);
 	char *ret;
 
 	x_fprintf(dbf, "%s", prompt);
@@ -70,7 +70,7 @@
 		FD_SET(fd,&fds);
 	
 		if (sys_select_intr(fd+1,&fds,NULL,NULL,&timeout) == 1) {
-			ret = fgets(line, sizeof(line), stdin);
+			ret = x_fgets(line, sizeof(line), x_stdin);
 			return ret;
 		}
 		if (callback)
@@ -86,7 +86,7 @@
 		   char **(completion_fn)(char *text, int start, int end))
 {
 #if HAVE_LIBREADLINE
-	if (isatty(fileno(stdin))) {
+	if (isatty(x_fileno(x_stdin))) {
 		char *ret;
 
 		/* Aargh!  Readline does bizzare things with the terminal width
diff -uNr samba-3.0alpha21.orig/source/lib/replace.c samba-3.0alpha21/source/lib/replace.c
--- samba-3.0alpha21.orig/source/lib/replace.c	2003-02-16 19:06:31.000000000 -0600
+++ samba-3.0alpha21/source/lib/replace.c	2003-02-16 19:05:45.000000000 -0600
@@ -328,13 +328,8 @@
 {
 	unsigned char *p = (unsigned char *)&ip.s_addr;
 	static char buf[18];
-#if WORDS_BIGENDIAN
 	slprintf(buf, 17, "%d.%d.%d.%d", 
 		 (int)p[0], (int)p[1], (int)p[2], (int)p[3]);
-#else /* WORDS_BIGENDIAN */
-	slprintf(buf, 17, "%d.%d.%d.%d", 
-		 (int)p[3], (int)p[2], (int)p[1], (int)p[0]);
-#endif /* WORDS_BIGENDIAN */
 	return buf;
 }
 #endif /* REPLACE_INET_NTOA */
@@ -432,26 +427,23 @@
 
 #ifndef HAVE_TIMEGM
 /*
-  see the timegm man page on linux
+  yes, I know this looks insane, but its really needed. The function in the 
+  Linux timegm() manpage does not work on solaris.
 */
  time_t timegm(struct tm *tm) 
 {
-	time_t ret;
-	char *tz;
-	char *tzvar;
-	
-	tz = getenv("TZ");
-	putenv("TZ=");
-	tzset();
-	ret = mktime(tm);
-	if (tz) {
-		asprintf(&tzvar, "TZ=%s", tz);
-		putenv(tzvar);
-		safe_free(tzvar);
-	} else {
-		putenv("TZ");
-	}
-	tzset();
-	return ret;
+	struct tm tm2, tm3;
+	time_t t;
+
+	tm2 = *tm;
+
+	t = mktime(&tm2);
+	tm3 = *localtime(&t);
+	tm2 = *tm;
+	tm2.tm_isdst = tm3.tm_isdst;
+	t = mktime(&tm2);
+	t -= TimeDiff(t);
+
+	return t;
 }
 #endif
diff -uNr samba-3.0alpha21.orig/source/lib/sendfile.c samba-3.0alpha21/source/lib/sendfile.c
--- samba-3.0alpha21.orig/source/lib/sendfile.c	2003-02-16 19:06:31.000000000 -0600
+++ samba-3.0alpha21/source/lib/sendfile.c	2003-02-16 19:05:45.000000000 -0600
@@ -38,7 +38,7 @@
 {
 	size_t total=0;
 	ssize_t ret;
-	ssize_t hdr_len = 0;
+	size_t hdr_len = 0;
 
 	/*
 	 * Send the header first.
diff -uNr samba-3.0alpha21.orig/source/lib/server_mutex.c samba-3.0alpha21/source/lib/server_mutex.c
--- samba-3.0alpha21.orig/source/lib/server_mutex.c	2003-02-16 19:06:31.000000000 -0600
+++ samba-3.0alpha21/source/lib/server_mutex.c	2003-02-16 19:05:45.000000000 -0600
@@ -30,6 +30,8 @@
    like the single-connection that NT makes. */
 
 static char *mutex_server_name;
+/* FIXME. ref_count should be allocated per name... JRA. */
+size_t ref_count;
 
 BOOL grab_server_mutex(const char *name)
 {
@@ -38,7 +40,7 @@
 		DEBUG(0,("grab_server_mutex: malloc failed for %s\n", name));
 		return False;
 	}
-	if (!secrets_named_mutex(mutex_server_name, 10)) {
+	if (!secrets_named_mutex(mutex_server_name, 10, &ref_count)) {
 		DEBUG(10,("grab_server_mutex: failed for %s\n", name));
 		SAFE_FREE(mutex_server_name);
 		return False;
@@ -50,7 +52,7 @@
 void release_server_mutex(void)
 {
 	if (mutex_server_name) {
-		secrets_named_mutex_release(mutex_server_name);
+		secrets_named_mutex_release(mutex_server_name, &ref_count);
 		SAFE_FREE(mutex_server_name);
 	}
 }
diff -uNr samba-3.0alpha21.orig/source/lib/signal.c samba-3.0alpha21/source/lib/signal.c
--- samba-3.0alpha21.orig/source/lib/signal.c	2003-02-16 19:06:31.000000000 -0600
+++ samba-3.0alpha21/source/lib/signal.c	2003-02-16 19:05:45.000000000 -0600
@@ -57,8 +57,6 @@
 
 #if !defined(HAVE_SIGACTION)
 	CatchSignal(SIGCLD, sig_cld_leave_status);
-#else
-	;
 #endif
 }
 
diff -uNr samba-3.0alpha21.orig/source/lib/smbpasswd.c samba-3.0alpha21/source/lib/smbpasswd.c
--- samba-3.0alpha21.orig/source/lib/smbpasswd.c	2003-02-16 19:06:31.000000000 -0600
+++ samba-3.0alpha21/source/lib/smbpasswd.c	2003-02-16 19:05:45.000000000 -0600
@@ -60,7 +60,7 @@
 {
 	int i;
 	unsigned char   lonybble, hinybble;
-	char           *hexchars = "0123456789ABCDEF";
+	const char      *hexchars = "0123456789ABCDEF";
 	char           *p1, *p2;
 	
 	if (!p) return (False);
diff -uNr samba-3.0alpha21.orig/source/lib/snprintf.c samba-3.0alpha21/source/lib/snprintf.c
--- samba-3.0alpha21.orig/source/lib/snprintf.c	2003-02-16 19:06:31.000000000 -0600
+++ samba-3.0alpha21/source/lib/snprintf.c	2003-02-16 19:05:45.000000000 -0600
@@ -341,6 +341,7 @@
 					fvalue = va_arg (args, LDOUBLE);
 				else
 					fvalue = va_arg (args, double);
+				fmtfp (buffer, &currlen, maxlen, fvalue, min, max, flags);
 				break;
 			case 'G':
 				flags |= DP_F_UP;
@@ -349,6 +350,7 @@
 					fvalue = va_arg (args, LDOUBLE);
 				else
 					fvalue = va_arg (args, double);
+				fmtfp (buffer, &currlen, maxlen, fvalue, min, max, flags);
 				break;
 			case 'c':
 				dopr_outch (buffer, &currlen, maxlen, va_arg (args, int));
diff -uNr samba-3.0alpha21.orig/source/lib/system.c samba-3.0alpha21/source/lib/system.c
--- samba-3.0alpha21.orig/source/lib/system.c	2003-02-16 19:06:31.000000000 -0600
+++ samba-3.0alpha21/source/lib/system.c	2003-02-16 19:05:45.000000000 -0600
@@ -1233,7 +1233,7 @@
  Wrapper for Admin Logs.
 ****************************************************************************/
 
-void sys_adminlog(int priority, char *format_str, ...)
+ void sys_adminlog(int priority, const char *format_str, ...) 
 {
 	va_list ap;
 	int ret;
diff -uNr samba-3.0alpha21.orig/source/lib/talloc.c samba-3.0alpha21/source/lib/talloc.c
--- samba-3.0alpha21.orig/source/lib/talloc.c	2003-02-16 19:06:31.000000000 -0600
+++ samba-3.0alpha21/source/lib/talloc.c	2003-02-16 19:05:45.000000000 -0600
@@ -117,7 +117,7 @@
 
 
 /** Create a new talloc context. **/
-TALLOC_CTX *talloc_init(void)
+static TALLOC_CTX *talloc_init_internal(void)
 {
 	TALLOC_CTX *t;
 
@@ -136,18 +136,27 @@
 
 /**
  * Create a new talloc context, with a name specifying its purpose.
- * Please call this in preference to talloc_init().
  **/
- TALLOC_CTX *talloc_init_named(char const *fmt, ...) 
+
+ TALLOC_CTX *talloc_init(char const *fmt, ...) 
 {
 	TALLOC_CTX *t;
 	va_list ap;
 
-	t = talloc_init();
+	t = talloc_init_internal();
 	if (t && fmt) {
+		/*
+		 * t->name must not be talloced.
+		 * as destroying the pool would destroy it. JRA.
+		 */
+		t->name = NULL;
 		va_start(ap, fmt);
-		t->name = talloc_vasprintf(t, fmt, ap);
+		vasprintf(&t->name, fmt, ap);
 		va_end(ap);
+		if (!t->name) {
+			talloc_destroy(t);
+			t = NULL;
+		}
 	}
 	
 	return t;
@@ -234,6 +243,7 @@
 
 	talloc_destroy_pool(t);
 	talloc_disenroll(t);
+	SAFE_FREE(t->name);
 	memset(t, 0, sizeof(TALLOC_CTX));
 	SAFE_FREE(t);
 }
@@ -411,7 +421,7 @@
 		if (it->name)
 			fstrcpy(what, it->name);
 		else
-			slprintf(what, sizeof what, "@%p", it);
+			slprintf(what, sizeof(what), "@%p", it);
 		
 		s = talloc_asprintf_append(rt, s, "%-40s %8u %8u\n",
 					   what,
diff -uNr samba-3.0alpha21.orig/source/lib/tallocmsg.c samba-3.0alpha21/source/lib/tallocmsg.c
--- samba-3.0alpha21.orig/source/lib/tallocmsg.c	2003-02-16 19:06:31.000000000 -0600
+++ samba-3.0alpha21/source/lib/tallocmsg.c	2003-02-16 19:05:45.000000000 -0600
@@ -34,7 +34,7 @@
 		    void *UNUSED(buf), size_t UNUSED(len))
 {
 	char *reply;
-	TALLOC_CTX *reply_pool = talloc_init_named("msg_pool_usage");
+	TALLOC_CTX *reply_pool = talloc_init("msg_pool_usage");
 
 	SMB_ASSERT(msg_type == MSG_REQ_POOL_USAGE);
 	
diff -uNr samba-3.0alpha21.orig/source/lib/talloctort.c samba-3.0alpha21/source/lib/talloctort.c
--- samba-3.0alpha21.orig/source/lib/talloctort.c	2003-02-16 19:06:31.000000000 -0600
+++ samba-3.0alpha21/source/lib/talloctort.c	2003-02-16 19:05:45.000000000 -0600
@@ -29,7 +29,7 @@
 	TALLOC_CTX *ctx[NCTX];
 
 	for (i = 0; i < NCTX; i++) {
-		ctx[i] = talloc_init_named("torture(%d)", i);
+		ctx[i] = talloc_init("torture(%d)", i);
 	}
 
 	for (i = 0; i < NCTX; i++) {
diff -uNr samba-3.0alpha21.orig/source/lib/time.c samba-3.0alpha21/source/lib/time.c
--- samba-3.0alpha21.orig/source/lib/time.c	2003-02-16 19:06:31.000000000 -0600
+++ samba-3.0alpha21/source/lib/time.c	2003-02-16 19:05:45.000000000 -0600
@@ -330,13 +330,14 @@
 }
 
 /****************************************************************************
-convert a NTTIME structure to a time_t
-It's originally in "100ns units"
+ Convert a NTTIME structure to a time_t.
+ It's originally in "100ns units".
 
-this is an absolute version of the one above.
-By absolute I mean, it doesn't adjust from 1/1/1601 to 1/1/1970
-if the NTTIME was 5 seconds, the time_t is 5 seconds. JFM
+ This is an absolute version of the one above.
+ By absolute I mean, it doesn't adjust from 1/1/1601 to 1/1/1970
+ if the NTTIME was 5 seconds, the time_t is 5 seconds. JFM
 ****************************************************************************/
+
 time_t nt_time_to_unix_abs(NTTIME *nt)
 {
 	double d;
@@ -366,15 +367,9 @@
 
 	ret = (time_t)(d+0.5);
 
-	/* this takes us from kludge-GMT to real GMT */
-	ret -= get_serverzone();
-	ret += LocTimeDiff(ret);
-
 	return(ret);
 }
 
-
-
 /****************************************************************************
 interprets an nt time into a unix time_t
 ****************************************************************************/
@@ -425,12 +420,13 @@
 }
 
 /****************************************************************************
-convert a time_t to a NTTIME structure
+ Convert a time_t to a NTTIME structure
 
-this is an absolute version of the one above.
-By absolute I mean, it doesn't adjust from 1/1/1970 to 1/1/1601
-if the nttime_t was 5 seconds, the NTTIME is 5 seconds. JFM
+ This is an absolute version of the one above.
+ By absolute I mean, it doesn't adjust from 1/1/1970 to 1/1/1601
+ If the nttime_t was 5 seconds, the NTTIME is 5 seconds. JFM
 ****************************************************************************/
+
 void unix_to_nt_time_abs(NTTIME *nt, time_t t)
 {
 	double d;
@@ -454,9 +450,6 @@
 		return;
 	}		
 
-	/* this converts GMT to kludge-GMT */
-	t -= LocTimeDiff(t) - get_serverzone(); 
-
 	d = (double)(t);
 	d *= 1.0e7;
 
diff -uNr samba-3.0alpha21.orig/source/lib/util.c samba-3.0alpha21/source/lib/util.c
--- samba-3.0alpha21.orig/source/lib/util.c	2003-02-16 19:06:31.000000000 -0600
+++ samba-3.0alpha21/source/lib/util.c	2003-02-16 19:05:45.000000000 -0600
@@ -4,6 +4,7 @@
    Copyright (C) Andrew Tridgell 1992-1998
    Copyright (C) Jeremy Allison 2001-2002
    Copyright (C) Simo Sorce 2001
+   Copyright (C) Anthony Liguori 2003
    
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -140,8 +141,14 @@
 	return True;
 }
 
+/*********************************************************************
+ Ensure scope is never null string.
+*********************************************************************/
+
 const char *global_scope(void)
 {
+	if (!smb_scope)
+		set_global_scope("");
 	return smb_scope;
 }
 
@@ -670,7 +677,7 @@
  Make a dir struct.
 ****************************************************************************/
 
-void make_dir_struct(char *buf,char *mask,char *fname,SMB_OFF_T size,int mode,time_t date)
+void make_dir_struct(char *buf, const char *mask, const char *fname,SMB_OFF_T size,int mode,time_t date)
 {  
 	char *p;
 	pstring mask2;
@@ -704,6 +711,7 @@
 
 void close_low_fds(BOOL stderr_too)
 {
+#ifndef VALGRIND
 	int fd;
 	int i;
 
@@ -731,6 +739,7 @@
 			return;
 		}
 	}
+#endif
 }
 
 /****************************************************************************
@@ -865,10 +874,13 @@
  Become a daemon, discarding the controlling terminal.
 ****************************************************************************/
 
-void become_daemon(void)
+void become_daemon(BOOL Fork)
 {
-	if (sys_fork())
-		_exit(0);
+	if (Fork) {
+		if (sys_fork()) {
+			_exit(0);
+		}
+	}
 
   /* detach from the terminal */
 #ifdef HAVE_SETSID
@@ -975,6 +987,62 @@
 }
 
 /****************************************************************************
+ Get my own name, including domain.
+****************************************************************************/
+
+BOOL get_myfullname(char *my_name)
+{
+	pstring hostname;
+
+	*hostname = 0;
+
+	/* get my host name */
+	if (gethostname(hostname, sizeof(hostname)) == -1) {
+		DEBUG(0,("gethostname failed\n"));
+		return False;
+	} 
+
+	/* Ensure null termination. */
+	hostname[sizeof(hostname)-1] = '\0';
+
+	if (my_name)
+		fstrcpy(my_name, hostname);
+	return True;
+}
+
+/****************************************************************************
+ Get my own domain name.
+****************************************************************************/
+
+BOOL get_mydomname(char *my_domname)
+{
+	pstring hostname;
+	char *p;
+
+	*hostname = 0;
+	/* get my host name */
+	if (gethostname(hostname, sizeof(hostname)) == -1) {
+		DEBUG(0,("gethostname failed\n"));
+		return False;
+	} 
+
+	/* Ensure null termination. */
+	hostname[sizeof(hostname)-1] = '\0';
+
+	p = strchr_m(hostname, '.');
+
+	if (!p)
+		return False;
+
+	p++;
+	
+	if (my_domname)
+		fstrcpy(my_domname, p);
+
+	return True;
+}
+
+/****************************************************************************
  Interpret a protocol description string, with a default.
 ****************************************************************************/
 
@@ -1334,7 +1402,7 @@
  Something really nasty happened - panic !
 ********************************************************************/
 
-void smb_panic(char *why)
+void smb_panic(const char *why)
 {
 	char *cmd = lp_panic_action();
 	int result;
@@ -1399,7 +1467,7 @@
  of a path matches a (possibly wildcarded) entry in a namelist.
 ********************************************************************/
 
-BOOL is_in_path(char *name, name_compare_entry *namelist)
+BOOL is_in_path(const char *name, name_compare_entry *namelist)
 {
 	pstring last_component;
 	char *p;
@@ -1532,10 +1600,13 @@
 
 void free_namearray(name_compare_entry *name_array)
 {
+	int i;
+
 	if(name_array == NULL)
 		return;
 
-	SAFE_FREE(name_array->name);
+	for(i=0; name_array[i].name!=NULL; i++)
+		SAFE_FREE(name_array[i].name);
 	SAFE_FREE(name_array);
 }
 
@@ -2016,7 +2087,7 @@
   vasprintf that aborts on malloc fail
 */
 
-int smb_xvasprintf(char **ptr, const char *format, va_list ap)
+ int smb_xvasprintf(char **ptr, const char *format, va_list ap)
 {
 	int n;
 	va_list ap2;
@@ -2112,6 +2183,17 @@
 	return fname;
 }
 
+/**
+ * @brief Returns the platform specific shared library extension.
+ *
+ * @retval Pointer to a static #fstring containing the extension.
+ **/
+
+const char *shlib_ext(void)
+{
+  return dyn_SHLIBEXT;
+}
+
 /*******************************************************************
  Given a filename - get its directory name
  NB: Returned in static storage.  Caveats:
@@ -2183,7 +2265,7 @@
  of the ".." name.
 *******************************************************************/
 
-BOOL mask_match(char *string, char *pattern, BOOL is_case_sensitive)
+BOOL mask_match(const char *string, char *pattern, BOOL is_case_sensitive)
 {
 	fstring p2, s2;
 
diff -uNr samba-3.0alpha21.orig/source/lib/util_sid.c samba-3.0alpha21/source/lib/util_sid.c
--- samba-3.0alpha21.orig/source/lib/util_sid.c	2003-02-16 19:06:31.000000000 -0600
+++ samba-3.0alpha21/source/lib/util_sid.c	2003-02-16 19:05:45.000000000 -0600
@@ -79,9 +79,9 @@
  Lookup string names for SID types.
 ****************************************************************************/
 
-const static struct {
+static const struct {
 	enum SID_NAME_USE sid_type;
-	char *string;
+	const char *string;
 } sid_name_type[] = {
 	{SID_NAME_USER, "User"},
 	{SID_NAME_DOM_GRP, "Domain Group"},
@@ -181,7 +181,8 @@
 void split_domain_name(const char *fullname, char *domain, char *name)
 {
 	pstring full_name;
-	char *p, *sep;
+	const char *sep;
+	char *p;
 
 	sep = lp_winbind_separator();
 
diff -uNr samba-3.0alpha21.orig/source/lib/util_sock.c samba-3.0alpha21/source/lib/util_sock.c
--- samba-3.0alpha21.orig/source/lib/util_sock.c	2003-02-16 19:06:31.000000000 -0600
+++ samba-3.0alpha21/source/lib/util_sock.c	2003-02-16 19:05:45.000000000 -0600
@@ -43,7 +43,7 @@
 enum SOCK_OPT_TYPES {OPT_BOOL,OPT_INT,OPT_ON};
 
 typedef struct smb_socket_option {
-	char *name;
+	const char *name;
 	int level;
 	int option;
 	int value;
@@ -186,30 +186,6 @@
 	return(ret);
 }
 
-/*******************************************************************
- checks if read data is outstanding.
- ********************************************************************/
-static int read_data_outstanding(int fd, unsigned int time_out)
-{
-	int selrtn;
-	fd_set fds;
-	struct timeval timeout;
-
-	FD_ZERO(&fds);
-	FD_SET(fd, &fds);
-
-	timeout.tv_sec = (time_t) (time_out / 1000);
-	timeout.tv_usec = (long)(1000 * (time_out % 1000));
-
-	selrtn = sys_select_intr(fd + 1, &fds, NULL, NULL, &timeout);
-
-	if (selrtn <= 0)
-	{
-		return selrtn;
-	}
-	return FD_ISSET(fd, &fds) ? 1 : 0;
-}
-
 /****************************************************************************
  Read data from a socket with a timout in msec.
  mincount = if timeout, minimum to read before returning
@@ -217,7 +193,7 @@
  time_out = timeout in milliseconds
 ****************************************************************************/
 
-static ssize_t read_socket_with_timeout(int fd,char *buf,size_t mincnt,size_t maxcnt,unsigned int time_out)
+ssize_t read_socket_with_timeout(int fd,char *buf,size_t mincnt,size_t maxcnt,unsigned int time_out)
 {
 	fd_set fds;
 	int selrtn;
@@ -309,62 +285,6 @@
 }
 
 /****************************************************************************
- Read data from a fd with a timout in msec.
- mincount = if timeout, minimum to read before returning
- maxcount = number to be read.
- time_out = timeout in milliseconds
-****************************************************************************/
-
-ssize_t read_with_timeout(int fd, char *buf, size_t mincnt, size_t maxcnt,
-			  unsigned int time_out)
-{
-	ssize_t readret;
-	size_t nread = 0;
-	
-	/* just checking .... */
-	if (maxcnt <= 0)
-		return(0);
-	
-	/* Blocking read */
-	if (time_out <= 0) {
-		if (mincnt == 0) mincnt = maxcnt;
-		
-		while (nread < mincnt) {
-			readret = sys_read(fd, buf + nread, maxcnt - nread);
-			
-			if (readret <= 0)
-				return readret;
-			
-			nread += readret;
-		}
-		return((ssize_t)nread);
-	}
-	
-	/* Most difficult - timeout read */
-	/* If this is ever called on a disk file and 
-	   mincnt is greater then the filesize then
-	   system performance will suffer severely as 
-	   select always returns true on disk files */
-	
-	for (nread=0; nread < mincnt; ) {      
-		int selrtn = read_data_outstanding(fd, time_out);
-		
-		if(selrtn <= 0)
-			return selrtn;
-		
-		readret = sys_read(fd, buf+nread, maxcnt-nread);
-		
-		if (readret <= 0)
-			return readret;
-		
-		nread += readret;
-	}
-	
-	/* Return the number we got */
-	return((ssize_t)nread);
-}
-
-/****************************************************************************
   read data from the client, reading exactly N bytes. 
 ****************************************************************************/
 
@@ -968,103 +888,93 @@
 /*******************************************************************
  Create protected unix domain socket.
 
- some unixen cannot set permissions on a ux-dom-sock, so we
+ Some unixes cannot set permissions on a ux-dom-sock, so we
  have to make sure that the directory contains the protection
- permissions, instead.
+ permissions instead.
  ******************************************************************/
+
 int create_pipe_sock(const char *socket_dir,
 		     const char *socket_name,
 		     mode_t dir_perms)
 {
 #ifdef HAVE_UNIXSOCKET
-        struct sockaddr_un sunaddr;
-        struct stat st;
-        int sock;
-        mode_t old_umask;
-        pstring path;
-        
-        /* Create the socket directory or reuse the existing one */
-        
-        if (lstat(socket_dir, &st) == -1) {
-                
-                if (errno == ENOENT) {
-                        
-                        /* Create directory */
-                        
-                        if (mkdir(socket_dir, dir_perms) == -1) {
-                                DEBUG(0, ("error creating socket directory "
-                                          "%s: %s\n", socket_dir, 
-                                          strerror(errno)));
-                                return -1;
-                        }
-                        
-                } else {
-                        
-                        DEBUG(0, ("lstat failed on socket directory %s: %s\n",
-                                  socket_dir, strerror(errno)));
-                        return -1;
-                }
-                
-        } else {
-                
-                /* Check ownership and permission on existing directory */
-                
-                if (!S_ISDIR(st.st_mode)) {
-                        DEBUG(0, ("socket directory %s isn't a directory\n",
-                                  socket_dir));
-                        return -1;
-                }
-                
-                if ((st.st_uid != sec_initial_uid()) || 
-                    ((st.st_mode & 0777) != dir_perms)) {
-                        DEBUG(0, ("invalid permissions on socket directory "
-                                  "%s\n", socket_dir));
-                        return -1;
-                }
-        }
+	struct sockaddr_un sunaddr;
+	struct stat st;
+	int sock;
+	mode_t old_umask;
+	pstring path;
         
-        /* Create the socket file */
+	old_umask = umask(0);
         
-        old_umask = umask(0);
+	/* Create the socket directory or reuse the existing one */
         
-        sock = socket(AF_UNIX, SOCK_STREAM, 0);
+	if (lstat(socket_dir, &st) == -1) {
+		if (errno == ENOENT) {
+			/* Create directory */
+			if (mkdir(socket_dir, dir_perms) == -1) {
+				DEBUG(0, ("error creating socket directory "
+					"%s: %s\n", socket_dir, 
+					strerror(errno)));
+				goto out_umask;
+			}
+		} else {
+			DEBUG(0, ("lstat failed on socket directory %s: %s\n",
+				socket_dir, strerror(errno)));
+			goto out_umask;
+		}
+	} else {
+		/* Check ownership and permission on existing directory */
+		if (!S_ISDIR(st.st_mode)) {
+			DEBUG(0, ("socket directory %s isn't a directory\n",
+				socket_dir));
+			goto out_umask;
+		}
+		if ((st.st_uid != sec_initial_uid()) || 
+				((st.st_mode & 0777) != dir_perms)) {
+			DEBUG(0, ("invalid permissions on socket directory "
+				"%s\n", socket_dir));
+			goto out_umask;
+		}
+	}
         
-        if (sock == -1) {
-                perror("socket");
-		umask(old_umask);
-                return -1;
-        }
+	/* Create the socket file */
         
-        snprintf(path, sizeof(path), "%s/%s", socket_dir, socket_name);
+	sock = socket(AF_UNIX, SOCK_STREAM, 0);
         
-        unlink(path);
-        memset(&sunaddr, 0, sizeof(sunaddr));
-        sunaddr.sun_family = AF_UNIX;
-        safe_strcpy(sunaddr.sun_path, path, sizeof(sunaddr.sun_path)-1);
+	if (sock == -1) {
+		perror("socket");
+                goto out_umask;
+	}
         
-        if (bind(sock, (struct sockaddr *)&sunaddr, sizeof(sunaddr)) == -1) {
-                DEBUG(0, ("bind failed on pipe socket %s: %s\n",
-                          path,
-                          strerror(errno)));
-                close(sock);
-		umask(old_umask);
-                return -1;
-        }
+	snprintf(path, sizeof(path), "%s/%s", socket_dir, socket_name);
         
-        if (listen(sock, 5) == -1) {
-                DEBUG(0, ("listen failed on pipe socket %s: %s\n",
-                          path,
-                          strerror(errno)));
-                close(sock);
-		umask(old_umask);
-                return -1;
-        }
+	unlink(path);
+	memset(&sunaddr, 0, sizeof(sunaddr));
+	sunaddr.sun_family = AF_UNIX;
+	safe_strcpy(sunaddr.sun_path, path, sizeof(sunaddr.sun_path)-1);
         
-        umask(old_umask);
+	if (bind(sock, (struct sockaddr *)&sunaddr, sizeof(sunaddr)) == -1) {
+		DEBUG(0, ("bind failed on pipe socket %s: %s\n", path,
+			strerror(errno)));
+		goto out_close;
+	}
         
-        /* Success! */
+	if (listen(sock, 5) == -1) {
+		DEBUG(0, ("listen failed on pipe socket %s: %s\n", path,
+			strerror(errno)));
+		goto out_close;
+	}
         
-        return sock;
+	umask(old_umask);
+	return sock;
+
+out_close:
+	close(sock);
+
+out_umask:
+	umask(old_umask);
+	return -1;
+
 #else
         DEBUG(0, ("create_pipe_sock: No Unix sockets on this system\n"));
         return -1;
diff -uNr samba-3.0alpha21.orig/source/lib/util_str.c samba-3.0alpha21/source/lib/util_str.c
--- samba-3.0alpha21.orig/source/lib/util_str.c	2003-02-16 19:06:31.000000000 -0600
+++ samba-3.0alpha21/source/lib/util_str.c	2003-02-16 19:05:45.000000000 -0600
@@ -308,8 +308,22 @@
 
 size_t str_charnum(const char *s)
 {
-	push_ucs2(NULL, tmpbuf,s, sizeof(tmpbuf), STR_TERMINATE);
-	return strlen_w(tmpbuf);
+	uint16 tmpbuf2[sizeof(pstring)];
+	push_ucs2(NULL, tmpbuf2,s, sizeof(tmpbuf2), STR_TERMINATE);
+	return strlen_w(tmpbuf2);
+}
+
+/*******************************************************************
+ Count the number of characters in a string. Normally this will
+ be the same as the number of bytes in a string for single byte strings,
+ but will be different for multibyte.
+********************************************************************/
+
+size_t str_ascii_charnum(const char *s)
+{
+	pstring tmpbuf2;
+	push_ascii(tmpbuf2, s, sizeof(tmpbuf2), STR_TERMINATE);
+	return strlen(tmpbuf2);
 }
 
 /*******************************************************************
@@ -465,11 +479,15 @@
 	
 	src_len = strlen(src);
 	dest_len = strlen(dest);
-	
+
 	if (src_len + dest_len > maxlength) {
 		DEBUG(0,("ERROR: string overflow by %d in safe_strcat [%.50s]\n",
 			 (int)(src_len + dest_len - maxlength), src));
-		src_len = maxlength - dest_len;
+		if (maxlength > dest_len) {
+			memcpy(&dest[dest_len], src, maxlength - dest_len);
+		}
+		dest[maxlength] = 0;
+		return NULL;
 	}
 	
 	memcpy(&dest[dest_len], src, src_len);
@@ -576,7 +594,7 @@
 	size_t i;
 	size_t num_chars = 0;
 	unsigned char   lonybble, hinybble;
-	char           *hexchars = "0123456789ABCDEF";
+	const char     *hexchars = "0123456789ABCDEF";
 	char           *p1 = NULL, *p2 = NULL;
 
 	for (i = 0; i < len && strhex[i] != 0; i++) {
@@ -655,13 +673,11 @@
 		}
 		*dest = null_string;
 	} else {
-		(*dest) = (char *)malloc(l+1);
+		(*dest) = strdup(src);
 		if ((*dest) == NULL) {
 			DEBUG(0,("Out of memory in string_init\n"));
 			return False;
 		}
-
-		pstrcpy(*dest,src);
 	}
 	return(True);
 }
@@ -958,7 +974,7 @@
  Write an octal as a string.
 ****************************************************************************/
 
-char *octal_string(int i)
+const char *octal_string(int i)
 {
 	static char ret[64];
 	if (i == -1)
@@ -1025,8 +1041,10 @@
 	   supported multi-byte character sets are ascii-compatible
 	   (ie. they match for the first 128 chars) */
 
-	while (*s && !(((unsigned char)s[0]) & 0x7F))
-		*s++ = tolower((unsigned char)*s);
+	while (*s && !(((unsigned char)s[0]) & 0x7F)) {
+		*s = tolower((unsigned char)*s);
+		s++;
+	}
 
 	if (!*s)
 		return;
@@ -1062,8 +1080,10 @@
 	   supported multi-byte character sets are ascii-compatible
 	   (ie. they match for the first 128 chars) */
 
-	while (*s && !(((unsigned char)s[0]) & 0x7F))
-		*s++ = toupper((unsigned char)*s);
+	while (*s && !(((unsigned char)s[0]) & 0x7F)) {
+		*s = toupper((unsigned char)*s);
+		s++;
+	}
 
 	if (!*s)
 		return;
@@ -1116,7 +1136,7 @@
  Just a typesafety wrapper for snprintf into a pstring.
 ********************************************************************/
 
-int pstr_sprintf(pstring s, const char *fmt, ...)
+ int pstr_sprintf(pstring s, const char *fmt, ...)
 {
 	va_list ap;
 	int ret;
@@ -1131,7 +1151,7 @@
  Just a typesafety wrapper for snprintf into a fstring.
 ********************************************************************/
 
-int fstr_sprintf(fstring s, const char *fmt, ...)
+ int fstr_sprintf(fstring s, const char *fmt, ...)
 {
 	va_list ap;
 	int ret;
@@ -1366,3 +1386,259 @@
 	
 	return True;
 }
+
+
+#define IPSTR_LIST_SEP	","
+
+/**
+ * Add ip string representation to ipstr list. Used also
+ * as part of @function ipstr_list_make
+ *
+ * @param ipstr_list pointer to string containing ip list;
+ *        MUST BE already allocated and IS reallocated if necessary
+ * @param ipstr_size pointer to current size of ipstr_list (might be changed
+ *        as a result of reallocation)
+ * @param ip IP address which is to be added to list
+ * @return pointer to string appended with new ip and possibly
+ *         reallocated to new length
+ **/
+
+char* ipstr_list_add(char** ipstr_list, const struct in_addr *ip)
+{
+	char* new_ipstr = NULL;
+	
+	/* arguments checking */
+	if (!ipstr_list || !ip) return NULL;
+
+	/* attempt to convert ip to a string and append colon separator to it */
+	if (*ipstr_list) {
+		asprintf(&new_ipstr, "%s%s%s", *ipstr_list, IPSTR_LIST_SEP,inet_ntoa(*ip));
+		SAFE_FREE(*ipstr_list);
+	} else {
+		asprintf(&new_ipstr, "%s", inet_ntoa(*ip));
+	}
+	*ipstr_list = new_ipstr;
+	return *ipstr_list;
+}
+
+
+/**
+ * Allocate and initialise an ipstr list using ip adresses
+ * passed as arguments.
+ *
+ * @param ipstr_list pointer to string meant to be allocated and set
+ * @param ip_list array of ip addresses to place in the list
+ * @param ip_count number of addresses stored in ip_list
+ * @return pointer to allocated ip string
+ **/
+ 
+char* ipstr_list_make(char** ipstr_list, const struct in_addr* ip_list, int ip_count)
+{
+	int i;
+	
+	/* arguments checking */
+	if (!ip_list && !ipstr_list) return 0;
+
+	*ipstr_list = NULL;
+	
+	/* process ip addresses given as arguments */
+	for (i = 0; i < ip_count; i++)
+		*ipstr_list = ipstr_list_add(ipstr_list, &ip_list[i]);
+	
+	return (*ipstr_list);
+}
+
+
+/**
+ * Parse given ip string list into array of ip addresses
+ * (as in_addr structures)
+ *
+ * @param ipstr ip string list to be parsed 
+ * @param ip_list pointer to array of ip addresses which is
+ *        allocated by this function and must be freed by caller
+ * @return number of succesfully parsed addresses
+ **/
+ 
+int ipstr_list_parse(const char* ipstr_list, struct in_addr** ip_list)
+{
+	fstring token_str;
+	int count;
+
+	if (!ipstr_list || !ip_list) return 0;
+	
+	for (*ip_list = NULL, count = 0;
+	     next_token(&ipstr_list, token_str, IPSTR_LIST_SEP, FSTRING_LEN);
+	     count++) {
+	     
+		struct in_addr addr;
+
+		/* convert single token to ip address */
+		if ( (addr.s_addr = inet_addr(token_str)) == INADDR_NONE )
+			break;
+		
+		/* prepare place for another in_addr structure */
+		*ip_list = Realloc(*ip_list, (count + 1) * sizeof(struct in_addr));
+		if (!*ip_list) return -1;
+		
+		(*ip_list)[count] = addr;
+	}
+	
+	return count;
+}
+
+
+/**
+ * Safely free ip string list
+ *
+ * @param ipstr_list ip string list to be freed
+ **/
+
+void ipstr_list_free(char* ipstr_list)
+{
+	SAFE_FREE(ipstr_list);
+}
+
+
+/***********************************************************
+ Unescape a URL encoded string, in place.
+***********************************************************/
+
+void rfc1738_unescape(char *buf)
+{
+	char *p=buf;
+
+	while ((p=strchr_m(p,'+')))
+		*p = ' ';
+
+	p = buf;
+
+	while (p && *p && (p=strchr_m(p,'%'))) {
+		int c1 = p[1];
+		int c2 = p[2];
+
+		if (c1 >= '0' && c1 <= '9')
+			c1 = c1 - '0';
+		else if (c1 >= 'A' && c1 <= 'F')
+			c1 = 10 + c1 - 'A';
+		else if (c1 >= 'a' && c1 <= 'f')
+			c1 = 10 + c1 - 'a';
+		else {p++; continue;}
+
+		if (c2 >= '0' && c2 <= '9')
+			c2 = c2 - '0';
+		else if (c2 >= 'A' && c2 <= 'F')
+			c2 = 10 + c2 - 'A';
+		else if (c2 >= 'a' && c2 <= 'f')
+			c2 = 10 + c2 - 'a';
+		else {p++; continue;}
+			
+		*p = (c1<<4) | c2;
+
+		memmove(p+1, p+3, strlen(p+3)+1);
+		p++;
+	}
+}
+
+static const char *b64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
+
+/***************************************************************************
+decode a base64 string into a DATA_BLOB - simple and slow algorithm
+  ***************************************************************************/
+DATA_BLOB base64_decode_data_blob(const char *s)
+{
+	int bit_offset, byte_offset, idx, i, n;
+	DATA_BLOB decoded = data_blob(s, strlen(s)+1);
+	unsigned char *d = decoded.data;
+	char *p;
+
+	n=i=0;
+
+	while (*s && (p=strchr_m(b64,*s))) {
+		idx = (int)(p - b64);
+		byte_offset = (i*6)/8;
+		bit_offset = (i*6)%8;
+		d[byte_offset] &= ~((1<<(8-bit_offset))-1);
+		if (bit_offset < 3) {
+			d[byte_offset] |= (idx << (2-bit_offset));
+			n = byte_offset+1;
+		} else {
+			d[byte_offset] |= (idx >> (bit_offset-2));
+			d[byte_offset+1] = 0;
+			d[byte_offset+1] |= (idx << (8-(bit_offset-2))) & 0xFF;
+			n = byte_offset+2;
+		}
+		s++; i++;
+	}
+
+	/* fix up length */
+	decoded.length = n;
+	return decoded;
+}
+
+/***************************************************************************
+decode a base64 string in-place - wrapper for the above
+***************************************************************************/
+void base64_decode(char *s)
+{
+	DATA_BLOB decoded = base64_decode_data_blob(s);
+	memcpy(s, decoded.data, decoded.length);
+	data_blob_free(&decoded);
+
+	/* null terminate */
+	s[decoded.length] = '\0';
+}
+
+/***************************************************************************
+encode a base64 string into a malloc()ed string caller to free.
+
+From SQUID: adopted from http://ftp.sunet.se/pub2/gnu/vm/base64-encode.c with adjustments
+***************************************************************************/
+char * base64_encode_data_blob(DATA_BLOB data)
+{
+	int bits = 0;
+	int char_count = 0;
+	size_t out_cnt = 0;
+	size_t len = data.length;
+	size_t output_len = data.length * 2;
+	char *result = malloc(output_len); /* get us plenty of space */
+
+	while (len-- && out_cnt < (data.length * 2) - 5) {
+		int c = (unsigned char) *(data.data++);
+		bits += c;
+		char_count++;
+		if (char_count == 3) {
+			result[out_cnt++] = b64[bits >> 18];
+			result[out_cnt++] = b64[(bits >> 12) & 0x3f];
+			result[out_cnt++] = b64[(bits >> 6) & 0x3f];
+	    result[out_cnt++] = b64[bits & 0x3f];
+	    bits = 0;
+	    char_count = 0;
+	} else {
+	    bits <<= 8;
+	}
+    }
+    if (char_count != 0) {
+	bits <<= 16 - (8 * char_count);
+	result[out_cnt++] = b64[bits >> 18];
+	result[out_cnt++] = b64[(bits >> 12) & 0x3f];
+	if (char_count == 1) {
+	    result[out_cnt++] = '=';
+	    result[out_cnt++] = '=';
+	} else {
+	    result[out_cnt++] = b64[(bits >> 6) & 0x3f];
+	    result[out_cnt++] = '=';
+	}
+    }
+    result[out_cnt] = '\0';	/* terminate */
+    return result;
+}
+
+#ifdef VALGRIND
+size_t valgrind_strlen(const char *s)
+{
+	size_t count;
+	for(count = 0; *s++; count++)
+		;
+	return count;
+}
+#endif
diff -uNr samba-3.0alpha21.orig/source/lib/util_unistr.c samba-3.0alpha21/source/lib/util_unistr.c
--- samba-3.0alpha21.orig/source/lib/util_unistr.c	2003-02-16 19:06:31.000000000 -0600
+++ samba-3.0alpha21/source/lib/util_unistr.c	2003-02-16 19:05:45.000000000 -0600
@@ -169,6 +169,7 @@
  */ 
 int rpcstr_pull(char* dest, void *src, int dest_len, int src_len, int flags)
 {
+	if (!src) return 0;
 	if(dest_len==-1) dest_len=MAXUNI-3;
 	return pull_ucs2(NULL, dest, src, dest_len, src_len, flags|STR_UNICODE|STR_NOALIGN);
 }
diff -uNr samba-3.0alpha21.orig/source/lib/util_uuid.c samba-3.0alpha21/source/lib/util_uuid.c
--- samba-3.0alpha21.orig/source/lib/util_uuid.c	2003-02-16 19:06:31.000000000 -0600
+++ samba-3.0alpha21/source/lib/util_uuid.c	2003-02-16 19:05:45.000000000 -0600
@@ -71,7 +71,7 @@
 	uuid_pack(&uu, out);
 }
 
-char *uuid_to_string(const GUID in)
+char *guid_to_string(const GUID in)
 {
 	struct uuid uu;
 	char *out;
diff -uNr samba-3.0alpha21.orig/source/lib/wins_srv.c samba-3.0alpha21/source/lib/wins_srv.c
--- samba-3.0alpha21.orig/source/lib/wins_srv.c	2003-02-16 19:06:31.000000000 -0600
+++ samba-3.0alpha21/source/lib/wins_srv.c	2003-02-16 19:05:45.000000000 -0600
@@ -3,6 +3,7 @@
    Samba wins server helper functions
    Copyright (C) Andrew Tridgell 1992-2002
    Copyright (C) Christopher R. Hertel 2000
+   Copyright (C) Tim Potter 2003
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -22,7 +23,7 @@
 #include "includes.h"
 
 /*
-  this is pretty much a complete rewrite of the earlier code. The main
+  This is pretty much a complete rewrite of the earlier code. The main
   aim of the rewrite is to add support for having multiple wins server
   lists, so Samba can register with multiple groups of wins servers
   and each group has a failover list of wins servers.
@@ -56,50 +57,48 @@
   confused yet? (tridge)
 */
 
-
 /* how long a server is marked dead for */
 #define DEATH_TIME 600
 
-/* a list of wins server that are marked dead from the point of view
-   of a given source address. We keep a separate dead list for each src address
-   to cope with multiple interfaces that are not routable to each other
+/* The list of dead wins servers is stored in gencache.tdb.  Each server is
+   marked dead from the point of view of a given source address. We keep a 
+   separate dead list for each src address to cope with multiple interfaces 
+   that are not routable to each other.
   */
-static struct wins_dead {
-	struct in_addr dest_ip;
-	struct in_addr src_ip;
-	time_t revival; /* when it will be revived */
-	struct wins_dead *next, *prev;
-} *dead_servers;
 
-/* an internal convenience structure for an IP with a short string tag
-   attached */
-struct tagged_ip {
-	fstring tag;
-	struct in_addr ip;
-};
+#define WINS_SRV_FMT "WINS_SRV_DEAD/%s,%s" /* wins_ip,src_ip */
+
+static char *wins_srv_keystr(struct in_addr wins_ip, struct in_addr src_ip)
+{
+	char *keystr;
+
+	if (asprintf(&keystr, WINS_SRV_FMT, inet_ntoa(wins_ip),
+		     inet_ntoa(src_ip)) == -1) {
+		DEBUG(0, ("wins_srv_is_dead: malloc error\n"));
+		return NULL;
+	}
+
+	return keystr;
+}
 
 /*
   see if an ip is on the dead list
 */
+
 BOOL wins_srv_is_dead(struct in_addr wins_ip, struct in_addr src_ip)
 {
-	struct wins_dead *d;
-	for (d=dead_servers; d; d=d->next) {
-		if (ip_equal(wins_ip, d->dest_ip) && ip_equal(src_ip, d->src_ip)) {
-			/* it might be due for revival */
-			if (d->revival <= time(NULL)) {
-				fstring src_name;
-				fstrcpy(src_name, inet_ntoa(src_ip));
-				DEBUG(4,("Reviving wins server %s for source %s\n", 
-					 inet_ntoa(wins_ip), src_name));
-				DLIST_REMOVE(dead_servers, d);
-				free(d);
-				return False;
-			}
-			return True;
-		}
-	}
-	return False;
+	char *keystr = wins_srv_keystr(wins_ip, src_ip);
+	BOOL result;
+
+	/* If the key exists then the WINS server has been marked as dead */
+
+	result = gencache_get(keystr, NULL, NULL);
+	SAFE_FREE(keystr);
+
+	DEBUG(4, ("wins_srv_is_dead: %s is %s\n", inet_ntoa(wins_ip),
+		  result ? "dead" : "alive"));
+
+	return result;
 }
 
 
@@ -108,45 +107,33 @@
 */
 void wins_srv_alive(struct in_addr wins_ip, struct in_addr src_ip)
 {
-	struct wins_dead *d;
-	for (d=dead_servers; d; d=d->next) {
-		if (ip_equal(wins_ip, d->dest_ip) && ip_equal(src_ip, d->src_ip)) {
-			fstring src_name;
-			fstrcpy(src_name, inet_ntoa(src_ip));
-			DEBUG(4,("Reviving wins server %s for source %s\n", 
-				 inet_ntoa(wins_ip), src_name));
-			DLIST_REMOVE(dead_servers, d);
-			return;
-		}
-	}
-}
+	char *keystr = wins_srv_keystr(wins_ip, src_ip);
 
+	gencache_del(keystr);
+	SAFE_FREE(keystr);
+
+	DEBUG(4, ("wins_srv_alive: marking wins server %s alive\n", 
+		  inet_ntoa(wins_ip)));
+}
 
 /*
   mark a wins server as temporarily dead
 */
 void wins_srv_died(struct in_addr wins_ip, struct in_addr src_ip)
 {
-	struct wins_dead *d;
-	fstring src_name;
+	char *keystr;
 
-	if (is_zero_ip(wins_ip) || wins_srv_is_dead(wins_ip, src_ip)) {
+	if (is_zero_ip(wins_ip) || wins_srv_is_dead(wins_ip, src_ip))
 		return;
-	}
-
-	d = (struct wins_dead *)malloc(sizeof(*d));
-	if (!d) return;
 
-	d->dest_ip = wins_ip;
-	d->src_ip = src_ip;
-	d->revival = time(NULL) + DEATH_TIME;
+	keystr = wins_srv_keystr(wins_ip, src_ip);
 
-	fstrcpy(src_name, inet_ntoa(src_ip));
+	gencache_set(keystr, "DOWN", time(NULL) + DEATH_TIME);
 
-	DEBUG(4,("Marking wins server %s dead for %u seconds from source %s\n", 
-		 inet_ntoa(wins_ip), DEATH_TIME, src_name));
+	SAFE_FREE(keystr);
 
-	DLIST_ADD(dead_servers, d);
+	DEBUG(4,("Marking wins server %s dead for %u seconds from source %s\n",
+		 inet_ntoa(wins_ip), DEATH_TIME, inet_ntoa(src_ip)));
 }
 
 /*
@@ -169,6 +156,13 @@
 	return count;
 }
 
+/* an internal convenience structure for an IP with a short string tag
+   attached */
+struct tagged_ip {
+	fstring tag;
+	struct in_addr ip;
+};
+
 /*
   parse an IP string that might be in tagged format
   the result is a tagged_ip structure containing the tag
diff -uNr samba-3.0alpha21.orig/source/lib/xfile.c samba-3.0alpha21/source/lib/xfile.c
--- samba-3.0alpha21.orig/source/lib/xfile.c	2003-02-16 19:06:31.000000000 -0600
+++ samba-3.0alpha21/source/lib/xfile.c	2003-02-16 19:05:45.000000000 -0600
@@ -184,7 +184,7 @@
 }
 
 /* thank goodness for asprintf() */
-int x_vfprintf(XFILE *f, const char *format, va_list ap)
+ int x_vfprintf(XFILE *f, const char *format, va_list ap)
 {
 	char *p;
 	int len, ret;
@@ -199,7 +199,7 @@
 	return ret;
 }
 
-int x_fprintf(XFILE *f, const char *format, ...)
+ int x_fprintf(XFILE *f, const char *format, ...)
 {
 	va_list ap;
 	int ret;
diff -uNr samba-3.0alpha21.orig/source/libads/ads_struct.c samba-3.0alpha21/source/libads/ads_struct.c
--- samba-3.0alpha21.orig/source/libads/ads_struct.c	2003-02-16 19:06:31.000000000 -0600
+++ samba-3.0alpha21/source/libads/ads_struct.c	2003-02-16 19:05:45.000000000 -0600
@@ -33,32 +33,34 @@
 	
 	r = strdup(realm);
 
-	if (!r || !*r) return r;
+	if (!r || !*r)
+		return r;
 
-	for (p=r; *p; p++) {
-		if (strchr(sep, *p)) numbits++;
-	}
+	for (p=r; *p; p++)
+		if (strchr(sep, *p))
+			numbits++;
 
 	len = (numbits+1)*(strlen(field)+1) + strlen(r) + 1;
 
 	ret = malloc(len);
+	if (!ret)
+		return NULL;
+
 	strlcpy(ret,field, len);
 	p=strtok(r,sep); 
 	strlcat(ret, p, len);
 
 	while ((p=strtok(NULL,sep))) {
 		char *s;
-		if (reverse) {
+		if (reverse)
 			asprintf(&s, "%s%s,%s", field, p, ret);
-		} else {
+		else
 			asprintf(&s, "%s,%s%s", ret, field, p);
-		}
 		free(ret);
 		ret = s;
 	}
 
 	free(r);
-
 	return ret;
 }
 
@@ -94,10 +96,10 @@
 
 	/* we need to know if this is a foreign realm to know if we can
 	   use lp_ads_server() */
-	if (realm && strcasecmp(lp_realm(), realm) != 0) {
+	if (realm && *realm && strcasecmp(lp_realm(), realm) != 0) {
 		ads->server.foreign = 1;
 	}
-	if (workgroup && strcasecmp(lp_workgroup(), workgroup) != 0) {
+	if (workgroup && *workgroup && strcasecmp(lp_workgroup(), workgroup) != 0) {
 		ads->server.foreign = 1;
 	}
 
diff -uNr samba-3.0alpha21.orig/source/libads/disp_sec.c samba-3.0alpha21/source/libads/disp_sec.c
--- samba-3.0alpha21.orig/source/libads/disp_sec.c	2003-02-16 19:06:31.000000000 -0600
+++ samba-3.0alpha21/source/libads/disp_sec.c	2003-02-16 19:05:45.000000000 -0600
@@ -22,7 +22,7 @@
 
 static struct perm_mask_str {
 	uint32  mask;
-	char   *str;
+	const char   *str;
 } perms[] = {
 	{SEC_RIGHTS_FULL_CTRL,		"[Full Control]"},
 
@@ -83,7 +83,7 @@
 /* display ACE */
 static void ads_disp_ace(SEC_ACE *sec_ace)
 {
-	char *access_type = "UNKNOWN";
+	const char *access_type = "UNKNOWN";
 
 	if (!sec_ace_object(sec_ace->type)) {
 		printf("------- ACE (type: 0x%02x, flags: 0x%02x, size: 0x%02x, mask: 0x%x)\n", 
@@ -121,7 +121,7 @@
 }
 
 /* display ACL */
-static void ads_disp_acl(SEC_ACL *sec_acl, char *type)
+static void ads_disp_acl(SEC_ACL *sec_acl, const char *type)
 {
         if (!sec_acl)
 		printf("------- (%s) ACL not present\n", type);
diff -uNr samba-3.0alpha21.orig/source/libads/kerberos_verify.c samba-3.0alpha21/source/libads/kerberos_verify.c
--- samba-3.0alpha21.orig/source/libads/kerberos_verify.c	2003-02-16 19:06:31.000000000 -0600
+++ samba-3.0alpha21/source/libads/kerberos_verify.c	2003-02-16 19:05:45.000000000 -0600
@@ -36,8 +36,6 @@
 	krb5_keytab keytab = NULL;
 	krb5_data packet;
 	krb5_ticket *tkt = NULL;
-	krb5_data salt;
-	krb5_encrypt_block eblock;
 	int ret;
 	krb5_keyblock * key;
 	krb5_principal host_princ;
@@ -91,24 +89,15 @@
 		return NT_STATUS_LOGON_FAILURE;
 	}
 
-	ret = krb5_principal2salt(context, host_princ, &salt);
-	if (ret) {
-		DEBUG(1,("krb5_principal2salt failed (%s)\n", error_message(ret)));
-		return NT_STATUS_LOGON_FAILURE;
-	}
-    
 	if (!(key = (krb5_keyblock *)malloc(sizeof(*key)))) {
 		return NT_STATUS_NO_MEMORY;
 	}
 	
-	krb5_use_enctype(context, &eblock, ENCTYPE_DES_CBC_MD5);
-	
-	ret = krb5_string_to_key(context, &eblock, key, &password, &salt);
-	if (ret) {
-		DEBUG(1,("krb5_string_to_key failed (%s)\n", error_message(ret)));
+	if (create_kerberos_key_from_string(context, host_princ, &password, key)) {
+		SAFE_FREE(key);
 		return NT_STATUS_LOGON_FAILURE;
 	}
-
+    
 	krb5_auth_con_setuseruserkey(context, auth_context, key);
 
 	packet.length = ticket->length;
@@ -125,10 +114,7 @@
 		return NT_STATUS_LOGON_FAILURE;
 	}
 
-	if (tkt->enc_part2) {
-		*auth_data = data_blob(tkt->enc_part2->authorization_data[0]->contents,
-				       tkt->enc_part2->authorization_data[0]->length);
-	}
+	get_auth_data_from_tkt(auth_data, tkt);
 
 #if 0
 	if (tkt->enc_part2) {
@@ -138,7 +124,7 @@
 	}
 #endif
 
-	if ((ret = krb5_unparse_name(context, tkt->enc_part2->client, principal))) {
+	if ((ret = krb5_unparse_name(context, get_principal_from_tkt(tkt), principal))) {
 		DEBUG(3,("krb5_unparse_name failed (%s)\n", 
 			 error_message(ret)));
 		return NT_STATUS_LOGON_FAILURE;
diff -uNr samba-3.0alpha21.orig/source/libads/krb5_setpw.c samba-3.0alpha21/source/libads/krb5_setpw.c
--- samba-3.0alpha21.orig/source/libads/krb5_setpw.c	2003-02-16 19:06:31.000000000 -0600
+++ samba-3.0alpha21/source/libads/krb5_setpw.c	2003-02-16 19:05:45.000000000 -0600
@@ -139,13 +139,19 @@
 	}
 
 	packet->data = (char *)malloc(ap_req->length + cipherpw.length + 6);
+	if (!packet->data)
+		return -1;
 
 	/* see the RFC for details */
-	p = packet->data + 2;
-	RSSVAL(p, 0, 0xff80); p += 2;
-	RSSVAL(p, 0, ap_req->length); p += 2;
-	memcpy(p, ap_req->data, ap_req->length); p += ap_req->length;
-	memcpy(p, cipherpw.data, cipherpw.length); p += cipherpw.length;
+	p = ((char *)packet->data) + 2;
+	RSSVAL(p, 0, 0xff80);
+	p += 2;
+	RSSVAL(p, 0, ap_req->length);
+	p += 2;
+	memcpy(p, ap_req->data, ap_req->length);
+	p += ap_req->length;
+	memcpy(p, cipherpw.data, cipherpw.length);
+	p += cipherpw.length;
 	packet->length = PTR_DIFF(p,packet->data);
 	RSSVAL(packet->data, 0, packet->length);
 	
@@ -172,10 +178,10 @@
 	
 	p = packet->data;
 	
-	if (packet->data[0] == 0x7e || packet->data[0] == 0x5e) {
+	if (((char *)packet->data)[0] == 0x7e || ((char *)packet->data)[0] == 0x5e) {
 		/* it's an error packet. We should parse it ... */
 		DEBUG(1,("Got error packet 0x%x from kpasswd server\n",
-			 packet->data[0]));
+			 ((char *)packet->data)[0]));
 		return KRB5KRB_AP_ERR_MODIFIED;
 	}
 	
@@ -196,7 +202,7 @@
 	
 	ap_rep.length = RSVAL(p, 0); p += 2;
 	
-	if (p + ap_rep.length >= packet->data + packet->length) {
+	if (p + ap_rep.length >= (char *)packet->data + packet->length) {
 		DEBUG(1,("ptr beyond end of packet from kpasswd server\n"));
 		return KRB5KRB_AP_ERR_MODIFIED;
 	}
@@ -219,7 +225,7 @@
 	krb5_free_ap_rep_enc_part(context, ap_rep_enc);
 	
 	cipherresult.data = p;
-	cipherresult.length = (packet->data + packet->length) - p;
+	cipherresult.length = ((char *)packet->data + packet->length) - p;
 		
 	ret = krb5_rd_priv(context, auth_context, &cipherresult, &clearresult,
 			   &replay);
@@ -353,12 +359,8 @@
 	addr_len = sizeof(local_addr);
 	getsockname(sock, &local_addr, &addr_len);
 	
-	remote_kaddr.addrtype = ADDRTYPE_INET;
-	remote_kaddr.length = sizeof(((struct sockaddr_in *)&remote_addr)->sin_addr);
-	remote_kaddr.contents = (char *)&(((struct sockaddr_in *)&remote_addr)->sin_addr);
-	local_kaddr.addrtype = ADDRTYPE_INET;
-	local_kaddr.length = sizeof(((struct sockaddr_in *)&local_addr)->sin_addr);
-	local_kaddr.contents = (char *)&(((struct sockaddr_in *)&local_addr)->sin_addr);
+	setup_kaddr(&remote_kaddr, &remote_addr);
+	setup_kaddr(&local_kaddr, &local_addr);
 
 	ret = krb5_auth_con_setaddrs(context, auth_context, &local_kaddr, NULL);
 	if (ret) {
@@ -401,6 +403,17 @@
 
 	chpw_rep.length = 1500;
 	chpw_rep.data = (char *) malloc(chpw_rep.length);
+	if (!chpw_rep.data) {
+	        close(sock);
+	        free(ap_req.data);
+	        krb5_free_creds(context, credsp);
+		krb5_free_principal(context, creds.client);
+		krb5_free_principal(context, principal);
+		krb5_free_context(context);
+		DEBUG(1,("send of chpw failed (%s)\n", strerror(errno)));
+		errno = ENOMEM;
+		return ADS_ERROR_SYSTEM(errno);
+	}
 
 	ret = read(sock, chpw_rep.data, chpw_rep.length);
 	if (ret < 0) {
diff -uNr samba-3.0alpha21.orig/source/libads/ldap.c samba-3.0alpha21/source/libads/ldap.c
--- samba-3.0alpha21.orig/source/libads/ldap.c	2003-02-16 19:06:31.000000000 -0600
+++ samba-3.0alpha21/source/libads/ldap.c	2003-02-16 19:05:45.000000000 -0600
@@ -326,6 +326,8 @@
 	if (!in_val) return NULL;
 
 	value = talloc_zero(ctx, sizeof(struct berval));
+	if (value == NULL)
+		return NULL;
 	if (in_val->bv_len == 0) return value;
 
 	value->bv_len = in_val->bv_len;
@@ -420,7 +422,7 @@
 
 	*res = NULL;
 
-	if (!(ctx = talloc_init()))
+	if (!(ctx = talloc_init("ads_do_paged_search")))
 		return ADS_ERROR(LDAP_NO_MEMORY);
 
 	/* 0 means the conversion worked but the result was empty 
@@ -642,7 +644,7 @@
 	char *utf8_exp, *utf8_path, **search_attrs = NULL;
 	TALLOC_CTX *ctx;
 
-	if (!(ctx = talloc_init())) {
+	if (!(ctx = talloc_init("ads_do_search"))) {
 		DEBUG(1,("ads_do_search: talloc_init() failed!"));
 		return ADS_ERROR(LDAP_NO_MEMORY);
 	}
@@ -972,7 +974,7 @@
 	/* make sure the end of the list is NULL */
 	mods[i] = NULL;
 
-	ret = ldap_add_s(ads->ld, utf8_dn ? utf8_dn : new_dn, mods);
+	ret = ldap_add_s(ads->ld, utf8_dn, mods);
 	SAFE_FREE(utf8_dn);
 	return ADS_ERROR(ret);
 }
@@ -992,7 +994,7 @@
 		return ADS_ERROR_NT(NT_STATUS_NO_MEMORY);
 	}
 	
-	ret = ldap_delete(ads->ld, utf8_dn ? utf8_dn : del_dn);
+	ret = ldap_delete(ads->ld, utf8_dn);
 	return ADS_ERROR(ret);
 }
 
@@ -1027,11 +1029,11 @@
 	ADS_MODLIST mods;
 	const char *objectClass[] = {"top", "person", "organizationalPerson",
 				     "user", "computer", NULL};
-	const char *servicePrincipalName[3] = {NULL, NULL, NULL};
-	char *psp;
+	const char *servicePrincipalName[5] = {NULL, NULL, NULL, NULL, NULL};
+	char *psp, *psp2;
 	unsigned acct_control;
 
-	if (!(ctx = talloc_init_named("machine_account")))
+	if (!(ctx = talloc_init("machine_account")))
 		return ADS_ERROR(LDAP_NO_MEMORY);
 
 	ret = ADS_ERROR(LDAP_NO_MEMORY);
@@ -1049,10 +1051,16 @@
 				 ads->config.bind_path);
 	servicePrincipalName[0] = talloc_asprintf(ctx, "HOST/%s", hostname);
 	psp = talloc_asprintf(ctx, "HOST/%s.%s", 
-						  hostname, 
-						  ads->config.realm);
+			      hostname, 
+			      ads->config.realm);
 	strlower(&psp[5]);
 	servicePrincipalName[1] = psp;
+	servicePrincipalName[2] = talloc_asprintf(ctx, "CIFS/%s", hostname);
+	psp2 = talloc_asprintf(ctx, "CIFS/%s.%s", 
+			       hostname, 
+			       ads->config.realm);
+	strlower(&psp2[5]);
+	servicePrincipalName[3] = psp2;
 
 	free(ou_str);
 	if (!new_dn)
@@ -1144,13 +1152,13 @@
 	SEC_DESC   *psd = 0;
 	TALLOC_CTX *ctx = 0;
 
-	if (!(ctx = talloc_init_named("sec_io_desc")))
+	if (!(ctx = talloc_init("sec_io_desc")))
 		return;
 
 	/* prepare data */
 	prs_init(&ps, values[0]->bv_len, ctx, UNMARSHALL);
-	prs_append_data(&ps, values[0]->bv_val, values[0]->bv_len);
-	ps.data_offset = 0;
+	prs_copy_data_in(&ps, values[0]->bv_val, values[0]->bv_len);
+	prs_set_offset(&ps,0);
 
 	/* parse secdesc */
 	if (!sec_io_desc("sd", &psd, &ps, 1)) {
@@ -1182,8 +1190,8 @@
 
 static BOOL ads_dump_field(char *field, void **values, void *data_area)
 {
-	struct {
-		char *name;
+	const struct {
+		const char *name;
 		BOOL string;
 		void (*handler)(const char *, struct berval **);
 	} handlers[] = {
@@ -1246,7 +1254,7 @@
 	void *msg;
 	TALLOC_CTX *ctx;
 
-	if (!(ctx = talloc_init()))
+	if (!(ctx = talloc_init("ads_process_results")))
 		return;
 
 	for (msg = ads_first_entry(ads, res); msg; 
@@ -1403,6 +1411,7 @@
 	size_t          sd_size = 0;
 	struct berval   bval = {0, NULL};
 	prs_struct      ps_wire;
+	char           *escaped_hostname = escape_ldap_string_alloc(hostname);
 
 	LDAPMessage *res  = 0;
 	LDAPMessage *msg  = 0;
@@ -1418,18 +1427,29 @@
 
 	ret = ADS_ERROR(LDAP_SUCCESS);
 
-	if (asprintf(&exp, "(samAccountName=%s$)", hostname) == -1) {
+	if (!escaped_hostname) {
+		return ADS_ERROR_NT(NT_STATUS_NO_MEMORY);
+	}
+
+	if (asprintf(&exp, "(samAccountName=%s$)", escaped_hostname) == -1) {
 		DEBUG(1, ("ads_set_machine_sd: asprintf failed!\n"));
+		SAFE_FREE(escaped_hostname);
 		return ADS_ERROR_NT(NT_STATUS_NO_MEMORY);
 	}
 
+	SAFE_FREE(escaped_hostname);
+
 	ret = ads_search(ads, (void *) &res, exp, attrs);
 
 	if (!ADS_ERR_OK(ret)) return ret;
 
-	msg   = ads_first_entry(ads, res);
+	if ( !(msg = ads_first_entry(ads, res) )) {
+		ret = ADS_ERROR(LDAP_NO_RESULTS_RETURNED);
+		goto ads_set_sd_error;
+	}
+
 	ads_pull_sid(ads, msg, attrs[1], &sid);	
-	if (!(ctx = talloc_init_named("sec_io_desc"))) {
+	if (!(ctx = talloc_init("sec_io_desc"))) {
 		ret =  ADS_ERROR(LDAP_NO_MEMORY);
 		goto ads_set_sd_error;
 	}
@@ -1458,7 +1478,13 @@
 	if (!(mods = ads_init_mods(ctx))) return ADS_ERROR(LDAP_NO_MEMORY);
 
 	bval.bv_len = sd_size;
-	bval.bv_val = prs_data_p(&ps_wire);
+	bval.bv_val = talloc(ctx, sd_size);
+	if (!bval.bv_val) {
+		ret = ADS_ERROR(LDAP_NO_MEMORY);
+		goto ads_set_sd_error;
+	}
+	prs_copy_all_data_out((char *)&bval.bv_val, &ps_wire);
+
 	ads_mod_ber(ctx, &mods, attrs[0], &bval);
 	ret = ads_gen_mod(ads, dn, mods);
 
@@ -1508,7 +1534,8 @@
 	int rc;
 
 	values = ldap_get_values(ads->ld, msg, field);
-	if (!values) return NULL;
+	if (!values)
+		return NULL;
 	
 	if (values[0]) {
 		rc = pull_utf8_talloc(mem_ctx, &ux_string, 
@@ -1537,15 +1564,22 @@
 	int i, n;
 
 	values = ldap_get_values(ads->ld, msg, field);
-	if (!values) return NULL;
+	if (!values)
+		return NULL;
 
-	for (i=0;values[i];i++) /* noop */ ;
+	for (i=0;values[i];i++)
+		/* noop */ ;
 	n = i;
 
 	ret = talloc(mem_ctx, sizeof(char *) * (n+1));
+	if (!ret) {
+		ldap_value_free(values);
+		return NULL;
+	}
 
 	for (i=0;i<n;i++) {
 		if (pull_utf8_talloc(mem_ctx, &ret[i], values[i]) == -1) {
+			ldap_value_free(values);
 			return NULL;
 		}
 	}
@@ -1570,7 +1604,8 @@
 	char **values;
 
 	values = ldap_get_values(ads->ld, msg, field);
-	if (!values) return False;
+	if (!values)
+		return False;
 	if (!values[0]) {
 		ldap_value_free(values);
 		return False;
@@ -1582,6 +1617,33 @@
 }
 
 /**
+ * pull a single objectGUID from an ADS result
+ * @param ads connection to ADS server
+ * @param msg results of search
+ * @param guid 37-byte area to receive text guid
+ * @return boolean indicating success
+ **/
+BOOL ads_pull_guid(ADS_STRUCT *ads,
+		   void *msg, GUID *guid)
+{
+	char **values;
+
+	values = ldap_get_values(ads->ld, msg, "objectGUID");
+	if (!values)
+		return False;
+	
+	if (values[0]) {
+		memcpy(guid, values[0], sizeof(GUID));
+		ldap_value_free(values);
+		return True;
+	}
+	ldap_value_free(values);
+	return False;
+
+}
+
+
+/**
  * pull a single DOM_SID from a ADS result
  * @param ads connection to ads server
  * @param msg Results of search
@@ -1597,11 +1659,11 @@
 
 	values = ldap_get_values_len(ads->ld, msg, field);
 
-	if (!values) return False;
+	if (!values)
+		return False;
 
-	if (values[0]) {
+	if (values[0])
 		ret = sid_parse(values[0]->bv_val, values[0]->bv_len, sid);
-	}
 	
 	ldap_value_free_len(values);
 	return ret;
@@ -1625,16 +1687,23 @@
 
 	values = ldap_get_values_len(ads->ld, msg, field);
 
-	if (!values) return 0;
+	if (!values)
+		return 0;
 
-	for (i=0; values[i]; i++) /* nop */ ;
+	for (i=0; values[i]; i++)
+		/* nop */ ;
 
 	(*sids) = talloc(mem_ctx, sizeof(DOM_SID) * i);
+	if (!(*sids)) {
+		ldap_value_free_len(values);
+		return 0;
+	}
 
 	count = 0;
 	for (i=0; values[i]; i++) {
 		ret = sid_parse(values[i]->bv_val, values[i]->bv_len, &(*sids)[count]);
-		if (ret) count++;
+		if (ret)
+			count++;
 	}
 	
 	ldap_value_free_len(values);
@@ -1663,8 +1732,8 @@
 
 	if (values[0]) {
 		prs_init(&ps, values[0]->bv_len, mem_ctx, UNMARSHALL);
-		prs_append_data(&ps, values[0]->bv_val, values[0]->bv_len);
-		ps.data_offset = 0;
+		prs_copy_data_in(&ps, values[0]->bv_val, values[0]->bv_len);
+		prs_set_offset(&ps,0);
 
 		ret = sec_io_desc("sd", sd, &ps, 1);
 	}
@@ -1759,7 +1828,7 @@
 	char *timestr;
 	TALLOC_CTX *ctx;
 
-	if (!(ctx = talloc_init())) {
+	if (!(ctx = talloc_init("ads_server_info"))) {
 		return ADS_ERROR(LDAP_NO_MEMORY);
 	}
 
@@ -1918,6 +1987,13 @@
    for the domain, but there isn't a simple query to do this. Instead
    we look for the principle names on the DCs account and find one that has 
    the right form, then extract the netbios name of the domain from that
+
+   NOTE! better method is this:
+
+bin/net -Uadministrator%XXXXX ads search '(&(objectclass=crossref)(dnsroot=VNET3.HOME.SAMBA.ORG))'  nETBIOSName 
+
+but you need to force the bind path to match the configurationNamingContext from the rootDSE
+
 */
 ADS_STATUS ads_workgroup_name(ADS_STRUCT *ads, TALLOC_CTX *mem_ctx, char **workgroup)
 {
diff -uNr samba-3.0alpha21.orig/source/libads/ldap_printer.c samba-3.0alpha21/source/libads/ldap_printer.c
--- samba-3.0alpha21.orig/source/libads/ldap_printer.c	2003-02-16 19:06:31.000000000 -0600
+++ samba-3.0alpha21/source/libads/ldap_printer.c	2003-02-16 19:05:45.000000000 -0600
@@ -167,7 +167,7 @@
 }
 
 struct valmap_to_ads {
-	char *valname;
+	const char *valname;
 	BOOL (*fn)(TALLOC_CTX *, ADS_MODLIST *, const REGISTRY_VALUE *);
 };
 
@@ -177,58 +177,59 @@
 static void map_regval_to_ads(TALLOC_CTX *ctx, ADS_MODLIST *mods, 
 			      REGISTRY_VALUE *value)
 {
-	struct valmap_to_ads map[] = {
-		{"assetNumber", map_sz},
-		{"bytesPerMinute", map_dword},
-		{"defaultPriority", map_dword},
-		{"driverName", map_sz},
-		{"driverVersion", map_dword},
-		{"flags", map_dword},
-		{"location", map_sz},
-		{"operatingSystem", map_sz},
-		{"operatingSystemHotfix", map_sz},
-		{"operatingSystemServicePack", map_sz},
-		{"operatingSystemVersion", map_sz},
-		{"portName", map_multi_sz},
-		{"printAttributes", map_dword},
-		{"printBinNames", map_multi_sz},
-		{"printCollate", map_bool},
-		{"printColor", map_bool},
-		{"printDuplexSupported", map_bool},
-		{"printEndTime", map_dword},
-		{"printFormName", map_sz},
-		{"printKeepPrintedJobs", map_bool},
-		{"printLanguage", map_multi_sz},
-		{"printMACAddress", map_sz},
-		{"printMaxCopies", map_sz},
-		{"printMaxResolutionSupported", map_dword},
-		{"printMaxXExtent", map_dword},
-		{"printMaxYExtent", map_dword},
-		{"printMediaReady", map_multi_sz},
-		{"printMediaSupported", map_multi_sz},
-		{"printMemory", map_dword},
-		{"printMinXExtent", map_dword},
-		{"printMinYExtent", map_dword},
-		{"printNetworkAddress", map_sz},
-		{"printNotify", map_sz},
-		{"printNumberUp", map_dword},
-		{"printOrientationsSupported", map_multi_sz},
-		{"printOwner", map_sz},
-		{"printPagesPerMinute", map_dword},
-		{"printRate", map_dword},
-		{"printRateUnit", map_sz},
-		{"printSeparatorFile", map_sz},
-		{"printShareName", map_sz},
-		{"printSpooling", map_sz},
-		{"printStaplingSupported", map_bool},
-		{"printStartTime", map_dword},
-		{"printStatus", map_sz},
-		{"priority", map_dword},
-		{"serverName", map_sz},
-		{"shortServerName", map_sz},
-		{"uNCName", map_sz},
-		{"url", map_sz},
-		{"versionNumber", map_dword},
+	const struct valmap_to_ads map[] = {
+		{SPOOL_REG_ASSETNUMBER, map_sz},
+		{SPOOL_REG_BYTESPERMINUTE, map_dword},
+		{SPOOL_REG_DEFAULTPRIORITY, map_dword},
+		{SPOOL_REG_DESCRIPTION, map_sz},
+		{SPOOL_REG_DRIVERNAME, map_sz},
+		{SPOOL_REG_DRIVERVERSION, map_dword},
+		{SPOOL_REG_FLAGS, map_dword},
+		{SPOOL_REG_LOCATION, map_sz},
+		{SPOOL_REG_OPERATINGSYSTEM, map_sz},
+		{SPOOL_REG_OPERATINGSYSTEMHOTFIX, map_sz},
+		{SPOOL_REG_OPERATINGSYSTEMSERVICEPACK, map_sz},
+		{SPOOL_REG_OPERATINGSYSTEMVERSION, map_sz},
+		{SPOOL_REG_PORTNAME, map_multi_sz},
+		{SPOOL_REG_PRINTATTRIBUTES, map_dword},
+		{SPOOL_REG_PRINTBINNAMES, map_multi_sz},
+		{SPOOL_REG_PRINTCOLLATE, map_bool},
+		{SPOOL_REG_PRINTCOLOR, map_bool},
+		{SPOOL_REG_PRINTDUPLEXSUPPORTED, map_bool},
+		{SPOOL_REG_PRINTENDTIME, map_dword},
+		{SPOOL_REG_PRINTFORMNAME, map_sz},
+		{SPOOL_REG_PRINTKEEPPRINTEDJOBS, map_bool},
+		{SPOOL_REG_PRINTLANGUAGE, map_multi_sz},
+		{SPOOL_REG_PRINTMACADDRESS, map_sz},
+		{SPOOL_REG_PRINTMAXCOPIES, map_sz},
+		{SPOOL_REG_PRINTMAXRESOLUTIONSUPPORTED, map_dword},
+		{SPOOL_REG_PRINTMAXXEXTENT, map_dword},
+		{SPOOL_REG_PRINTMAXYEXTENT, map_dword},
+		{SPOOL_REG_PRINTMEDIAREADY, map_multi_sz},
+		{SPOOL_REG_PRINTMEDIASUPPORTED, map_multi_sz},
+		{SPOOL_REG_PRINTMEMORY, map_dword},
+		{SPOOL_REG_PRINTMINXEXTENT, map_dword},
+		{SPOOL_REG_PRINTMINYEXTENT, map_dword},
+		{SPOOL_REG_PRINTNETWORKADDRESS, map_sz},
+		{SPOOL_REG_PRINTNOTIFY, map_sz},
+		{SPOOL_REG_PRINTNUMBERUP, map_dword},
+		{SPOOL_REG_PRINTORIENTATIONSSUPPORTED, map_multi_sz},
+		{SPOOL_REG_PRINTOWNER, map_sz},
+		{SPOOL_REG_PRINTPAGESPERMINUTE, map_dword},
+		{SPOOL_REG_PRINTRATE, map_dword},
+		{SPOOL_REG_PRINTRATEUNIT, map_sz},
+		{SPOOL_REG_PRINTSEPARATORFILE, map_sz},
+		{SPOOL_REG_PRINTSHARENAME, map_sz},
+		{SPOOL_REG_PRINTSPOOLING, map_sz},
+		{SPOOL_REG_PRINTSTAPLINGSUPPORTED, map_bool},
+		{SPOOL_REG_PRINTSTARTTIME, map_dword},
+		{SPOOL_REG_PRINTSTATUS, map_sz},
+		{SPOOL_REG_PRIORITY, map_dword},
+		{SPOOL_REG_SERVERNAME, map_sz},
+		{SPOOL_REG_SHORTSERVERNAME, map_sz},
+		{SPOOL_REG_UNCNAME, map_sz},
+		{SPOOL_REG_URL, map_sz},
+		{SPOOL_REG_VERSIONNUMBER, map_dword},
 		{NULL, NULL}
 	};
 	int i;
@@ -249,11 +250,12 @@
 WERROR get_remote_printer_publishing_data(struct cli_state *cli, 
 					  TALLOC_CTX *mem_ctx,
 					  ADS_MODLIST *mods,
-					  char *printer)
+					  const char *printer)
 {
 	WERROR result;
 	char *printername, *servername;
 	REGVAL_CTR dsdriver_ctr, dsspooler_ctr;
+	BOOL got_dsdriver = False, got_dsspooler = False;
 	uint32 needed, i;
 	POLICY_HND pol;
 
@@ -274,47 +276,50 @@
 	}
 	
 	result = cli_spoolss_enumprinterdataex(cli, mem_ctx, 0, &needed, 
-					       &pol, "DsDriver", NULL);
+					       &pol, SPOOL_DSDRIVER_KEY, NULL);
 
 	if (W_ERROR_V(result) == ERRmoredata)
 		result = cli_spoolss_enumprinterdataex(cli, mem_ctx, needed, 
-						       NULL, &pol, "DsDriver",
+						       NULL, &pol, 
+						       SPOOL_DSDRIVER_KEY,
 						       &dsdriver_ctr);
 
 	if (!W_ERROR_IS_OK(result)) {
 		DEBUG(3, ("Unable to do enumdataex on %s, error is %s.\n",
 			  printername, dos_errstr(result)));
-		cli_spoolss_close_printer(cli, mem_ctx, &pol);
-		return result;
-	}
-
-	/* Have the data we need now, so start building */
+	} else {
 
-	for (i=0; i < dsdriver_ctr.num_values; i++)
-		map_regval_to_ads(mem_ctx, mods, dsdriver_ctr.values[i]);
+		/* Have the data we need now, so start building */
+		got_dsdriver = True;
+		for (i=0; i < dsdriver_ctr.num_values; i++)
+			map_regval_to_ads(mem_ctx, mods, 
+					  dsdriver_ctr.values[i]);
+	}
 	
 	result = cli_spoolss_enumprinterdataex(cli, mem_ctx, 0, &needed, 
-					       &pol, "DsSpooler", NULL);
+					       &pol, SPOOL_DSSPOOLER_KEY, 
+					       NULL);
 
 	if (W_ERROR_V(result) == ERRmoredata)
 		result = cli_spoolss_enumprinterdataex(cli, mem_ctx, needed, 
-						       NULL, &pol, "DsSpooler",
+						       NULL, &pol, 
+						       SPOOL_DSSPOOLER_KEY,
 						       &dsspooler_ctr);
 
 	if (!W_ERROR_IS_OK(result)) {
 		DEBUG(3, ("Unable to do enumdataex on %s, error is %s.\n",
 			  printername, dos_errstr(result)));
-		regval_ctr_destroy(&dsdriver_ctr);
-		cli_spoolss_close_printer(cli, mem_ctx, &pol);
-		return result;
+	} else {
+		got_dsspooler = True;
+		for (i=0; i < dsspooler_ctr.num_values; i++)
+			map_regval_to_ads(mem_ctx, mods, 
+					  dsspooler_ctr.values[i]);
 	}
-	for (i=0; i < dsspooler_ctr.num_values; i++)
-		map_regval_to_ads(mem_ctx, mods, dsspooler_ctr.values[i]);
 	
-	ads_mod_str(mem_ctx, mods, "printerName", printername);
+	ads_mod_str(mem_ctx, mods, SPOOL_REG_PRINTERNAME, printer);
 
-	regval_ctr_destroy(&dsdriver_ctr);
-	regval_ctr_destroy(&dsspooler_ctr);
+	if (got_dsdriver) regval_ctr_destroy(&dsdriver_ctr);
+	if (got_dsspooler) regval_ctr_destroy(&dsspooler_ctr);
 	cli_spoolss_close_printer(cli, mem_ctx, &pol);
 
 	return result;
diff -uNr samba-3.0alpha21.orig/source/libads/ldap_user.c samba-3.0alpha21/source/libads/ldap_user.c
--- samba-3.0alpha21.orig/source/libads/ldap_user.c	2003-02-16 19:06:31.000000000 -0600
+++ samba-3.0alpha21/source/libads/ldap_user.c	2003-02-16 19:05:45.000000000 -0600
@@ -30,15 +30,20 @@
 	ADS_STATUS status;
 	char *exp;
 	const char *attrs[] = {"*", NULL};
+	char *escaped_user = escape_ldap_string_alloc(user);
+	if (!escaped_user) {
+		return ADS_ERROR(LDAP_NO_MEMORY);
+	}
 
-	asprintf(&exp, "(samAccountName=%s)", user);
+	asprintf(&exp, "(samAccountName=%s)", escaped_user);
 	status = ads_search(ads, res, exp, attrs);
-	free(exp);
+	SAFE_FREE(exp);
+	SAFE_FREE(escaped_user);
 	return status;
 }
 
 ADS_STATUS ads_add_user_acct(ADS_STRUCT *ads, const char *user, 
-			     const char *fullname)
+			     const char *container, const char *fullname)
 {
 	TALLOC_CTX *ctx;
 	ADS_MODLIST mods;
@@ -50,14 +55,14 @@
 	if (fullname && *fullname) name = fullname;
 	else name = user;
 
-	if (!(ctx = talloc_init_named("ads_add_user_acct")))
+	if (!(ctx = talloc_init("ads_add_user_acct")))
 		return ADS_ERROR(LDAP_NO_MEMORY);
 
 	status = ADS_ERROR(LDAP_NO_MEMORY);
 
 	if (!(upn = talloc_asprintf(ctx, "%s@%s", user, ads->config.realm)))
 		goto done;
-	if (!(new_dn = talloc_asprintf(ctx, "cn=%s,cn=Users,%s", name, 
+	if (!(new_dn = talloc_asprintf(ctx, "cn=%s,%s,%s", name, container,
 				       ads->config.bind_path)))
 		goto done;
 	if (!(controlstr = talloc_asprintf(ctx, "%u", UF_NORMAL_ACCOUNT)))
@@ -80,7 +85,7 @@
 }
 
 ADS_STATUS ads_add_group_acct(ADS_STRUCT *ads, const char *group, 
-			      const char *comment)
+			      const char *container, const char *comment)
 {
 	TALLOC_CTX *ctx;
 	ADS_MODLIST mods;
@@ -88,12 +93,12 @@
 	char *new_dn;
 	const char *objectClass[] = {"top", "group", NULL};
 
-	if (!(ctx = talloc_init_named("ads_add_group_acct")))
+	if (!(ctx = talloc_init("ads_add_group_acct")))
 		return ADS_ERROR(LDAP_NO_MEMORY);
 
 	status = ADS_ERROR(LDAP_NO_MEMORY);
 
-	if (!(new_dn = talloc_asprintf(ctx, "cn=%s,cn=Users,%s", group, 
+	if (!(new_dn = talloc_asprintf(ctx, "cn=%s,%s,%s", group, container,
 				       ads->config.bind_path)))
 		goto done;
 	if (!(mods = ads_init_mods(ctx)))
@@ -102,7 +107,7 @@
 	ads_mod_str(ctx, &mods, "cn", group);
 	ads_mod_strlist(ctx, &mods, "objectClass",objectClass);
 	ads_mod_str(ctx, &mods, "name", group);
-	if (comment)
+	if (comment && *comment) 
 		ads_mod_str(ctx, &mods, "description", comment);
 	ads_mod_str(ctx, &mods, "sAMAccountName", group);
 	status = ads_gen_add(ads, new_dn, mods);
diff -uNr samba-3.0alpha21.orig/source/libsmb/asn1.c samba-3.0alpha21/source/libsmb/asn1.c
--- samba-3.0alpha21.orig/source/libsmb/asn1.c	2003-02-16 19:06:31.000000000 -0600
+++ samba-3.0alpha21/source/libsmb/asn1.c	2003-02-16 19:05:45.000000000 -0600
@@ -338,7 +338,7 @@
 }
 
 /* check that the next object ID is correct */
-BOOL asn1_check_OID(ASN1_DATA *data, char *OID)
+BOOL asn1_check_OID(ASN1_DATA *data, const char *OID)
 {
 	char *id;
 
@@ -407,7 +407,7 @@
 	return !data->has_error && (v == b);
 }
 
-/* check a enumarted value is correct */
+/* write an enumarted value to the stream */
 BOOL asn1_write_enumerated(ASN1_DATA *data, uint8 v)
 {
 	if (!asn1_push_tag(data, ASN1_ENUMERATED)) return False;
diff -uNr samba-3.0alpha21.orig/source/libsmb/cliconnect.c samba-3.0alpha21/source/libsmb/cliconnect.c
--- samba-3.0alpha21.orig/source/libsmb/cliconnect.c	2003-02-16 19:06:31.000000000 -0600
+++ samba-3.0alpha21/source/libsmb/cliconnect.c	2003-02-16 19:05:45.000000000 -0600
@@ -465,7 +465,8 @@
 
 	neg_flags = NTLMSSP_NEGOTIATE_UNICODE | 
 		NTLMSSP_NEGOTIATE_128 | 
-		NTLMSSP_NEGOTIATE_NTLM;
+		NTLMSSP_NEGOTIATE_NTLM |
+		NTLMSSP_REQUEST_TARGET;
 
 	memset(sess_key, 0, 16);
 
@@ -476,8 +477,8 @@
 		  "NTLMSSP",
 		  NTLMSSP_NEGOTIATE,
 		  neg_flags,
-		  workgroup, strlen(workgroup),
-		  cli->calling.name, strlen(cli->calling.name) + 1);
+		  workgroup, 
+		  cli->calling.name);
 	DEBUG(10, ("neg_flags: %0X, workgroup: %s, calling name %s\n",
 		  neg_flags, workgroup, cli->calling.name));
 	/* and wrap it in a SPNEGO wrapper */
@@ -1258,8 +1259,8 @@
 	if (service) {
 		if (!cli_send_tconX(cli, service, service_type,
 				    password, strlen(password)+1)) {
-			DEBUG(1,("failed tcon_X with %s\n", nt_errstr(nt_status)));
 			nt_status = cli_nt_error(cli);
+			DEBUG(1,("failed tcon_X with %s\n", nt_errstr(nt_status)));
 			cli_shutdown(cli);
 			if (NT_STATUS_IS_OK(nt_status)) {
 				nt_status = NT_STATUS_UNSUCCESSFUL;
diff -uNr samba-3.0alpha21.orig/source/libsmb/clidgram.c samba-3.0alpha21/source/libsmb/clidgram.c
--- samba-3.0alpha21.orig/source/libsmb/clidgram.c	2003-02-16 19:06:31.000000000 -0600
+++ samba-3.0alpha21/source/libsmb/clidgram.c	2003-02-16 19:05:45.000000000 -0600
@@ -26,7 +26,7 @@
  * cli_send_mailslot, send a mailslot for client code ...
  */
 
-int cli_send_mailslot(int dgram_sock, BOOL unique, char *mailslot, 
+int cli_send_mailslot(int dgram_sock, BOOL unique, const char *mailslot, 
 		      char *buf, int len,
 		      const char *srcname, int src_type, 
 		      const char *dstname, int dest_type,
@@ -100,7 +100,7 @@
 /*
  * cli_get_response: Get a response ...
  */
-int cli_get_response(int dgram_sock, BOOL unique, char *mailslot, char *buf, int bufsiz)
+int cli_get_response(int dgram_sock, BOOL unique, const char *mailslot, char *buf, int bufsiz)
 {
   struct packet_struct *packet;
 
diff -uNr samba-3.0alpha21.orig/source/libsmb/clientgen.c samba-3.0alpha21/source/libsmb/clientgen.c
--- samba-3.0alpha21.orig/source/libsmb/clientgen.c	2003-02-16 19:06:31.000000000 -0600
+++ samba-3.0alpha21/source/libsmb/clientgen.c	2003-02-16 19:05:45.000000000 -0600
@@ -262,7 +262,7 @@
 	if (!cli->outbuf || !cli->inbuf)
                 goto error;
 
-	if ((cli->mem_ctx = talloc_init_named("cli based talloc")) == NULL)
+	if ((cli->mem_ctx = talloc_init("cli based talloc")) == NULL)
                 goto error;
 
 	memset(cli->outbuf, 0, cli->bufsize);
@@ -327,7 +327,7 @@
  Set socket options on a open connection.
 ****************************************************************************/
 
-void cli_sockopt(struct cli_state *cli, char *options)
+void cli_sockopt(struct cli_state *cli, const char *options)
 {
 	set_socket_options(cli->fd, options);
 }
diff -uNr samba-3.0alpha21.orig/source/libsmb/clierror.c samba-3.0alpha21/source/libsmb/clierror.c
--- samba-3.0alpha21.orig/source/libsmb/clierror.c	2003-02-16 19:06:31.000000000 -0600
+++ samba-3.0alpha21/source/libsmb/clierror.c	2003-02-16 19:05:45.000000000 -0600
@@ -33,7 +33,7 @@
 static const struct
 {
   int err;
-  char *message;
+  const char *message;
 } rap_errmap[] =
 {
   {5,    "RAP5: User has insufficient privilege" },
@@ -62,7 +62,7 @@
 /****************************************************************************
   return a description of an SMB error
 ****************************************************************************/
-static char *cli_smb_errstr(struct cli_state *cli)
+static const char *cli_smb_errstr(struct cli_state *cli)
 {
 	return smb_dos_errstr(cli->inbuf);
 }
@@ -73,7 +73,7 @@
  in which case they can be safely ignored.
 ****************************************************************************/
     
-char *cli_errstr(struct cli_state *cli)
+const char *cli_errstr(struct cli_state *cli)
 {   
 	static fstring cli_error_message;
 	uint32 flgs2 = SVAL(cli->inbuf,smb_flg2), errnum;
diff -uNr samba-3.0alpha21.orig/source/libsmb/clikrb5.c samba-3.0alpha21/source/libsmb/clikrb5.c
--- samba-3.0alpha21.orig/source/libsmb/clikrb5.c	2003-02-16 19:06:31.000000000 -0600
+++ samba-3.0alpha21/source/libsmb/clikrb5.c	2003-02-16 19:05:45.000000000 -0600
@@ -2,6 +2,7 @@
    Unix SMB/CIFS implementation.
    simple kerberos5 routines for active directory
    Copyright (C) Andrew Tridgell 2001
+   Copyright (C) Luke Howard 2002
    
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -21,6 +22,176 @@
 #include "includes.h"
 
 #ifdef HAVE_KRB5
+
+#ifndef HAVE_KRB5_SET_REAL_TIME
+/*
+ * This function is not in the Heimdal mainline.
+ */
+ krb5_error_code krb5_set_real_time(krb5_context context, int32_t seconds, int32_t microseconds)
+{
+	krb5_error_code ret;
+	int32_t sec, usec;
+
+	ret = krb5_us_timeofday(context, &sec, &usec);
+	if (ret)
+		return ret;
+
+	context->kdc_sec_offset = seconds - sec;
+	context->kdc_usec_offset = microseconds - usec;
+
+	return 0;
+}
+#endif
+
+#if defined(HAVE_KRB5_SET_DEFAULT_IN_TKT_ETYPES) && !defined(HAVE_KRB5_SET_DEFAULT_TGS_KTYPES)
+ krb5_error_code krb5_set_default_tgs_ktypes(krb5_context ctx, const krb5_enctype *enc)
+{
+	return krb5_set_default_in_tkt_etypes(ctx, enc);
+}
+#endif
+
+#if defined(HAVE_ADDR_TYPE_IN_KRB5_ADDRESS)
+/* HEIMDAL */
+ void setup_kaddr( krb5_address *pkaddr, struct sockaddr *paddr)
+{
+	pkaddr->addr_type = KRB5_ADDRESS_INET;
+	pkaddr->address.length = sizeof(((struct sockaddr_in *)paddr)->sin_addr);
+	pkaddr->address.data = (char *)&(((struct sockaddr_in *)paddr)->sin_addr);
+}
+#elif defined(HAVE_ADDRTYPE_IN_KRB5_ADDRESS)
+/* MIT */
+ void setup_kaddr( krb5_address *pkaddr, struct sockaddr *paddr)
+{
+	pkaddr->addrtype = ADDRTYPE_INET;
+	pkaddr->length = sizeof(((struct sockaddr_in *)paddr)->sin_addr);
+	pkaddr->contents = (char *)&(((struct sockaddr_in *)paddr)->sin_addr);
+}
+#else
+ __ERROR__XX__UNKNOWN_ADDRTYPE
+#endif
+
+#if defined(HAVE_KRB5_PRINCIPAL2SALT) && defined(HAVE_KRB5_USE_ENCTYPE) && defined(HAVE_KRB5_STRING_TO_KEY)
+ int create_kerberos_key_from_string(krb5_context context,
+					krb5_principal host_princ,
+					krb5_data *password,
+					krb5_keyblock *key)
+{
+	int ret;
+	krb5_data salt;
+	krb5_encrypt_block eblock;
+
+	ret = krb5_principal2salt(context, host_princ, &salt);
+	if (ret) {
+		DEBUG(1,("krb5_principal2salt failed (%s)\n", error_message(ret)));
+		return ret;
+	}
+	krb5_use_enctype(context, &eblock, ENCTYPE_DES_CBC_MD5);
+	return krb5_string_to_key(context, &eblock, key, password, &salt);
+}
+#elif defined(HAVE_KRB5_GET_PW_SALT) && defined(HAVE_KRB5_STRING_TO_KEY_SALT)
+ int create_kerberos_key_from_string(krb5_context context,
+					krb5_principal host_princ,
+					krb5_data *password,
+					krb5_keyblock *key)
+{
+	int ret;
+	krb5_salt salt;
+
+	ret = krb5_get_pw_salt(context, host_princ, &salt);
+	if (ret) {
+		DEBUG(1,("krb5_get_pw_salt failed (%s)\n", error_message(ret)));
+		return ret;
+	}
+	return krb5_string_to_key_salt(context, ENCTYPE_DES_CBC_MD5, password->data,
+		salt, key);
+}
+#else
+ __ERROR_XX_UNKNOWN_CREATE_KEY_FUNCTIONS
+#endif
+
+#if defined(HAVE_KRB5_AUTH_CON_SETKEY) && !defined(HAVE_KRB5_AUTH_CON_SETUSERUSERKEY)
+ krb5_error_code krb5_auth_con_setuseruserkey(krb5_context context,
+					krb5_auth_context auth_context,
+					krb5_keyblock *keyblock)
+{
+	return krb5_auth_con_setkey(context, auth_context, keyblock);
+}
+#endif
+
+ void get_auth_data_from_tkt(DATA_BLOB *auth_data, krb5_ticket *tkt)
+{
+#if defined(HAVE_KRB5_TKT_ENC_PART2)
+	if (tkt->enc_part2)
+		*auth_data = data_blob(tkt->enc_part2->authorization_data[0]->contents,
+			tkt->enc_part2->authorization_data[0]->length);
+#else
+	if (tkt->ticket.authorization_data && tkt->ticket.authorization_data->len)
+		*auth_data = data_blob(tkt->ticket.authorization_data->val->ad_data.data,
+			tkt->ticket.authorization_data->val->ad_data.length);
+#endif
+}
+
+ krb5_const_principal get_principal_from_tkt(krb5_ticket *tkt)
+{
+#if defined(HAVE_KRB5_TKT_ENC_PART2)
+	return tkt->enc_part2->client;
+#else
+	return tkt->client;
+#endif
+}
+
+#if !defined(HAVE_KRB5_LOCATE_KDC)
+ krb5_error_code krb5_locate_kdc(krb5_context ctx, const krb5_data *realm, struct sockaddr **addr_pp, int *naddrs, int get_masters)
+{
+	krb5_krbhst_handle hnd;
+	krb5_krbhst_info *hinfo;
+	krb5_error_code rc;
+	int num_kdcs, i;
+	struct sockaddr *sa;
+
+	*addr_pp = NULL;
+	*naddrs = 0;
+
+	rc = krb5_krbhst_init(ctx, realm->data, KRB5_KRBHST_KDC, &hnd);
+	if (rc) {
+		DEBUG(0, ("krb5_locate_kdc: krb5_krbhst_init failed (%s)\n", error_message(rc)));
+		return rc;
+	}
+
+	for ( num_kdcs = 0; (rc = krb5_krbhst_next(ctx, hnd, &hinfo) == 0); num_kdcs++)
+		;
+
+	krb5_krbhst_reset(ctx, hnd);
+
+	if (!num_kdcs) {
+		DEBUG(0, ("krb5_locate_kdc: zero kdcs found !\n"));
+		krb5_krbhst_free(ctx, hnd);
+		return -1;
+	}
+
+	sa = malloc( sizeof(struct sockaddr) * num_kdcs );
+	if (!sa) {
+		DEBUG(0, ("krb5_locate_kdc: malloc failed\n"));
+		krb5_krbhst_free(ctx, hnd);
+		naddrs = 0;
+		return -1;
+	}
+
+	memset(*addr_pp, '\0', sizeof(struct sockaddr) * num_kdcs );
+
+	for (i = 0; i < num_kdcs && (rc = krb5_krbhst_next(ctx, hnd, &hinfo) == 0); i++) {
+		if (hinfo->ai->ai_family == AF_INET)
+			memcpy(&sa[i], hinfo->ai->ai_addr, sizeof(struct sockaddr));
+	}
+
+	krb5_krbhst_free(ctx, hnd);
+
+	*naddrs = num_kdcs;
+	*addr_pp = sa;
+	return 0;
+}
+#endif
+
 /*
   we can't use krb5_mk_req because w2k wants the service to be in a particular format
 */
@@ -94,7 +265,7 @@
 /*
   get a kerberos5 ticket for the given service 
 */
-DATA_BLOB krb5_get_ticket(char *principal, time_t time_offset)
+DATA_BLOB krb5_get_ticket(const char *principal, time_t time_offset)
 {
 	krb5_error_code retval;
 	krb5_data packet;
@@ -156,7 +327,7 @@
 
 #else /* HAVE_KRB5 */
  /* this saves a few linking headaches */
- DATA_BLOB krb5_get_ticket(char *principal, time_t time_offset)
+ DATA_BLOB krb5_get_ticket(const char *principal, time_t time_offset)
  {
 	 DEBUG(0,("NO KERBEROS SUPPORT\n"));
 	 return data_blob(NULL, 0);
diff -uNr samba-3.0alpha21.orig/source/libsmb/clilist.c samba-3.0alpha21/source/libsmb/clilist.c
--- samba-3.0alpha21.orig/source/libsmb/clilist.c	2003-02-16 19:06:31.000000000 -0600
+++ samba-3.0alpha21/source/libsmb/clilist.c	2003-02-16 19:05:45.000000000 -0600
@@ -104,7 +104,7 @@
 			finfo->ctime = interpret_long_date(p); p += 8;
 			finfo->atime = interpret_long_date(p); p += 8;
 			finfo->mtime = interpret_long_date(p); p += 8; p += 8;
-			finfo->size = IVAL(p,0); p += 8;
+			finfo->size = IVAL2_TO_SMB_BIG_UINT(p,0); p += 8;
 			p += 8; /* alloc size */
 			finfo->mode = CVAL(p,0); p += 4;
 			namelen = IVAL(p,0); p += 4;
@@ -324,9 +324,11 @@
 	finfo->mtime = finfo->atime = finfo->ctime;
 	finfo->size = IVAL(p,26);
 	clistr_pull(cli, finfo->name, p+30, sizeof(finfo->name), 12, STR_ASCII);
-	if (strcmp(finfo->name, "..") && strcmp(finfo->name, "."))
-		fstrcpy(finfo->short_name,finfo->name);
-	
+	if (strcmp(finfo->name, "..") && strcmp(finfo->name, ".")) {
+		strncpy(finfo->short_name,finfo->name, sizeof(finfo->short_name)-1);
+		finfo->short_name[sizeof(finfo->short_name)-1] = '\0';
+	}
+
 	return(DIR_STRUCT_SIZE);
 }
 
diff -uNr samba-3.0alpha21.orig/source/libsmb/cliprint.c samba-3.0alpha21/source/libsmb/cliprint.c
--- samba-3.0alpha21.orig/source/libsmb/cliprint.c	2003-02-16 19:06:31.000000000 -0600
+++ samba-3.0alpha21/source/libsmb/cliprint.c	2003-02-16 19:05:45.000000000 -0600
@@ -27,7 +27,7 @@
  This function contains code to prevent core dumps if the server returns 
  invalid data.
 *****************************************************************************/
-static char *fix_char_ptr(unsigned int datap, unsigned int converter, 
+static const char *fix_char_ptr(unsigned int datap, unsigned int converter, 
 			  char *rdata, int rdrcnt)
 {
 	if (datap == 0)	{	/* turn NULL pointers into zero length strings */
diff -uNr samba-3.0alpha21.orig/source/libsmb/clirap.c samba-3.0alpha21/source/libsmb/clirap.c
--- samba-3.0alpha21.orig/source/libsmb/clirap.c	2003-02-16 19:06:31.000000000 -0600
+++ samba-3.0alpha21/source/libsmb/clirap.c	2003-02-16 19:05:45.000000000 -0600
@@ -26,7 +26,7 @@
 /****************************************************************************
 Call a remote api on an arbitrary pipe.  takes param, data and setup buffers.
 ****************************************************************************/
-BOOL cli_api_pipe(struct cli_state *cli, char *pipe_name, 
+BOOL cli_api_pipe(struct cli_state *cli, const char *pipe_name, 
                   uint16 *setup, uint32 setup_count, uint32 max_setup_count,
                   char *params, uint32 param_count, uint32 max_param_count,
                   char *data, uint32 data_count, uint32 max_data_count,
@@ -176,7 +176,7 @@
 					char *sname = p;
 					int type = SVAL(p,14);
 					int comment_offset = IVAL(p,16) & 0xFFFF;
-					char *cmnt = comment_offset?(rdata+comment_offset-converter):"";
+					const char *cmnt = comment_offset?(rdata+comment_offset-converter):"";
 					pstring s1, s2;
 
 					pull_ascii_pstring(s1, sname);
@@ -253,7 +253,7 @@
 			for (i = 0;i < count;i++, p += 26) {
 				char *sname = p;
 				int comment_offset = (IVAL(p,22) & 0xFFFF)-converter;
-				char *cmnt = comment_offset?(rdata+comment_offset):"";
+				const char *cmnt = comment_offset?(rdata+comment_offset):"";
 				pstring s1, s2;
 
 				if (comment_offset < 0 || comment_offset > rdrcnt) continue;
@@ -727,7 +727,7 @@
 		return NT_STATUS_INVALID_NETWORK_RESPONSE;
 	}
 
-	clistr_pull(cli, alt_name, rdata+4, sizeof(fstring), len, 0);
+	clistr_pull(cli, alt_name, rdata+4, sizeof(fstring), len, STR_UNICODE);
 
 	SAFE_FREE(rdata);
 	SAFE_FREE(rparam);
diff -uNr samba-3.0alpha21.orig/source/libsmb/clirap2.c samba-3.0alpha21/source/libsmb/clirap2.c
--- samba-3.0alpha21.orig/source/libsmb/clirap2.c	2003-02-16 19:06:31.000000000 -0600
+++ samba-3.0alpha21/source/libsmb/clirap2.c	2003-02-16 19:05:45.000000000 -0600
@@ -128,7 +128,7 @@
   pull_ascii_pstring(s, off?(r+off-c):"");\
   } while(0)
 
-static char *make_header(char *param, uint16 apinum, char *reqfmt, char *datafmt)
+static char *make_header(char *param, uint16 apinum, const char *reqfmt, const char *datafmt)
 {
   PUTWORD(param,apinum);
   if (reqfmt) 
diff -uNr samba-3.0alpha21.orig/source/libsmb/clireadwrite.c samba-3.0alpha21/source/libsmb/clireadwrite.c
--- samba-3.0alpha21.orig/source/libsmb/clireadwrite.c	2003-02-16 19:06:31.000000000 -0600
+++ samba-3.0alpha21/source/libsmb/clireadwrite.c	2003-02-16 19:05:45.000000000 -0600
@@ -29,10 +29,15 @@
 static BOOL cli_issue_read(struct cli_state *cli, int fnum, off_t offset, 
 			   size_t size, int i)
 {
+	BOOL bigoffset = False;
+
 	memset(cli->outbuf,'\0',smb_size);
 	memset(cli->inbuf,'\0',smb_size);
 
-	set_message(cli->outbuf,10,0,True);
+	if ((SMB_BIG_UINT)offset >> 32) 
+		bigoffset = True;
+
+	set_message(cli->outbuf,bigoffset ? 12 : 10,0,True);
 		
 	SCVAL(cli->outbuf,smb_com,SMBreadX);
 	SSVAL(cli->outbuf,smb_tid,cli->cnum);
@@ -45,6 +50,9 @@
 	SSVAL(cli->outbuf,smb_vwv6,size);
 	SSVAL(cli->outbuf,smb_mid,cli->mid + i);
 
+	if (bigoffset)
+		SIVAL(cli->outbuf,smb_vwv10,(offset>>32) & 0xffffffff);
+
 	return cli_send_smb(cli);
 }
 
@@ -84,6 +92,7 @@
                    errors. */
 
                 if (cli_is_error(cli)) {
+			BOOL recoverable_error = False;
                         NTSTATUS status = NT_STATUS_OK;
                         uint8 eclass = 0;
 			uint32 ecode = 0;
@@ -93,8 +102,17 @@
                         else
                                 cli_dos_error(cli, &eclass, &ecode);
 
+			/*
+			 * ERRDOS ERRmoredata or STATUS_MORE_ENRTIES is a
+			 * recoverable error, plus we have valid data in the
+			 * packet so don't error out here.
+			 */
+
                         if ((eclass == ERRDOS && ecode == ERRmoredata) ||
                             NT_STATUS_V(status) == NT_STATUS_V(STATUS_MORE_ENTRIES))
+				recoverable_error = True;
+
+			if (!recoverable_error)
                                 return -1;
 		}
 
@@ -230,10 +248,12 @@
 issue a single SMBwrite and don't wait for a reply
 ****************************************************************************/
 
-static BOOL cli_issue_write(struct cli_state *cli, int fnum, off_t offset, uint16 mode, char *buf,
+static BOOL cli_issue_write(struct cli_state *cli, int fnum, off_t offset, 
+			    uint16 mode, const char *buf,
 			    size_t size, int i)
 {
 	char *p;
+	BOOL bigoffset = False;
 
 	if (size > cli->bufsize) {
 		cli->outbuf = realloc(cli->outbuf, size + 1024);
@@ -246,7 +266,10 @@
 	memset(cli->outbuf,'\0',smb_size);
 	memset(cli->inbuf,'\0',smb_size);
 
-	if (size > 0xFFFF)
+	if ((SMB_BIG_UINT)offset >> 32) 
+		bigoffset = True;
+
+	if (bigoffset)
 		set_message(cli->outbuf,14,0,True);
 	else
 		set_message(cli->outbuf,12,0,True);
@@ -259,14 +282,23 @@
 	SSVAL(cli->outbuf,smb_vwv2,fnum);
 
 	SIVAL(cli->outbuf,smb_vwv3,offset);
-	SIVAL(cli->outbuf,smb_vwv5,(mode & 0x0008) ? 0xFFFFFFFF : 0);
+	SIVAL(cli->outbuf,smb_vwv5,0);
 	SSVAL(cli->outbuf,smb_vwv7,mode);
 
 	SSVAL(cli->outbuf,smb_vwv8,(mode & 0x0008) ? size : 0);
+	/*
+	 * According to CIFS-TR-1p00, this following field should only
+	 * be set if CAP_LARGE_WRITEX is set. We should check this
+	 * locally. However, this check might already have been
+	 * done by our callers.
+	 */
 	SSVAL(cli->outbuf,smb_vwv9,((size>>16)&1));
 	SSVAL(cli->outbuf,smb_vwv10,size);
 	SSVAL(cli->outbuf,smb_vwv11,
 	      smb_buf(cli->outbuf) - smb_base(cli->outbuf));
+
+	if (bigoffset)
+		SIVAL(cli->outbuf,smb_vwv12,(offset>>32) & 0xffffffff);
 	
 	p = smb_base(cli->outbuf) + SVAL(cli->outbuf,smb_vwv11);
 	memcpy(p, buf, size);
@@ -288,7 +320,7 @@
 
 ssize_t cli_write(struct cli_state *cli,
 		  int fnum, uint16 write_mode,
-		  char *buf, off_t offset, size_t size)
+		  const char *buf, off_t offset, size_t size)
 {
 	int bwritten = 0;
 	int issued = 0;
diff -uNr samba-3.0alpha21.orig/source/libsmb/clisecdesc.c samba-3.0alpha21/source/libsmb/clisecdesc.c
--- samba-3.0alpha21.orig/source/libsmb/clisecdesc.c	2003-02-16 19:06:31.000000000 -0600
+++ samba-3.0alpha21/source/libsmb/clisecdesc.c	2003-02-16 19:05:45.000000000 -0600
@@ -54,8 +54,8 @@
 	}
 
 	prs_init(&pd, rdata_count, mem_ctx, UNMARSHALL);
-	prs_append_data(&pd, rdata, rdata_count);
-	pd.data_offset = 0;
+	prs_copy_data_in(&pd, rdata, rdata_count);
+	prs_set_offset(&pd,0);
 
 	if (!sec_io_desc("sd data", &psd, &pd, 1)) {
 		DEBUG(1,("Failed to parse secdesc\n"));
@@ -83,7 +83,7 @@
 	prs_struct pd;
 	BOOL ret = False;
 
-	if ((mem_ctx = talloc_init()) == NULL) {
+	if ((mem_ctx = talloc_init("cli_set_secdesc")) == NULL) {
 		DEBUG(0,("talloc_init failed.\n"));
 		goto cleanup;
 	}
@@ -104,7 +104,7 @@
 			       0, 
 			       NULL, 0, 0,
 			       param, 8, 0,
-			       pd.data_p, pd.data_offset, 0)) {
+			       prs_data_p(&pd), prs_offset(&pd), 0)) {
 		DEBUG(1,("Failed to send NT_TRANSACT_SET_SECURITY_DESC\n"));
 		goto cleanup;
 	}
diff -uNr samba-3.0alpha21.orig/source/libsmb/clispnego.c samba-3.0alpha21/source/libsmb/clispnego.c
--- samba-3.0alpha21.orig/source/libsmb/clispnego.c	2003-02-16 19:06:31.000000000 -0600
+++ samba-3.0alpha21/source/libsmb/clispnego.c	2003-02-16 19:05:45.000000000 -0600
@@ -387,51 +387,6 @@
 
 
 /*
-  generate a spnego NTLMSSP challenge packet given two security blobs
-  The second challenge is optional
-*/
-BOOL spnego_gen_challenge(DATA_BLOB *blob,
-			  DATA_BLOB *chal1, DATA_BLOB *chal2)
-{
-	ASN1_DATA data;
-
-	ZERO_STRUCT(data);
-
-	asn1_push_tag(&data,ASN1_CONTEXT(1));
-	asn1_push_tag(&data,ASN1_SEQUENCE(0));
-
-	asn1_push_tag(&data,ASN1_CONTEXT(0));
-	asn1_write_enumerated(&data,1);
-	asn1_pop_tag(&data);
-
-	asn1_push_tag(&data,ASN1_CONTEXT(1));
-	asn1_write_OID(&data, OID_NTLMSSP);
-	asn1_pop_tag(&data);
-
-	asn1_push_tag(&data,ASN1_CONTEXT(2));
-	asn1_write_OctetString(&data, chal1->data, chal1->length);
-	asn1_pop_tag(&data);
-
-	/* the second challenge is optional (XP doesn't send it) */
-	if (chal2) {
-		asn1_push_tag(&data,ASN1_CONTEXT(3));
-		asn1_write_OctetString(&data, chal2->data, chal2->length);
-		asn1_pop_tag(&data);
-	}
-
-	asn1_pop_tag(&data);
-	asn1_pop_tag(&data);
-
-	if (data.has_error) {
-		return False;
-	}
-
-	*blob = data_blob(data.data, data.length);
-	asn1_free(&data);
-	return True;
-}
-
-/*
  generate a SPNEGO NTLMSSP auth packet. This will contain the encrypted passwords
 */
 DATA_BLOB spnego_gen_auth(DATA_BLOB blob)
@@ -485,18 +440,37 @@
 /*
   generate a minimal SPNEGO NTLMSSP response packet.  Doesn't contain much.
 */
-DATA_BLOB spnego_gen_auth_response(void)
+DATA_BLOB spnego_gen_auth_response(DATA_BLOB *ntlmssp_reply, NTSTATUS nt_status)
 {
 	ASN1_DATA data;
 	DATA_BLOB ret;
+	uint8 negResult;
 
-	memset(&data, 0, sizeof(data));
+	if (NT_STATUS_IS_OK(nt_status)) {
+		negResult = SPNGEO_NEG_RESULT_ACCEPT;
+	} else if (NT_STATUS_EQUAL(nt_status, NT_STATUS_MORE_PROCESSING_REQUIRED)) {
+		negResult = SPNGEO_NEG_RESULT_INCOMPLETE; 
+	} else {
+		negResult = SPNGEO_NEG_RESULT_REJECT; 
+	}
+
+	ZERO_STRUCT(data);
 
 	asn1_push_tag(&data, ASN1_CONTEXT(1));
 	asn1_push_tag(&data, ASN1_SEQUENCE(0));
 	asn1_push_tag(&data, ASN1_CONTEXT(0));
-	asn1_write_enumerated(&data, 0);	
+	asn1_write_enumerated(&data, negResult);
 	asn1_pop_tag(&data);
+	if (negResult == SPNGEO_NEG_RESULT_INCOMPLETE) {
+		asn1_push_tag(&data,ASN1_CONTEXT(1));
+		asn1_write_OID(&data, OID_NTLMSSP);
+		asn1_pop_tag(&data);
+		
+		asn1_push_tag(&data,ASN1_CONTEXT(2));
+		asn1_write_OctetString(&data, ntlmssp_reply->data, ntlmssp_reply->length);
+		asn1_pop_tag(&data);
+	}
+
 	asn1_pop_tag(&data);
 	asn1_pop_tag(&data);
 
@@ -514,8 +488,9 @@
   format specifiers are:
 
   U = unicode string (input is unix string)
-  a = address (1 byte type, 1 byte length, unicode string, all inline)
-  A = ASCII string (pointer + length) Actually same as B
+  a = address (input is BOOL unicode, char *unix_string)
+      (1 byte type, 1 byte length, unicode/ASCII string, all inline)
+  A = ASCII string (input is unix string)
   B = data blob (pointer + length)
   b = data blob in header (pointer + length)
   D
@@ -531,6 +506,7 @@
 	uint8 *b;
 	int head_size=0, data_size=0;
 	int head_ofs, data_ofs;
+	BOOL unicode;
 
 	/* first scan the format to work out the header and body size */
 	va_start(ap, format);
@@ -541,12 +517,21 @@
 			head_size += 8;
 			data_size += str_charnum(s) * 2;
 			break;
+		case 'A':
+			s = va_arg(ap, char *);
+			head_size += 8;
+			data_size += str_ascii_charnum(s);
+			break;
 		case 'a':
+			unicode = va_arg(ap, BOOL);
 			n = va_arg(ap, int);
 			s = va_arg(ap, char *);
-			data_size += (str_charnum(s) * 2) + 4;
+			if (unicode) {
+				data_size += (str_charnum(s) * 2) + 4;
+			} else {
+				data_size += (str_ascii_charnum(s)) + 4;
+			}
 			break;
-		case 'A':
 		case 'B':
 			b = va_arg(ap, uint8 *);
 			head_size += 8;
@@ -586,20 +571,39 @@
 			push_string(NULL, blob->data+data_ofs, s, n*2, STR_UNICODE|STR_NOALIGN);
 			data_ofs += n*2;
 			break;
+		case 'A':
+			s = va_arg(ap, char *);
+			n = str_ascii_charnum(s);
+			SSVAL(blob->data, head_ofs, n); head_ofs += 2;
+			SSVAL(blob->data, head_ofs, n); head_ofs += 2;
+			SIVAL(blob->data, head_ofs, data_ofs); head_ofs += 4;
+			push_string(NULL, blob->data+data_ofs, s, n, STR_ASCII|STR_NOALIGN);
+			data_ofs += n;
+			break;
 		case 'a':
+			unicode = va_arg(ap, BOOL);
 			n = va_arg(ap, int);
 			SSVAL(blob->data, data_ofs, n); data_ofs += 2;
 			s = va_arg(ap, char *);
-			n = str_charnum(s);
-			SSVAL(blob->data, data_ofs, n*2); data_ofs += 2;
-			if (0 < n) {
-				push_string(NULL, blob->data+data_ofs, s, n*2,
-					    STR_UNICODE|STR_NOALIGN);
+			if (unicode) {
+				n = str_charnum(s);
+				SSVAL(blob->data, data_ofs, n*2); data_ofs += 2;
+				if (0 < n) {
+					push_string(NULL, blob->data+data_ofs, s, n*2,
+						    STR_UNICODE|STR_NOALIGN);
+				}
+				data_ofs += n*2;
+			} else {
+				n = str_ascii_charnum(s);
+				SSVAL(blob->data, data_ofs, n); data_ofs += 2;
+				if (0 < n) {
+					push_string(NULL, blob->data+data_ofs, s, n,
+						    STR_ASCII|STR_NOALIGN);
+				}
+				data_ofs += n;
 			}
-			data_ofs += n*2;
 			break;
 
-		case 'A':
 		case 'B':
 			b = va_arg(ap, uint8 *);
 			n = va_arg(ap, int);
@@ -714,7 +718,7 @@
 			break;
 		case 'C':
 			s = va_arg(ap, char *);
-			head_ofs += pull_string(NULL, p, blob->data+head_ofs, -1, 
+			head_ofs += pull_string(NULL, p, blob->data+head_ofs, sizeof(p), 
 						blob->length - head_ofs, 
 						STR_ASCII|STR_TERMINATE);
 			if (strcmp(s, p) != 0) {
diff -uNr samba-3.0alpha21.orig/source/libsmb/doserr.c samba-3.0alpha21/source/libsmb/doserr.c
--- samba-3.0alpha21.orig/source/libsmb/doserr.c	2003-02-16 19:06:31.000000000 -0600
+++ samba-3.0alpha21/source/libsmb/doserr.c	2003-02-16 19:05:45.000000000 -0600
@@ -24,7 +24,7 @@
 
 typedef const struct
 {
-	char *dos_errstr;
+	const char *dos_errstr;
 	WERROR werror;
 } werror_code_struct;
 
@@ -73,7 +73,7 @@
 /*****************************************************************************
  returns a DOS error message.  not amazingly helpful, but better than a number.
  *****************************************************************************/
-char *dos_errstr(WERROR werror)
+const char *dos_errstr(WERROR werror)
 {
         static pstring msg;
         int idx = 0;
diff -uNr samba-3.0alpha21.orig/source/libsmb/errormap.c samba-3.0alpha21/source/libsmb/errormap.c
--- samba-3.0alpha21.orig/source/libsmb/errormap.c	2003-02-16 19:06:31.000000000 -0600
+++ samba-3.0alpha21/source/libsmb/errormap.c	2003-02-16 19:05:45.000000000 -0600
@@ -45,7 +45,7 @@
 */
 
 /* NT status -> dos error map */
-const static struct {
+static const struct {
 	uint8 dos_class;
 	uint32 dos_code;
 	NTSTATUS ntstatus;
@@ -611,7 +611,7 @@
 
 
 /* dos -> nt status error map */
-const static struct {
+static const struct {
 	uint8 dos_class;
 	uint32 dos_code;
 	NTSTATUS ntstatus;
@@ -866,7 +866,7 @@
 };
 
 /* errmap NTSTATUS->Win32 */
-const static struct {
+static const struct {
 	NTSTATUS ntstatus;
 	WERROR werror;
 } ntstatus_to_werror_map[] = {
@@ -1484,7 +1484,6 @@
 	return W_ERROR(NT_STATUS_V(error) & 0xffff);
 }
 
-
 /* Mapping between Unix, DOS and NT error numbers */
 
 const struct unix_error_map unix_dos_nt_errmap[] = {
@@ -1514,6 +1513,9 @@
 #ifdef ENAMETOOLONG
 	{ ENAMETOOLONG, ERRDOS, 206, NT_STATUS_OBJECT_NAME_INVALID },
 #endif
+#ifdef EFBIG
+	{ EFBIG, ERRHRD, ERRdiskfull, NT_STATUS_DISK_FULL },
+#endif
 	{ 0, 0, 0, NT_STATUS_OK }
 };
 
diff -uNr samba-3.0alpha21.orig/source/libsmb/libsmb_compat.c samba-3.0alpha21/source/libsmb/libsmb_compat.c
--- samba-3.0alpha21.orig/source/libsmb/libsmb_compat.c	2003-02-16 19:06:32.000000000 -0600
+++ samba-3.0alpha21/source/libsmb/libsmb_compat.c	2003-02-16 19:05:45.000000000 -0600
@@ -24,11 +24,7 @@
 
 #include "includes.h"
 
-/*
- * Define this to get the real SMBCFILE and SMBCSRV structures 
- */
-#define _SMBC_INTERNAL
-#include "../include/libsmbclient.h"
+#include "../include/libsmb_internal.h"
 
 struct smbc_compat_fdlist {
 	SMBCFILE * file;
@@ -272,7 +268,7 @@
 	return (int) file;
 }
 
-int smbc_list_print_jobs(const char *purl, smbc_get_print_job_info fn)
+int smbc_list_print_jobs(const char *purl, smbc_list_print_job_fn fn)
 {
 	return statcont->list_print_jobs(statcont, purl, fn);
 }
diff -uNr samba-3.0alpha21.orig/source/libsmb/libsmbclient.c samba-3.0alpha21/source/libsmb/libsmbclient.c
--- samba-3.0alpha21.orig/source/libsmb/libsmbclient.c	2003-02-16 19:06:32.000000000 -0600
+++ samba-3.0alpha21/source/libsmb/libsmbclient.c	2003-02-16 19:05:45.000000000 -0600
@@ -23,7 +23,7 @@
 
 #include "includes.h"
 
-#include "../include/libsmbclient.h"
+#include "../include/libsmb_internal.h"
 
 /*
  * Functions exported by libsmb_cache.c that we need here
@@ -70,7 +70,7 @@
 {
 	static pstring s;
 	pstring userinfo;
-	char *p;
+	const char *p;
 	char *q, *r;
 	int len;
 
@@ -119,7 +119,7 @@
 	r = strchr_m(p, '/');
 	if (q && (!r || q < r)) {
 		pstring username, passwd, domain;
-		char *u = userinfo;
+		const char *u = userinfo;
 
 		next_token(&p, userinfo, "@", sizeof(fstring));
 
@@ -218,7 +218,7 @@
 }
 
 /* 
- * Remove a server from the list server_table if it's unused.
+ * Remove a server from the cached server list it's unused.
  * On success, 0 is returned. 1 is returned if the server could not be removed.
  * 
  * Also useable outside libsmbclient
@@ -228,11 +228,12 @@
 	SMBCFILE * file;
 
 	/* are we being fooled ? */
-	if (!context || !context->_initialized || !srv) return 1;
+	if (!context || !context->internal ||
+	    !context->internal->_initialized || !srv) return 1;
 
 	
 	/* Check all open files/directories for a relation with this server */
-	for (file = context->_files; file; file=file->next) {
+	for (file = context->internal->_files; file; file=file->next) {
 		if (file->srv == srv) {
 			/* Still used */
 			DEBUG(3, ("smbc_remove_usused_server: %p still used by %p.\n", 
@@ -241,7 +242,7 @@
 		}
 	}
 
-	DLIST_REMOVE(context->_servers, srv);
+	DLIST_REMOVE(context->internal->_servers, srv);
 
 	cli_shutdown(&srv->cli);
 
@@ -474,7 +475,8 @@
 	SMBCFILE *file = NULL;
 	int fd;
 
-	if (!context || !context->_initialized) {
+	if (!context || !context->internal ||
+	    !context->internal->_initialized) {
 
 		errno = EINVAL;  /* Best I can think of ... */
 		return NULL;
@@ -541,7 +543,7 @@
 		file->offset  = 0;
 		file->file    = True;
 
-		DLIST_ADD(context->_files, file);
+		DLIST_ADD(context->internal->_files, file);
 		return file;
 
 	}
@@ -572,7 +574,8 @@
 static SMBCFILE *smbc_creat_ctx(SMBCCTX *context, const char *path, mode_t mode)
 {
 
-	if (!context || !context->_initialized) {
+	if (!context || !context->internal ||
+	    !context->internal->_initialized) {
 
 		errno = EINVAL;
 		return NULL;
@@ -590,7 +593,8 @@
 {
 	int ret;
 
-	if (!context || !context->_initialized) {
+	if (!context || !context->internal ||
+	    !context->internal->_initialized) {
 
 		errno = EINVAL;
 		return -1;
@@ -599,7 +603,7 @@
 
 	DEBUG(4, ("smbc_read(%p, %d)\n", file, (int)count));
 
-	if (!file || !DLIST_CONTAINS(context->_files, file)) {
+	if (!file || !DLIST_CONTAINS(context->internal->_files, file)) {
 
 		errno = EBADF;
 		return -1;
@@ -640,14 +644,15 @@
 {
 	int ret;
 
-	if (!context || context->_initialized) {
+	if (!context || !context->internal ||
+	    !context->internal->_initialized) {
 
 		errno = EINVAL;
 		return -1;
 
 	}
 
-	if (!file || !DLIST_CONTAINS(context->_files, file)) {
+	if (!file || !DLIST_CONTAINS(context->internal->_files, file)) {
 
 		errno = EBADF;
 		return -1;
@@ -685,14 +690,15 @@
 {
         SMBCSRV *srv; 
 
-	if (!context || !context->_initialized) {
+	if (!context || !context->internal ||
+	    !context->internal->_initialized) {
 
 		errno = EINVAL;
 		return -1;
 
 	}
 
-	if (!file || !DLIST_CONTAINS(context->_files, file)) {
+	if (!file || !DLIST_CONTAINS(context->internal->_files, file)) {
    
 		errno = EBADF;
 		return -1;
@@ -714,7 +720,7 @@
 		 * from the server cache if unused */
 		errno = smbc_errno(context, &file->srv->cli);  
 		srv = file->srv;
-		DLIST_REMOVE(context->_files, file);
+		DLIST_REMOVE(context->internal->_files, file);
 		SAFE_FREE(file->fname);
 		SAFE_FREE(file);
 		context->callbacks.remove_unused_server_fn(context, srv);
@@ -736,7 +742,7 @@
 		 * from the server cache if unused */
 		errno = smbc_errno(context, &file->srv->cli);  
 		srv = file->srv;
-		DLIST_REMOVE(context->_files, file);
+		DLIST_REMOVE(context->internal->_files, file);
 		SAFE_FREE(file->fname);
 		SAFE_FREE(file);
 		context->callbacks.remove_unused_server_fn(context, srv);
@@ -744,7 +750,7 @@
 		return -1;
 	}
 
-	DLIST_REMOVE(context->_files, file);
+	DLIST_REMOVE(context->internal->_files, file);
 	SAFE_FREE(file->fname);
 	SAFE_FREE(file);
 
@@ -761,7 +767,8 @@
 		 SMB_INO_T *ino)
 {
 
-	if (!context || !context->_initialized) {
+	if (!context || !context->internal ||
+	    !context->internal->_initialized) {
  
 		errno = EINVAL;
  		return -1;
@@ -797,7 +804,8 @@
 	pstring path;
 	SMBCSRV *srv = NULL;
 
-	if (!context || context->_initialized) {
+	if (!context || !context->internal ||
+	    !context->internal->_initialized) {
 
 		errno = EINVAL;  /* Best I can think of ... */
 		return -1;
@@ -891,8 +899,10 @@
 	pstring path1, path2;
 	SMBCSRV *srv = NULL;
 
-	if (!ocontext || !ncontext ||
-	    !ocontext->_initialized || !ncontext->_initialized) {
+	if (!ocontext || !ncontext || 
+	    !ocontext->internal || !ncontext->internal ||
+	    !ocontext->internal->_initialized || 
+	    !ncontext->internal->_initialized) {
 
 		errno = EINVAL;  /* Best I can think of ... */
 		return -1;
@@ -960,14 +970,15 @@
 {
 	size_t size;
 
-	if (!context || !context->_initialized) {
+	if (!context || !context->internal ||
+	    !context->internal->_initialized) {
 
 		errno = EINVAL;
 		return -1;
 		
 	}
 
-	if (!file || !DLIST_CONTAINS(context->_files, file)) {
+	if (!file || !DLIST_CONTAINS(context->internal->_files, file)) {
 
 		errno = EBADF;
 		return -1;
@@ -1020,7 +1031,8 @@
 ino_t smbc_inode(SMBCCTX *context, const char *name)
 {
 
-	if (!context || !context->_initialized) {
+	if (!context || !context->internal ||
+	    !context->internal->_initialized) {
 
 		errno = EINVAL;
 		return -1;
@@ -1088,7 +1100,8 @@
 	uint16 mode = 0;
 	SMB_INO_T ino = 0;
 
-	if (!context || !context->_initialized) {
+	if (!context || !context->internal ||
+	    !context->internal->_initialized) {
 
 		errno = EINVAL;  /* Best I can think of ... */
 		return -1;
@@ -1171,14 +1184,15 @@
 	uint16 mode;
 	SMB_INO_T ino = 0;
 
-	if (!context || !context->_initialized) {
+	if (!context || !context->internal ||
+	    !context->internal->_initialized) {
 
 		errno = EINVAL;
 		return -1;
 
 	}
 
-	if (!file || !DLIST_CONTAINS(context->_files, file)) {
+	if (!file || !DLIST_CONTAINS(context->internal->_files, file)) {
 
 		errno = EBADF;
 		return -1;
@@ -1271,9 +1285,6 @@
 
 	ZERO_STRUCTP(dirent);
 
-	ZERO_STRUCTP(dirent);
-
-
 	if (dir->dir_list == NULL) {
 
 		dir->dir_list = malloc(sizeof(struct smbc_dir_list));
@@ -1354,8 +1365,6 @@
 			dirent_type = SMBC_FILE_SHARE; /* FIXME, error? */
 			break;
 		}
-		ZERO_STRUCTP(dir->dir_list);
-
 	}
 	else dirent_type = dir->dir_type;
 
@@ -1390,9 +1399,9 @@
 	SMBCSRV *srv  = NULL;
 	SMBCFILE *dir = NULL;
 	struct in_addr rem_ip;
-	int slot = 0;
 
-	if (!context || !context->_initialized) {
+	if (!context || !context->internal ||
+	    !context->internal->_initialized) {
 
 		errno = EINVAL;
 		return NULL;
@@ -1488,7 +1497,6 @@
 			return NULL;
 
 		}
-		ZERO_STRUCTP(dir->dir_end);
 
 		dir->srv = srv;
 
@@ -1668,7 +1676,7 @@
 
 	}
 
-	DLIST_ADD(context->_files, dir);
+	DLIST_ADD(context->internal->_files, dir);
 	return dir;
 
 }
@@ -1680,14 +1688,15 @@
 static int smbc_closedir_ctx(SMBCCTX *context, SMBCFILE *dir)
 {
 
-	if (!context || !context->_initialized) {
+        if (!context || !context->internal ||
+	    !context->internal->_initialized) {
 
 		errno = EINVAL;
 		return -1;
 
 	}
 
-	if (!dir || !DLIST_CONTAINS(context->_files, dir)) {
+	if (!dir || !DLIST_CONTAINS(context->internal->_files, dir)) {
 
 		errno = EBADF;
 		return -1;
@@ -1696,7 +1705,7 @@
 
 	smbc_remove_dir(dir); /* Clean it up */
 
-	DLIST_REMOVE(context->_files, dir);
+	DLIST_REMOVE(context->internal->_files, dir);
 
 	if (dir) {
 
@@ -1719,14 +1728,15 @@
 
 	/* Check that all is ok first ... */
 
-	if (!context || !context->_initialized) {
+	if (!context || !context->internal ||
+	    !context->internal->_initialized) {
 
 		errno = EINVAL;
 		return NULL;
 
 	}
 
-	if (!dir || !DLIST_CONTAINS(context->_files, dir)) {
+	if (!dir || !DLIST_CONTAINS(context->internal->_files, dir)) {
 
 		errno = EBADF;
 		return NULL;
@@ -1755,12 +1765,12 @@
 
 		/* Hmmm, do I even need to copy it? */
 
-		memcpy(context->_dirent, dirent, dirent->dirlen); /* Copy the dirent */
-		dirp = (struct smbc_dirent *)context->_dirent;
+		memcpy(context->internal->_dirent, dirent, dirent->dirlen); /* Copy the dirent */
+		dirp = (struct smbc_dirent *)context->internal->_dirent;
 		dirp->comment = (char *)(&dirp->name + dirent->namelen + 1);
 		dir->dir_next = dir->dir_next->next;
 
-		return (struct smbc_dirent *)context->_dirent;
+		return (struct smbc_dirent *)context->internal->_dirent;
 	}
 
 }
@@ -1777,14 +1787,15 @@
 
 	/* Check that all is ok first ... */
 
-	if (!context || !context->_initialized) {
+	if (!context || !context->internal ||
+	    !context->internal->_initialized) {
 
 		errno = EINVAL;
 		return -1;
 
 	}
 
-	if (!dir || !DLIST_CONTAINS(context->_files, dir)) {
+	if (!dir || !DLIST_CONTAINS(context->internal->_files, dir)) {
 
 		errno = EBADF;
 		return -1;
@@ -1863,7 +1874,8 @@
 	fstring server, share, user, password, workgroup;
 	pstring path;
 
-	if (!context || !context->_initialized) {
+	if (!context || !context->internal || 
+	    !context->internal->_initialized) {
 
 		errno = EINVAL;
 		return -1;
@@ -1949,7 +1961,8 @@
 	fstring server, share, user, password, workgroup;
 	pstring path;
 
-	if (!context || !context->_initialized) {
+	if (!context || !context->internal || 
+	    !context->internal->_initialized) {
 
 		errno = EINVAL;
 		return -1;
@@ -2046,14 +2059,15 @@
 static off_t smbc_telldir_ctx(SMBCCTX *context, SMBCFILE *dir)
 {
 
-	if (!context || !context->_initialized) {
+	if (!context || !context->internal ||
+	    !context->internal->_initialized) {
 
 		errno = EINVAL;
 		return -1;
 
 	}
 
-	if (!dir || !DLIST_CONTAINS(context->_files, dir)) {
+	if (!dir || !DLIST_CONTAINS(context->internal->_files, dir)) {
 
 		errno = EBADF;
 		return -1;
@@ -2110,7 +2124,8 @@
 	struct smbc_dirent *dirent = (struct smbc_dirent *)offset;
 	struct smbc_dir_list *list_ent = NULL;
 
-	if (!context || !context->_initialized) {
+	if (!context || !context->internal ||
+	    !context->internal->_initialized) {
 
 		errno = EINVAL;
 		return -1;
@@ -2156,7 +2171,8 @@
 static int smbc_fstatdir_ctx(SMBCCTX *context, SMBCFILE *dir, struct stat *st)
 {
 
-	if (context || !context->_initialized) {
+	if (!context || !context->internal || 
+	    !context->internal->_initialized) {
 
 		errno = EINVAL;
 		return -1;
@@ -2178,7 +2194,8 @@
 	fstring server, share, user, password;
 	pstring path;
 	
-	if (!context || context->_initialized) {
+	if (!context || !context->internal ||
+	    !context->internal->_initialized) {
 
 		errno = EINVAL;
 		return NULL;
@@ -2215,8 +2232,8 @@
 	int bytes, saverr, tot_bytes = 0;
 	char buf[4096];
 
-	if (!c_file || !c_file->_initialized || !c_print ||
-	    !c_print->_initialized) {
+	if (!c_file || !c_file->internal->_initialized || !c_print ||
+	    !c_print->internal->_initialized) {
 
 		errno = EINVAL;
 		return -1;
@@ -2285,13 +2302,14 @@
  * Routine to list print jobs on a printer share ...
  */
 
-static int smbc_list_print_jobs_ctx(SMBCCTX *context, const char *fname, void (*fn)(struct print_job_info *))
+static int smbc_list_print_jobs_ctx(SMBCCTX *context, const char *fname, smbc_list_print_job_fn fn)
 {
 	SMBCSRV *srv;
 	fstring server, share, user, password, workgroup;
 	pstring path;
 
-	if (!context || !context->_initialized) {
+	if (!context || !context->internal ||
+	    !context->internal->_initialized) {
 
 		errno = EINVAL;
 		return -1;
@@ -2321,7 +2339,7 @@
 
 	}
 
-	if (cli_print_queue(&srv->cli, fn) < 0) {
+	if (cli_print_queue(&srv->cli, (void (*)(struct print_job_info *))fn) < 0) {
 
 		errno = smbc_errno(context, &srv->cli);
 		return -1;
@@ -2343,7 +2361,8 @@
 	pstring path;
 	int err;
 
-	if (!context || !context->_initialized) {
+	if (!context || !context->internal ||
+	    !context->internal->_initialized) {
 
 		errno = EINVAL;
 		return -1;
@@ -2394,14 +2413,23 @@
 {
 	SMBCCTX * context;
 
-	context = malloc(sizeof(*context));
+	context = malloc(sizeof(SMBCCTX));
 	if (!context) {
 		errno = ENOMEM;
 		return NULL;
 	}
-	
+
 	ZERO_STRUCTP(context);
 
+	context->internal = malloc(sizeof(struct smbc_internal_data));
+	if (!context->internal) {
+		errno = ENOMEM;
+		return NULL;
+	}
+
+	ZERO_STRUCTP(context->internal);
+
+	
 	/* ADD REASONABLE DEFAULTS */
 	context->debug            = 0;
 	context->timeout          = 20000; /* 20 seconds */
@@ -2456,25 +2484,25 @@
 		SMBCFILE * f;
 		DEBUG(1,("Performing aggressive shutdown.\n"));
 		
-		f = context->_files;
+		f = context->internal->_files;
 		while (f) {
 			context->close(context, f);
 			f = f->next;
 		}
-		context->_files = NULL;
+		context->internal->_files = NULL;
 
 		/* First try to remove the servers the nice way. */
 		if (context->callbacks.purge_cached_fn(context)) {
 			SMBCSRV * s;
 			DEBUG(1, ("Could not purge all servers, Nice way shutdown failed.\n"));
-			s = context->_servers;
+			s = context->internal->_servers;
 			while (s) {
 				cli_shutdown(&s->cli);
 				context->callbacks.remove_cached_srv_fn(context, s);
 				SAFE_FREE(s);
 				s = s->next;
 			}
-			context->_servers = NULL;
+			context->internal->_servers = NULL;
 		}
 	}
 	else {
@@ -2484,12 +2512,12 @@
 			errno = EBUSY;
 			return 1;
 		}
-		if (context->_servers) {
+		if (context->internal->_servers) {
 			DEBUG(1, ("Active servers in context, free_context failed.\n"));
 			errno = EBUSY;
 			return 1;
 		}
-		if (context->_files) {
+		if (context->internal->_files) {
 			DEBUG(1, ("Active files in context, free_context failed.\n"));
 			errno = EBUSY;
 			return 1;
@@ -2502,6 +2530,7 @@
 	SAFE_FREE(context->user);
 	
 	DEBUG(3, ("Context %p succesfully freed\n", context));
+	SAFE_FREE(context->internal);
 	SAFE_FREE(context);
 	return 0;
 }
@@ -2520,13 +2549,13 @@
 	int pid;
 	char *user = NULL, *home = NULL;
 
-	if (!context) {
+	if (!context || !context->internal) {
 		errno = EBADF;
 		return NULL;
 	}
 
 	/* Do not initialise the same client twice */
-	if (context->_initialized) { 
+	if (context->internal->_initialized) { 
 		return 0;
 	}
 
@@ -2633,7 +2662,7 @@
 	 * FIXME: Should we check the function pointers here? 
 	 */
 
-	context->_initialized = 1;
+	context->internal->_initialized = 1;
 	
 	return context;
 }
diff -uNr samba-3.0alpha21.orig/source/libsmb/namecache.c samba-3.0alpha21/source/libsmb/namecache.c
--- samba-3.0alpha21.orig/source/libsmb/namecache.c	2003-02-16 19:06:32.000000000 -0600
+++ samba-3.0alpha21/source/libsmb/namecache.c	2003-02-16 19:05:45.000000000 -0600
@@ -1,9 +1,10 @@
 /* 
    Unix SMB/CIFS implementation.
 
-   NetBIOS name cache module.
-
-   Copyright (C) Tim Potter, 2002
+   NetBIOS name cache module on top of gencache mechanism.
+   
+   Copyright (C) Tim Potter         2002
+   Copyright (C) Rafal Szczesniak   2002
    
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -22,242 +23,224 @@
 
 #include "includes.h"
 
-static BOOL done_namecache_init;
-static BOOL enable_namecache;
-static TDB_CONTEXT *namecache_tdb;
-
-struct nc_value {
-	time_t expiry;		     /* When entry expires */
-	int count;		     /* Number of addresses */
-	struct in_addr ip_list[1];   /* Address list */
-};
+#define NBTKEY_FMT  "NBT/%s#%02X"
+
 
-/* Initialise namecache system */
+/**
+ * Initialise namecache system. Function calls gencache
+ * initialisation function to perform necessary actions
+ * 
+ * @return true upon successful initialisation of the cache or
+ *         false on failure
+ **/
 
 BOOL namecache_enable(void)
 {
-	/* Check if we have been here before, or name caching disabled
-           by setting the name cache timeout to zero. */ 
-
-	if (done_namecache_init)
-		return False;
-
-	done_namecache_init = True;
+	/*
+	 * Check if name caching disabled by setting the name cache
+	 * timeout to zero.
+	 */ 
 
 	if (lp_name_cache_timeout() == 0) {
-		DEBUG(5, ("namecache_init: disabling netbios name cache\n"));
+		DEBUG(5, ("namecache_enable: disabling netbios name cache\n"));
 		return False;
 	}
 
-	/* Open namecache tdb in read/write or readonly mode */
+	/* Init namecache by calling gencache initialisation */
 
-	namecache_tdb = tdb_open_log(
-		lock_path("namecache.tdb"), 0,
-		TDB_DEFAULT, O_RDWR | O_CREAT, 0644);
-
-	if (!namecache_tdb) {
-		DEBUG(5, ("namecache_init: could not open %s\n",
-			  lock_path("namecache.tdb")));
+	if (!gencache_init()) {
+		DEBUG(2, ("namecache_enable: Couldn't initialise namecache on top of gencache.\n"));
 		return False;
 	}
 
-	DEBUG(5, ("namecache_init: enabling netbios namecache, timeout %d "
+	/* I leave it for now, though I don't think we really need this (mimir, 27.09.2002) */
+	DEBUG(5, ("namecache_enable: enabling netbios namecache, timeout %d "
 		  "seconds\n", lp_name_cache_timeout()));
 
-	enable_namecache = True;
-
 	return True;
 }
 
-/* Return a key for a name and name type.  The caller must free
-   retval.dptr when finished. */
 
-static TDB_DATA namecache_key(const char *name, int name_type)
+/**
+ * Shutdown namecache. Routine calls gencache close function
+ * to safely close gencache file.
+ *
+ * @return true upon successful shutdown of the cache or
+ *         false on failure
+ **/
+ 
+BOOL namecache_shutdown(void)
 {
-	TDB_DATA retval;
-	char *keystr;
-
-	asprintf(&keystr, "%s#%02X", strupper_static(name), name_type);
-
-	retval.dsize = strlen(keystr) + 1;
-	retval.dptr = keystr;
-
-	return retval;
+	if (!gencache_shutdown()) {
+		DEBUG(2, ("namecache_shutdown: Couldn't close namecache on top of gencache.\n"));
+		return False;
+	}
+	
+	DEBUG(5, ("namecache_shutdown: netbios namecache closed successfully.\n"));
+	return True;
 }
 
-/* Return a data value for an IP list.  The caller must free
-   retval.dptr when finished. */
-
-static TDB_DATA namecache_value(struct in_addr *ip_list, int num_names, 
-				time_t expiry)
-{
-	TDB_DATA retval;
-	struct nc_value *value;
-	int size = sizeof(struct nc_value);
 
-	if (num_names > 0)
-		size += sizeof(struct in_addr) * (num_names-1);
+/**
+ * Generates a key for netbios name lookups on basis of
+ * netbios name and type.
+ * The caller must free returned key string when finished.
+ *
+ * @param name netbios name string (case insensitive)
+ * @param name_type netbios type of the name being looked up
+ *
+ * @return string consisted of uppercased name and appended
+ *         type number
+ */
 
-	value = (struct nc_value *)malloc(size);
-
-	memset(value, 0, size);
-
-	value->expiry = expiry;
-	value->count = num_names;
-
-	if (ip_list)
-		memcpy(value->ip_list, ip_list, sizeof(struct in_addr) * num_names);
-
-	retval.dptr = (char *)value;
-	retval.dsize = size;
+static char* namecache_key(const char *name, int name_type)
+{
+	char *keystr;
+	asprintf(&keystr, NBTKEY_FMT, strupper_static(name), name_type);
 
-	return retval;
+	return keystr;
 }
 
-/* Store a name in the name cache */
 
-void namecache_store(const char *name, int name_type,
-		     int num_names, struct in_addr *ip_list)
+/**
+ * Store a name(s) in the name cache
+ *
+ * @param name netbios names array
+ * @param name_type integer netbios name type
+ * @param num_names number of names being stored
+ * @param ip_list array of in_addr structures containing
+ *        ip addresses being stored
+ **/
+
+BOOL namecache_store(const char *name, int name_type,
+                     int num_names, struct in_addr *ip_list)
 {
-	TDB_DATA key, value;
 	time_t expiry;
+	char *key, *value_string;
 	int i;
 
-	if (!enable_namecache)
-		return;
+	/*
+	 * we use gecache call to avoid annoying debug messages about
+	 * initialised namecache again and again...
+	 */
+	if (!gencache_init()) return False;
 
 	DEBUG(5, ("namecache_store: storing %d address%s for %s#%02x: ",
-		  num_names, num_names == 1 ? "": "es", name, name_type));
+	          num_names, num_names == 1 ? "": "es", name, name_type));
 
 	for (i = 0; i < num_names; i++) 
 		DEBUGADD(5, ("%s%s", inet_ntoa(ip_list[i]),
-			     i == (num_names - 1) ? "" : ", "));
+		             i == (num_names - 1) ? "" : ", "));
 
 	DEBUGADD(5, ("\n"));
 
 	key = namecache_key(name, name_type);
 
-	/* Cache pdc location or dc lists for only a little while
-	   otherwise if we lock on to a bad DC we can potentially be
-	   out of action for the entire cache timeout time! */
+	/* 
+	 * Cache pdc location or dc lists for only a little while
+	 * otherwise if we lock on to a bad DC we can potentially be
+	 * out of action for the entire cache timeout time!
+	 */
 
-	if (name_type != 0x1b || name_type != 0x1c)
+	if (name_type == 0x1b || name_type == 0x1c)
 		expiry = time(NULL) + 10;
 	else
 		expiry = time(NULL) + lp_name_cache_timeout();
 
-	value = namecache_value(ip_list, num_names, expiry);
-
-	tdb_store(namecache_tdb, key, value, TDB_REPLACE);
-
-	free(key.dptr);
-	free(value.dptr);
+	/*
+	 * Generate string representation of ip addresses list
+	 * First, store the number of ip addresses and then
+	 * place each single ip
+	 */
+	ipstr_list_make(&value_string, ip_list, num_names);
+	
+	/* set the entry */
+	return (gencache_set(key, value_string, expiry));
 }
 
-/* Look up a name in the name cache.  Return a mallocated list of IP
-   addresses if the name is contained in the cache. */
+
+/**
+ * Look up a name in the cache.
+ *
+ * @param name netbios name to look up for
+ * @param name_type netbios name type of @param name
+ * @param ip_list mallocated list of IP addresses if found in the cache,
+ *        NULL otherwise
+ * @param num_names number of entries found
+ *
+ * @return true upon successful fetch or
+ *         false if name isn't found in the cache or has expired
+ **/
 
 BOOL namecache_fetch(const char *name, int name_type, struct in_addr **ip_list,
-		     int *num_names)
+                     int *num_names)
 {
-	TDB_DATA key, value;
-	struct nc_value *data = NULL;
-	time_t now;
-	int i;
+	char *key, *value;
+	time_t timeout;
 
-	*ip_list = NULL;
 	*num_names = 0;
 
-	if (!enable_namecache)
-		return False;
+	/* exit now if null pointers were passed as they're required further */
+	if (!ip_list || !num_names) return False;
 
-	/* Read value */
+	if (!gencache_init())
+		return False;
 
+	/* 
+	 * Use gencache interface - lookup the key
+	 */
 	key = namecache_key(name, name_type);
 
-	value = tdb_fetch(namecache_tdb, key);
-	
-	if (!value.dptr) {
-		DEBUG(5, ("namecache_fetch: %s#%02x not found\n",
-			  name, name_type));
-		goto done;
-	}
-
-	data = (struct nc_value *)value.dptr;
-
-	/* Check expiry time */
-
-	now = time(NULL);
-
-	if (now > data->expiry) {
-
-		DEBUG(5, ("namecache_fetch: entry for %s#%02x expired\n",
-			  name, name_type));
-
-		tdb_delete(namecache_tdb, key);
-
-		value = tdb_null;
-
-		goto done;
-	}
-
-	if ((data->expiry - now) > lp_name_cache_timeout()) {
-
-		/* Someone may have changed the system time on us */
-
-		DEBUG(5, ("namecache_fetch: entry for %s#%02x has bad expiry\n",
-			  name, name_type));
-
-		tdb_delete(namecache_tdb, key);
-
-		value = tdb_null;
-
-		goto done;
-	}
-
-	/* Extract and return namelist */
-
-	DEBUG(5, ("namecache_fetch: returning %d address%s for %s#%02x: ",
-		  data->count, data->count == 1 ? "" : "es", name, name_type));
-
-	if (data->count) {
-
-		*ip_list = (struct in_addr *)malloc(
-			sizeof(struct in_addr) * data->count);
-		
-		memcpy(*ip_list, data->ip_list, sizeof(struct in_addr) * data->count);
-		
-		*num_names = data->count;
-		
-		for (i = 0; i < *num_names; i++)
-			DEBUGADD(5, ("%s%s", inet_ntoa((*ip_list)[i]),
-				     i == (*num_names - 1) ? "" : ", "));
-
+	if (!gencache_get(key, &value, &timeout)) {
+		DEBUG(5, ("no entry for %s#%02X found.\n", name, name_type));
+		SAFE_FREE(key);
+		return False;
+	} else {
+		DEBUG(5, ("name %s#%02X found.\n", name, name_type));
 	}
+	
+	/*
+	 * Split up the stored value into the list of IP adresses
+	 */
+	*num_names = ipstr_list_parse(value, ip_list);
+	
+	SAFE_FREE(key);
+	SAFE_FREE(value);		 
+	return *num_names > 0;		/* true only if some ip has been fetched */
+}
 
-	DEBUGADD(5, ("\n"));
 
-done:
-	SAFE_FREE(key.dptr);
-	SAFE_FREE(data);
+/**
+ * Delete single namecache entry. Look at the
+ * gencache_iterate definition.
+ *
+ **/
 
-	return value.dsize > 0;
+static void flush_netbios_name(const char* key, const char *value, time_t timeout, void* dptr)
+{
+	gencache_del(key);
+	DEBUG(5, ("Deleting entry %s\n", key));
 }
 
-/* Flush all names from the name cache */
+
+/**
+ * Flush all names from the name cache.
+ * It's done by gencache_iterate()
+ *
+ * @return True upon successful deletion or
+ *         False in case of an error
+ **/
 
 void namecache_flush(void)
 {
-	int result;
-
-	if (!namecache_tdb)
+	if (!gencache_init())
 		return;
 
-	result = tdb_traverse(namecache_tdb, tdb_traverse_delete_fn, NULL);
-
-	if (result == -1)
-		DEBUG(5, ("namecache_flush: error deleting cache entries\n"));
-	else
-		DEBUG(5, ("namecache_flush: deleted %d cache entr%s\n", 
-			  result, result == 1 ? "y" : "ies"));
+	/* 
+	 * iterate through each NBT cache's entry and flush it
+	 * by flush_netbios_name function
+	 */
+	gencache_iterate(flush_netbios_name, NULL, "NBT/*");
+	DEBUG(5, ("Namecache flushed\n"));
 }
+
diff -uNr samba-3.0alpha21.orig/source/libsmb/namequery.c samba-3.0alpha21/source/libsmb/namequery.c
--- samba-3.0alpha21.orig/source/libsmb/namequery.c	2003-02-16 19:06:32.000000000 -0600
+++ samba-3.0alpha21/source/libsmb/namequery.c	2003-02-16 19:05:45.000000000 -0600
@@ -837,11 +837,6 @@
 			  if (resolve_hosts(name, return_iplist, return_count)) {
 				  result = True;
 				  goto done;
-			  } else {
-
-				  /* Store negative lookup result */
-
-				  namecache_store(name, name_type, 0, NULL);
 			  }
 		  }
 	  } else if(strequal( tok, "lmhosts")) {
@@ -916,7 +911,10 @@
   }
  
   /* Save in name cache */
-
+  for (i = 0; i < *return_count && DEBUGLEVEL == 100; i++)
+    DEBUG(100, ("Storing name %s of type %d (ip: %s)\n", name,
+                name_type, inet_ntoa((*return_iplist)[i])));
+    
   namecache_store(name, name_type, *return_count, *return_iplist);
 
   /* Display some debugging info */
@@ -1216,15 +1214,34 @@
 {
 	struct in_addr *ip_list;
 	int count;
+	int i = 0;
 
 	/* Look up #1B name */
 
 	if (!internal_resolve_name(domain, 0x1b, &ip_list, &count))
 		return False;
 
-	SMB_ASSERT(count == 1);
+	/* if we get more than 1 IP back we have to assume it is a
+	   multi-homed PDC and not a mess up */
+	   
+	if ( count > 1 ) {
+		DEBUG(6,("get_pdc_ip: PDC has %d IP addresses!\n", count));
+				
+		/* look for a local net */
+		for ( i=0; i<count; i++ ) {
+			if ( is_local_net( ip_list[i] ) )
+				break;
+		}
+		
+		/* if we hit then end then just grab the first 
+		   one from the list */
+		   
+		if ( i == count )
+			i = 0;
+	}
 
-	*ip = ip_list[0];
+	*ip = ip_list[i];
+	
 	SAFE_FREE(ip_list);
 
 	return True;
@@ -1296,8 +1313,7 @@
 
 		/* fill in the return list now with real IP's */
 				
-		while ( (local_count<num_addresses) && next_token(&p,name,LIST_SEP,sizeof(name)) ) 
-		{
+		while ( (local_count<num_addresses) && next_token(&p,name,LIST_SEP,sizeof(name)) ) {
 			struct in_addr name_ip;
 			
 			/* copy any addersses from the auto lookup */
@@ -1308,7 +1324,7 @@
 				continue;
 			}
 			
-			/* explicit lookup */
+			/* explicit lookup; resolve_name() will handle names & IP addresses */
 					
 			if ( resolve_name( name, &name_ip, 0x20) ) {
 				return_iplist[local_count++] = name_ip;
@@ -1317,16 +1333,14 @@
 				
 		}
 				
+		SAFE_FREE(auto_ip_list);
+
 		/* need to remove duplicates in the list if we have 
 		   any explicit password servers */
 		   
-		if ( *ordered )
-		{		
-			int hole_index = -1;
-
+		if ( *ordered ) {		
 			/* one loop to remove duplicates */
-			for ( i=0; i<local_count; i++ )
-			{
+			for ( i=0; i<local_count; i++ ) {
 				if ( is_zero_ip(return_iplist[i]) )
 					continue;
 					
@@ -1337,29 +1351,17 @@
 			}
 			
 			/* one loop to clean up any holes we left */
-			/* first ip can never be a zero_ip() */
-			i = 0;
-			while ( i<local_count )
-			{
-				if ( !is_zero_ip(return_iplist[i]) ) {
-					i++;
+			/* first ip should never be a zero_ip() */
+			for (i = 0; i<local_count; ) {
+				if ( is_zero_ip(return_iplist[i]) ) {
+					if (i != local_count-1 )
+						memmove(&return_iplist[i], &return_iplist[i+1],
+							(local_count - i - 1)*sizeof(return_iplist[i]));
+					local_count--;
 					continue;
 				}
-				
-				hole_index = i;
 				i++;
-				
-				while ( i<local_count ) {
-					if ( !is_zero_ip(return_iplist[i]) )
-						return_iplist[hole_index++] = return_iplist[i];
-					i++;
-				}
-				
-				/* we should exit the loop implicitly here, but ... */
-				break;
 			}
-			
-			local_count = hole_index;
 		}
 		
 		*ip_list = return_iplist;
diff -uNr samba-3.0alpha21.orig/source/libsmb/namequery_dc.c samba-3.0alpha21/source/libsmb/namequery_dc.c
--- samba-3.0alpha21.orig/source/libsmb/namequery_dc.c	1969-12-31 18:00:00.000000000 -0600
+++ samba-3.0alpha21/source/libsmb/namequery_dc.c	2003-02-16 19:05:45.000000000 -0600
@@ -0,0 +1,104 @@
+/* 
+   Unix SMB/CIFS implementation.
+
+   Winbind daemon connection manager
+
+   Copyright (C) Tim Potter 2001
+   Copyright (C) Andrew Bartlett 2002
+   
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+   
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+   GNU General Public License for more details.
+   
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*/
+
+
+#include "includes.h"
+
+
+/*
+  find the DC for a domain using methods appropriate for a RPC domain
+*/
+BOOL rpc_find_dc(const char *domain, fstring srv_name, struct in_addr *ip_out)
+{
+	struct in_addr *ip_list = NULL, dc_ip, exclude_ip;
+	int count, i;
+	BOOL list_ordered;
+	BOOL use_pdc_only;
+	
+	zero_ip(&exclude_ip);
+
+	use_pdc_only = must_use_pdc(domain);
+	
+	/* Lookup domain controller name */
+	   
+	if ( use_pdc_only && get_pdc_ip(domain, &dc_ip) ) {
+		DEBUG(10,("rpc_find_dc: Atempting to lookup PDC to avoid sam sync delays\n"));
+		
+		if (name_status_find(domain, 0x1c, 0x20, dc_ip, srv_name)) {
+			goto done;
+		}
+		/* Didn't get name, remember not to talk to this DC. */
+		exclude_ip = dc_ip;
+	}
+
+	/* get a list of all domain controllers */
+	
+	if (!get_dc_list( domain, &ip_list, &count, &list_ordered) ) {
+		DEBUG(3, ("Could not look up dc's for domain %s\n", domain));
+		return False;
+	}
+
+	/* Remove the entry we've already failed with (should be the PDC). */
+
+	if ( use_pdc_only ) {
+		for (i = 0; i < count; i++) {	
+			if (ip_equal( exclude_ip, ip_list[i]))
+				zero_ip(&ip_list[i]);
+		}
+	}
+
+	/* Pick a nice close server, but only if the list was not ordered */
+	if (!list_ordered && (count > 1) ) {
+		qsort(ip_list, count, sizeof(struct in_addr), QSORT_CAST ip_compare);
+	}
+
+	for (i = 0; i < count; i++) {
+		if (is_zero_ip(ip_list[i]))
+			continue;
+
+		if (name_status_find(domain, 0x1c, 0x20, ip_list[i], srv_name)) {
+			dc_ip = ip_list[i];
+			goto done;
+		}
+	}
+
+
+	SAFE_FREE(ip_list);
+
+	return False;
+done:
+	/* We have the netbios name and IP address of a domain controller.
+	   Ideally we should sent a SAMLOGON request to determine whether
+	   the DC is alive and kicking.  If we can catch a dead DC before
+	   performing a cli_connect() we can avoid a 30-second timeout. */
+
+	DEBUG(3, ("rpc_find_dc: Returning DC %s (%s) for domain %s\n", srv_name,
+		  inet_ntoa(dc_ip), domain));
+
+	*ip_out = dc_ip;
+
+	SAFE_FREE(ip_list);
+
+	return True;
+}
+
diff -uNr samba-3.0alpha21.orig/source/libsmb/netlogon_unigrp.c samba-3.0alpha21/source/libsmb/netlogon_unigrp.c
--- samba-3.0alpha21.orig/source/libsmb/netlogon_unigrp.c	2003-02-16 19:06:32.000000000 -0600
+++ samba-3.0alpha21/source/libsmb/netlogon_unigrp.c	2003-02-16 19:05:45.000000000 -0600
@@ -47,7 +47,7 @@
 	return (netlogon_unigrp_tdb != NULL);
 }
 
-void uni_group_cache_store_netlogon(TALLOC_CTX *mem_ctx, NET_USER_INFO_3 *user)
+BOOL  uni_group_cache_store_netlogon(TALLOC_CTX *mem_ctx, NET_USER_INFO_3 *user)
 {
 	TDB_DATA key,data;
         fstring keystr;
@@ -55,7 +55,7 @@
 
 	if (!uni_group_cache_init()) {
 		DEBUG(0,("uni_group_cache_store_netlogon: cannot open netlogon_unigrp.tdb for write!\n"));
-		return;
+		return False;
 	}
 
 	/* Prepare key as DOMAIN-SID/USER-RID string */
@@ -70,7 +70,7 @@
 	if(!data.dptr) {
 		DEBUG(0,("uni_group_cache_store_netlogon: cannot allocate memory!\n"));
 		talloc_destroy(mem_ctx);
-		return;
+		return False;
 	}
 	
 	/* Store data in byteorder-independent format */
@@ -78,7 +78,9 @@
 	for(i=1; i<=user->num_groups2; i++) {
 		SIVAL(&((uint32*)data.dptr)[i],0,user->gids[i-1].g_rid);
 	}
-	tdb_store(netlogon_unigrp_tdb, key, data, TDB_REPLACE);	
+	if (tdb_store(netlogon_unigrp_tdb, key, data, TDB_REPLACE) == -1)
+		return False;
+	return True;
 }
 
 /*
@@ -149,10 +151,9 @@
 }
 
 /* Shutdown netlogon_unigrp database */
-void uni_group_cache_shutdown(void)
+BOOL uni_group_cache_shutdown(void)
 {
-	if(netlogon_unigrp_tdb) {
-		tdb_close(netlogon_unigrp_tdb);
-	}
+	if(netlogon_unigrp_tdb)
+		return (tdb_close(netlogon_unigrp_tdb) == 0);
+	return True;
 }
-
diff -uNr samba-3.0alpha21.orig/source/libsmb/nmblib.c samba-3.0alpha21/source/libsmb/nmblib.c
--- samba-3.0alpha21.orig/source/libsmb/nmblib.c	2003-02-16 19:06:32.000000000 -0600
+++ samba-3.0alpha21/source/libsmb/nmblib.c	2003-02-16 19:05:45.000000000 -0600
@@ -25,7 +25,7 @@
 int num_good_receives = 0;
 
 static const struct opcode_names {
-	char *nmb_opcode_name;
+	const char *nmb_opcode_name;
 	int opcode;
 } nmb_header_opcode_names[] = {
 	{"Query",           0 },
@@ -57,7 +57,7 @@
 /****************************************************************************
   print out a res_rec structure
   ****************************************************************************/
-static void debug_nmb_res_rec(struct res_rec *res, char *hdr)
+static void debug_nmb_res_rec(struct res_rec *res, const char *hdr)
 {
   int i, j;
 
@@ -1005,7 +1005,7 @@
   queue. The packet must be a reply packet and have the specified mailslot name
   The timeout is in milliseconds
   ***************************************************************************/
-struct packet_struct *receive_dgram_packet(int fd, int t, char *mailslot_name)
+struct packet_struct *receive_dgram_packet(int fd, int t, const char *mailslot_name)
 {
 	struct packet_struct *p;
 
@@ -1024,7 +1024,7 @@
 /****************************************************************************
  see if a datagram has the right mailslot name
 ***************************************************************************/
-BOOL match_mailslot_name(struct packet_struct *p, char *mailslot_name)
+BOOL match_mailslot_name(struct packet_struct *p, const char *mailslot_name)
 {
 	struct dgram_packet *dgram = &p->packet.dgram;
 	char *buf;
@@ -1203,7 +1203,7 @@
   p[0] = '\0';
 
   /* Add the scope string. */
-  for( i = 0, len = 0; NULL != global_scope(); i++, len++ )
+  for( i = 0, len = 0; *(global_scope()) != '\0'; i++, len++ )
     {
     switch( (global_scope())[i] )
       {
diff -uNr samba-3.0alpha21.orig/source/libsmb/nterr.c samba-3.0alpha21/source/libsmb/nterr.c
--- samba-3.0alpha21.orig/source/libsmb/nterr.c	2003-02-16 19:06:32.000000000 -0600
+++ samba-3.0alpha21/source/libsmb/nterr.c	2003-02-16 19:05:45.000000000 -0600
@@ -24,7 +24,7 @@
 
 typedef const struct
 {
-	char *nt_errstr;
+	const char *nt_errstr;
 	NTSTATUS nt_errcode;
 } nt_err_code_struct;
 
@@ -541,29 +541,99 @@
 
 nt_err_code_struct nt_err_desc[] =
 {
-	{ "Success", NT_STATUS_OK },
-	{ "Undetermined error", NT_STATUS_UNSUCCESSFUL },
-	{ "Access denied", NT_STATUS_ACCESS_DENIED },
-	{ "Account locked out", NT_STATUS_ACCOUNT_LOCKED_OUT },
-	{ "Password is too short", NT_STATUS_PWD_TOO_SHORT },
-	{ "Password is too recent", NT_STATUS_PWD_TOO_RECENT },
-	{ "Password history conflict", NT_STATUS_PWD_HISTORY_CONFLICT },
-	{ "No logon servers", NT_STATUS_NO_LOGON_SERVERS },
-	{ "Invalid account name", NT_STATUS_INVALID_ACCOUNT_NAME },
-	{ "User exists", NT_STATUS_USER_EXISTS },
-	{ "No such user", NT_STATUS_NO_SUCH_USER },
-	{ "Group exists", NT_STATUS_GROUP_EXISTS },
-	{ "No such group", NT_STATUS_NO_SUCH_GROUP },
-	{ "Member not in group", NT_STATUS_MEMBER_NOT_IN_GROUP },
-	{ "Wrong Password", NT_STATUS_WRONG_PASSWORD },
-	{ "Ill formed password", NT_STATUS_ILL_FORMED_PASSWORD },
-	{ "Password restriction", NT_STATUS_PASSWORD_RESTRICTION },
-	{ "Logon failure", NT_STATUS_LOGON_FAILURE },
-	{ "Account restruction", NT_STATUS_ACCOUNT_RESTRICTION },
-	{ "Invalid logon hours", NT_STATUS_INVALID_LOGON_HOURS },
-	{ "Invalid workstation", NT_STATUS_INVALID_WORKSTATION },
-	{ "Password expired", NT_STATUS_PASSWORD_EXPIRED },
-	{ "Account Disabled", NT_STATUS_ACCOUNT_DISABLED },
+	{ "Success", 				NT_STATUS_OK },
+	{ "Undetermined error", 		NT_STATUS_UNSUCCESSFUL },
+	{ "Access denied", 			NT_STATUS_ACCESS_DENIED },
+	{ "Account locked out", 		NT_STATUS_ACCOUNT_LOCKED_OUT },
+	{ "Must change password", 		NT_STATUS_PASSWORD_MUST_CHANGE },
+	{ "Password is too short", 		NT_STATUS_PWD_TOO_SHORT },
+	{ "Password is too recent", 		NT_STATUS_PWD_TOO_RECENT },
+	{ "Password history conflict", 		NT_STATUS_PWD_HISTORY_CONFLICT },
+	{ "No logon servers", 			NT_STATUS_NO_LOGON_SERVERS },
+	{ "Improperly formed account name", 	NT_STATUS_INVALID_ACCOUNT_NAME },
+	{ "User exists", 			NT_STATUS_USER_EXISTS },
+	{ "No such user", 			NT_STATUS_NO_SUCH_USER },
+	{ "Group exists", 			NT_STATUS_GROUP_EXISTS },
+	{ "No such group", 			NT_STATUS_NO_SUCH_GROUP },
+	{ "Member not in group", 		NT_STATUS_MEMBER_NOT_IN_GROUP },
+	{ "Wrong Password", 			NT_STATUS_WRONG_PASSWORD },
+	{ "Ill formed password", 		NT_STATUS_ILL_FORMED_PASSWORD },
+	{ "Password restriction", 		NT_STATUS_PASSWORD_RESTRICTION },
+	{ "Logon failure", 			NT_STATUS_LOGON_FAILURE },
+	{ "Account restriction", 		NT_STATUS_ACCOUNT_RESTRICTION },
+	{ "Invalid logon hours", 		NT_STATUS_INVALID_LOGON_HOURS },
+	{ "Invalid workstation", 		NT_STATUS_INVALID_WORKSTATION },
+	{ "Password expired", 			NT_STATUS_PASSWORD_EXPIRED },
+	{ "Account disabled", 			NT_STATUS_ACCOUNT_DISABLED },
+	{ "Unexpected information received", 	NT_STATUS_INVALID_PARAMETER },
+	{ "Memory allocation error", 		NT_STATUS_NO_MEMORY },
+	{ "No domain controllers located", 	NT_STATUS_DOMAIN_CONTROLLER_NOT_FOUND },
+	{ "Account locked out", 		NT_STATUS_ACCOUNT_LOCKED_OUT },
+	{ "Named pipe not available", 		NT_STATUS_PIPE_NOT_AVAILABLE },
+	{ "Not implemented", 			NT_STATUS_NOT_IMPLEMENTED },
+	{ "Invalid information class", 		NT_STATUS_INVALID_INFO_CLASS },
+	{ "Information length mismatch", 	NT_STATUS_INFO_LENGTH_MISMATCH },
+	{ "Access violation", 			NT_STATUS_ACCESS_VIOLATION },
+	{ "Invalid handle", 			NT_STATUS_INVALID_HANDLE },
+	{ "Invalid parameter", 			NT_STATUS_INVALID_PARAMETER },
+	{ "No memory", 				NT_STATUS_NO_MEMORY },
+	{ "Buffer too small", 			NT_STATUS_BUFFER_TOO_SMALL },
+	{ "Revision mismatch", 			NT_STATUS_REVISION_MISMATCH },
+	{ "No logon servers", 			NT_STATUS_NO_LOGON_SERVERS },
+	{ "No such logon session", 		NT_STATUS_NO_SUCH_LOGON_SESSION },
+	{ "No such privilege", 			NT_STATUS_NO_SUCH_PRIVILEGE },
+	{ "Procedure not found", 		NT_STATUS_PROCEDURE_NOT_FOUND },
+	{ "Server disabled", 			NT_STATUS_SERVER_DISABLED },
+	{ "Invalid pipe state", 		NT_STATUS_INVALID_PIPE_STATE },
+	{ "Named pipe busy", 			NT_STATUS_PIPE_BUSY },
+	{ "Illegal function",		 	NT_STATUS_ILLEGAL_FUNCTION },
+	{ "Named pipe dicconnected", 		NT_STATUS_PIPE_DISCONNECTED },
+	{ "Named pipe closing", 		NT_STATUS_PIPE_CLOSING },
+	{ "Remote host not listening", 		NT_STATUS_REMOTE_NOT_LISTENING },
+	{ "Duplicate name on network", 		NT_STATUS_DUPLICATE_NAME },
+	{ "Print queue is full", 		NT_STATUS_PRINT_QUEUE_FULL },
+	{ "No print spool space available", 	NT_STATUS_NO_SPOOL_SPACE },
+	{ "Too many names", 			NT_STATUS_TOO_MANY_NAMES },
+	{ "Too many sessions", 			NT_STATUS_TOO_MANY_SESSIONS },
+	{ "Invalid server state", 		NT_STATUS_INVALID_SERVER_STATE },
+	{ "Invalid domain state", 		NT_STATUS_INVALID_DOMAIN_STATE },
+	{ "Invalid domain role", 		NT_STATUS_INVALID_DOMAIN_ROLE },
+	{ "No such domain", 			NT_STATUS_NO_SUCH_DOMAIN },
+	{ "Domain exists", 			NT_STATUS_DOMAIN_EXISTS },
+	{ "Domain limit exceeded", 		NT_STATUS_DOMAIN_LIMIT_EXCEEDED },
+	{ "Bad logon session state", 		NT_STATUS_BAD_LOGON_SESSION_STATE },
+	{ "Logon session collision", 		NT_STATUS_LOGON_SESSION_COLLISION },
+	{ "Invalid logon type", 		NT_STATUS_INVALID_LOGON_TYPE },
+	{ "Cancelled", 				NT_STATUS_CANCELLED },
+	{ "Invalid computer name", 		NT_STATUS_INVALID_COMPUTER_NAME },	
+	{ "Logon server conflict", 		NT_STATUS_LOGON_SERVER_CONFLICT },
+	{ "Time difference at domain controller", NT_STATUS_TIME_DIFFERENCE_AT_DC },
+	{ "Pipe broken", 			NT_STATUS_PIPE_BROKEN },
+	{ "Registry corrupt", 			NT_STATUS_REGISTRY_CORRUPT },
+	{ "Too many secrets", 			NT_STATUS_TOO_MANY_SECRETS },
+	{ "Too many SIDs", 			NT_STATUS_TOO_MANY_SIDS },
+	{ "Lanmanager cross encryption required", NT_STATUS_LM_CROSS_ENCRYPTION_REQUIRED },
+	{ "Log file full", 			NT_STATUS_LOG_FILE_FULL },
+	{ "No trusted LSA secret", 		NT_STATUS_NO_TRUST_LSA_SECRET },
+	{ "No trusted SAM account", 		NT_STATUS_NO_TRUST_SAM_ACCOUNT },
+	{ "Trusted domain failure", 		NT_STATUS_TRUSTED_DOMAIN_FAILURE },
+	{ "Trust relationship failure", 	NT_STATUS_TRUSTED_RELATIONSHIP_FAILURE },
+	{ "Trust failure", 			NT_STATUS_TRUST_FAILURE },
+	{ "Netlogon service not started", 	NT_STATUS_NETLOGON_NOT_STARTED },
+	{ "Account expired", 			NT_STATUS_ACCOUNT_EXPIRED },
+	{ "Network credential conflict", 	NT_STATUS_NETWORK_CREDENTIAL_CONFLICT },
+	{ "Remote session limit", 		NT_STATUS_REMOTE_SESSION_LIMIT },
+	{ "No logon interdomain trust account", NT_STATUS_NOLOGON_INTERDOMAIN_TRUST_ACCOUNT },
+	{ "No logon workstation trust account", NT_STATUS_NOLOGON_WORKSTATION_TRUST_ACCOUNT },
+	{ "No logon server trust account", 	NT_STATUS_NOLOGON_SERVER_TRUST_ACCOUNT },
+	{ "Domain trust inconsistent", 		NT_STATUS_DOMAIN_TRUST_INCONSISTENT },
+	{ "No user session key available", 	NT_STATUS_NO_USER_SESSION_KEY },
+	{ "User session deleted", 		NT_STATUS_USER_SESSION_DELETED },
+	{ "Insufficient server resources", 	NT_STATUS_INSUFF_SERVER_RESOURCES },
+	{ "Insufficient logon information", 	NT_STATUS_INSUFFICIENT_LOGON_INFO },
+	
+	{ "License quota exceeded", 		NT_STATUS_LICENSE_QUOTA_EXCEEDED },
+
 	{ NULL, NT_STATUS(0) }
 };
 
@@ -571,7 +641,7 @@
 /*****************************************************************************
  returns an NT error message.  not amazingly helpful, but better than a number.
  *****************************************************************************/
-char *nt_errstr(NTSTATUS nt_code)
+const char *nt_errstr(NTSTATUS nt_code)
 {
         static pstring msg;
         int idx = 0;
@@ -593,14 +663,14 @@
  Print friendler version fo NT error code
  ***********************************************************************/
  
-char *get_friendly_nt_error_msg(NTSTATUS nt_code)
+const char *get_friendly_nt_error_msg(NTSTATUS nt_code)
 {
         int idx = 0;
 
 	while (nt_err_desc[idx].nt_errstr != NULL) {
-		if (NT_STATUS_V(nt_errs[idx].nt_errcode) == NT_STATUS_V(nt_code)) 
+		if (NT_STATUS_V(nt_err_desc[idx].nt_errcode) == NT_STATUS_V(nt_code)) 
 		{
-                        return nt_errs[idx].nt_errstr;
+                        return nt_err_desc[idx].nt_errstr;
 		}
 		idx++;
 	}
@@ -613,7 +683,7 @@
 /*****************************************************************************
  returns an NT_STATUS constant as a string for inclusion in autogen C code
  *****************************************************************************/
-char *get_nt_error_c_code(NTSTATUS nt_code)
+const char *get_nt_error_c_code(NTSTATUS nt_code)
 {
         static pstring out;
         int idx = 0;
diff -uNr samba-3.0alpha21.orig/source/libsmb/ntlmssp.c samba-3.0alpha21/source/libsmb/ntlmssp.c
--- samba-3.0alpha21.orig/source/libsmb/ntlmssp.c	1969-12-31 18:00:00.000000000 -0600
+++ samba-3.0alpha21/source/libsmb/ntlmssp.c	2003-02-16 19:05:45.000000000 -0600
@@ -0,0 +1,281 @@
+/* 
+   Unix SMB/Netbios implementation.
+   Version 3.0
+   handle NLTMSSP, server side
+
+   Copyright (C) Andrew Tridgell      2001
+   Copyright (C) Andrew Bartlett 2001-2003
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+   
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+   
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*/
+
+#include "includes.h"
+
+/**
+ * Default challange generation code.
+ *
+ */
+   
+
+static const uint8 *get_challenge(struct ntlmssp_state *ntlmssp_state)
+{
+	static uchar chal[8];
+	generate_random_buffer(chal, sizeof(chal), False);
+
+	return chal;
+}
+
+NTSTATUS ntlmssp_server_start(NTLMSSP_STATE **ntlmssp_state)
+{
+	TALLOC_CTX *mem_ctx;
+
+	mem_ctx = talloc_init("NTLMSSP context");
+	
+	*ntlmssp_state = talloc_zero(mem_ctx, sizeof(**ntlmssp_state));
+	if (!*ntlmssp_state) {
+		DEBUG(0,("ntlmssp_start: talloc failed!\n"));
+		talloc_destroy(mem_ctx);
+		return NT_STATUS_NO_MEMORY;
+	}
+
+	ZERO_STRUCTP(*ntlmssp_state);
+
+	(*ntlmssp_state)->mem_ctx = mem_ctx;
+	(*ntlmssp_state)->get_challenge = get_challenge;
+
+	(*ntlmssp_state)->get_global_myname = global_myname;
+	(*ntlmssp_state)->get_domain = lp_workgroup;
+	(*ntlmssp_state)->server_role = ROLE_DOMAIN_MEMBER; /* a good default */
+
+	return NT_STATUS_OK;
+}
+
+NTSTATUS ntlmssp_server_end(NTLMSSP_STATE **ntlmssp_state)
+{
+	TALLOC_CTX *mem_ctx = (*ntlmssp_state)->mem_ctx;
+
+	data_blob_free(&(*ntlmssp_state)->chal);
+	data_blob_free(&(*ntlmssp_state)->lm_resp);
+	data_blob_free(&(*ntlmssp_state)->nt_resp);
+
+	SAFE_FREE((*ntlmssp_state)->user);
+	SAFE_FREE((*ntlmssp_state)->domain);
+	SAFE_FREE((*ntlmssp_state)->workstation);
+
+	talloc_destroy(mem_ctx);
+	*ntlmssp_state = NULL;
+	return NT_STATUS_OK;
+}
+
+NTSTATUS ntlmssp_server_update(NTLMSSP_STATE *ntlmssp_state, 
+			       DATA_BLOB request, DATA_BLOB *reply) 
+{
+	uint32 ntlmssp_command;
+	*reply = data_blob(NULL, 0);
+
+	if (!msrpc_parse(&request, "Cd",
+			 "NTLMSSP",
+			 &ntlmssp_command)) {
+		
+		return NT_STATUS_LOGON_FAILURE;
+	}
+
+	if (ntlmssp_command == NTLMSSP_NEGOTIATE) {
+		return ntlmssp_negotiate(ntlmssp_state, request, reply);
+	} else if (ntlmssp_command == NTLMSSP_AUTH) {
+		return ntlmssp_auth(ntlmssp_state, request, reply);
+	} else {
+		return NT_STATUS_LOGON_FAILURE;
+	}
+}
+
+static const char *ntlmssp_target_name(NTLMSSP_STATE *ntlmssp_state, 
+				       uint32 neg_flags, uint32 *chal_flags) 
+{
+	if (neg_flags & NTLMSSP_REQUEST_TARGET) {
+		*chal_flags |= NTLMSSP_CHAL_TARGET_INFO;
+		*chal_flags |= NTLMSSP_REQUEST_TARGET;
+		if (ntlmssp_state->server_role == ROLE_STANDALONE) {
+			*chal_flags |= NTLMSSP_TARGET_TYPE_SERVER;
+			return ntlmssp_state->get_global_myname();
+		} else {
+			*chal_flags |= NTLMSSP_TARGET_TYPE_DOMAIN;
+			return ntlmssp_state->get_domain();
+		};
+	} else {
+		return "";
+	}
+}
+
+NTSTATUS ntlmssp_negotiate(NTLMSSP_STATE *ntlmssp_state, 
+			   DATA_BLOB request, DATA_BLOB *reply) 
+{
+	DATA_BLOB struct_blob;
+	fstring dnsname, dnsdomname;
+	uint32 ntlmssp_command, neg_flags, chal_flags;
+	char *cliname=NULL, *domname=NULL;
+	const uint8 *cryptkey;
+	const char *target_name;
+
+	/* parse the NTLMSSP packet */
+#if 0
+	file_save("ntlmssp_negotiate.dat", request.data, request.length);
+#endif
+
+	if (!msrpc_parse(&request, "CddAA",
+			 "NTLMSSP",
+			 &ntlmssp_command,
+			 &neg_flags,
+			 &cliname,
+			 &domname)) {
+		return NT_STATUS_LOGON_FAILURE;
+	}
+
+	SAFE_FREE(cliname);
+	SAFE_FREE(domname);
+  
+	debug_ntlmssp_flags(neg_flags);
+
+	cryptkey = ntlmssp_state->get_challenge(ntlmssp_state);
+
+	data_blob_free(&ntlmssp_state->chal);
+	ntlmssp_state->chal = data_blob(cryptkey, 8);
+
+	/* Give them the challenge. For now, ignore neg_flags and just
+	   return the flags we want. Obviously this is not correct */
+	
+	chal_flags = 
+		NTLMSSP_NEGOTIATE_128 | 
+		NTLMSSP_NEGOTIATE_NTLM;
+	
+	if (neg_flags & NTLMSSP_NEGOTIATE_UNICODE) {
+		chal_flags |= NTLMSSP_NEGOTIATE_UNICODE;
+		ntlmssp_state->unicode = True;
+	} else {
+		chal_flags |= NTLMSSP_NEGOTIATE_OEM;
+	}
+
+	target_name = ntlmssp_target_name(ntlmssp_state, 
+					  neg_flags, &chal_flags); 
+
+	/* This should be a 'netbios domain -> DNS domain' mapping */
+	dnsdomname[0] = '\0';
+	get_mydomname(dnsdomname);
+	strlower(dnsdomname);
+	
+	dnsname[0] = '\0';
+	get_myfullname(dnsname);
+	strlower(dnsname);
+	
+	if (chal_flags & NTLMSSP_CHAL_TARGET_INFO) 
+	{
+		const char *target_name_dns = "";
+		if (chal_flags |= NTLMSSP_TARGET_TYPE_DOMAIN) {
+			target_name_dns = dnsdomname;
+		} else if (chal_flags |= NTLMSSP_TARGET_TYPE_SERVER) {
+			target_name_dns = dnsname;
+		}
+
+		/* the numbers here are the string type flags */
+		msrpc_gen(&struct_blob, "aaaaa",
+			  ntlmssp_state->unicode, NTLMSSP_NAME_TYPE_DOMAIN, target_name,
+			  ntlmssp_state->unicode, NTLMSSP_NAME_TYPE_SERVER, ntlmssp_state->get_global_myname(),
+			  ntlmssp_state->unicode, NTLMSSP_NAME_TYPE_DOMAIN_DNS, target_name_dns,
+			  ntlmssp_state->unicode, NTLMSSP_NAME_TYPE_SERVER_DNS, dnsdomname,
+			  ntlmssp_state->unicode, 0, "");
+	} else {
+		struct_blob = data_blob(NULL, 0);
+	}
+
+	{
+		const char *gen_string;
+		if (ntlmssp_state->unicode) {
+			gen_string = "CdUdbddB";
+		} else {
+			gen_string = "CdAdbddB";
+		}
+		
+		msrpc_gen(reply, gen_string,
+			  "NTLMSSP", 
+			  NTLMSSP_CHALLENGE,
+			  target_name,
+			  chal_flags,
+			  cryptkey, 8,
+			  0, 0,
+			  struct_blob.data, struct_blob.length);
+	}
+		
+	data_blob_free(&struct_blob);
+
+	return NT_STATUS_MORE_PROCESSING_REQUIRED;
+}
+
+NTSTATUS ntlmssp_auth(NTLMSSP_STATE *ntlmssp_state, 
+		      DATA_BLOB request, DATA_BLOB *reply) 
+{
+	DATA_BLOB sess_key;
+	uint32 ntlmssp_command, neg_flags;
+	NTSTATUS nt_status;
+
+	const char *parse_string;
+
+	/* parse the NTLMSSP packet */
+#if 0
+	file_save("ntlmssp_auth.dat", request.data, request.length);
+#endif
+
+	if (ntlmssp_state->unicode) {
+		parse_string = "CdBBUUUBd";
+	} else {
+		parse_string = "CdBBAAABd";
+	}
+
+	data_blob_free(&ntlmssp_state->lm_resp);
+	data_blob_free(&ntlmssp_state->nt_resp);
+
+	SAFE_FREE(ntlmssp_state->user);
+	SAFE_FREE(ntlmssp_state->domain);
+	SAFE_FREE(ntlmssp_state->workstation);
+
+	/* now the NTLMSSP encoded auth hashes */
+	if (!msrpc_parse(&request, parse_string,
+			 "NTLMSSP", 
+			 &ntlmssp_command, 
+			 &ntlmssp_state->lm_resp,
+			 &ntlmssp_state->nt_resp,
+			 &ntlmssp_state->domain, 
+			 &ntlmssp_state->user, 
+			 &ntlmssp_state->workstation,
+			 &sess_key,
+			 &neg_flags)) {
+		return NT_STATUS_LOGON_FAILURE;
+	}
+
+	data_blob_free(&sess_key);
+	
+	DEBUG(3,("Got user=[%s] domain=[%s] workstation=[%s] len1=%d len2=%d\n",
+		 ntlmssp_state->user, ntlmssp_state->domain, ntlmssp_state->workstation, ntlmssp_state->lm_resp.length, ntlmssp_state->nt_resp.length));
+
+#if 0
+	file_save("nthash1.dat",  &ntlmssp_state->nt_resp.data,  &ntlmssp_state->nt_resp.length);
+	file_save("lmhash1.dat",  &ntlmssp_state->lm_resp.data,  &ntlmssp_state->lm_resp.length);
+#endif
+
+	nt_status = ntlmssp_state->check_password(ntlmssp_state);
+	
+	*reply = data_blob(NULL, 0);
+
+	return nt_status;
+}
diff -uNr samba-3.0alpha21.orig/source/libsmb/smbencrypt.c samba-3.0alpha21/source/libsmb/smbencrypt.c
--- samba-3.0alpha21.orig/source/libsmb/smbencrypt.c	2003-02-16 19:06:32.000000000 -0600
+++ samba-3.0alpha21/source/libsmb/smbencrypt.c	2003-02-16 19:05:45.000000000 -0600
@@ -73,13 +73,14 @@
  
 void E_deshash(const char *passwd, uchar p16[16])
 {
-	uchar dospwd[15]; /* Password must not be > 14 chars long. */
+	fstring dospwd; 
 	ZERO_STRUCT(dospwd);
 	ZERO_STRUCTP(p16);
 	
 	/* Password must be converted to DOS charset - null terminated, uppercase. */
 	push_ascii(dospwd, (const char *)passwd, sizeof(dospwd), STR_UPPER|STR_TERMINATE);
 
+	/* Only the fisrt 14 chars are considered, password need not be null terminated. */
 	E_P16(dospwd, p16);
 
 	ZERO_STRUCT(dospwd);	
@@ -122,33 +123,33 @@
 	smb_ucs2_t *user;
 	smb_ucs2_t *domain;
 	
-	int user_byte_len;
-	int domain_byte_len;
+	size_t user_byte_len;
+	size_t domain_byte_len;
 
 	HMACMD5Context ctx;
 
 	user_byte_len = push_ucs2_allocate(&user, user_in);
-	if (user_byte_len < 0) {
-		DEBUG(0, ("push_uss2_allocate() for user returned %d (probably malloc() failure)\n", user_byte_len));
+	if (user_byte_len == (size_t)-1) {
+		DEBUG(0, ("push_uss2_allocate() for user returned -1 (probably malloc() failure)\n"));
 		return False;
 	}
 
 	domain_byte_len = push_ucs2_allocate(&domain, domain_in);
-	if (domain_byte_len < 0) {
-		DEBUG(0, ("push_uss2_allocate() for domain returned %d (probably malloc() failure)\n", user_byte_len));
+	if (domain_byte_len == (size_t)-1) {
+		DEBUG(0, ("push_uss2_allocate() for domain returned -1 (probably malloc() failure)\n"));
 		return False;
 	}
 
 	strupper_w(user);
 	strupper_w(domain);
 
+	SMB_ASSERT(user_byte_len >= 2);
+	SMB_ASSERT(domain_byte_len >= 2);
+
 	/* We don't want null termination */
 	user_byte_len = user_byte_len - 2;
 	domain_byte_len = domain_byte_len - 2;
 	
-	SMB_ASSERT(user_byte_len >= 0);
-	SMB_ASSERT(domain_byte_len >= 0);
-
 	hmac_md5_init_limK_to_64(owf, 16, &ctx);
 	hmac_md5_update((const unsigned char *)user, user_byte_len, &ctx);
 	hmac_md5_update((const unsigned char *)domain, domain_byte_len, &ctx);
diff -uNr samba-3.0alpha21.orig/source/libsmb/smberr.c samba-3.0alpha21/source/libsmb/smberr.c
--- samba-3.0alpha21.orig/source/libsmb/smberr.c	2003-02-16 19:06:32.000000000 -0600
+++ samba-3.0alpha21/source/libsmb/smberr.c	2003-02-16 19:05:45.000000000 -0600
@@ -37,9 +37,9 @@
 
 typedef const struct
 {
-  char *name;
+  const char *name;
   int code;
-  char *message;
+  const char *message;
 } err_code_struct;
 
 /* Dos Error Messages */
@@ -142,7 +142,7 @@
 const struct
 {
   int code;
-  char *class;
+  const char *class;
   err_code_struct *err_msgs;
 } err_classes[] = { 
   {0,"SUCCESS",NULL},
@@ -160,7 +160,7 @@
 /****************************************************************************
 return a SMB error name from a class and code
 ****************************************************************************/
-char *smb_dos_err_name(uint8 class, uint16 num)
+const char *smb_dos_err_name(uint8 class, uint16 num)
 {
 	static pstring ret;
 	int i,j;
@@ -184,7 +184,7 @@
 
 /* Return a string for a DOS error */
 
-char *get_dos_error_msg(WERROR result)
+const char *get_dos_error_msg(WERROR result)
 {
 	uint16 errnum;
 
@@ -196,7 +196,7 @@
 /****************************************************************************
 return a SMB error class name as a string.
 ****************************************************************************/
-char *smb_dos_err_class(uint8 class)
+const char *smb_dos_err_class(uint8 class)
 {
 	static pstring ret;
 	int i;
diff -uNr samba-3.0alpha21.orig/source/libsmb/unexpected.c samba-3.0alpha21/source/libsmb/unexpected.c
--- samba-3.0alpha21.orig/source/libsmb/unexpected.c	2003-02-16 19:06:32.000000000 -0600
+++ samba-3.0alpha21/source/libsmb/unexpected.c	2003-02-16 19:05:45.000000000 -0600
@@ -110,7 +110,7 @@
 static struct packet_struct *matched_packet;
 static int match_id;
 static enum packet_type match_type;
-static char *match_name;
+static const char *match_name;
 
 /****************************************************************************
 tdb traversal fn to find a matching 137 packet
@@ -144,7 +144,7 @@
 check for a particular packet in the unexpected packet queue
   **************************************************************************/
 struct packet_struct *receive_unexpected(enum packet_type packet_type, int id, 
-					 char *mailslot_name)
+					 const char *mailslot_name)
 {
 	TDB_CONTEXT *tdb2;
 
diff -uNr samba-3.0alpha21.orig/source/locking/locking.c samba-3.0alpha21/source/locking/locking.c
--- samba-3.0alpha21.orig/source/locking/locking.c	2003-02-16 19:06:32.000000000 -0600
+++ samba-3.0alpha21/source/locking/locking.c	2003-02-16 19:05:45.000000000 -0600
@@ -100,14 +100,13 @@
 static NTSTATUS do_lock(files_struct *fsp,connection_struct *conn, uint16 lock_pid,
 		 SMB_BIG_UINT count,SMB_BIG_UINT offset,enum brl_type lock_type)
 {
-	NTSTATUS status;
+	NTSTATUS status = NT_STATUS_LOCK_NOT_GRANTED;
 
 	if (!lp_locking(SNUM(conn)))
 		return NT_STATUS_OK;
 
 	/* NOTE! 0 byte long ranges ARE allowed and should be stored  */
 
-
 	DEBUG(10,("do_lock: lock type %s start=%.0f len=%.0f requested for file %s\n",
 		  lock_type_name(lock_type), (double)offset, (double)count, fsp->fsp_name ));
 
@@ -612,6 +611,7 @@
 	/* read in the existing share modes if any */
 	dbuf = tdb_fetch(tdb, locking_key_fsp(fsp));
 	if (!dbuf.dptr) {
+		size_t offset;
 		/* we'll need to create a new record */
 		pstring fname;
 
@@ -629,7 +629,8 @@
 		DEBUG(10,("set_share_mode: creating entry for file %s. num_share_modes = 1\n",
 			fsp->fsp_name ));
 
-		pstrcpy(p + sizeof(*data) + sizeof(share_mode_entry), fname);
+		offset = sizeof(*data) + sizeof(share_mode_entry);
+		safe_strcpy(p + offset, fname, size - offset);
 		fill_share_mode(p + sizeof(*data), fsp, port, op_type);
 		dbuf.dptr = p;
 		dbuf.dsize = size;
diff -uNr samba-3.0alpha21.orig/source/locking/posix.c samba-3.0alpha21/source/locking/posix.c
--- samba-3.0alpha21.orig/source/locking/posix.c	2003-02-16 19:06:32.000000000 -0600
+++ samba-3.0alpha21/source/locking/posix.c	2003-02-16 19:05:45.000000000 -0600
@@ -552,7 +552,11 @@
 	 * find the maximum positive lock offset as an SMB_OFF_T.
 	 */
 
-#if defined(LARGE_SMB_OFF_T) && !defined(HAVE_BROKEN_FCNTL64_LOCKS)
+#if defined(MAX_POSITIVE_LOCK_OFFSET) /* Some systems have arbitrary limits. */
+
+	SMB_OFF_T max_positive_lock_offset = (MAX_POSITIVE_LOCK_OFFSET);
+
+#elif defined(LARGE_SMB_OFF_T) && !defined(HAVE_BROKEN_FCNTL64_LOCKS)
 
 	/*
 	 * In this case SMB_OFF_T is 64 bits,
@@ -598,19 +602,10 @@
 	}
 
 	/*
-	 * We must truncate the offset and count to less than max_positive_lock_offset.
-	 */
-
-	offset &= max_positive_lock_offset;
-	count &= max_positive_lock_offset;
-
-
-	/*
-	 * Deal with a very common case of count of all ones.
-	 * (lock entire file).
+	 * We must truncate the count to less than max_positive_lock_offset.
 	 */
 
-	if(count == (SMB_OFF_T)-1)
+	if (u_count & ~((SMB_BIG_UINT)max_positive_lock_offset))
 		count = max_positive_lock_offset;
 
 	/*
@@ -1003,7 +998,7 @@
 	 * semantics that if a write lock is added, then it will be first in the array.
 	 */
 	
-	if ((l_ctx = talloc_init()) == NULL) {
+	if ((l_ctx = talloc_init("set_posix_lock")) == NULL) {
 		DEBUG(0,("set_posix_lock: unable to init talloc context.\n"));
 		return True; /* Not a fatal error. */
 	}
@@ -1149,7 +1144,7 @@
 		}
 	}
 
-	if ((ul_ctx = talloc_init()) == NULL) {
+	if ((ul_ctx = talloc_init("release_posix_lock")) == NULL) {
 		DEBUG(0,("release_posix_lock: unable to init talloc context.\n"));
 		return True; /* Not a fatal error. */
 	}
diff -uNr samba-3.0alpha21.orig/source/modules/vfs_extd_audit.c samba-3.0alpha21/source/modules/vfs_extd_audit.c
--- samba-3.0alpha21.orig/source/modules/vfs_extd_audit.c	1969-12-31 18:00:00.000000000 -0600
+++ samba-3.0alpha21/source/modules/vfs_extd_audit.c	2003-02-16 19:05:45.000000000 -0600
@@ -0,0 +1,319 @@
+/* 
+ * Auditing VFS module for samba.  Log selected file operations to syslog
+ * facility.
+ *
+ * Copyright (C) Tim Potter, 1999-2000
+ * Copyright (C) Alexander Bokovoy, 2002
+ * Copyright (C) John H Terpstra, 2003
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *  
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *  
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include "config.h"
+#include <stdio.h>
+#include <sys/stat.h>
+#ifdef HAVE_UTIME_H
+#include <utime.h>
+#endif
+#ifdef HAVE_DIRENT_H
+#include <dirent.h>
+#endif
+#include <syslog.h>
+#ifdef HAVE_FCNTL_H
+#include <fcntl.h>
+#endif
+#include <errno.h>
+#include <string.h>
+#include <includes.h>
+#include <vfs.h>
+
+#ifndef SYSLOG_FACILITY
+#define SYSLOG_FACILITY   LOG_USER
+#endif
+
+#ifndef SYSLOG_PRIORITY
+#define SYSLOG_PRIORITY   LOG_NOTICE
+#endif
+
+/* Function prototypes */
+
+static int audit_connect(struct connection_struct *conn, const char *svc, const char *user);
+static void audit_disconnect(struct connection_struct *conn);
+static DIR *audit_opendir(struct connection_struct *conn, const char *fname);
+static int audit_mkdir(struct connection_struct *conn, const char *path, mode_t mode);
+static int audit_rmdir(struct connection_struct *conn, const char *path);
+static int audit_open(struct connection_struct *conn, const char *fname, int flags, mode_t mode);
+static int audit_close(struct files_struct *fsp, int fd);
+static int audit_rename(struct connection_struct *conn, const char *old, const char *new);
+static int audit_unlink(struct connection_struct *conn, const char *path);
+static int audit_chmod(struct connection_struct *conn, const char *path, mode_t mode);
+static int audit_chmod_acl(struct connection_struct *conn, const char *name, mode_t mode);
+static int audit_fchmod(struct files_struct *fsp, int fd, mode_t mode);
+static int audit_fchmod_acl(struct files_struct *fsp, int fd, mode_t mode);
+
+/* VFS operations */
+
+static struct vfs_ops default_vfs_ops;   /* For passthrough operation */
+static struct smb_vfs_handle_struct *audit_handle;
+
+static vfs_op_tuple audit_ops[] = {
+    
+	/* Disk operations */
+
+	{audit_connect, 	SMB_VFS_OP_CONNECT, 	SMB_VFS_LAYER_LOGGER},
+	{audit_disconnect, 	SMB_VFS_OP_DISCONNECT, 	SMB_VFS_LAYER_LOGGER},
+
+	/* Directory operations */
+
+	{audit_opendir, 	SMB_VFS_OP_OPENDIR, 	SMB_VFS_LAYER_LOGGER},
+	{audit_mkdir, 		SMB_VFS_OP_MKDIR, 	SMB_VFS_LAYER_LOGGER},
+	{audit_rmdir, 		SMB_VFS_OP_RMDIR, 	SMB_VFS_LAYER_LOGGER},
+
+	/* File operations */
+
+	{audit_open, 		SMB_VFS_OP_OPEN, 	SMB_VFS_LAYER_LOGGER},
+	{audit_close, 		SMB_VFS_OP_CLOSE, 	SMB_VFS_LAYER_LOGGER},
+	{audit_rename, 		SMB_VFS_OP_RENAME, 	SMB_VFS_LAYER_LOGGER},
+	{audit_unlink, 		SMB_VFS_OP_UNLINK, 	SMB_VFS_LAYER_LOGGER},
+	{audit_chmod, 		SMB_VFS_OP_CHMOD, 	SMB_VFS_LAYER_LOGGER},
+	{audit_fchmod, 		SMB_VFS_OP_FCHMOD, 	SMB_VFS_LAYER_LOGGER},
+	{audit_chmod_acl, 	SMB_VFS_OP_CHMOD_ACL, 	SMB_VFS_LAYER_LOGGER},
+	{audit_fchmod_acl, 	SMB_VFS_OP_FCHMOD_ACL, 	SMB_VFS_LAYER_LOGGER},
+	
+	/* Finish VFS operations definition */
+	
+	{NULL, 			SMB_VFS_OP_NOOP, 	SMB_VFS_LAYER_NOOP}
+};
+
+/* VFS initialisation function.  Return vfs_op_tuple array back to SAMBA. */
+
+vfs_op_tuple *vfs_init(int *vfs_version, struct vfs_ops *def_vfs_ops, 
+			struct smb_vfs_handle_struct *vfs_handle)
+{
+	*vfs_version = SMB_VFS_INTERFACE_VERSION;
+	memcpy(&default_vfs_ops, def_vfs_ops, sizeof(struct vfs_ops));
+	
+	audit_handle = vfs_handle;
+
+	openlog("smbd_audit", LOG_PID, SYSLOG_FACILITY);
+	syslog(SYSLOG_PRIORITY, "VFS_INIT: vfs_ops loaded\n");
+
+	return audit_ops;
+}
+
+/* VFS finalization function. */
+
+void vfs_done(connection_struct *conn)
+{
+	syslog(SYSLOG_PRIORITY, "VFS_DONE: vfs module unloaded\n");
+}
+
+/* Implementation of vfs_ops.  Pass everything on to the default
+   operation but log event first. */
+
+static int audit_connect(struct connection_struct *conn, const char *svc, const char *user)
+{
+	syslog(SYSLOG_PRIORITY, "connect to service %s by user %s\n", 
+	       svc, user);
+	DEBUG(10, ("Connected to service %s as user %s\n",
+	       svc, user));
+
+	return default_vfs_ops.connect(conn, svc, user);
+}
+
+static void audit_disconnect(struct connection_struct *conn)
+{
+	syslog(SYSLOG_PRIORITY, "disconnected\n");
+	DEBUG(10, ("Disconnected from VFS module extd_audit\n"));
+
+	default_vfs_ops.disconnect(conn);
+}
+
+static DIR *audit_opendir(struct connection_struct *conn, const char *fname)
+{
+	DIR *result = default_vfs_ops.opendir(conn, fname);
+
+	syslog(SYSLOG_PRIORITY, "opendir %s %s%s\n",
+	       fname,
+	       (result == NULL) ? "failed: " : "",
+	       (result == NULL) ? strerror(errno) : "");
+	DEBUG(1, ("vfs_extd_audit: opendir %s %s %s",
+	       fname,
+	       (result == NULL) ? "failed: " : "",
+	       (result == NULL) ? strerror(errno) : ""));
+
+	return result;
+}
+
+static int audit_mkdir(struct connection_struct *conn, const char *path, mode_t mode)
+{
+	int result = default_vfs_ops.mkdir(conn, path, mode);
+
+	syslog(SYSLOG_PRIORITY, "mkdir %s %s%s\n", 
+	       path,
+	       (result < 0) ? "failed: " : "",
+	       (result < 0) ? strerror(errno) : "");
+	DEBUG(0, ("vfs_extd_audit: mkdir %s %s %s\n",
+	       path,
+	       (result < 0) ? "failed: " : "",
+	       (result < 0) ? strerror(errno) : ""));
+
+	return result;
+}
+
+static int audit_rmdir(struct connection_struct *conn, const char *path)
+{
+	int result = default_vfs_ops.rmdir(conn, path);
+
+	syslog(SYSLOG_PRIORITY, "rmdir %s %s%s\n", 
+	       path, 
+	       (result < 0) ? "failed: " : "",
+	       (result < 0) ? strerror(errno) : "");
+	DEBUG(0, ("vfs_extd_audit: rmdir %s %s %s\n",
+               path,
+	       (result < 0) ? "failed: " : "",
+	       (result < 0) ? strerror(errno) : ""));
+
+	return result;
+}
+
+static int audit_open(struct connection_struct *conn, const char *fname, int flags, mode_t mode)
+{
+	int result = default_vfs_ops.open(conn, fname, flags, mode);
+
+	syslog(SYSLOG_PRIORITY, "open %s (fd %d) %s%s%s\n", 
+	       fname, result,
+	       ((flags & O_WRONLY) || (flags & O_RDWR)) ? "for writing " : "", 
+	       (result < 0) ? "failed: " : "",
+	       (result < 0) ? strerror(errno) : "");
+	DEBUG(2, ("vfs_extd_audit: open %s %s %s\n",
+	       fname,
+	       (result < 0) ? "failed: " : "",
+	       (result < 0) ? strerror(errno) : ""));
+
+	return result;
+}
+
+static int audit_close(struct files_struct *fsp, int fd)
+{
+	int result = default_vfs_ops.close(fsp, fd);
+
+	syslog(SYSLOG_PRIORITY, "close fd %d %s%s\n",
+	       fd,
+	       (result < 0) ? "failed: " : "",
+	       (result < 0) ? strerror(errno) : "");
+	DEBUG(2, ("vfs_extd_audit: close fd %d %s %s\n",
+	       fd,
+	       (result < 0) ? "failed: " : "",
+	       (result < 0) ? strerror(errno) : ""));
+
+	return result;
+}
+
+static int audit_rename(struct connection_struct *conn, const char *old, const char *new)
+{
+	int result = default_vfs_ops.rename(conn, old, new);
+
+	syslog(SYSLOG_PRIORITY, "rename %s -> %s %s%s\n",
+	       old, new,
+	       (result < 0) ? "failed: " : "",
+	       (result < 0) ? strerror(errno) : "");
+	DEBUG(1, ("vfs_extd_audit: rename old: %s new: %s  %s %s\n",
+	       old, new,
+	       (result < 0) ? "failed: " : "",
+	       (result < 0) ? strerror(errno) : ""));
+
+	return result;    
+}
+
+static int audit_unlink(struct connection_struct *conn, const char *path)
+{
+	int result = default_vfs_ops.unlink(conn, path);
+
+	syslog(SYSLOG_PRIORITY, "unlink %s %s%s\n",
+	       path,
+	       (result < 0) ? "failed: " : "",
+	       (result < 0) ? strerror(errno) : "");
+	DEBUG(0, ("vfs_extd_audit: unlink %s %s %s\n",
+	       path,
+	       (result < 0) ? "failed: " : "",
+	       (result < 0) ? strerror(errno) : ""));
+
+	return result;
+}
+
+static int audit_chmod(struct connection_struct *conn, const char *path, mode_t mode)
+{
+	int result = default_vfs_ops.chmod(conn, path, mode);
+
+	syslog(SYSLOG_PRIORITY, "chmod %s mode 0x%x %s%s\n",
+	       path, mode,
+	       (result < 0) ? "failed: " : "",
+	       (result < 0) ? strerror(errno) : "");
+	DEBUG(1, ("vfs_extd_audit: chmod %s mode 0x%x %s %s\n",
+	       path, mode,
+	       (result < 0) ? "failed: " : "",
+	       (result < 0) ? strerror(errno) : ""));
+
+	return result;
+}
+
+static int audit_chmod_acl(struct connection_struct *conn, const char *path, mode_t mode)
+{
+	int result = default_vfs_ops.chmod_acl(conn, path, mode);
+
+	syslog(SYSLOG_PRIORITY, "chmod_acl %s mode 0x%x %s%s\n",
+	       path, mode,
+	       (result < 0) ? "failed: " : "",
+	       (result < 0) ? strerror(errno) : "");
+	DEBUG(1, ("vfs_extd_audit: chmod_acl %s mode 0x%x %s %s\n",
+	        path, mode,
+	       (result < 0) ? "failed: " : "",
+	       (result < 0) ? strerror(errno) : ""));
+
+	return result;
+}
+
+static int audit_fchmod(struct files_struct *fsp, int fd, mode_t mode)
+{
+	int result = default_vfs_ops.fchmod(fsp, fd, mode);
+
+	syslog(SYSLOG_PRIORITY, "fchmod %s mode 0x%x %s%s\n",
+	       fsp->fsp_name, mode,
+	       (result < 0) ? "failed: " : "",
+	       (result < 0) ? strerror(errno) : "");
+	DEBUG(1, ("vfs_extd_audit: fchmod %s mode 0x%x %s %s",
+	       fsp->fsp_name,  mode,
+	       (result < 0) ? "failed: " : "",
+	       (result < 0) ? strerror(errno) : ""));
+
+	return result;
+}
+
+static int audit_fchmod_acl(struct files_struct *fsp, int fd, mode_t mode)
+{
+	int result = default_vfs_ops.fchmod_acl(fsp, fd, mode);
+
+	syslog(SYSLOG_PRIORITY, "fchmod_acl %s mode 0x%x %s%s\n",
+	       fsp->fsp_name, mode,
+	       (result < 0) ? "failed: " : "",
+	       (result < 0) ? strerror(errno) : "");
+	DEBUG(1, ("vfs_extd_audit: fchmod_acl %s mode 0x%x %s %s",
+	       fsp->fsp_name,  mode,
+	       (result < 0) ? "failed: " : "",
+	       (result < 0) ? strerror(errno) : ""));
+
+	return result;
+}
diff -uNr samba-3.0alpha21.orig/source/modules/vfs_netatalk.c samba-3.0alpha21/source/modules/vfs_netatalk.c
--- samba-3.0alpha21.orig/source/modules/vfs_netatalk.c	2003-02-16 19:06:32.000000000 -0600
+++ samba-3.0alpha21/source/modules/vfs_netatalk.c	2003-02-16 19:05:45.000000000 -0600
@@ -161,27 +161,26 @@
 
 static void atalk_rrmdir(TALLOC_CTX *ctx, char *path)
 {
-	int n;
 	char *dpath;
-	struct dirent **namelist;
+	struct dirent *dent = 0;
+	DIR *dir;
 
 	if (!path) return;
 
-	n = scandir(path, &namelist, 0, alphasort);
-	if (n < 0) {
-		return;
-	} else {
-		while (n --) {
-			if (strcmp(namelist[n]->d_name, ".") == 0 ||
-			  strcmp(namelist[n]->d_name, "..") == 0)
-				continue;
-			if (!(dpath = talloc_asprintf(ctx, "%s/%s", 
-			  path, namelist[n]->d_name)))
-				continue;
-			atalk_unlink_file(dpath);
-			free(namelist[n]);
-		}
+	dir = opendir(path);
+	if (!dir) return;
+
+	while (NULL != (dent = readdir(dir))) {
+		if (strcmp(dent->d_name, ".") == 0 ||
+		    strcmp(dent->d_name, "..") == 0)
+			continue;
+		if (!(dpath = talloc_asprintf(ctx, "%s/%s", 
+					      path, dent->d_name)))
+			continue;
+		atalk_unlink_file(dpath);
 	}
+
+	closedir(dir);
 }
 
 /* Disk operations */
@@ -223,7 +222,7 @@
 
 	strstr(path, APPLEDOUBLE) ? (add = False) : (add = True);
 
-	if (!(ctx = talloc_init_named("remove_directory")))
+	if (!(ctx = talloc_init("remove_directory")))
 		goto exit_rmdir;
 
 	if (!(dpath = talloc_asprintf(ctx, "%s/%s%s", 
@@ -252,7 +251,7 @@
 
 	if (!conn || !old) return ret;
 
-	if (!(ctx = talloc_init_named("rename_file")))
+	if (!(ctx = talloc_init("rename_file")))
 		return ret;
 
 	if (atalk_build_paths(ctx, conn->origpath, old, &adbl_path, &orig_path, 
@@ -308,7 +307,7 @@
 		}
 	}
 
-	if (!(ctx = talloc_init_named("unlink_file")))
+	if (!(ctx = talloc_init("unlink_file")))
 		return ret;
 
 	if (atalk_build_paths(ctx, conn->origpath, path, &adbl_path, &orig_path, 
@@ -340,7 +339,7 @@
 
 	if (!conn || !path) return ret;
 
-	if (!(ctx = talloc_init_named("chmod_file")))
+	if (!(ctx = talloc_init("chmod_file")))
 		return ret;
 
 	if (atalk_build_paths(ctx, conn->origpath, path, &adbl_path, &orig_path,
@@ -372,7 +371,7 @@
 
 	if (!conn || !path) return ret;
 
-	if (!(ctx = talloc_init_named("chown_file")))
+	if (!(ctx = talloc_init("chown_file")))
 		return ret;
 
 	if (atalk_build_paths(ctx, conn->origpath, path, &adbl_path, &orig_path,
diff -uNr samba-3.0alpha21.orig/source/modules/vfs_recycle.c samba-3.0alpha21/source/modules/vfs_recycle.c
--- samba-3.0alpha21.orig/source/modules/vfs_recycle.c	2003-02-16 19:06:32.000000000 -0600
+++ samba-3.0alpha21/source/modules/vfs_recycle.c	2003-02-16 19:05:45.000000000 -0600
@@ -119,7 +119,7 @@
 
 	DEBUG(10, ("Called for service %s (%d) as user %s\n", service, SNUM(conn), user));
 
-	if (!(ctx = talloc_init_named("recycle bin"))) {
+	if (!(ctx = talloc_init("recycle bin"))) {
 		DEBUG(0, ("Failed to allocate memory in VFS module recycle_bin\n"));
 		return 0;
 	}
diff -uNr samba-3.0alpha21.orig/source/msdfs/msdfs.c samba-3.0alpha21/source/msdfs/msdfs.c
--- samba-3.0alpha21.orig/source/msdfs/msdfs.c	2003-02-16 19:06:32.000000000 -0600
+++ samba-3.0alpha21/source/msdfs/msdfs.c	2003-02-16 19:05:45.000000000 -0600
@@ -381,6 +381,26 @@
 		return False;
 	}
 
+	if (*lp_msdfs_proxy(snum) != '\0') {
+		struct referral* ref;
+		jn->referral_count = 1;
+		if ((ref = (struct referral*) malloc(sizeof(struct referral)))
+		    == NULL) {
+			DEBUG(0, ("malloc failed for referral\n"));
+			return False;
+		}
+
+		pstrcpy(ref->alternate_path, lp_msdfs_proxy(snum));
+		if (dp.reqpath[0] != '\0')
+			pstrcat(ref->alternate_path, dp.reqpath);
+		ref->proximity = 0;
+		ref->ttl = REFERRAL_TTL;
+		jn->referral_list = ref;
+		if (consumedcntp)
+			*consumedcntp = strlen(pathname);
+		return True;
+	}
+
 	/* If not remote & not a self referral, return False */
 	if (!resolve_dfs_path(pathname, &dp, conn, False, 
 			      &jn->referral_list, &jn->referral_count,
@@ -630,7 +650,7 @@
 			dbgtext(".\n");
 		}
 	}
-	
+
 	/* create the referral depeding on version */
 	DEBUG(10,("max_referral_level :%d\n",max_referral_level));
 	if(max_referral_level<2 || max_referral_level>3)
@@ -798,6 +818,7 @@
 	char* service_name = lp_servicename(snum);
 	connection_struct conns;
 	connection_struct *conn = &conns;
+	struct referral *ref = NULL;
  
 	pstrcpy(connect_path,lp_pathname(snum));
 
@@ -811,31 +832,34 @@
 	if (!create_conn_struct(conn, snum, connect_path))
 		return False;
 
-	{ 
-		/* form a junction for the msdfs root - convention 
-		   DO NOT REMOVE THIS: NT clients will not work with us
-		   if this is not present
-		*/ 
-		struct referral *ref = NULL;
-		pstring alt_path;
-		pstrcpy(jn[cnt].service_name, service_name);
-		jn[cnt].volume_name[0] = '\0';
-		jn[cnt].referral_count = 1;
-	
-		slprintf(alt_path,sizeof(alt_path)-1,"\\\\%s\\%s", 
-			 local_machine, service_name);
-		ref = jn[cnt].referral_list = (struct referral*) malloc(sizeof(struct referral));
-		if (jn[cnt].referral_list == NULL) {
-			DEBUG(0, ("Malloc failed!\n"));
-			return False;
-		}
-
-		safe_strcpy(ref->alternate_path, alt_path, sizeof(pstring));
-		ref->proximity = 0;
-		ref->ttl = REFERRAL_TTL;
-		cnt++;
+	/* form a junction for the msdfs root - convention 
+	   DO NOT REMOVE THIS: NT clients will not work with us
+	   if this is not present
+	*/ 
+	pstrcpy(jn[cnt].service_name, service_name);
+	jn[cnt].volume_name[0] = '\0';
+	jn[cnt].referral_count = 1;
+
+	ref = jn[cnt].referral_list
+		= (struct referral*) malloc(sizeof(struct referral));
+	if (jn[cnt].referral_list == NULL) {
+		DEBUG(0, ("Malloc failed!\n"));
+		return False;
 	}
 
+	ref->proximity = 0;
+	ref->ttl = REFERRAL_TTL;
+	if (*lp_msdfs_proxy(snum) != '\0') {
+		pstrcpy(ref->alternate_path, lp_msdfs_proxy(snum));
+		*jn_count = ++cnt;
+		return True;
+	}
+		
+	slprintf(ref->alternate_path, sizeof(pstring)-1,
+		 "\\\\%s\\%s", local_machine, service_name);
+	cnt++;
+	
+	/* Now enumerate all dfs links */
 	dirp = conn->vfs_ops.opendir(conn, connect_path);
 	if(!dirp)
 		return False;
diff -uNr samba-3.0alpha21.orig/source/nmbd/nmbd.c samba-3.0alpha21/source/nmbd/nmbd.c
--- samba-3.0alpha21.orig/source/nmbd/nmbd.c	2003-02-16 19:06:32.000000000 -0600
+++ samba-3.0alpha21/source/nmbd/nmbd.c	2003-02-16 19:05:45.000000000 -0600
@@ -32,6 +32,12 @@
 /* are we running as a daemon ? */
 static BOOL is_daemon = False;
 
+/* fork or run in foreground ? */
+static BOOL Fork = True;
+
+/* log to standard output ? */
+static BOOL log_stdout = False;
+
 /* have we found LanMan clients yet? */
 BOOL found_lm_clients = False;
 
@@ -95,6 +101,25 @@
 	sys_select_signal();
 }
 
+/*******************************************************************
+ Print out all talloc memory info.
+********************************************************************/
+
+void return_all_talloc_info(int msg_type, pid_t src_pid, void *buf, size_t len)
+{
+	TALLOC_CTX *ctx = talloc_init("info context");
+	char *info = NULL;
+
+	if (!ctx)
+		return;
+
+	info = talloc_describe_all(ctx);
+	if (info)
+		DEBUG(10,(info));
+	message_send_pid(src_pid, MSG_TALLOC_USAGE, info, info ? strlen(info) + 1 : 0, True);
+	talloc_destroy(ctx);
+}
+
 #if DUMP_CORE
 /**************************************************************************** **
  Prepare to dump a core file - carefully!
@@ -571,6 +596,8 @@
 	POPT_AUTOHELP
 	{"daemon", 'D', POPT_ARG_VAL, &is_daemon, True, "Become a daemon(default)" },
 	{"interactive", 'i', POPT_ARG_VAL, &opt_interactive, True, "Run interactive (not a daemon)" },
+	{"foreground", 'F', POPT_ARG_VAL, &Fork, False, "Run daemon in foreground (for daemontools & etc)" },
+	{"log-stdout", 'S', POPT_ARG_VAL, &log_stdout, True, "Log to stdout" },
 	{"hosts", 'H', POPT_ARG_STRING, dyn_LMHOSTSFILE, 'H', "Load a netbios hosts file"},
 	{"port", 'p', POPT_ARG_INT, &global_nmb_port, NMB_PORT, "Listen on the specified port" },
 	{NULL, 0, POPT_ARG_INCLUDE_TABLE, popt_common_debug },
@@ -620,8 +647,18 @@
     { }
 
   poptFreeContext(pc);
-  
-  setup_logging( argv[0], opt_interactive );
+
+  if ( opt_interactive ) {
+    Fork = False;
+    log_stdout = True;
+  }
+
+  if ( log_stdout && Fork ) {
+    DEBUG(0,("ERROR: Can't log to stdout (-S) unless daemon is in foreground (-F) or interactive (-i)\n"));
+    exit(1);
+  }
+
+  setup_logging( argv[0], log_stdout );
 
   reopen_logs();
 
@@ -653,7 +690,7 @@
   if (is_daemon && !opt_interactive)
   {
     DEBUG( 2, ( "Becoming a daemon.\n" ) );
-    become_daemon();
+    become_daemon(Fork);
   }
 
 #if HAVE_SETPGID
@@ -682,6 +719,7 @@
   message_register(MSG_FORCE_ELECTION, nmbd_message_election);
   message_register(MSG_WINS_NEW_ENTRY, nmbd_wins_new_entry);
   message_register(MSG_SHUTDOWN, nmbd_terminate);
+  message_register(MSG_REQ_TALLOC_USAGE, return_all_talloc_info);
 
   DEBUG( 3, ( "Opening sockets %d\n", global_nmb_port ) );
 
diff -uNr samba-3.0alpha21.orig/source/nmbd/nmbd_become_lmb.c samba-3.0alpha21/source/nmbd/nmbd_become_lmb.c
--- samba-3.0alpha21.orig/source/nmbd/nmbd_become_lmb.c	2003-02-16 19:06:32.000000000 -0600
+++ samba-3.0alpha21/source/nmbd/nmbd_become_lmb.c	2003-02-16 19:05:45.000000000 -0600
@@ -563,7 +563,7 @@
   userdata->copy_fn = NULL;
   userdata->free_fn = NULL;
   userdata->userdata_len = strlen(work->work_group)+1;
-  pstrcpy(userdata->data, work->work_group);
+  fstrcpy(userdata->data, work->work_group);
 
   /* Register the special browser group name. */
   register_name(subrec, MSBROWSE, 0x01, samba_nb_type|NB_GROUP,
diff -uNr samba-3.0alpha21.orig/source/nmbd/nmbd_browsesync.c samba-3.0alpha21/source/nmbd/nmbd_browsesync.c
--- samba-3.0alpha21.orig/source/nmbd/nmbd_browsesync.c	2003-02-16 19:06:32.000000000 -0600
+++ samba-3.0alpha21/source/nmbd/nmbd_browsesync.c	2003-02-16 19:05:45.000000000 -0600
@@ -22,7 +22,6 @@
 */
 
 #include "includes.h"
-#include "smb.h"
 
 /* This is our local master browser list database. */
 extern ubi_dlList lmb_browserlist[];
@@ -334,7 +333,7 @@
   userdata->copy_fn = NULL;
   userdata->free_fn = NULL;
   userdata->userdata_len = strlen(work->work_group)+1;
-  pstrcpy(userdata->data, work->work_group);
+  fstrcpy(userdata->data, work->work_group);
 
   node_status( subrec, &nmbname, answer_ip, 
                domain_master_node_status_success,
diff -uNr samba-3.0alpha21.orig/source/nmbd/nmbd_namelistdb.c samba-3.0alpha21/source/nmbd/nmbd_namelistdb.c
--- samba-3.0alpha21.orig/source/nmbd/nmbd_namelistdb.c	2003-02-16 19:06:32.000000000 -0600
+++ samba-3.0alpha21/source/nmbd/nmbd_namelistdb.c	2003-02-16 19:05:45.000000000 -0600
@@ -173,7 +173,7 @@
  * ************************************************************************** **
  */
 struct name_record *add_name_to_subnet( struct subnet_record *subrec,
-                                        char                 *name,
+                                        const char           *name,
                                         int                   type,
                                         uint16                nb_flags,
                                         int                   ttl,
@@ -525,7 +525,7 @@
 static void dump_subnet_namelist( struct subnet_record *subrec, XFILE *fp)
 {
   struct name_record *namerec;
-  char *src_type;
+  const char *src_type;
   struct tm *tm;
   int i;
 
diff -uNr samba-3.0alpha21.orig/source/nmbd/nmbd_namequery.c samba-3.0alpha21/source/nmbd/nmbd_namequery.c
--- samba-3.0alpha21.orig/source/nmbd/nmbd_namequery.c	2003-02-16 19:06:32.000000000 -0600
+++ samba-3.0alpha21/source/nmbd/nmbd_namequery.c	2003-02-16 19:05:45.000000000 -0600
@@ -81,6 +81,14 @@
     }
     else
     {
+      if (!nmb->answers)
+      {
+        dbgtext( "query_name_response: On subnet %s ", subrec->subnet_name );
+	dbgtext( "IP %s ", inet_ntoa(p->ip) );
+	dbgtext( "returned a success response with no answer\n" );
+	return;
+      }
+
       success = True;
 
       putip((char *)&answer_ip,&nmb->answers->rdata[2]);
@@ -102,7 +110,8 @@
   {
     if( DEBUGLVL( 0 ) )
       {
-      putip( (char *)&answer_ip, &nmb->answers->rdata[2] );
+      if (nmb->answers)
+        putip( (char *)&answer_ip, &nmb->answers->rdata[2] );
       dbgtext( "query_name_response: " );
       dbgtext( "Multiple (%d) responses ", rrec->num_msgs );
       dbgtext( "received for a query on subnet %s ", subrec->subnet_name );
diff -uNr samba-3.0alpha21.orig/source/nmbd/nmbd_packets.c samba-3.0alpha21/source/nmbd/nmbd_packets.c
--- samba-3.0alpha21.orig/source/nmbd/nmbd_packets.c	2003-02-16 19:06:32.000000000 -0600
+++ samba-3.0alpha21/source/nmbd/nmbd_packets.c	2003-02-16 19:05:45.000000000 -0600
@@ -887,7 +887,7 @@
   struct res_rec answers;
   struct nmb_packet *orig_nmb = &orig_packet->packet.nmb;
   BOOL loopback_this_packet = False;
-  char *packet_type = "unknown";
+  const char *packet_type = "unknown";
   
   /* Check if we are sending to or from ourselves. */
   if(ismyip(orig_packet->ip) && (orig_packet->port == global_nmb_port))
@@ -1929,7 +1929,7 @@
 /****************************************************************************
   Construct and send a netbios DGRAM.
 **************************************************************************/
-BOOL send_mailslot(BOOL unique, char *mailslot,char *buf,int len,
+BOOL send_mailslot(BOOL unique, const char *mailslot,char *buf,int len,
                    const char *srcname, int src_type,
                    const char *dstname, int dest_type,
                    struct in_addr dest_ip,struct in_addr src_ip,
diff -uNr samba-3.0alpha21.orig/source/nmbd/nmbd_processlogon.c samba-3.0alpha21/source/nmbd/nmbd_processlogon.c
--- samba-3.0alpha21.orig/source/nmbd/nmbd_processlogon.c	2003-02-16 19:06:32.000000000 -0600
+++ samba-3.0alpha21/source/nmbd/nmbd_processlogon.c	2003-02-16 19:05:45.000000000 -0600
@@ -62,8 +62,8 @@
 Process a domain logon packet
 **************************************************************************/
 
-void process_logon_packet(struct packet_struct *p,char *buf,int len, 
-                          char *mailslot)
+void process_logon_packet(struct packet_struct *p, char *buf,int len, 
+                          const char *mailslot)
 {
   struct dgram_packet *dgram = &p->packet.dgram;
   pstring my_name;
@@ -272,8 +272,8 @@
       pull_ucs2_fstring(asccomp, unicomp);
       DEBUG(3,("process_logon_packet: SAMLOGON user %s\n", ascuser));
 
-      fstrcpy(reply_name,"\\\\"); /* Here it wants \\LOGONSERVER. */
-      fstrcpy(reply_name+2,my_name); 
+      fstrcpy(reply_name, "\\\\"); /* Here it wants \\LOGONSERVER. */
+      fstrcat(reply_name, my_name);
 
       DEBUG(3,("process_logon_packet: SAMLOGON request from %s(%s) for %s, returning logon svr %s domain %s code %x token=%x\n",
 	       asccomp,inet_ntoa(p->ip), ascuser, reply_name, lp_workgroup(),
@@ -301,10 +301,12 @@
       else {
 	GUID domain_guid;
 	pstring domain;
+	pstring hostname;
 	char *component, *dc, *q1;
 	uint8 size;
 
-	safe_strcpy(domain, lp_realm(), sizeof(domain));
+	get_mydomname(domain);
+	get_myname(hostname);
 	
 	if (SVAL(uniuser, 0) == 0) {
 	  SSVAL(q, 0, SAMLOGON_AD_UNK_R);	/* user unknown */
@@ -341,14 +343,14 @@
 	q += 2;              /* it must follow the domain name. */
 
 	/* Push dns host name */
-	size = push_ascii(&q[1], global_myname(), -1, 0);
+	size = push_ascii(&q[1], hostname, -1, 0);
 	SCVAL(q, 0, size);
 	q += (size + 1);
 	SSVAL(q, 0, 0x18c0); /* not sure what this is for, but  */
 	q += 2;              /* it must follow the domain name. */
 
 	/* Push NETBIOS of domain */
-	size = push_ascii(&q[1], domain, -1, STR_UPPER);
+	size = push_ascii(&q[1], lp_workgroup(), -1, STR_UPPER);
 	SCVAL(q, 0, size);
 	q += (size + 1);
 	SCVAL(q, 0, 0); q++; /* is this a null terminator or empty field */
diff -uNr samba-3.0alpha21.orig/source/nmbd/nmbd_sendannounce.c samba-3.0alpha21/source/nmbd/nmbd_sendannounce.c
--- samba-3.0alpha21.orig/source/nmbd/nmbd_sendannounce.c	2003-02-16 19:06:32.000000000 -0600
+++ samba-3.0alpha21/source/nmbd/nmbd_sendannounce.c	2003-02-16 19:05:45.000000000 -0600
@@ -33,7 +33,7 @@
  Send a browser reset packet.
 **************************************************************************/
 
-void send_browser_reset(int reset_type, char *to_name, int to_type, struct in_addr to_ip)
+void send_browser_reset(int reset_type, const char *to_name, int to_type, struct in_addr to_ip)
 {
   pstring outbuf;
   char *p;
diff -uNr samba-3.0alpha21.orig/source/nmbd/nmbd_serverlistdb.c samba-3.0alpha21/source/nmbd/nmbd_serverlistdb.c
--- samba-3.0alpha21.orig/source/nmbd/nmbd_serverlistdb.c	2003-02-16 19:06:32.000000000 -0600
+++ samba-3.0alpha21/source/nmbd/nmbd_serverlistdb.c	2003-02-16 19:05:45.000000000 -0600
@@ -22,7 +22,6 @@
 */
 
 #include "includes.h"
-#include "smb.h"
 
 extern int ClientNMB;
 
diff -uNr samba-3.0alpha21.orig/source/nmbd/nmbd_subnetdb.c samba-3.0alpha21/source/nmbd/nmbd_subnetdb.c
--- samba-3.0alpha21.orig/source/nmbd/nmbd_subnetdb.c	2003-02-16 19:06:32.000000000 -0600
+++ samba-3.0alpha21/source/nmbd/nmbd_subnetdb.c	2003-02-16 19:05:45.000000000 -0600
@@ -24,7 +24,6 @@
 */
 
 #include "includes.h"
-#include "smb.h"
 
 extern int ClientNMB;
 extern int ClientDGRAM;
@@ -106,7 +105,7 @@
   Create a subnet entry.
   ****************************************************************************/
 
-static struct subnet_record *make_subnet(char *name, enum subnet_type type,
+static struct subnet_record *make_subnet(const char *name, enum subnet_type type,
 					 struct in_addr myip, struct in_addr bcast_ip, 
 					 struct in_addr mask_ip)
 {
diff -uNr samba-3.0alpha21.orig/source/nmbd/nmbd_synclists.c samba-3.0alpha21/source/nmbd/nmbd_synclists.c
--- samba-3.0alpha21.orig/source/nmbd/nmbd_synclists.c	2003-02-16 19:06:32.000000000 -0600
+++ samba-3.0alpha21/source/nmbd/nmbd_synclists.c	2003-02-16 19:05:45.000000000 -0600
@@ -28,7 +28,6 @@
    also allows us to have more than 1 sync going at once (tridge) */
 
 #include "includes.h"
-#include "smb.h"
 
 struct sync_record {
 	struct sync_record *next, *prev;
diff -uNr samba-3.0alpha21.orig/source/nmbd/nmbd_winsserver.c samba-3.0alpha21/source/nmbd/nmbd_winsserver.c
--- samba-3.0alpha21.orig/source/nmbd/nmbd_winsserver.c	2003-02-16 19:06:32.000000000 -0600
+++ samba-3.0alpha21/source/nmbd/nmbd_winsserver.c	2003-02-16 19:05:45.000000000 -0600
@@ -100,7 +100,7 @@
 /****************************************************************************
 possibly call the WINS hook external program when a WINS change is made
 *****************************************************************************/
-static void wins_hook(char *operation, struct name_record *namerec, int ttl)
+static void wins_hook(const char *operation, struct name_record *namerec, int ttl)
 {
 	pstring command;
 	char *cmd = lp_wins_hook();
@@ -250,7 +250,8 @@
 	     kbuf.dptr; 
 	     newkey = tdb_nextkey(tdb, kbuf), safe_free(kbuf.dptr), kbuf=newkey) {
 
-		pstring name_type, name, ip_str;
+		fstring name_type;
+		pstring name, ip_str;
 		char *p;
 		int type = 0;
 		int nb_flags;
diff -uNr samba-3.0alpha21.orig/source/nmbd/nmbd_workgroupdb.c samba-3.0alpha21/source/nmbd/nmbd_workgroupdb.c
--- samba-3.0alpha21.orig/source/nmbd/nmbd_workgroupdb.c	2003-02-16 19:06:32.000000000 -0600
+++ samba-3.0alpha21/source/nmbd/nmbd_workgroupdb.c	2003-02-16 19:05:45.000000000 -0600
@@ -22,7 +22,6 @@
 */
 
 #include "includes.h"
-#include "smb.h"
 
 extern int ClientNMB;
 
diff -uNr samba-3.0alpha21.orig/source/nsswitch/pam_winbind.c samba-3.0alpha21/source/nsswitch/pam_winbind.c
--- samba-3.0alpha21.orig/source/nsswitch/pam_winbind.c	2003-02-16 19:06:32.000000000 -0600
+++ samba-3.0alpha21/source/nsswitch/pam_winbind.c	2003-02-16 19:05:45.000000000 -0600
@@ -121,7 +121,8 @@
 	/* Copy reply data from socket */
 	if (response->result != WINBINDD_OK) {
 		if (response->data.auth.pam_error != PAM_SUCCESS) {
-			_pam_log(LOG_ERR, "request failed, PAM error was %d, NT error was %s", 
+			_pam_log(LOG_ERR, "request failed: %s, PAM error was %d, NT error was %s", 
+				 response->data.auth.error_string,
 				 response->data.auth.pam_error,
 				 response->data.auth.nt_status_string);
 			return response->data.auth.pam_error;
diff -uNr samba-3.0alpha21.orig/source/nsswitch/wb_common.c samba-3.0alpha21/source/nsswitch/wb_common.c
--- samba-3.0alpha21.orig/source/nsswitch/wb_common.c	2003-02-16 19:06:32.000000000 -0600
+++ samba-3.0alpha21/source/nsswitch/wb_common.c	2003-02-16 19:05:45.000000000 -0600
@@ -24,8 +24,7 @@
    Boston, MA  02111-1307, USA.   
 */
 
-#include "winbind_nss_config.h"
-#include "winbindd_nss.h"
+#include "winbind_client.h"
 
 /* Global variables.  These are effectively the client state information */
 
@@ -45,25 +44,11 @@
 
 void init_request(struct winbindd_request *request, int request_type)
 {
-        static char *domain_env;
-        static BOOL initialised;
-
 	request->length = sizeof(struct winbindd_request);
 
 	request->cmd = (enum winbindd_cmd)request_type;
 	request->pid = getpid();
-	request->domain[0] = '\0';
-
-	if (!initialised) {
-		initialised = True;
-		domain_env = getenv(WINBINDD_DOMAIN_ENV);
-	}
 
-	if (domain_env) {
-		strncpy(request->domain, domain_env,
-			sizeof(request->domain) - 1);
-		request->domain[sizeof(request->domain) - 1] = '\0';
-	}
 }
 
 /* Initialise a response structure */
diff -uNr samba-3.0alpha21.orig/source/nsswitch/winbind_nss_solaris.c samba-3.0alpha21/source/nsswitch/winbind_nss_solaris.c
--- samba-3.0alpha21.orig/source/nsswitch/winbind_nss_solaris.c	2003-02-16 19:06:32.000000000 -0600
+++ samba-3.0alpha21/source/nsswitch/winbind_nss_solaris.c	2003-02-16 19:05:45.000000000 -0600
@@ -1,10 +1,30 @@
 /*
   Solaris NSS wrapper for winbind 
   - Shirish Kalele 2000
-
+  
   Based on Luke Howard's ldap_nss module for Solaris 
   */
 
+/*
+  Copyright (C) 1997-2003 Luke Howard.
+  This file is part of the nss_ldap library.
+
+  The nss_ldap library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Library General Public License as
+  published by the Free Software Foundation; either version 2 of the
+  License, or (at your option) any later version.
+
+  The nss_ldap library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Library General Public License for more details.
+
+  You should have received a copy of the GNU Library General Public
+  License along with the nss_ldap library; see the file COPYING.LIB.  If not,
+  write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+  Boston, MA 02111-1307, USA.
+*/
+
 #include <stdlib.h>
 #include <sys/types.h>
 #include <sys/param.h>
diff -uNr samba-3.0alpha21.orig/source/nsswitch/winbindd.c samba-3.0alpha21/source/nsswitch/winbindd.c
--- samba-3.0alpha21.orig/source/nsswitch/winbindd.c	2003-02-16 19:06:32.000000000 -0600
+++ samba-3.0alpha21/source/nsswitch/winbindd.c	2003-02-16 19:05:45.000000000 -0600
@@ -58,6 +58,25 @@
 	return(ret);
 }
 
+/*******************************************************************
+ Print out all talloc memory info.
+********************************************************************/
+
+void return_all_talloc_info(int msg_type, pid_t src_pid, void *buf, size_t len)
+{
+	TALLOC_CTX *ctx = talloc_init("info context");
+	char *info = NULL;
+
+	if (!ctx)
+		return;
+
+	info = talloc_describe_all(ctx);
+	if (info)
+		DEBUG(10,(info));
+	message_send_pid(src_pid, MSG_TALLOC_USAGE, info, info ? strlen(info) + 1: 0, True);
+	talloc_destroy(ctx);
+}
+
 #if DUMP_CORE
 
 /**************************************************************************** **
@@ -188,7 +207,7 @@
 struct dispatch_table {
 	enum winbindd_cmd cmd;
 	enum winbindd_result (*fn)(struct winbindd_cli_state *state);
-	char *winbindd_cmd_name;
+	const char *winbindd_cmd_name;
 };
 
 static struct dispatch_table dispatch_table[] = {
@@ -245,6 +264,7 @@
 	{ WINBINDD_INFO, winbindd_info, "INFO" },
 	{ WINBINDD_INTERFACE_VERSION, winbindd_interface_version, "INTERFACE_VERSION" },
 	{ WINBINDD_DOMAIN_NAME, winbindd_domain_name, "DOMAIN_NAME" },
+	{ WINBINDD_NETBIOS_NAME, winbindd_netbios_name, "NETBIOS_NAME" },
 
 	/* WINS functions */
 
@@ -362,7 +382,7 @@
 	/* Process request */
 	
 	/* Ensure null termination of entire request */
-	state->request.domain[sizeof(state->request.domain)-1]='\0';
+	state->request.null_term = '\0';
 
 	state->pid = state->request.pid;
 	
@@ -509,7 +529,7 @@
 
 		/* rescan the trusted domains list. This must be done
 		   regularly to cope with transitive trusts */
-		rescan_trusted_domains();
+		rescan_trusted_domains(False);
 
 		/* Free up temporary memory */
 
@@ -519,6 +539,12 @@
 		/* Initialise fd lists for select() */
 
 		listen_sock = open_winbindd_socket();
+
+		if (listen_sock == -1) {
+			perror("open_winbind_socket");
+			exit(1);
+		}
+
 		maxfd = listen_sock;
 
 		FD_ZERO(&r_fds);
@@ -689,12 +715,6 @@
 	if (!winbindd_param_init())
 		return False;
 
-	/* Get list of domains we look up requests for.  This includes the
-	   domain which we are a member of as well as any trusted
-	   domains. */ 
-
-	init_domain_list();
-
 	/* Winbind daemon initialisation */
 
 	if (!winbindd_idmap_init())
@@ -733,6 +753,8 @@
 static void usage(void)
 {
 	printf("Usage: winbindd [options]\n");
+        printf("\t-F                daemon in foreground mode\n");
+        printf("\t-S                log to stdout\n");
 	printf("\t-i                interactive mode\n");
 	printf("\t-B                dual daemon mode\n");
 	printf("\t-n                disable cacheing\n");
@@ -746,6 +768,8 @@
 	extern BOOL AllowDebugChange;
 	pstring logfile;
 	BOOL interactive = False;
+	BOOL Fork = True;
+	BOOL log_stdout = False;
 	int opt;
 
 	/* glibc (?) likes to print "User defined signal 1" and exit if a
@@ -770,12 +794,20 @@
 
 	/* Initialise samba/rpc client stuff */
 
-	while ((opt = getopt(argc, argv, "id:s:nhB")) != EOF) {
+	while ((opt = getopt(argc, argv, "FSid:s:nhB")) != EOF) {
 		switch (opt) {
 
+		case 'F':
+			Fork = False;
+			break;
+		case 'S':
+			log_stdout = True;
+			break;
 			/* Don't become a daemon */
 		case 'i':
 			interactive = True;
+			log_stdout = True;
+			Fork = False;
 			break;
 
 			/* dual daemon system */
@@ -809,9 +841,15 @@
 		}
 	}
 
+	if (log_stdout && Fork) {
+		printf("Can't log to stdout (-S) unless daemon is in foreground +(-F) or interactive (-i)\n");
+		usage();
+		exit(1);
+	}
+
 	snprintf(logfile, sizeof(logfile), "%s/log.winbindd", dyn_LOGFILEBASE);
 	lp_set_logfile(logfile);
-	setup_logging("winbindd", interactive);
+	setup_logging("winbindd", log_stdout);
 	reopen_logs();
 
 	DEBUG(1, ("winbindd version %s started.\n", VERSION ) );
@@ -828,7 +866,7 @@
 		exit(1);
 
 	if (!interactive) {
-		become_daemon();
+		become_daemon(Fork);
 		pidfile_create("winbindd");
 	}
 
@@ -858,6 +896,7 @@
 	}
 
 	register_msg_pool_usage();
+	message_register(MSG_REQ_TALLOC_USAGE, return_all_talloc_info);
 
 	/* Loop waiting for requests */
 
diff -uNr samba-3.0alpha21.orig/source/nsswitch/winbindd_ads.c samba-3.0alpha21/source/nsswitch/winbindd_ads.c
--- samba-3.0alpha21.orig/source/nsswitch/winbindd_ads.c	2003-02-16 19:06:32.000000000 -0600
+++ samba-3.0alpha21/source/nsswitch/winbindd_ads.c	2003-02-16 19:05:45.000000000 -0600
@@ -677,7 +677,7 @@
 	ads = ads_cached_connection(domain);
 	if (!ads) return NT_STATUS_UNSUCCESSFUL;
 
-	if (!(ctx = talloc_init_named("alternate_name"))) {
+	if (!(ctx = talloc_init("alternate_name"))) {
 		return NT_STATUS_NO_MEMORY;
 	}
 
diff -uNr samba-3.0alpha21.orig/source/nsswitch/winbindd_cm.c samba-3.0alpha21/source/nsswitch/winbindd_cm.c
--- samba-3.0alpha21.orig/source/nsswitch/winbindd_cm.c	2003-02-16 19:06:32.000000000 -0600
+++ samba-3.0alpha21/source/nsswitch/winbindd_cm.c	2003-02-16 19:05:46.000000000 -0600
@@ -72,6 +72,7 @@
 	fstring domain;
 	fstring controller;
 	fstring pipe_name;
+	size_t mutex_ref_count;
 	struct cli_state *cli;
 	POLICY_HND pol;
 };
@@ -90,7 +91,6 @@
 	struct get_dc_name_cache *prev, *next;
 };
 
-
 /*
   find the DC for a domain using methods appropriate for a ADS domain
 */
@@ -99,14 +99,12 @@
 	ADS_STRUCT *ads;
 	const char *realm = domain;
 
-	if (strcasecmp(realm, lp_workgroup()) == 0) {
+	if (strcasecmp(realm, lp_workgroup()) == 0)
 		realm = lp_realm();
-	}
 
 	ads = ads_init(realm, domain, NULL);
-	if (!ads) {
+	if (!ads)
 		return False;
-	}
 
 	/* we don't need to bind, just connect */
 	ads->auth.flags |= ADS_AUTH_NO_BIND;
@@ -120,9 +118,8 @@
 	ads_connect(ads);
 #endif
 
-	if (!ads->config.realm) {
+	if (!ads->config.realm)
 		return False;
-	}
 
 	fstrcpy(srv_name, ads->config.ldap_server_name);
 	strupper(srv_name);
@@ -135,54 +132,6 @@
 	return True;
 }
 
-/*
-  find the DC for a domain using methods appropriate for a RPC domain
-*/
-static BOOL cm_rpc_find_dc(const char *domain, struct in_addr *dc_ip, fstring srv_name)
-{
-	struct in_addr *ip_list = NULL;
-	int count, i;
-	BOOL list_ordered;
-
-	if (!get_dc_list(domain, &ip_list, &count, &list_ordered)) {
-		struct in_addr pdc_ip;
-		
-		if (!get_pdc_ip(domain, &pdc_ip)) {
-			DEBUG(3, ("Could not look up any DCs for domain %s\n", 
-				  domain));
-			return False;
-		}
-
-		ip_list = (struct in_addr *)malloc(sizeof(struct in_addr));
-
-		if (!ip_list)
-			return False;
-
-		ip_list[0] = pdc_ip;
-		count = 1;
-	}
-
-	/* Pick a nice close server, but only if the list was not ordered */
-	if (!list_ordered && (count > 1) ) {
-		qsort(ip_list, count, sizeof(struct in_addr), QSORT_CAST ip_compare);
-	}
-
-	for (i = 0; i < count; i++) {
-		if (is_zero_ip(ip_list[i]))
-			continue;
-
-		if (name_status_find(domain, 0x1c, 0x20, ip_list[i], srv_name)) {
-			*dc_ip = ip_list[i];
-			SAFE_FREE(ip_list);
-			return True;
-		}
-	}
-
-
-	SAFE_FREE(ip_list);
-
-	return False;
-}
 
 
 static BOOL cm_get_dc_name(const char *domain, fstring srv_name, struct in_addr *ip_out)
@@ -242,17 +191,16 @@
 	zero_ip(&dc_ip);
 
 	ret = False;
-	if (lp_security() == SEC_ADS) {
+	if (lp_security() == SEC_ADS)
 		ret = cm_ads_find_dc(domain, &dc_ip, srv_name);
-	}
+
 	if (!ret) {
 		/* fall back on rpc methods if the ADS methods fail */
-		ret = cm_rpc_find_dc(domain, &dc_ip, srv_name);
+		ret = rpc_find_dc(domain, srv_name, &dc_ip);
 	}
 
-	if (!ret) {
+	if (!ret)
 		return False;
-	}
 
 	/* We have a name so make the cache entry positive now */
 	fstrcpy(dcc->srv_name, srv_name);
@@ -354,7 +302,7 @@
 /* Open a connction to the remote server, cache failures for 30 seconds */
 
 static NTSTATUS cm_open_connection(const char *domain, const int pipe_index,
-			       struct winbindd_cm_conn *new_conn)
+			       struct winbindd_cm_conn *new_conn, BOOL keep_mutex)
 {
 	struct failed_connection_cache *fcc;
 	NTSTATUS result;
@@ -362,6 +310,7 @@
 	struct in_addr dc_ip;
 	int i;
 	BOOL retry = True;
+	BOOL got_mutex = False;
 
 	ZERO_STRUCT(dc_ip);
 
@@ -418,19 +367,23 @@
 
 	for (i = 0; retry && (i < 3); i++) {
 		
-		if (!secrets_named_mutex(new_conn->controller, 10)) {
+		if (!secrets_named_mutex(new_conn->controller, WINBIND_SERVER_MUTEX_WAIT_TIME, &new_conn->mutex_ref_count)) {
 			DEBUG(0,("cm_open_connection: mutex grab failed for %s\n", new_conn->controller));
+			result = NT_STATUS_POSSIBLE_DEADLOCK;
 			continue;
 		}
 
+		got_mutex = True;
+
 		result = cli_full_connection(&new_conn->cli, global_myname(), new_conn->controller, 
 			&dc_ip, 0, "IPC$", "IPC", ipc_username, ipc_domain, 
 			ipc_password, 0, &retry);
 
-		secrets_named_mutex_release(new_conn->controller);
-
 		if (NT_STATUS_IS_OK(result))
 			break;
+
+		secrets_named_mutex_release(new_conn->controller, &new_conn->mutex_ref_count);
+		got_mutex = False;
 	}
 
 	SAFE_FREE(ipc_username);
@@ -438,6 +391,8 @@
 	SAFE_FREE(ipc_password);
 
 	if (!NT_STATUS_IS_OK(result)) {
+		if (got_mutex)
+			secrets_named_mutex_release(new_conn->controller, &new_conn->mutex_ref_count);
 		add_failed_connection_entry(new_conn, result);
 		return result;
 	}
@@ -452,12 +407,16 @@
 		 * if the PDC is an NT4 box.   but since there is only one 2k 
 		 * specific UUID right now, i'm not going to bother.  --jerry
 		 */
+		if (got_mutex)
+			secrets_named_mutex_release(new_conn->controller, &new_conn->mutex_ref_count);
 		if ( !is_win2k_pipe(pipe_index) )
-		add_failed_connection_entry(new_conn, result);
+			add_failed_connection_entry(new_conn, result);
 		cli_shutdown(new_conn->cli);
 		return result;
 	}
 
+	if ((got_mutex) && !keep_mutex)
+		secrets_named_mutex_release(new_conn->controller, &new_conn->mutex_ref_count);
 	return NT_STATUS_OK;
 }
 
@@ -495,7 +454,8 @@
 
 /* Get a connection to the remote DC and open the pipe.  If there is already a connection, use that */
 
-static NTSTATUS get_connection_from_cache(const char *domain, const char *pipe_name, struct winbindd_cm_conn **conn_out) 
+static NTSTATUS get_connection_from_cache(const char *domain, const char *pipe_name,
+		struct winbindd_cm_conn **conn_out, BOOL keep_mutex) 
 {
 	struct winbindd_cm_conn *conn, conn_temp;
 	NTSTATUS result;
@@ -504,15 +464,20 @@
 		if (strequal(conn->domain, domain) && 
 		    strequal(conn->pipe_name, pipe_name)) {
 			if (!connection_ok(conn)) {
-				if (conn->cli) {
+				if (conn->cli)
 					cli_shutdown(conn->cli);
-				}
 				ZERO_STRUCT(conn_temp);
 				conn_temp.next = conn->next;
 				DLIST_REMOVE(cm_conns, conn);
 				SAFE_FREE(conn);
 				conn = &conn_temp;  /* Just to keep the loop moving */
 			} else {
+				if (keep_mutex) {
+					if (!secrets_named_mutex(conn->controller,
+							WINBIND_SERVER_MUTEX_WAIT_TIME, &conn->mutex_ref_count))
+						DEBUG(0,("get_connection_from_cache: mutex grab failed for %s\n",
+							conn->controller));
+				}
 				break;
 			}
 		}
@@ -524,7 +489,7 @@
 		
 		ZERO_STRUCTP(conn);
 		
-		if (!NT_STATUS_IS_OK(result = cm_open_connection(domain, get_pipe_index(pipe_name), conn))) {
+		if (!NT_STATUS_IS_OK(result = cm_open_connection(domain, get_pipe_index(pipe_name), conn, keep_mutex))) {
 			DEBUG(3, ("Could not open a connection to %s for %s (%s)\n", 
 				  domain, pipe_name, nt_errstr(result)));
 		        SAFE_FREE(conn);
@@ -552,8 +517,7 @@
 	ZERO_STRUCT( ctr );
 	
 	
-	if ( !NT_STATUS_IS_OK(result = cm_open_connection(domain, PI_LSARPC_DS, &conn)) ) 
-	{
+	if ( !NT_STATUS_IS_OK(result = cm_open_connection(domain, PI_LSARPC_DS, &conn, False)) ) {
 		DEBUG(5, ("cm_check_for_native_mode_win2k: Could not open a connection to %s for PIPE_LSARPC (%s)\n", 
 			  domain, nt_errstr(result)));
 		return False;
@@ -561,18 +525,15 @@
 	
 	if ( conn.cli ) {
 		if ( !NT_STATUS_IS_OK(cli_ds_getprimarydominfo( conn.cli, 
-			conn.cli->mem_ctx, DsRolePrimaryDomainInfoBasic, &ctr)) ) 
-		{
+				conn.cli->mem_ctx, DsRolePrimaryDomainInfoBasic, &ctr)) ) {
 			ret = False;
 			goto done;
 		}
 	}
 				
 	if ( (ctr.basic->flags & DSROLE_PRIMARY_DS_RUNNING) 
-		&& !(ctr.basic->flags & DSROLE_PRIMARY_DS_MIXED_MODE) )
-	{
+			&& !(ctr.basic->flags & DSROLE_PRIMARY_DS_MIXED_MODE) )
 		ret = True;
-	}
 
 done:
 	if ( conn.cli )
@@ -594,9 +555,8 @@
 
 	/* Look for existing connections */
 
-	if (!NT_STATUS_IS_OK(result = get_connection_from_cache(domain, PIPE_LSARPC, &conn))) {
+	if (!NT_STATUS_IS_OK(result = get_connection_from_cache(domain, PIPE_LSARPC, &conn, False)))
 		return NULL;
-	}
 
 	/* This *shitty* code needs scrapping ! JRA */
 	if (policy_handle_is_valid(&conn->pol)) {
@@ -611,9 +571,8 @@
 	if (!NT_STATUS_IS_OK(result)) {
 		/* Hit the cache code again.  This cleans out the old connection and gets a new one */
 		if (conn->cli->fd == -1) { /* Try again, if the remote host disapeared */
-			if (!NT_STATUS_IS_OK(result = get_connection_from_cache(domain, PIPE_LSARPC, &conn))) {
+			if (!NT_STATUS_IS_OK(result = get_connection_from_cache(domain, PIPE_LSARPC, &conn, False)))
 				return NULL;
-			}
 
 			result = cli_lsa_open_policy(conn->cli, conn->cli->mem_ctx, False, 
 						     des_access, &conn->pol);
@@ -644,9 +603,8 @@
 
 	/* Look for existing connections */
 
-	if (!NT_STATUS_IS_OK(result = get_connection_from_cache(domain, PIPE_SAMR, &conn))) {
+	if (!NT_STATUS_IS_OK(result = get_connection_from_cache(domain, PIPE_SAMR, &conn, False)))
 		return NULL;
-	}
 	
 	/* This *shitty* code needs scrapping ! JRA */
 	if (policy_handle_is_valid(&conn->pol)) {
@@ -660,9 +618,8 @@
 	if (!NT_STATUS_IS_OK(result)) {
 		/* Hit the cache code again.  This cleans out the old connection and gets a new one */
 		if (conn->cli->fd == -1) { /* Try again, if the remote host disapeared */
-			if (!NT_STATUS_IS_OK(result = get_connection_from_cache(domain, PIPE_SAMR, &conn))) {
+			if (!NT_STATUS_IS_OK(result = get_connection_from_cache(domain, PIPE_SAMR, &conn, False)))
 				return NULL;
-			}
 
 			result = cli_samr_connect(conn->cli, conn->cli->mem_ctx,
 						  des_access, &conn->pol);
@@ -919,30 +876,34 @@
 	struct winbindd_cm_conn *conn;
 	uint32 neg_flags = 0x000001ff;
 
-	if (!cli) {
+	if (!cli)
 		return NT_STATUS_INVALID_PARAMETER;
-	}
 
-	/* Open an initial conection */
+	/* Open an initial conection - keep the mutex. */
 
-	if (!NT_STATUS_IS_OK(result = get_connection_from_cache(domain, PIPE_NETLOGON, &conn))) {
+	if (!NT_STATUS_IS_OK(result = get_connection_from_cache(domain, PIPE_NETLOGON, &conn, True)))
 		return result;
-	}
 	
 	result = cli_nt_setup_creds(conn->cli, get_sec_chan(), trust_passwd, &neg_flags, 2);
 
+	if (conn->mutex_ref_count)
+		secrets_named_mutex_release(conn->controller, &conn->mutex_ref_count);
+
 	if (!NT_STATUS_IS_OK(result)) {
 		DEBUG(0, ("error connecting to domain password server: %s\n",
 			  nt_errstr(result)));
 		
 		/* Hit the cache code again.  This cleans out the old connection and gets a new one */
 		if (conn->cli->fd == -1) {
-			if (!NT_STATUS_IS_OK(result = get_connection_from_cache(domain, PIPE_NETLOGON, &conn))) {
+
+			if (!NT_STATUS_IS_OK(result = get_connection_from_cache(domain, PIPE_NETLOGON, &conn, True)))
 				return result;
-			}
 			
 			/* Try again */
 			result = cli_nt_setup_creds( conn->cli, get_sec_chan(),trust_passwd, &neg_flags, 2);
+
+			if (conn->mutex_ref_count)
+				secrets_named_mutex_release(conn->controller, &conn->mutex_ref_count);
 		}
 		
 		if (!NT_STATUS_IS_OK(result)) {
diff -uNr samba-3.0alpha21.orig/source/nsswitch/winbindd_group.c samba-3.0alpha21/source/nsswitch/winbindd_group.c
--- samba-3.0alpha21.orig/source/nsswitch/winbindd_group.c	2003-02-16 19:06:32.000000000 -0600
+++ samba-3.0alpha21/source/nsswitch/winbindd_group.c	2003-02-16 19:05:46.000000000 -0600
@@ -64,7 +64,7 @@
 	TALLOC_CTX *mem_ctx;
 	NTSTATUS status;
 
-	if (!(mem_ctx = talloc_init_named("fill_grent_mem(%s)", domain->name)))
+	if (!(mem_ctx = talloc_init("fill_grent_mem(%s)", domain->name)))
 		return False;
 
 	/* Initialise group membership information */
@@ -356,13 +356,6 @@
 	for (domain = domain_list(); domain != NULL; domain = domain->next) {
 		struct getent_state *domain_state;
 		
-		/* Skip domains other than WINBINDD_DOMAIN environment 
-		   variable */
-		
-		if ((strcmp(state->request.domain, "") != 0) &&
-		    !check_domain_env(state->request.domain, domain->name))
-			continue;
-		
 		/* Create a state record for this domain */
 		
 		if ((domain_state = (struct getent_state *)
@@ -415,7 +408,7 @@
 	if (ent->got_sam_entries)
 		return False;
 
-	if (!(mem_ctx = talloc_init_named("get_sam_group_entries(%s)",
+	if (!(mem_ctx = talloc_init("get_sam_group_entries(%s)",
 					  ent->domain_name))) {
 		DEBUG(1, ("get_sam_group_entries: could not create talloc context!\n")); 
 		return False;
@@ -748,12 +741,6 @@
 
 		ZERO_STRUCT(groups);
 
-		/* Skip domains other than WINBINDD_DOMAIN environment
-		   variable */ 
-		if ((strcmp(state->request.domain, "") != 0) &&
-		    !check_domain_env(state->request.domain, domain->name))
-			continue;
-
 		/* Get list of sam groups */
 		ZERO_STRUCT(groups);
 		fstrcpy(groups.domain_name, domain->name);
@@ -833,7 +820,7 @@
 	DEBUG(3, ("[%5d]: getgroups %s\n", state->pid,
 		  state->request.data.username));
 
-	if (!(mem_ctx = talloc_init_named("winbindd_getgroups(%s)",
+	if (!(mem_ctx = talloc_init("winbindd_getgroups(%s)",
 					  state->request.data.username)))
 		return WINBINDD_ERROR;
 
diff -uNr samba-3.0alpha21.orig/source/nsswitch/winbindd_misc.c samba-3.0alpha21/source/nsswitch/winbindd_misc.c
--- samba-3.0alpha21.orig/source/nsswitch/winbindd_misc.c	2003-02-16 19:06:32.000000000 -0600
+++ samba-3.0alpha21/source/nsswitch/winbindd_misc.c	2003-02-16 19:05:46.000000000 -0600
@@ -26,19 +26,6 @@
 #undef DBGC_CLASS
 #define DBGC_CLASS DBGC_WINBIND
 
-/************************************************************************
- Routine to get the trust account password for a domain
-************************************************************************/
-static BOOL _get_trust_account_password(const char *domain, unsigned char *ret_pwd, 
-					time_t *pass_last_set_time)
-{
-	if (!secrets_fetch_trust_account_password(domain, ret_pwd, pass_last_set_time)) {
-                return False;
-	}
-
-	return True;
-}
-
 /* Check the machine account password is valid */
 
 enum winbindd_result winbindd_check_machine_acct(struct winbindd_cli_state *state)
@@ -52,8 +39,8 @@
 	/* Get trust account password */
 
  again:
-	if (!_get_trust_account_password(lp_workgroup(), trust_passwd, 
-                                         NULL)) {
+	if (!secrets_fetch_trust_account_password(
+		    lp_workgroup(), trust_passwd, NULL)) {
 		result = NT_STATUS_INTERNAL_ERROR;
 		goto done;
 	}
@@ -113,7 +100,11 @@
 	   have changed since we last looked.  There may be a sequence
 	   number or something we should use but I haven't found it yet. */
 
-	init_domain_list();
+	if (!init_domain_list()) {
+		DEBUG(1, ("winbindd_list_trusted_domains: could not "
+			  "refresh trusted domain list\n"));
+		return WINBINDD_ERROR;
+	}
 
 	for(domain = domain_list(); domain; domain = domain->next) {
 
@@ -230,3 +221,15 @@
 
 	return WINBINDD_OK;
 }
+
+/* What's my name again? */
+
+enum winbindd_result winbindd_netbios_name(struct winbindd_cli_state *state)
+{
+
+	DEBUG(3, ("[%5d]: request netbios name\n", state->pid));
+	
+	fstrcpy(state->response.data.netbios_name, global_myname());
+
+	return WINBINDD_OK;
+}
diff -uNr samba-3.0alpha21.orig/source/nsswitch/winbindd_nss.h samba-3.0alpha21/source/nsswitch/winbindd_nss.h
--- samba-3.0alpha21.orig/source/nsswitch/winbindd_nss.h	2003-02-16 19:06:32.000000000 -0600
+++ samba-3.0alpha21/source/nsswitch/winbindd_nss.h	2003-02-16 19:05:46.000000000 -0600
@@ -36,7 +36,7 @@
 
 /* Update this when you change the interface.  */
 
-#define WINBIND_INTERFACE_VERSION 5
+#define WINBIND_INTERFACE_VERSION 7
 
 /* Socket commands */
 
@@ -102,6 +102,7 @@
 	/* this is like GETGRENT but gives an empty group list */
 	WINBINDD_GETGRLST,
 
+	WINBINDD_NETBIOS_NAME,       /* The netbios name of the server */
 	/* Placeholder for end of cmd list */
 
 	WINBINDD_NUM_CMDS
@@ -156,7 +157,7 @@
 		} name;
 		uint32 num_entries;  /* getpwent, getgrent */
 	} data;
-	fstring domain;      /* {set,get,end}{pw,gr}ent() */
+	char null_term;
 };
 
 /* Response values */
@@ -221,6 +222,7 @@
 			fstring samba_version;
 		} info;
 		fstring domain_name;
+		fstring netbios_name;
 
 		struct auth_reply {
 			uint32 nt_status;
diff -uNr samba-3.0alpha21.orig/source/nsswitch/winbindd_pam.c samba-3.0alpha21/source/nsswitch/winbindd_pam.c
--- samba-3.0alpha21.orig/source/nsswitch/winbindd_pam.c	2003-02-16 19:06:32.000000000 -0600
+++ samba-3.0alpha21/source/nsswitch/winbindd_pam.c	2003-02-16 19:05:46.000000000 -0600
@@ -42,11 +42,12 @@
 	}
 
 	size = prs_data_size(&ps);
-	state->response.extra_data = memdup(prs_data_p(&ps), size);
+	state->response.extra_data = malloc(size);
 	if (!state->response.extra_data) {
 		prs_mem_free(&ps);
 		return NT_STATUS_NO_MEMORY;
 	}
+	prs_copy_all_data_out(state->response.extra_data, &ps);
 	state->response.length += size;
 	prs_mem_free(&ps);
 	return NT_STATUS_OK;
@@ -77,7 +78,7 @@
 	DEBUG(3, ("[%5d]: pam auth %s\n", state->pid,
 		  state->request.data.auth.user));
 
-	if (!(mem_ctx = talloc_init_named("winbind pam auth for %s", state->request.data.auth.user))) {
+	if (!(mem_ctx = talloc_init("winbind pam auth for %s", state->request.data.auth.user))) {
 		DEBUG(0, ("winbindd_pam_auth: could not talloc_init()!\n"));
 		result = NT_STATUS_NO_MEMORY;
 		goto done;
@@ -142,7 +143,7 @@
 
 	state->response.data.auth.nt_status = NT_STATUS_V(result);
 	fstrcpy(state->response.data.auth.nt_status_string, nt_errstr(result));
-	fstrcpy(state->response.data.auth.error_string, nt_errstr(result));
+	fstrcpy(state->response.data.auth.error_string, get_friendly_nt_error_msg(result));
 	state->response.data.auth.pam_error = nt_status_to_pam(result);
 
 	DEBUG(NT_STATUS_IS_OK(result) ? 5 : 2, ("Plain-text authentication for user %s returned %s (PAM: %d)\n", 
@@ -179,19 +180,19 @@
 	/* Ensure null termination */
 	state->request.data.auth_crap.domain[sizeof(state->request.data.auth_crap.domain)-1]='\0';
 
-	if (!(mem_ctx = talloc_init_named("winbind pam auth crap for (utf8) %s", state->request.data.auth_crap.user))) {
+	if (!(mem_ctx = talloc_init("winbind pam auth crap for (utf8) %s", state->request.data.auth_crap.user))) {
 		DEBUG(0, ("winbindd_pam_auth_crap: could not talloc_init()!\n"));
 		result = NT_STATUS_NO_MEMORY;
 		goto done;
 	}
 
-        if (pull_utf8_talloc(mem_ctx, &user, state->request.data.auth_crap.user) < 0) {
+        if (pull_utf8_talloc(mem_ctx, &user, state->request.data.auth_crap.user) == (size_t)-1) {
 		DEBUG(0, ("winbindd_pam_auth_crap: pull_utf8_talloc failed!\n"));
 	}
 
 	if (*state->request.data.auth_crap.domain) {
 		char *dom = NULL;
-		if (pull_utf8_talloc(mem_ctx, &dom, state->request.data.auth_crap.domain) < 0) {
+		if (pull_utf8_talloc(mem_ctx, &dom, state->request.data.auth_crap.domain) == (size_t)-1) {
 			DEBUG(0, ("winbindd_pam_auth_crap: pull_utf8_talloc failed!\n"));
 		}
 		domain = dom;
@@ -215,7 +216,7 @@
 
 	if (*state->request.data.auth_crap.workstation) {
 		char *wrk = NULL;
-		if (pull_utf8_talloc(mem_ctx, &wrk, state->request.data.auth_crap.workstation) < 0) {
+		if (pull_utf8_talloc(mem_ctx, &wrk, state->request.data.auth_crap.workstation) == (size_t)-1) {
 			DEBUG(0, ("winbindd_pam_auth_crap: pull_utf8_talloc failed!\n"));
 		}
 		workstation = wrk;
@@ -273,6 +274,8 @@
 
 #if 0
 		/* we don't currently do this stuff right */
+		/* Doing an assert in a daemon is going to be a pretty bad 
+                   idea. - tpot */
 		if (state->request.data.auth_crap.flags & WINBIND_PAM_NTKEY) {
 			SMB_ASSERT(sizeof(state->response.data.auth.nt_session_key) == sizeof(info3.user_sess_key)); 
 			memcpy(state->response.data.auth.nt_session_key, info3.user_sess_key, sizeof(state->response.data.auth.nt_session_key) /* 16 */);
diff -uNr samba-3.0alpha21.orig/source/nsswitch/winbindd_rpc.c samba-3.0alpha21/source/nsswitch/winbindd_rpc.c
--- samba-3.0alpha21.orig/source/nsswitch/winbindd_rpc.c	2003-02-16 19:06:32.000000000 -0600
+++ samba-3.0alpha21/source/nsswitch/winbindd_rpc.c	2003-02-16 19:05:46.000000000 -0600
@@ -39,7 +39,8 @@
 	POLICY_HND dom_pol;
 	BOOL got_dom_pol = False;
 	uint32 des_access = SEC_RIGHTS_MAXIMUM_ALLOWED;
-	int i;
+	int i, loop_count = 0;
+	int retry;
 
 	DEBUG(3,("rpc: query_user_list\n"));
 
@@ -48,13 +49,17 @@
 
 	/* Get sam handle */
 
-	if (!(hnd = cm_get_sam_handle(domain->name)))
-		goto done;
+	retry = 0;
+	do {
+		if (!(hnd = cm_get_sam_handle(domain->name)))
+			goto done;
 
-	/* Get domain handle */
+		/* Get domain handle */
 
-	result = cli_samr_open_domain(hnd->cli, mem_ctx, &hnd->pol,
-					des_access, &domain->sid, &dom_pol);
+		result = cli_samr_open_domain(hnd->cli, mem_ctx, &hnd->pol,
+						des_access, &domain->sid, &dom_pol);
+
+	} while (!NT_STATUS_IS_OK(result) && (retry++ < 1) && hnd && hnd->cli && hnd->cli->fd == -1);
 
 	if (!NT_STATUS_IS_OK(result))
 		goto done;
@@ -65,22 +70,27 @@
 	do {
 		SAM_DISPINFO_CTR ctr;
 		SAM_DISPINFO_1 info1;
-		uint32 count = 0, start=i;
+		uint32 count = 0, start=i, max_entries, max_size;
 		int j;
 		TALLOC_CTX *ctx2;
 
 		ctr.sam.info1 = &info1;
 
-		ctx2 = talloc_init_named("winbindd dispinfo");
+		ctx2 = talloc_init("winbindd dispinfo");
 		if (!ctx2) {
 			result = NT_STATUS_NO_MEMORY;
 			goto done;
 		}
 		
+		get_query_dispinfo_params(
+			loop_count, &max_entries, &max_size);
+
 		/* Query display info level 1 */
-		result = cli_samr_query_dispinfo(hnd->cli, ctx2,
-						 &dom_pol, &start, 1,
-						 &count, 0xFFFF, &ctr);
+		result = cli_samr_query_dispinfo(
+			hnd->cli, ctx2, &dom_pol, &start, 1, &count, 
+			max_entries, max_size, &ctr);
+
+		loop_count++;
 
 		if (!NT_STATUS_IS_OK(result) && 
 		    !NT_STATUS_EQUAL(result, STATUS_MORE_ENTRIES)) break;
@@ -131,29 +141,34 @@
 	CLI_POLICY_HND *hnd;
 	POLICY_HND dom_pol;
 	NTSTATUS status;
+	uint32 start = 0;
+	int retry;
 
 	*num_entries = 0;
 	*info = NULL;
 
 	DEBUG(3,("rpc: enum_dom_groups\n"));
 
-	if (!(hnd = cm_get_sam_handle(domain->name))) {
-		return NT_STATUS_UNSUCCESSFUL;
-	}
+	retry = 0;
+	do {
+		if (!(hnd = cm_get_sam_handle(domain->name)))
+			return NT_STATUS_UNSUCCESSFUL;
 
-	status = cli_samr_open_domain(hnd->cli, mem_ctx,
-				      &hnd->pol, des_access, &domain->sid, &dom_pol);
-	if (!NT_STATUS_IS_OK(status)) {
+		status = cli_samr_open_domain(hnd->cli, mem_ctx,
+					      &hnd->pol, des_access, &domain->sid, &dom_pol);
+	} while (!NT_STATUS_IS_OK(status) && (retry++ < 1) && hnd && hnd->cli && hnd->cli->fd == -1);
+
+	if (!NT_STATUS_IS_OK(status))
 		return status;
-	}
 
 	do {
 		struct acct_info *info2 = NULL;
-		uint32 count = 0, start = *num_entries;
+		uint32 count = 0;
 		TALLOC_CTX *mem_ctx2;
 
-		mem_ctx2 = talloc_init_named("enum_dom_groups[rpc]");
+		mem_ctx2 = talloc_init("enum_dom_groups[rpc]");
 
+		/* start is updated by this call. */
 		status = cli_samr_enum_dom_groups(hnd->cli, mem_ctx2, &dom_pol,
 						  &start,
 						  0xFFFF, /* buffer size? */
@@ -194,25 +209,29 @@
 	CLI_POLICY_HND *hnd;
 	POLICY_HND dom_pol;
 	NTSTATUS result;
+	int retry;
 
 	*num_entries = 0;
 	*info = NULL;
 
-	if ( !(hnd = cm_get_sam_handle(domain->name)) )
-		return NT_STATUS_UNSUCCESSFUL;
+	retry = 0;
+	do {
+		if ( !(hnd = cm_get_sam_handle(domain->name)) )
+			return NT_STATUS_UNSUCCESSFUL;
 
-	if ( !NT_STATUS_IS_OK(result = cli_samr_open_domain( hnd->cli, mem_ctx, &hnd->pol, 
-						des_access, &domain->sid, &dom_pol)) )
-	{
+		result = cli_samr_open_domain( hnd->cli, mem_ctx, &hnd->pol, 
+						des_access, &domain->sid, &dom_pol);
+	} while (!NT_STATUS_IS_OK(result) && (retry++ < 1) && hnd && hnd->cli && hnd->cli->fd == -1);
+
+	if ( !NT_STATUS_IS_OK(result))
 		return result;
-	}
 
 	do {
 		struct acct_info *info2 = NULL;
 		uint32 count = 0, start = *num_entries;
 		TALLOC_CTX *mem_ctx2;
 
-		mem_ctx2 = talloc_init_named("enum_dom_local_groups[rpc]");
+		mem_ctx2 = talloc_init("enum_dom_local_groups[rpc]");
 
 		result = cli_samr_enum_als_groups( hnd->cli, mem_ctx2, &dom_pol,
 					  &start, 0xFFFF, &info2, &count);
@@ -254,19 +273,15 @@
 	DOM_SID *sids = NULL;
 	uint32 *types = NULL;
 	const char *full_name;
+	int retry;
 
 	DEBUG(3,("rpc: name_to_sid name=%s\n", name));
 
-	if (!(mem_ctx = talloc_init_named("name_to_sid[rpc] for [%s]\\[%s]", domain->name, name))) {
+	if (!(mem_ctx = talloc_init("name_to_sid[rpc] for [%s]\\[%s]", domain->name, name))) {
 		DEBUG(0, ("talloc_init failed!\n"));
 		return NT_STATUS_NO_MEMORY;
 	}
         
-	if (!(hnd = cm_get_lsa_handle(domain->name))) {
-		talloc_destroy(mem_ctx);
-		return NT_STATUS_UNSUCCESSFUL;
-	}
-        
 	full_name = talloc_asprintf(mem_ctx, "%s\\%s", domain->name, name);
 	
 	if (!full_name) {
@@ -275,8 +290,16 @@
 		return NT_STATUS_NO_MEMORY;
 	}
 
-	status = cli_lsa_lookup_names(hnd->cli, mem_ctx, &hnd->pol, 1, 
-				      &full_name, &sids, &types);
+	retry = 0;
+	do {
+		if (!(hnd = cm_get_lsa_handle(domain->name))) {
+			talloc_destroy(mem_ctx);
+			return NT_STATUS_UNSUCCESSFUL;
+		}
+        
+		status = cli_lsa_lookup_names(hnd->cli, mem_ctx, &hnd->pol, 1, 
+					      &full_name, &sids, &types);
+	} while (!NT_STATUS_IS_OK(status) && (retry++ < 1) && hnd && hnd->cli && hnd->cli->fd == -1);
         
 	/* Return rid and type if lookup successful */
 
@@ -303,14 +326,18 @@
 	char **names;
 	uint32 *types;
 	NTSTATUS status;
+	int retry;
 
 	DEBUG(3,("rpc: sid_to_name\n"));
 
-	if (!(hnd = cm_get_lsa_handle(domain->name)))
-		return NT_STATUS_UNSUCCESSFUL;
+	retry = 0;
+	do {
+		if (!(hnd = cm_get_lsa_handle(domain->name)))
+			return NT_STATUS_UNSUCCESSFUL;
         
-	status = cli_lsa_lookup_sids(hnd->cli, mem_ctx, &hnd->pol,
-				     1, sid, &domains, &names, &types);
+		status = cli_lsa_lookup_sids(hnd->cli, mem_ctx, &hnd->pol,
+					     1, sid, &domains, &names, &types);
+	} while (!NT_STATUS_IS_OK(status) && (retry++ < 1) && hnd && hnd->cli && hnd->cli->fd == -1);
 
 	if (NT_STATUS_IS_OK(status)) {
 		*type = types[0];
@@ -337,18 +364,22 @@
 	POLICY_HND dom_pol, user_pol;
 	BOOL got_dom_pol = False, got_user_pol = False;
 	SAM_USERINFO_CTR *ctr;
+	int retry;
 
 	DEBUG(3,("rpc: query_user rid=%u\n", user_rid));
 
-	/* Get sam handle */
-	if (!(hnd = cm_get_sam_handle(domain->name)))
-		goto done;
+	retry = 0;
+	do {
+		/* Get sam handle */
+		if (!(hnd = cm_get_sam_handle(domain->name)))
+			goto done;
 
-	/* Get domain handle */
+		/* Get domain handle */
 
-	result = cli_samr_open_domain(hnd->cli, mem_ctx, &hnd->pol,
-				      SEC_RIGHTS_MAXIMUM_ALLOWED, 
-				      &domain->sid, &dom_pol);
+		result = cli_samr_open_domain(hnd->cli, mem_ctx, &hnd->pol,
+					      SEC_RIGHTS_MAXIMUM_ALLOWED, 
+					      &domain->sid, &dom_pol);
+	} while (!NT_STATUS_IS_OK(result) && (retry++ < 1) && hnd && hnd->cli && hnd->cli->fd == -1);
 
 	if (!NT_STATUS_IS_OK(result))
 		goto done;
@@ -405,6 +436,7 @@
 	BOOL got_dom_pol = False, got_user_pol = False;
 	DOM_GID *user_groups;
 	int i;
+	int retry;
 
 	DEBUG(3,("rpc: lookup_usergroups rid=%u\n", user_rid));
 
@@ -419,13 +451,16 @@
 	    *num_groups = 0;
 	}
 
-	/* Get sam handle */
-	if (!(hnd = cm_get_sam_handle(domain->name)))
-		goto done;
+	retry = 0;
+	do {
+		/* Get sam handle */
+		if (!(hnd = cm_get_sam_handle(domain->name)))
+			goto done;
 
-	/* Get domain handle */
-	result = cli_samr_open_domain(hnd->cli, mem_ctx, &hnd->pol,
-					des_access, &domain->sid, &dom_pol);
+		/* Get domain handle */
+		result = cli_samr_open_domain(hnd->cli, mem_ctx, &hnd->pol,
+						des_access, &domain->sid, &dom_pol);
+	} while (!NT_STATUS_IS_OK(result) && (retry++ < 1) && hnd && hnd->cli && hnd->cli->fd == -1);
 
 	if (!NT_STATUS_IS_OK(result))
 		goto done;
@@ -478,20 +513,23 @@
         POLICY_HND dom_pol, group_pol;
         uint32 des_access = SEC_RIGHTS_MAXIMUM_ALLOWED;
         BOOL got_dom_pol = False, got_group_pol = False;
+	int retry;
 
 	DEBUG(10,("rpc: lookup_groupmem %s rid=%u\n", domain->name, group_rid));
 
 	*num_names = 0;
 
-        /* Get sam handle */
-
-        if (!(hnd = cm_get_sam_handle(domain->name)))
-                goto done;
+	retry = 0;
+	do {
+	        /* Get sam handle */
+		if (!(hnd = cm_get_sam_handle(domain->name)))
+			goto done;
 
-        /* Get domain handle */
+		/* Get domain handle */
 
-        result = cli_samr_open_domain(hnd->cli, mem_ctx, &hnd->pol,
-                                      des_access, &domain->sid, &dom_pol);
+		result = cli_samr_open_domain(hnd->cli, mem_ctx, &hnd->pol,
+				des_access, &domain->sid, &dom_pol);
+	} while (!NT_STATUS_IS_OK(result) && (retry++ < 1) && hnd && hnd->cli && hnd->cli->fd == -1);
 
         if (!NT_STATUS_IS_OK(result))
                 goto done;
@@ -582,23 +620,25 @@
 	POLICY_HND dom_pol;
 	BOOL got_dom_pol = False;
 	uint32 des_access = SEC_RIGHTS_MAXIMUM_ALLOWED;
+	int retry;
 
 	DEBUG(10,("rpc: fetch sequence_number for %s\n", domain->name));
 
 	*seq = DOM_SEQUENCE_NONE;
 
-	if (!(mem_ctx = talloc_init_named("sequence_number[rpc]")))
+	if (!(mem_ctx = talloc_init("sequence_number[rpc]")))
 		return NT_STATUS_NO_MEMORY;
 
-	/* Get sam handle */
-
-	if (!(hnd = cm_get_sam_handle(domain->name)))
-		goto done;
-
-	/* Get domain handle */
+	retry = 0;
+	do {
+		/* Get sam handle */
+		if (!(hnd = cm_get_sam_handle(domain->name)))
+			goto done;
 
-	result = cli_samr_open_domain(hnd->cli, mem_ctx, &hnd->pol, 
+		/* Get domain handle */
+		result = cli_samr_open_domain(hnd->cli, mem_ctx, &hnd->pol, 
 				      des_access, &domain->sid, &dom_pol);
+	} while (!NT_STATUS_IS_OK(result) && (retry++ < 1) && hnd && hnd->cli && hnd->cli->fd == -1);
 
 	if (!NT_STATUS_IS_OK(result))
 		goto done;
@@ -641,18 +681,23 @@
 	CLI_POLICY_HND *hnd;
 	NTSTATUS result = NT_STATUS_UNSUCCESSFUL;
 	uint32 enum_ctx = 0;
+	int retry;
 
 	DEBUG(3,("rpc: trusted_domains\n"));
 
 	*num_domains = 0;
 	*alt_names = NULL;
 
-	if (!(hnd = cm_get_lsa_handle(lp_workgroup())))
-		goto done;
+	retry = 0;
+	do {
+		if (!(hnd = cm_get_lsa_handle(lp_workgroup())))
+			goto done;
+
+		result = cli_lsa_enum_trust_dom(hnd->cli, mem_ctx,
+						&hnd->pol, &enum_ctx,
+						num_domains, names, dom_sids);
+	} while (!NT_STATUS_IS_OK(result) && (retry++ < 1) &&  hnd && hnd->cli && hnd->cli->fd == -1);
 
-	result = cli_lsa_enum_trust_dom(hnd->cli, mem_ctx,
-					&hnd->pol, &enum_ctx,
-					num_domains, names, dom_sids);
 done:
 	return result;
 }
@@ -664,18 +709,22 @@
 	TALLOC_CTX *mem_ctx;
 	CLI_POLICY_HND *hnd;
 	fstring level5_dom;
+	int retry;
 
 	DEBUG(3,("rpc: domain_sid\n"));
 
-	if (!(mem_ctx = talloc_init_named("domain_sid[rpc]")))
+	if (!(mem_ctx = talloc_init("domain_sid[rpc]")))
 		return NT_STATUS_NO_MEMORY;
 
-	/* Get sam handle */
-	if (!(hnd = cm_get_lsa_handle(domain->name)))
-		goto done;
+	retry = 0;
+	do {
+		/* Get sam handle */
+		if (!(hnd = cm_get_lsa_handle(domain->name)))
+			goto done;
 
-	status = cli_lsa_query_info_policy(hnd->cli, mem_ctx,
+		status = cli_lsa_query_info_policy(hnd->cli, mem_ctx,
 					   &hnd->pol, 0x05, level5_dom, sid);
+	} while (!NT_STATUS_IS_OK(status) && (retry++ < 1) &&  hnd && hnd->cli && hnd->cli->fd == -1);
 
 done:
 	talloc_destroy(mem_ctx);
diff -uNr samba-3.0alpha21.orig/source/nsswitch/winbindd_sid.c samba-3.0alpha21/source/nsswitch/winbindd_sid.c
--- samba-3.0alpha21.orig/source/nsswitch/winbindd_sid.c	2003-02-16 19:06:32.000000000 -0600
+++ samba-3.0alpha21/source/nsswitch/winbindd_sid.c	2003-02-16 19:05:46.000000000 -0600
@@ -72,8 +72,10 @@
 	return WINBINDD_OK;
 }
 
-/* Convert a sid to a string */
 
+/**
+ * Look up the SID for a qualified name.  
+ **/
 enum winbindd_result winbindd_lookupname(struct winbindd_cli_state *state)
 {
 	enum SID_NAME_USE type;
diff -uNr samba-3.0alpha21.orig/source/nsswitch/winbindd_user.c samba-3.0alpha21/source/nsswitch/winbindd_user.c
--- samba-3.0alpha21.orig/source/nsswitch/winbindd_user.c	2003-02-16 19:06:32.000000000 -0600
+++ samba-3.0alpha21/source/nsswitch/winbindd_user.c	2003-02-16 19:05:46.000000000 -0600
@@ -138,7 +138,7 @@
 	   from the winbind_lookup_by_name() call and use it in a
 	   winbind_lookup_userinfo() */
     
-	if (!(mem_ctx = talloc_init_named("winbindd_getpwnam([%s]\\[%s])", 
+	if (!(mem_ctx = talloc_init("winbindd_getpwnam([%s]\\[%s])", 
 					  name_domain, name_user))) {
 		DEBUG(1, ("out of memory\n"));
 		return WINBINDD_ERROR;
@@ -218,7 +218,7 @@
 	
 	/* Get some user info */
 	
-	if (!(mem_ctx = talloc_init_named("winbind_getpwuid(%d)",
+	if (!(mem_ctx = talloc_init("winbind_getpwuid(%d)",
 					  state->request.data.uid))) {
 
 		DEBUG(1, ("out of memory\n"));
@@ -285,16 +285,6 @@
 	for(domain = domain_list(); domain != NULL; domain = domain->next) {
 		struct getent_state *domain_state;
                 
-		/*
-		 * Skip domains other than WINBINDD_DOMAIN environment
-		 * variable.
-		 */
-                
-		if ((strcmp(state->request.domain, "") != 0) &&
-				!check_domain_env(state->request.domain, 
-						  domain->name))
-			continue;
-
 		/* Create a state record for this domain */
                 
 		if ((domain_state = (struct getent_state *)
@@ -347,7 +337,7 @@
 	if (ent->num_sam_entries)
 		return False;
 
-	if (!(mem_ctx = talloc_init_named("get_sam_user_entries(%s)",
+	if (!(mem_ctx = talloc_init("get_sam_user_entries(%s)",
 					  ent->domain_name)))
 		return False;
 
@@ -542,7 +532,7 @@
 
 	DEBUG(3, ("[%5d]: list users\n", state->pid));
 
-	if (!(mem_ctx = talloc_init_named("winbindd_list_users")))
+	if (!(mem_ctx = talloc_init("winbindd_list_users")))
 		return WINBINDD_ERROR;
 
 	/* Enumerate over trusted domains */
@@ -552,13 +542,6 @@
 		struct winbindd_methods *methods;
 		int i;
 
-		/* Skip domains other than WINBINDD_DOMAIN environment
-		   variable */ 
-
-		if ((strcmp(state->request.domain, "") != 0) &&
-		    !check_domain_env(state->request.domain, domain->name))
-			continue;
-
 		methods = domain->methods;
 
 		/* Query display info */
diff -uNr samba-3.0alpha21.orig/source/nsswitch/winbindd_util.c samba-3.0alpha21/source/nsswitch/winbindd_util.c
--- samba-3.0alpha21.orig/source/nsswitch/winbindd_util.c	2003-02-16 19:06:32.000000000 -0600
+++ samba-3.0alpha21/source/nsswitch/winbindd_util.c	2003-02-16 19:05:46.000000000 -0600
@@ -146,7 +146,7 @@
 /*
   rescan our domains looking for new trusted domains
  */
-void rescan_trusted_domains(void)
+void rescan_trusted_domains(BOOL force)
 {
 	struct winbindd_domain *domain;
 	TALLOC_CTX *mem_ctx;
@@ -157,16 +157,17 @@
 	if (!lp_allow_trusted_domains()) {
 		return;
 	}
-	
-	/* ony rescan every few minutes */
-	if ((unsigned)(t - last_scan) < WINBINDD_RESCAN_FREQ) {
+
+	/* Only rescan every few minutes but force if necessary */
+
+	if (((unsigned)(t - last_scan) < WINBINDD_RESCAN_FREQ) && !force)
 		return;
-	}
+
 	last_scan = t;
 
 	DEBUG(1, ("scanning trusted domain list\n"));
 
-	if (!(mem_ctx = talloc_init_named("init_domain_list")))
+	if (!(mem_ctx = talloc_init("init_domain_list")))
 		return;
 
 	for (domain = _domain_list; domain; domain = domain->next) {
@@ -199,7 +200,6 @@
 /* Look up global info for the winbind daemon */
 BOOL init_domain_list(void)
 {
-	NTSTATUS result;
 	extern struct winbindd_methods cache_methods;
 	struct winbindd_domain *domain;
 
@@ -208,30 +208,17 @@
 
 	/* Add ourselves as the first entry */
 	domain = add_trusted_domain(lp_workgroup(), NULL, &cache_methods, NULL);
-
-	/* Now we *must* get the domain sid for our primary domain. Go into
-	   a holding pattern until that is available */
-
-	result = cache_methods.domain_sid(domain, &domain->sid);
-	while (!NT_STATUS_IS_OK(result)) {
-
-		sleep(10);
-		DEBUG(1,("Retrying startup domain sid fetch for %s\n",
-			 domain->name));
-		result = cache_methods.domain_sid(domain, &domain->sid);
-
-		/* If we don't call lp_talloc_free() here we end up 
-		   accumulating memory in the "global" lp_talloc in
-		   param/loadparm.c */
-
-		lp_talloc_free();
+	if (!secrets_fetch_domain_sid(domain->name, &domain->sid)) {
+		DEBUG(1, ("Could not fetch sid for our domain %s\n",
+			  domain->name));
+		return False;
 	}
-       
+
 	/* get any alternate name for the primary domain */
 	cache_methods.alternate_name(domain);
 
 	/* do an initial scan for trusted domains */
-	rescan_trusted_domains();
+	rescan_trusted_domains(True);
 
 	return True;
 }
@@ -333,7 +320,7 @@
 
 	/* Lookup name */
 
-	if (!(mem_ctx = talloc_init_named("winbindd_lookup_name_by_sid")))
+	if (!(mem_ctx = talloc_init("winbindd_lookup_name_by_sid")))
 		return False;
         
 	result = domain->methods->sid_to_name(domain, mem_ctx, sid, &names, type);
diff -uNr samba-3.0alpha21.orig/source/pam_smbpass/support.c samba-3.0alpha21/source/pam_smbpass/support.c
--- samba-3.0alpha21.orig/source/pam_smbpass/support.c	2003-02-16 19:06:32.000000000 -0600
+++ samba-3.0alpha21/source/pam_smbpass/support.c	2003-02-16 19:05:46.000000000 -0600
@@ -355,25 +355,6 @@
     strncpy( data_name, FAIL_PREFIX, sizeof(FAIL_PREFIX) );
     strncpy( data_name + sizeof(FAIL_PREFIX) - 1, name, strlen( name ) + 1 );
 
-    /* First we check whether we've been given the password in already
-       encrypted form. */
-    if (strlen( p ) == 16 || (strlen( p ) == 32
-         && pdb_gethexpwd( p, (char *) hash_pass ))) {
-
-        if (!memcmp( hash_pass, pdb_get_lanman_passwd(sampass), 16 )
-            || (pdb_get_nt_passwd(sampass)
-                && !memcmp( hash_pass, pdb_get_nt_passwd(sampass), 16 )))
-        {
-            retval = PAM_SUCCESS;
-            if (data_name) {	/* reset failures */
-                pam_set_data( pamh, data_name, NULL, _cleanup_failures );
-            }
-            _pam_delete( data_name );
-            memset( hash_pass, '\0', 16 );
-            return retval;
-        }
-    }
-
     /*
      * The password we were given wasn't an encrypted password, or it
      * didn't match the one we have.  We encrypt the password now and try
diff -uNr samba-3.0alpha21.orig/source/param/loadparm.c samba-3.0alpha21/source/param/loadparm.c
--- samba-3.0alpha21.orig/source/param/loadparm.c	2003-02-16 19:06:32.000000000 -0600
+++ samba-3.0alpha21/source/param/loadparm.c	2003-02-16 19:05:46.000000000 -0600
@@ -7,6 +7,7 @@
 
    Copyright (C) Simo Sorce 2001
    Copyright (C) Alexander Bokovoy 2002
+   Copyright (C) Stefan (metze) Metzmacher 2002
    
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -126,7 +127,10 @@
 	char *szSocketAddress;
 	char *szNISHomeMapName;
 	char *szAnnounceVersion;	/* This is initialised in init_globals */
+	char *szWorkgroup;
+	char *szNetbiosName;
 	char **szNetbiosAliases;
+	char *szNetbiosScope;
 	char *szDomainOtherSIDs;
 	char *szNameResolveOrder;
 	char *szPanicAction;
@@ -262,6 +266,7 @@
 	BOOL bUseSpnego;
 	BOOL bUnixExtensions;
 	BOOL bDisableNetbios;
+	BOOL bKernelChangeNotify;
 	int restrict_anonymous;
 	int name_cache_timeout;
 }
@@ -316,6 +321,7 @@
 	char *szVfsObjectFile;
 	char *szVfsOptions;
 	char *szVfsPath;
+	char *szMSDfsProxy;
 	int iMinPrintSpace;
 	int iMaxPrintJobs;
 	int iWriteCacheSize;
@@ -434,6 +440,7 @@
 	NULL,			/* vfs object */
 	NULL,			/* vfs options */
 	NULL,			/* vfs path */
+	NULL,                   /* szMSDfsProxy */
 	0,			/* iMinPrintSpace */
 	1000,			/* iMaxPrintJobs */
 	0,			/* iWriteCacheSize */
@@ -518,29 +525,29 @@
 #define NUMPARAMETERS (sizeof(parm_table) / sizeof(struct parm_struct))
 
 /* prototypes for the special type handlers */
-static BOOL handle_include(char *pszParmValue, char **ptr);
-static BOOL handle_copy(char *pszParmValue, char **ptr);
-static BOOL handle_vfs_object(char *pszParmValue, char **ptr);
-static BOOL handle_source_env(char *pszParmValue, char **ptr);
-static BOOL handle_netbios_name(char *pszParmValue, char **ptr);
-static BOOL handle_winbind_uid(char *pszParmValue, char **ptr);
-static BOOL handle_winbind_gid(char *pszParmValue, char **ptr);
-static BOOL handle_non_unix_account_range(char *pszParmValue, char **ptr);
-static BOOL handle_debug_list( char *pszParmValue, char **ptr );
-static BOOL handle_workgroup( char *pszParmValue, char **ptr );
-static BOOL handle_netbios_aliases( char *pszParmValue, char **ptr );
-static BOOL handle_netbios_scope( char *pszParmValue, char **ptr );
-
-static BOOL handle_ldap_machine_suffix ( char *pszParmValue, char **ptr );
-static BOOL handle_ldap_user_suffix ( char *pszParmValue, char **ptr );
-static BOOL handle_ldap_suffix ( char *pszParmValue, char **ptr );
+static BOOL handle_include(const char *pszParmValue, char **ptr);
+static BOOL handle_copy(const char *pszParmValue, char **ptr);
+static BOOL handle_vfs_object(const char *pszParmValue, char **ptr);
+static BOOL handle_source_env(const char *pszParmValue, char **ptr);
+static BOOL handle_netbios_name(const char *pszParmValue, char **ptr);
+static BOOL handle_winbind_uid(const char *pszParmValue, char **ptr);
+static BOOL handle_winbind_gid(const char *pszParmValue, char **ptr);
+static BOOL handle_non_unix_account_range(const char *pszParmValue, char **ptr);
+static BOOL handle_debug_list( const char *pszParmValue, char **ptr );
+static BOOL handle_workgroup( const char *pszParmValue, char **ptr );
+static BOOL handle_netbios_aliases( const char *pszParmValue, char **ptr );
+static BOOL handle_netbios_scope( const char *pszParmValue, char **ptr );
+
+static BOOL handle_ldap_machine_suffix ( const char *pszParmValue, char **ptr );
+static BOOL handle_ldap_user_suffix ( const char *pszParmValue, char **ptr );
+static BOOL handle_ldap_suffix ( const char *pszParmValue, char **ptr );
 
-static BOOL handle_acl_compatibility(char *pszParmValue, char **ptr);
+static BOOL handle_acl_compatibility(const char *pszParmValue, char **ptr);
 
 static void set_server_role(void);
 static void set_default_server_announce_type(void);
 
-static struct enum_list enum_protocol[] = {
+static const struct enum_list enum_protocol[] = {
 	{PROTOCOL_NT1, "NT1"},
 	{PROTOCOL_LANMAN2, "LANMAN2"},
 	{PROTOCOL_LANMAN1, "LANMAN1"},
@@ -550,7 +557,7 @@
 	{-1, NULL}
 };
 
-static struct enum_list enum_security[] = {
+static const struct enum_list enum_security[] = {
 	{SEC_SHARE, "SHARE"},
 	{SEC_USER, "USER"},
 	{SEC_SERVER, "SERVER"},
@@ -561,7 +568,7 @@
 	{-1, NULL}
 };
 
-static struct enum_list enum_printing[] = {
+static const struct enum_list enum_printing[] = {
 	{PRINT_SYSV, "sysv"},
 	{PRINT_AIX, "aix"},
 	{PRINT_HPUX, "hpux"},
@@ -580,7 +587,7 @@
 	{-1, NULL}
 };
 
-static struct enum_list enum_ldap_ssl[] = {
+static const struct enum_list enum_ldap_ssl[] = {
 #ifdef WITH_LDAP_SAMCONFIG
 	{LDAP_SSL_ON, "Yes"},
 	{LDAP_SSL_ON, "yes"},
@@ -596,7 +603,7 @@
 	{-1, NULL}
 };
 
-static struct enum_list enum_ldap_passwd_sync[] = {
+static const struct enum_list enum_ldap_passwd_sync[] = {
 	{LDAP_PASSWD_SYNC_ON, "Yes"},
 	{LDAP_PASSWD_SYNC_ON, "yes"},
 	{LDAP_PASSWD_SYNC_ON, "on"},
@@ -618,7 +625,7 @@
 #define ANNOUNCE_AS_WFW 3
 #define ANNOUNCE_AS_NT_WORKSTATION 4
 
-static struct enum_list enum_announce_as[] = {
+static const struct enum_list enum_announce_as[] = {
 	{ANNOUNCE_AS_NT_SERVER, "NT"},
 	{ANNOUNCE_AS_NT_SERVER, "NT Server"},
 	{ANNOUNCE_AS_NT_WORKSTATION, "NT Workstation"},
@@ -627,13 +634,13 @@
 	{-1, NULL}
 };
 
-static struct enum_list enum_case[] = {
+static const struct enum_list enum_case[] = {
 	{CASE_LOWER, "lower"},
 	{CASE_UPPER, "upper"},
 	{-1, NULL}
 };
 
-static struct enum_list enum_bool_auto[] = {
+static const struct enum_list enum_bool_auto[] = {
 	{False, "No"},
 	{False, "False"},
 	{False, "0"},
@@ -650,7 +657,7 @@
 #define CSC_POLICY_PROGRAMS 2
 #define CSC_POLICY_DISABLE 3
 
-static struct enum_list enum_csc_policy[] = {
+static const struct enum_list enum_csc_policy[] = {
 	{CSC_POLICY_MANUAL, "manual"},
 	{CSC_POLICY_DOCUMENTS, "documents"},
 	{CSC_POLICY_PROGRAMS, "programs"},
@@ -679,7 +686,7 @@
    level security.
 */
 
-static struct enum_list enum_map_to_guest[] = {
+static const struct enum_list enum_map_to_guest[] = {
 	{NEVER_MAP_TO_GUEST, "Never"},
 	{MAP_TO_GUEST_ON_BAD_USER, "Bad User"},
 	{MAP_TO_GUEST_ON_BAD_PASSWORD, "Bad Password"},
@@ -705,12 +712,12 @@
 	{"comment", P_STRING, P_LOCAL, &sDefault.comment, NULL, NULL, FLAG_BASIC | FLAG_ADVANCED | FLAG_SHARE | FLAG_PRINT | FLAG_DEVELOPER},
 	{"path", P_STRING, P_LOCAL, &sDefault.szPath, NULL, NULL, FLAG_BASIC | FLAG_ADVANCED | FLAG_SHARE | FLAG_PRINT | FLAG_DEVELOPER},
 	{"directory", P_STRING, P_LOCAL, &sDefault.szPath, NULL, NULL, FLAG_HIDE},
-	{"workgroup", P_USTRING, P_GLOBAL, NULL, handle_workgroup, NULL, FLAG_BASIC | FLAG_ADVANCED | FLAG_WIZARD | FLAG_DEVELOPER},
+	{"workgroup", P_USTRING, P_GLOBAL, &Globals.szWorkgroup, handle_workgroup, NULL, FLAG_BASIC | FLAG_ADVANCED | FLAG_WIZARD | FLAG_DEVELOPER},
 	{"realm", P_USTRING, P_GLOBAL, &Globals.szRealm, NULL, NULL, FLAG_BASIC | FLAG_ADVANCED | FLAG_WIZARD | FLAG_DEVELOPER},
 	{"ADS server", P_STRING, P_GLOBAL, &Globals.szADSserver, NULL, NULL, FLAG_BASIC | FLAG_ADVANCED | FLAG_WIZARD | FLAG_DEVELOPER},
-	{"netbios name", P_UGSTRING, P_GLOBAL, NULL, handle_netbios_name, NULL, FLAG_BASIC | FLAG_ADVANCED | FLAG_WIZARD | FLAG_DEVELOPER},
+	{"netbios name", P_USTRING, P_GLOBAL, &Globals.szNetbiosName, handle_netbios_name, NULL, FLAG_BASIC | FLAG_ADVANCED | FLAG_WIZARD | FLAG_DEVELOPER},
 	{"netbios aliases", P_LIST, P_GLOBAL, &Globals.szNetbiosAliases, handle_netbios_aliases, NULL, FLAG_ADVANCED | FLAG_WIZARD | FLAG_DEVELOPER},
-	{"netbios scope", P_UGSTRING, P_GLOBAL, NULL, handle_netbios_scope, NULL, FLAG_ADVANCED | FLAG_DEVELOPER},
+	{"netbios scope", P_USTRING, P_GLOBAL, &Globals.szNetbiosScope, handle_netbios_scope, NULL, FLAG_ADVANCED | FLAG_DEVELOPER},
 	{"server string", P_STRING, P_GLOBAL, &Globals.szServerString, NULL, NULL, FLAG_BASIC | FLAG_ADVANCED  | FLAG_DEVELOPER},
 	{"interfaces", P_LIST, P_GLOBAL, &Globals.szInterfaces, NULL, NULL, FLAG_BASIC | FLAG_ADVANCED | FLAG_WIZARD | FLAG_DEVELOPER},
 	{"bind interfaces only", P_BOOL, P_GLOBAL, &Globals.bBindInterfacesOnly, NULL, NULL, FLAG_ADVANCED | FLAG_WIZARD | FLAG_DEVELOPER},
@@ -731,7 +738,7 @@
 	{"password server", P_STRING, P_GLOBAL, &Globals.szPasswordServer, NULL, NULL, FLAG_ADVANCED | FLAG_WIZARD | FLAG_DEVELOPER},
 	{"smb passwd file", P_STRING, P_GLOBAL, &Globals.szSMBPasswdFile, NULL, NULL, FLAG_ADVANCED | FLAG_DEVELOPER},
 	{"private dir", P_STRING, P_GLOBAL, &Globals.szPrivateDir, NULL, NULL, FLAG_ADVANCED | FLAG_DEVELOPER},
-	{"passdb backend", P_LIST, P_GLOBAL, &Globals.szPassdbBackend, NULL, NULL, FLAG_ADVANCED | FLAG_DEVELOPER},
+	{"passdb backend", P_LIST, P_GLOBAL, &Globals.szPassdbBackend, NULL, NULL, FLAG_ADVANCED | FLAG_WIZARD | FLAG_DEVELOPER},
 	{"non unix account range", P_STRING, P_GLOBAL, &Globals.szNonUnixAccountRange, handle_non_unix_account_range, NULL, FLAG_ADVANCED | FLAG_DEVELOPER},
 	{"algorithmic rid base", P_INTEGER, P_GLOBAL, &Globals.bAlgorithmicRidBase, NULL, NULL, FLAG_ADVANCED | FLAG_DEVELOPER},
 	{"root directory", P_STRING, P_GLOBAL, &Globals.szRootdir, NULL, NULL, FLAG_ADVANCED | FLAG_DEVELOPER},
@@ -848,6 +855,7 @@
 	{"deadtime", P_INTEGER, P_GLOBAL, &Globals.deadtime, NULL, NULL, FLAG_DEVELOPER},
 	{"getwd cache", P_BOOL, P_GLOBAL, &use_getwd_cache, NULL, NULL, FLAG_DEVELOPER},
 	{"keepalive", P_INTEGER, P_GLOBAL, &keepalive, NULL, NULL, FLAG_ADVANCED | FLAG_DEVELOPER},
+	{"kernel change notify", P_BOOL, P_GLOBAL, &Globals.bKernelChangeNotify, NULL, NULL, FLAG_DEVELOPER},
 	
 	{"lpq cache time", P_INTEGER, P_GLOBAL, &Globals.lpqcachetime, NULL, NULL, FLAG_DEVELOPER},
 	{"max smbd processes", P_INTEGER, P_GLOBAL, &Globals.iMaxSmbdProcesses, NULL, NULL, FLAG_DEVELOPER},
@@ -1073,6 +1081,7 @@
 
 	
 	{"msdfs root", P_BOOL, P_LOCAL, &sDefault.bMSDfsRoot, NULL, NULL, FLAG_SHARE},
+	{"msdfs proxy", P_STRING, P_LOCAL, &sDefault.szMSDfsProxy, NULL, NULL, FLAG_SHARE},
 	{"host msdfs", P_BOOL, P_GLOBAL, &Globals.bHostMSDfs, NULL, NULL, FLAG_ADVANCED | FLAG_DEVELOPER},
 
 	{"Winbind options", P_SEP, P_SEPARATOR},
@@ -1253,7 +1262,13 @@
 	 * Allow the default PASSWD_CHAT to be overridden in local.h.
 	 */
 	string_set(&Globals.szPasswdChat, DEFAULT_PASSWD_CHAT);
+	
+	set_global_myname(myhostname());
+	string_set(&Globals.szNetbiosName,global_myname());
+
 	set_global_myworkgroup(WORKGROUP);
+	string_set(&Globals.szWorkgroup, lp_workgroup());
+	
 	string_set(&Globals.szPasswdProgram, "");
 	string_set(&Globals.szPrintcapname, PRINTCAP_NAME);
 	string_set(&Globals.szPidDir, dyn_PIDDIR);
@@ -1319,6 +1334,7 @@
 	Globals.min_wins_ttl = 60 * 60 * 6;	/* 6 hours default. */
 	Globals.machine_password_timeout = 60 * 60 * 24 * 7;	/* 7 days default. */
 	Globals.change_notify_timeout = 60;	/* 1 minute default. */
+	Globals.bKernelChangeNotify = True;	/* On if we have it. */
 	Globals.ReadSize = 16 * 1024;
 	Globals.lm_announce = 2;	/* = Auto: send only if LM clients found */
 	Globals.lm_interval = 60;
@@ -1459,7 +1475,7 @@
 #endif
 
 	if (!lp_talloc)
-		lp_talloc = talloc_init_named("lp_talloc");
+		lp_talloc = talloc_init("lp_talloc");
 
 	ret = (char *)talloc(lp_talloc, len + 100);	/* leave room for substitution */
 
@@ -1581,7 +1597,7 @@
 FN_GLOBAL_STRING(lp_wins_partners, &Globals.szWINSPartners)
 FN_GLOBAL_STRING(lp_template_homedir, &Globals.szTemplateHomedir)
 FN_GLOBAL_STRING(lp_template_shell, &Globals.szTemplateShell)
-FN_GLOBAL_STRING(lp_winbind_separator, &Globals.szWinbindSeparator)
+FN_GLOBAL_CONST_STRING(lp_winbind_separator, &Globals.szWinbindSeparator)
 FN_GLOBAL_STRING(lp_acl_compatibility, &Globals.szAclCompat)
 FN_GLOBAL_BOOL(lp_winbind_enum_users, &Globals.bWinbindEnumUsers)
 FN_GLOBAL_BOOL(lp_winbind_enum_groups, &Globals.bWinbindEnumGroups)
@@ -1649,6 +1665,7 @@
 FN_GLOBAL_BOOL(lp_unix_extensions, &Globals.bUnixExtensions)
 FN_GLOBAL_BOOL(lp_use_spnego, &Globals.bUseSpnego)
 FN_GLOBAL_BOOL(lp_hostname_lookups, &Globals.bHostnameLookups)
+FN_GLOBAL_BOOL(lp_kernel_change_notify, &Globals.bKernelChangeNotify)
 FN_GLOBAL_INTEGER(lp_os_level, &Globals.os_level)
 FN_GLOBAL_INTEGER(lp_max_ttl, &Globals.max_ttl)
 FN_GLOBAL_INTEGER(lp_max_wins_ttl, &Globals.max_wins_ttl)
@@ -1717,6 +1734,7 @@
 FN_LOCAL_STRING(lp_vfsobj, szVfsObjectFile)
 FN_LOCAL_STRING(lp_vfs_options, szVfsOptions)
 FN_LOCAL_STRING(lp_vfs_path, szVfsPath)
+FN_LOCAL_STRING(lp_msdfs_proxy, szMSDfsProxy)
 static FN_LOCAL_STRING(lp_volume, volume)
 FN_LOCAL_STRING(lp_mangled_map, szMangledMap)
 FN_LOCAL_STRING(lp_veto_files, szVetoFiles)
@@ -1838,15 +1856,15 @@
 
 /* local prototypes */
 
-static int map_parameter(char *pszParmName);
-static BOOL set_boolean(BOOL *pb, char *pszParmValue);
+static int map_parameter(const char *pszParmName);
+static BOOL set_boolean(BOOL *pb, const char *pszParmValue);
 static int getservicebyname(const char *pszServiceName,
 			    service * pserviceDest);
 static void copy_service(service * pserviceDest,
 			 service * pserviceSource, BOOL *pcopymapDest);
 static BOOL service_ok(int iService);
-static BOOL do_parameter(char *pszParmName, char *pszParmValue);
-static BOOL do_section(char *pszSectionName);
+static BOOL do_parameter(const char *pszParmName, const char *pszParmValue);
+static BOOL do_section(const char *pszSectionName);
 static void init_copymap(service * pservice);
 
 
@@ -2009,7 +2027,7 @@
  Add the IPC service.
 ***************************************************************************/
 
-static BOOL lp_add_ipc(char *ipc_name, BOOL guest_ok)
+static BOOL lp_add_ipc(const char *ipc_name, BOOL guest_ok)
 {
 	pstring comment;
 	int i = add_a_service(&sDefault, ipc_name);
@@ -2079,7 +2097,7 @@
  Returns False if the parameter string is not recognised, else TRUE.
 ***************************************************************************/
 
-static int map_parameter(char *pszParmName)
+static int map_parameter(const char *pszParmName)
 {
 	int iIndex;
 
@@ -2105,7 +2123,7 @@
  represent a boolean.
 ***************************************************************************/
 
-static BOOL set_boolean(BOOL *pb, char *pszParmValue)
+static BOOL set_boolean(BOOL *pb, const char *pszParmValue)
 {
 	BOOL bRetval;
 
@@ -2341,33 +2359,46 @@
  Note: We must *NOT* use string_set() here as ptr points to global_myname.
 ***************************************************************************/
 
-static BOOL handle_netbios_name(char *pszParmValue, char **ptr)
+static BOOL handle_netbios_name(const char *pszParmValue, char **ptr)
 {
+	BOOL ret;
 	pstring netbios_name;
 
 	pstrcpy(netbios_name, pszParmValue);
 
 	standard_sub_basic(current_user_info.smb_name, netbios_name,sizeof(netbios_name));
 
-	set_global_myname(netbios_name);
 
+	ret = set_global_myname(netbios_name);
+	string_set(&Globals.szNetbiosName,global_myname());
+	
 	DEBUG(4, ("handle_netbios_name: set global_myname to: %s\n",
 	       global_myname()));
 
-	return (True);
+	return ret;
 }
 
-static BOOL handle_workgroup(char *pszParmValue, char **ptr)
+static BOOL handle_workgroup(const char *pszParmValue, char **ptr)
 {
-	return set_global_myworkgroup(pszParmValue);
+	BOOL ret;
+	
+	ret = set_global_myworkgroup(pszParmValue);
+	string_set(&Globals.szWorkgroup,lp_workgroup());
+	
+	return ret;
 }
 
-static BOOL handle_netbios_scope(char *pszParmValue, char **ptr)
+static BOOL handle_netbios_scope(const char *pszParmValue, char **ptr)
 {
-	return set_global_scope(pszParmValue);
+	BOOL ret;
+	
+	ret = set_global_scope(pszParmValue);
+	string_set(&Globals.szNetbiosScope,global_scope());
+
+	return ret;
 }
 
-static BOOL handle_netbios_aliases(char *pszParmValue, char **ptr)
+static BOOL handle_netbios_aliases(const char *pszParmValue, char **ptr)
 {
 	Globals.szNetbiosAliases = str_list_make(pszParmValue, NULL);
 	return set_netbios_aliases((const char **)Globals.szNetbiosAliases);
@@ -2427,7 +2458,7 @@
  Handle the source environment operation.
 ***************************************************************************/
 
-static BOOL handle_source_env(char *pszParmValue, char **ptr)
+static BOOL handle_source_env(const char *pszParmValue, char **ptr)
 {
 	pstring fname;
 	char *p = fname;
@@ -2467,7 +2498,7 @@
  Handle the interpretation of the vfs object parameter.
 *************************************************************************/
 
-static BOOL handle_vfs_object(char *pszParmValue, char **ptr)
+static BOOL handle_vfs_object(const char *pszParmValue, char **ptr)
 {
 	/* Set string value */
 
@@ -2483,7 +2514,7 @@
  Handle the include operation.
 ***************************************************************************/
 
-static BOOL handle_include(char *pszParmValue, char **ptr)
+static BOOL handle_include(const char *pszParmValue, char **ptr)
 {
 	pstring fname;
 	pstrcpy(fname, pszParmValue);
@@ -2506,7 +2537,7 @@
  Handle the interpretation of the copy parameter.
 ***************************************************************************/
 
-static BOOL handle_copy(char *pszParmValue, char **ptr)
+static BOOL handle_copy(const char *pszParmValue, char **ptr)
 {
 	BOOL bRetval;
 	int iTemp;
@@ -2602,7 +2633,7 @@
 
 /* Do some simple checks on "winbind [ug]id" parameter values */
 
-static BOOL handle_winbind_uid(char *pszParmValue, char **ptr)
+static BOOL handle_winbind_uid(const char *pszParmValue, char **ptr)
 {
 	uint32 low, high;
 
@@ -2619,7 +2650,7 @@
 	return True;
 }
 
-static BOOL handle_winbind_gid(char *pszParmValue, char **ptr)
+static BOOL handle_winbind_gid(const char *pszParmValue, char **ptr)
 {
 	uint32 low, high;
 
@@ -2640,7 +2671,7 @@
  Do some simple checks on "non unix account range" parameter values.
 ***************************************************************************/
 
-static BOOL handle_non_unix_account_range(char *pszParmValue, char **ptr)
+static BOOL handle_non_unix_account_range(const char *pszParmValue, char **ptr)
 {
 	uint32 low, high;
 
@@ -2661,7 +2692,7 @@
  Handle the DEBUG level list.
 ***************************************************************************/
 
-static BOOL handle_debug_list( char *pszParmValueIn, char **ptr )
+static BOOL handle_debug_list( const char *pszParmValueIn, char **ptr )
 {
 	pstring pszParmValue;
 
@@ -2674,7 +2705,7 @@
  Handle the ldap machine suffix option.
 ***************************************************************************/
 
-static BOOL handle_ldap_machine_suffix( char *pszParmValue, char **ptr)
+static BOOL handle_ldap_machine_suffix( const char *pszParmValue, char **ptr)
 {
        pstring suffix;
        
@@ -2698,7 +2729,7 @@
  Handle the ldap user suffix option.
 ***************************************************************************/
 
-static BOOL handle_ldap_user_suffix( char *pszParmValue, char **ptr)
+static BOOL handle_ldap_user_suffix( const char *pszParmValue, char **ptr)
 {
        pstring suffix;
        
@@ -2723,7 +2754,7 @@
  to be set as well.
 ***************************************************************************/
 
-static BOOL handle_ldap_suffix( char *pszParmValue, char **ptr)
+static BOOL handle_ldap_suffix( const char *pszParmValue, char **ptr)
 {
        pstring suffix;
        pstring user_suffix;
@@ -2756,7 +2787,7 @@
        return True;
 }
 
-static BOOL handle_acl_compatibility(char *pszParmValue, char **ptr)
+static BOOL handle_acl_compatibility(const char *pszParmValue, char **ptr)
 {
 	if (strequal(pszParmValue, "auto"))
 		string_set(ptr, "");
@@ -2802,7 +2833,7 @@
  then assume we are in the globals.
 ***************************************************************************/
 
-BOOL lp_do_parameter(int snum, char *pszParmName, char *pszParmValue)
+BOOL lp_do_parameter(int snum, const char *pszParmName, const char *pszParmValue)
 {
 	int parmnum, i, slen;
 	void *parm_ptr = NULL;	/* where we are going to store the result */
@@ -2941,7 +2972,7 @@
  Process a parameter.
 ***************************************************************************/
 
-static BOOL do_parameter(char *pszParmName, char *pszParmValue)
+static BOOL do_parameter(const char *pszParmName, const char *pszParmValue)
 {
 	if (!bInGlobalSection && bGlobalOnly)
 		return (True);
@@ -3082,7 +3113,7 @@
  Returns True on success, False on failure. 
 ***************************************************************************/
 
-static BOOL do_section(char *pszSectionName)
+static BOOL do_section(const char *pszSectionName)
 {
 	BOOL bRetval;
 	BOOL isglobal = ((strwicmp(pszSectionName, GLOBAL_NAME) == 0) ||
@@ -3831,7 +3862,7 @@
  Copy a service.
 ********************************************************************/
 
-void lp_copy_service(int snum, char *new_name)
+void lp_copy_service(int snum, const char *new_name)
 {
 	char *oldname = lp_servicename(snum);
 	do_section(new_name);
diff -uNr samba-3.0alpha21.orig/source/param/params.c samba-3.0alpha21/source/param/params.c
--- samba-3.0alpha21.orig/source/param/params.c	2003-02-16 19:06:32.000000000 -0600
+++ samba-3.0alpha21/source/param/params.c	2003-02-16 19:05:46.000000000 -0600
@@ -201,7 +201,7 @@
 }
 
 
-static BOOL Section( myFILE *InFile, BOOL (*sfunc)(char *) )
+static BOOL Section( myFILE *InFile, BOOL (*sfunc)(const char *) )
   /* ------------------------------------------------------------------------ **
    * Scan a section name, and pass the name to function sfunc().
    *
@@ -219,7 +219,7 @@
   int   c;
   int   i;
   int   end;
-  char *func  = "params.c:Section() -";
+  const char *func  = "params.c:Section() -";
 
   i = 0;      /* <i> is the offset of the next free byte in bufr[] and  */
   end = 0;    /* <end> is the current "end of string" offset.  In most  */
@@ -297,7 +297,7 @@
   return( False );
   } /* Section */
 
-static BOOL Parameter( myFILE *InFile, BOOL (*pfunc)(char *, char *), int c )
+static BOOL Parameter( myFILE *InFile, BOOL (*pfunc)(const char *, const char *), int c )
   /* ------------------------------------------------------------------------ **
    * Scan a parameter name and value, and pass these two fields to pfunc().
    *
@@ -325,7 +325,7 @@
   int   i       = 0;    /* Position within bufr. */
   int   end     = 0;    /* bufr[end] is current end-of-string. */
   int   vstart  = 0;    /* Starting position of the parameter value. */
-  char *func    = "params.c:Parameter() -";
+  const char *func    = "params.c:Parameter() -";
 
   /* Read the parameter name. */
   while( 0 == vstart )  /* Loop until we've found the start of the value. */
@@ -445,8 +445,8 @@
   } /* Parameter */
 
 static BOOL Parse( myFILE *InFile,
-                   BOOL (*sfunc)(char *),
-                   BOOL (*pfunc)(char *, char *) )
+                   BOOL (*sfunc)(const char *),
+                   BOOL (*pfunc)(const char *, const char *) )
   /* ------------------------------------------------------------------------ **
    * Scan & parse the input.
    *
@@ -505,7 +505,7 @@
   return( True );
   } /* Parse */
 
-static myFILE *OpenConfFile( char *FileName )
+static myFILE *OpenConfFile( const char *FileName )
   /* ------------------------------------------------------------------------ **
    * Open a configuration file.
    *
@@ -516,7 +516,7 @@
    * ------------------------------------------------------------------------ **
    */
   {
-  char *func = "params.c:OpenConfFile() -";
+  const char *func = "params.c:OpenConfFile() -";
   extern BOOL in_client;
   int lvl = in_client?1:0;
   myFILE *ret;
@@ -538,9 +538,9 @@
   return( ret );
   } /* OpenConfFile */
 
-BOOL pm_process( char *FileName,
-                 BOOL (*sfunc)(char *),
-                 BOOL (*pfunc)(char *, char *) )
+BOOL pm_process( const char *FileName,
+                 BOOL (*sfunc)(const char *),
+                 BOOL (*pfunc)(const char *, const char *) )
   /* ------------------------------------------------------------------------ **
    * Process the named parameter file.
    *
@@ -557,7 +557,7 @@
   {
   int   result;
   myFILE *InFile;
-  char *func = "params.c:pm_process() -";
+  const char *func = "params.c:pm_process() -";
 
   InFile = OpenConfFile( FileName );          /* Open the config file. */
   if( NULL == InFile )
diff -uNr samba-3.0alpha21.orig/source/passdb/passdb.c samba-3.0alpha21/source/passdb/passdb.c
--- samba-3.0alpha21.orig/source/passdb/passdb.c	2003-02-16 19:06:32.000000000 -0600
+++ samba-3.0alpha21/source/passdb/passdb.c	2003-02-16 19:05:46.000000000 -0600
@@ -139,7 +139,7 @@
 	TALLOC_CTX *mem_ctx;
 	NTSTATUS nt_status;
 	
-	mem_ctx = talloc_init_named("passdb internal SAM_ACCOUNT allocation");
+	mem_ctx = talloc_init("passdb internal SAM_ACCOUNT allocation");
 
 	if (!mem_ctx) {
 		DEBUG(0,("pdb_init_sam: error while doing talloc_init()\n"));
@@ -304,7 +304,7 @@
 /**
  * Free the contets of the SAM_ACCOUNT, but not the structure.
  *
- * Also wipes the LM and NT hashes and plaintext passwrod from 
+ * Also wipes the LM and NT hashes and plaintext password from 
  * memory.
  *
  * @param user SAM_ACCOUNT to free members of.
@@ -473,7 +473,7 @@
 {
 	int i;
 	unsigned char   lonybble, hinybble;
-	char           *hexchars = "0123456789ABCDEF";
+	const char      *hexchars = "0123456789ABCDEF";
 	char           *p1, *p2;
 	
 	if (!p)
@@ -826,8 +826,6 @@
 		
 		if (pdb_getsampwnam(sam_user, pass->pw_name)) {
 			sid_copy(psid, pdb_get_user_sid(sam_user));
-		} else if (strcmp(pass->pw_name, lp_guestaccount()) == 0) {
-			sid_append_rid(psid, DOMAIN_USER_RID_GUEST);
 		} else {
 			sid_append_rid(psid, fallback_pdb_uid_to_user_rid(uid));
 		}
@@ -991,23 +989,6 @@
 	return True;
 }
 
-/** 
- * Quick hack to do an easy ucs2 -> mulitbyte conversion 
- * @return static buffer containing the converted string
- **/
-
-const char *pdb_unistr2_convert(const UNISTR2 *from)
-{
-	static pstring convert_buffer;
-	*convert_buffer = 0;
-	if (!from) {
-		return NULL;
-	}
-
-	unistr2_to_ascii(convert_buffer, from, sizeof(pstring));
-	return convert_buffer;
-}
-
 /*************************************************************
  Change a password entry in the local smbpasswd file.
 
diff -uNr samba-3.0alpha21.orig/source/passdb/pdb_get_set.c samba-3.0alpha21/source/passdb/pdb_get_set.c
--- samba-3.0alpha21.orig/source/passdb/pdb_get_set.c	2003-02-16 19:06:32.000000000 -0600
+++ samba-3.0alpha21/source/passdb/pdb_get_set.c	2003-02-16 19:05:46.000000000 -0600
@@ -1114,4 +1114,3 @@
 
 	return True;
 }
-
diff -uNr samba-3.0alpha21.orig/source/passdb/pdb_interface.c samba-3.0alpha21/source/passdb/pdb_interface.c
--- samba-3.0alpha21.orig/source/passdb/pdb_interface.c	2003-02-16 19:06:32.000000000 -0600
+++ samba-3.0alpha21/source/passdb/pdb_interface.c	2003-02-16 19:05:46.000000000 -0600
@@ -415,7 +415,7 @@
 {
 	TALLOC_CTX *mem_ctx;
 
-	mem_ctx = talloc_init_named("pdb_context internal allocation context");
+	mem_ctx = talloc_init("pdb_context internal allocation context");
 
 	if (!mem_ctx) {
 		DEBUG(0, ("make_pdb_context: talloc init failed!\n"));
diff -uNr samba-3.0alpha21.orig/source/passdb/pdb_ldap.c samba-3.0alpha21/source/passdb/pdb_ldap.c
--- samba-3.0alpha21.orig/source/passdb/pdb_ldap.c	2003-02-16 19:06:32.000000000 -0600
+++ samba-3.0alpha21/source/passdb/pdb_ldap.c	2003-02-16 19:05:46.000000000 -0600
@@ -218,7 +218,7 @@
 			
 			DEBUG(3,("LDAPS option set...!\n"));
 #else
-			DEBUG(0,("ldap_open_connection: Secure connection not supported by LDAP client libraries!\n"));
+			DEBUG(0,("ldapsam_open_connection: Secure connection not supported by LDAP client libraries!\n"));
 			return LDAP_OPERATIONS_ERROR;
 #endif
 		}
@@ -254,12 +254,12 @@
 			return LDAP_OPERATIONS_ERROR;
 		}
 #else
-		DEBUG(0,("ldap_open_connection: StartTLS not supported by LDAP client libraries!\n"));
+		DEBUG(0,("ldapsam_open_connection: StartTLS not supported by LDAP client libraries!\n"));
 		return LDAP_OPERATIONS_ERROR;
 #endif
 	}
 
-	DEBUG(2, ("ldap_open_connection: connection opened\n"));
+	DEBUG(2, ("ldapsam_open_connection: connection opened\n"));
 	return rc;
 }
 
@@ -284,7 +284,7 @@
 		memset(*credp, '\0', strlen(*credp));
 		SAFE_FREE(*credp);
 	} else {
-		DEBUG(5,("ldap_connect_system: Rebinding as \"%s\"\n", 
+		DEBUG(5,("rebind_proc_with_state: Rebinding as \"%s\"\n", 
 			  ldap_state->bind_dn));
 
 		*whop = strdup(ldap_state->bind_dn);
@@ -315,7 +315,7 @@
 {
 	struct ldapsam_privates *ldap_state = arg;
 	int rc;
-	DEBUG(5,("ldap_connect_system: Rebinding as \"%s\"\n", 
+	DEBUG(5,("rebindproc_connect_with_state: Rebinding as \"%s\"\n", 
 		 ldap_state->bind_dn));
 	
 	/** @TODO Should we be doing something to check what servers we rebind to?
@@ -385,8 +385,8 @@
 	/* removed the sasl_bind_s "EXTERNAL" stuff, as my testsuite 
 	   (OpenLDAP) doesnt' seem to support it */
 	   
-	DEBUG(10,("ldap_connect_system: Binding to ldap server as \"%s\"\n",
-		ldap_dn));
+	DEBUG(10,("ldap_connect_system: Binding to ldap server %s as \"%s\"\n",
+		  ldap_state->uri, ldap_dn));
 
 #if defined(LDAP_API_FEATURE_X_OPENLDAP) && (LDAP_API_VERSION > 2000)
 # if LDAP_SET_REBIND_PROC_ARGS == 2	
@@ -407,7 +407,14 @@
 	rc = ldap_simple_bind_s(ldap_struct, ldap_dn, ldap_secret);
 
 	if (rc != LDAP_SUCCESS) {
-		DEBUG(0, ("Bind failed: %s\n", ldap_err2string(rc)));
+		char *ld_error;
+		ldap_get_option(ldap_state->ldap_struct, LDAP_OPT_ERROR_STRING,
+				&ld_error);
+		DEBUG(0,
+		      ("failed to bind to server with dn= %s Error: %s\n\t%s\n",
+			       ldap_dn, ldap_err2string(rc),
+			       ld_error));
+		free(ld_error);
 		return rc;
 	}
 	
@@ -527,7 +534,7 @@
 	}
 	
 	if (rc == LDAP_SERVER_DOWN) {
-		DEBUG(0,("%s: LDAP server is down!\n",__FUNCTION__));
+		DEBUG(0,("%s: LDAP server is down!\n",FUNCTION_MACRO));
 		ldapsam_close(ldap_state);	
 	}
 	
@@ -551,7 +558,7 @@
 	}
 	
 	if (rc == LDAP_SERVER_DOWN) {
-		DEBUG(0,("%s: LDAP server is down!\n",__FUNCTION__));
+		DEBUG(0,("%s: LDAP server is down!\n",FUNCTION_MACRO));
 		ldapsam_close(ldap_state);	
 	}
 	
@@ -575,7 +582,7 @@
 	}
 	
 	if (rc == LDAP_SERVER_DOWN) {
-		DEBUG(0,("%s: LDAP server is down!\n",__FUNCTION__));
+		DEBUG(0,("%s: LDAP server is down!\n",FUNCTION_MACRO));
 		ldapsam_close(ldap_state);	
 	}
 		
@@ -599,7 +606,7 @@
 	}
 	
 	if (rc == LDAP_SERVER_DOWN) {
-		DEBUG(0,("%s: LDAP server is down!\n",__FUNCTION__));
+		DEBUG(0,("%s: LDAP server is down!\n",FUNCTION_MACRO));
 		ldapsam_close(ldap_state);	
 	}
 		
@@ -623,7 +630,7 @@
 	}
 	
 	if (rc == LDAP_SERVER_DOWN) {
-		DEBUG(0,("%s: LDAP server is down!\n",__FUNCTION__));
+		DEBUG(0,("%s: LDAP server is down!\n",FUNCTION_MACRO));
 		ldapsam_close(ldap_state);	
 	}
 		
@@ -659,7 +666,12 @@
 			     LDAPMessage ** result)
 {
 	pstring filter;
-	
+	char *escape_user = escape_ldap_string_alloc(user);
+
+	if (!escape_user) {
+		return LDAP_NO_MEMORY;
+	}
+
 	/*
 	 * in the filter expression, replace %u with the real name
 	 * so in ldap filter, %u MUST exist :-)
@@ -670,7 +682,10 @@
 	 * have to use this here because $ is filtered out
 	   * in pstring_sub
 	 */
-	all_string_sub(filter, "%u", user, sizeof(pstring));
+	
+
+	all_string_sub(filter, "%u", escape_user, sizeof(pstring));
+	SAFE_FREE(escape_user);
 
 	return ldapsam_search_one_user(ldap_state, filter, result);
 }
@@ -684,6 +699,7 @@
 {
 	struct passwd *user;
 	pstring filter;
+	char *escape_user;
 
 	/* Get the username from the system and look that up in the LDAP */
 	
@@ -694,9 +710,16 @@
 	
 	pstrcpy(filter, lp_ldap_filter());
 	
-	all_string_sub(filter, "%u", user->pw_name, sizeof(pstring));
+	escape_user = escape_ldap_string_alloc(user->pw_name);
+	if (!escape_user) {
+		passwd_free(&user);
+		return LDAP_NO_MEMORY;
+	}
+
+	all_string_sub(filter, "%u", escape_user, sizeof(pstring));
 
 	passwd_free(&user);
+	SAFE_FREE(escape_user);
 
 	return ldapsam_search_one_user(ldap_state, filter, result);
 }
@@ -728,7 +751,7 @@
 search an attribute and return the first value found.
 ******************************************************************/
 static BOOL get_single_attribute (LDAP * ldap_struct, LDAPMessage * entry,
-				  char *attribute, pstring value)
+				  const char *attribute, pstring value)
 {
 	char **values;
 
@@ -907,7 +930,7 @@
 			group_rid;
 	uint8 		smblmpwd[LM_HASH_LEN],
 			smbntpwd[NT_HASH_LEN];
-	uint16 		acct_ctrl, 
+	uint16 		acct_ctrl = 0, 
 			logon_divs;
 	uint32 hours_len;
 	uint8 		hours[MAX_HOURS_LEN];
@@ -1558,16 +1581,26 @@
 	struct ldapsam_privates *ldap_state = (struct ldapsam_privates *)my_methods->private_data;
 	LDAPMessage *result;
 	LDAPMessage *entry;
-
+	int count;
+	
 	if (ldapsam_search_one_user_by_name(ldap_state, sname, &result) != LDAP_SUCCESS) {
 		return NT_STATUS_NO_SUCH_USER;
 	}
-	if (ldap_count_entries(ldap_state->ldap_struct, result) < 1) {
+	
+	count = ldap_count_entries(ldap_state->ldap_struct, result);
+	
+	if (count < 1) {
 		DEBUG(4,
 		      ("We don't find this user [%s] count=%d\n", sname,
-		       ldap_count_entries(ldap_state->ldap_struct, result)));
+		       count));
+		return NT_STATUS_NO_SUCH_USER;
+	} else if (count > 1) {
+		DEBUG(1,
+		      ("Duplicate entries for this user [%s] Failing. count=%d\n", sname,
+		       count));
 		return NT_STATUS_NO_SUCH_USER;
 	}
+
 	entry = ldap_first_entry(ldap_state->ldap_struct, result);
 	if (entry) {
 		if (!init_sam_from_ldap(ldap_state, user, entry)) {
@@ -1593,15 +1626,23 @@
 		(struct ldapsam_privates *)my_methods->private_data;
 	LDAPMessage *result;
 	LDAPMessage *entry;
+	int count;
 
 	if (ldapsam_search_one_user_by_rid(ldap_state, rid, &result) != LDAP_SUCCESS) {
 		return NT_STATUS_NO_SUCH_USER;
 	}
 
-	if (ldap_count_entries(ldap_state->ldap_struct, result) < 1) {
+	count = ldap_count_entries(ldap_state->ldap_struct, result);
+		
+	if (count < 1) {
 		DEBUG(4,
 		      ("We don't find this rid [%i] count=%d\n", rid,
-		       ldap_count_entries(ldap_state->ldap_struct, result)));
+		       count));
+		return NT_STATUS_NO_SUCH_USER;
+	} else if (count > 1) {
+		DEBUG(1,
+		      ("More than one user with rid [%i]. Failing. count=%d\n", rid,
+		       count));
 		return NT_STATUS_NO_SUCH_USER;
 	}
 
@@ -1787,7 +1828,6 @@
 
 	if (!init_ldap_from_sam(ldap_state, &mods, LDAP_MOD_REPLACE, False, newpwd)) {
 		DEBUG(0, ("ldapsam_update_sam_account: init_ldap_from_sam failed!\n"));
-		ldap_msgfree(result);
 		return NT_STATUS_UNSUCCESSFUL;
 	}
 	
@@ -1854,7 +1894,8 @@
 	}
 
 	if (ldap_count_entries(ldap_state->ldap_struct, result) != 0) {
-		DEBUG(0,("User already in the base, with samba properties\n"));
+		DEBUG(0,("User '%s' already in the base, with samba properties\n", 
+			 username));
 		ldap_msgfree(result);
 		return NT_STATUS_UNSUCCESSFUL;
 	}
diff -uNr samba-3.0alpha21.orig/source/passdb/pdb_mysql.c samba-3.0alpha21/source/passdb/pdb_mysql.c
--- samba-3.0alpha21.orig/source/passdb/pdb_mysql.c	2003-02-16 19:06:32.000000000 -0600
+++ samba-3.0alpha21/source/passdb/pdb_mysql.c	2003-02-16 19:05:46.000000000 -0600
@@ -1,4 +1,3 @@
-
 /*
  * MySQL password backend for samba
  * Copyright (C) Jelmer Vernooij 2002
@@ -678,7 +677,7 @@
 	/* I know this is somewhat overkill but only the talloc 
 	 * functions have asprint_append and the 'normal' asprintf 
 	 * is a GNU extension */
-	query.mem_ctx = talloc_init();
+	query.mem_ctx = talloc_init("mysqlsam_replace_sam_account");
 	query.part2 = talloc_asprintf(query.mem_ctx, "%s", "");
 	if (query.update) {
 		query.part1 =
diff -uNr samba-3.0alpha21.orig/source/passdb/pdb_tdb.c samba-3.0alpha21/source/passdb/pdb_tdb.c
--- samba-3.0alpha21.orig/source/passdb/pdb_tdb.c	2003-02-16 19:06:32.000000000 -0600
+++ samba-3.0alpha21/source/passdb/pdb_tdb.c	2003-02-16 19:05:46.000000000 -0600
@@ -529,7 +529,7 @@
 	NTSTATUS nt_status = NT_STATUS_UNSUCCESSFUL;
 	struct tdbsam_privates *tdb_state = (struct tdbsam_privates *)my_methods->private_data;
 	TDB_DATA 	data;
-	char *prefix = USERPREFIX;
+	const char *prefix = USERPREFIX;
 	int  prefixlen = strlen (prefix);
 
 
diff -uNr samba-3.0alpha21.orig/source/passdb/secrets.c samba-3.0alpha21/source/passdb/secrets.c
--- samba-3.0alpha21.orig/source/passdb/secrets.c	2003-02-16 19:06:32.000000000 -0600
+++ samba-3.0alpha21/source/passdb/secrets.c	2003-02-16 19:05:46.000000000 -0600
@@ -240,6 +240,7 @@
 		DEBUG(4,("Using ADS machine password\n"));
 		E_md4hash(plaintext, ret_pwd);
 		SAFE_FREE(plaintext);
+		pass_last_set_time = 0;
 		return True;
 	}
 
@@ -324,7 +325,7 @@
  **/
 
 BOOL secrets_store_trusted_domain_password(const char* domain, smb_ucs2_t *uni_dom_name,
-					   size_t uni_name_len, char* pwd,
+					   size_t uni_name_len, const char* pwd,
 					   DOM_SID sid)
 {
 	struct trusted_dom_pass pass;
@@ -467,12 +468,12 @@
  * @return nt status code of rpc response
  **/ 
 
-NTSTATUS secrets_get_trusted_domains(TALLOC_CTX* ctx, int* enum_ctx, int max_num_domains, int *num_domains, TRUSTDOM ***domains)
+NTSTATUS secrets_get_trusted_domains(TALLOC_CTX* ctx, int* enum_ctx, unsigned int max_num_domains, int *num_domains, TRUSTDOM ***domains)
 {
 	TDB_LIST_NODE *keys, *k;
 	TRUSTDOM *dom = NULL;
 	char *pattern;
-	int start_idx;
+	unsigned int start_idx;
 	uint32 idx = 0;
 	size_t size;
 	fstring dom_name;
@@ -587,17 +588,24 @@
  between smbd instances.
 *******************************************************************************/
 
-BOOL secrets_named_mutex(const char *name, unsigned int timeout)
+BOOL secrets_named_mutex(const char *name, unsigned int timeout, size_t *p_ref_count)
 {
-	int ret;
+	size_t ref_count = *p_ref_count;
+	int ret = 0;
 
 	if (!message_init())
 		return False;
 
-	ret = tdb_lock_bystring(tdb, name, timeout);
-	if (ret == 0)
-		DEBUG(10,("secrets_named_mutex: got mutex for %s\n", name ));
+	if (ref_count == 0) {
+		ret = tdb_lock_bystring(tdb, name, timeout);
+		if (ret == 0)
+			DEBUG(10,("secrets_named_mutex: got mutex for %s\n", name ));
+	}
 
+	if (ret == 0) {
+		*p_ref_count = ++ref_count;
+		DEBUG(10,("secrets_named_mutex: ref_count for mutex %s = %u\n", name, (unsigned int)ref_count ));
+	}
 	return (ret == 0);
 }
 
@@ -605,8 +613,47 @@
  Unlock a named mutex.
 *******************************************************************************/
 
-void secrets_named_mutex_release(const char *name)
+void secrets_named_mutex_release(const char *name, size_t *p_ref_count)
 {
-	tdb_unlock_bystring(tdb, name);
-	DEBUG(10,("secrets_named_mutex: released mutex for %s\n", name ));
+	size_t ref_count = *p_ref_count;
+
+	SMB_ASSERT(ref_count != 0);
+
+	if (ref_count == 1) {
+		tdb_unlock_bystring(tdb, name);
+		DEBUG(10,("secrets_named_mutex: released mutex for %s\n", name ));
+	}
+
+	*p_ref_count = --ref_count;
+	DEBUG(10,("secrets_named_mutex_release: ref_count for mutex %s = %u\n", name, (unsigned int)ref_count ));
 }
+
+/*********************************************************
+ Check to see if we must talk to the PDC to avoid sam 
+ sync delays
+ ********************************************************/
+ 
+BOOL must_use_pdc( const char *domain )
+{
+	time_t	now = time(NULL);
+	time_t  last_change_time;
+	unsigned char	passwd[16];   
+	
+	if ( !secrets_fetch_trust_account_password(domain, passwd, &last_change_time) )
+		return False;
+		
+	/*
+	 * If the time the machine password has changed
+	 * was less than about 15 minutes then we need to contact
+	 * the PDC only, as we cannot be sure domain replication
+	 * has yet taken place. Bug found by Gerald (way to go
+	 * Gerald !). JRA.
+	 */
+	 
+	if ( now - last_change_time < SAM_SYNC_WINDOW )
+		return True;
+		
+	return False;
+
+}
+
diff -uNr samba-3.0alpha21.orig/source/passdb/util_sam_sid.c samba-3.0alpha21/source/passdb/util_sam_sid.c
--- samba-3.0alpha21.orig/source/passdb/util_sam_sid.c	2003-02-16 19:06:32.000000000 -0600
+++ samba-3.0alpha21/source/passdb/util_sam_sid.c	2003-02-16 19:05:46.000000000 -0600
@@ -27,14 +27,14 @@
 typedef struct _known_sid_users {
 	uint32 rid;
 	enum SID_NAME_USE sid_name_use;
-	char *known_user_name;
+	const char *known_user_name;
 } known_sid_users;
 
 static struct sid_name_map_info
 {
 	DOM_SID *sid;
-	char *name;
-	known_sid_users *known_users;
+	const char *name;
+	const known_sid_users *known_users;
 } sid_name_map[MAX_SID_NAMES];
 
 extern DOM_SID global_sid_Builtin; 				/* Local well-known domain */
@@ -46,16 +46,16 @@
 static BOOL sid_name_map_initialized = False;
 /* static known_sid_users no_users[] = {{0, 0, NULL}}; */
 
-static known_sid_users everyone_users[] = {
+static const known_sid_users everyone_users[] = {
 	{ 0, SID_NAME_WKN_GRP, "Everyone" },
 	{0, (enum SID_NAME_USE)0, NULL}};
 
-static known_sid_users creator_owner_users[] = {
+static const known_sid_users creator_owner_users[] = {
 	{ 0, SID_NAME_WKN_GRP, "Creator Owner" },
 	{ 1, SID_NAME_WKN_GRP, "Creator Group" },
 	{0, (enum SID_NAME_USE)0, NULL}};
 
-static known_sid_users nt_authority_users[] = {
+static const known_sid_users nt_authority_users[] = {
 	{  1, SID_NAME_ALIAS, "Dialup" },
 	{  2, SID_NAME_ALIAS, "Network"},
 	{  3, SID_NAME_ALIAS, "Batch"},
@@ -68,7 +68,7 @@
 	{ 18, SID_NAME_ALIAS, "SYSTEM"},
 	{  0, (enum SID_NAME_USE)0, NULL}};
 
-static known_sid_users builtin_groups[] = {
+static const known_sid_users builtin_groups[] = {
 	{ BUILTIN_ALIAS_RID_ADMINS, SID_NAME_ALIAS, "Administrators" },
 	{ BUILTIN_ALIAS_RID_USERS, SID_NAME_ALIAS, "Users" },
 	{ BUILTIN_ALIAS_RID_GUESTS, SID_NAME_ALIAS, "Guests" },
@@ -284,7 +284,7 @@
 		init_sid_name_map();
 
 	for (i=0; sid_name_map[i].sid != NULL; i++) {
-		known_sid_users *users = sid_name_map[i].known_users;
+		const known_sid_users *users = sid_name_map[i].known_users;
 
 		if (users == NULL)
 			continue;
diff -uNr samba-3.0alpha21.orig/source/printing/lpq_parse.c samba-3.0alpha21/source/printing/lpq_parse.c
--- samba-3.0alpha21.orig/source/printing/lpq_parse.c	2003-02-16 19:06:32.000000000 -0600
+++ samba-3.0alpha21/source/printing/lpq_parse.c	2003-02-16 19:05:46.000000000 -0600
@@ -20,7 +20,7 @@
 
 #include "includes.h"
 
-static char *Months[13] = { "Jan", "Feb", "Mar", "Apr", "May", "Jun",
+static const char *Months[13] = { "Jan", "Feb", "Mar", "Apr", "May", "Jun",
 			      "Jul", "Aug", "Sep", "Oct", "Nov", "Dec", "Err"};
 
 
@@ -947,9 +947,9 @@
   return(True);
 }
 
-static char *stat0_strings[] = { "enabled", "online", "idle", "no entries", "free", "ready", NULL };
-static char *stat1_strings[] = { "offline", "disabled", "down", "off", "waiting", "no daemon", NULL };
-static char *stat2_strings[] = { "jam", "paper", "error", "responding", "not accepting", "not running", "turned off", NULL };
+static const char *stat0_strings[] = { "enabled", "online", "idle", "no entries", "free", "ready", NULL };
+static const char *stat1_strings[] = { "offline", "disabled", "down", "off", "waiting", "no daemon", NULL };
+static const char *stat2_strings[] = { "jam", "paper", "error", "responding", "not accepting", "not running", "turned off", NULL };
 
 #ifdef DEVELOPER
 
diff -uNr samba-3.0alpha21.orig/source/printing/notify.c samba-3.0alpha21/source/printing/notify.c
--- samba-3.0alpha21.orig/source/printing/notify.c	2003-02-16 19:06:32.000000000 -0600
+++ samba-3.0alpha21/source/printing/notify.c	2003-02-16 19:05:46.000000000 -0600
@@ -26,11 +26,23 @@
 
 static struct notify_queue {
 	struct notify_queue *next, *prev;
-	char *printername;
-	void *buf;
+	struct spoolss_notify_msg *msg;
+	char *buf;
 	size_t buflen;
 } *notify_queue_head = NULL;
 
+
+static BOOL create_send_ctx(void)
+{
+	if (!send_ctx)
+		send_ctx = talloc_init("print notify queue");
+
+	if (!send_ctx)
+		return False;
+
+	return True;
+}
+
 /****************************************************************************
  Turn a queue name into a snum.
 ****************************************************************************/
@@ -53,10 +65,53 @@
 }
 
 /*******************************************************************
+ Flatten data into a message.
+*******************************************************************/
+
+static BOOL flatten_message(struct notify_queue *q)
+{
+	struct spoolss_notify_msg *msg = q->msg;
+	char *buf = NULL;
+	size_t buflen = 0, len;
+
+again:
+	len = 0;
+
+	/* Pack header */
+
+	len += tdb_pack(buf + len, buflen - len, "f", msg->printer);
+
+	len += tdb_pack(buf + len, buflen - len, "ddddd",
+			msg->type, msg->field, msg->id, msg->len, msg->flags);
+
+	/* Pack data */
+
+	if (msg->len == 0)
+		len += tdb_pack(buf + len, buflen - len, "dd",
+				msg->notify.value[0], msg->notify.value[1]);
+	else
+		len += tdb_pack(buf + len, buflen - len, "B",
+				msg->len, msg->notify.data);
+
+	if (buflen != len) {
+		buf = talloc_realloc(send_ctx, buf, len);
+		if (!buf)
+			return False;
+		buflen = len;
+		goto again;
+	}
+
+	q->buf = buf;
+	q->buflen = buflen;
+
+	return True;
+}
+
+/*******************************************************************
  Send the batched messages - on a per-printer basis.
 *******************************************************************/
 
-static void print_notify_send_messages_to_printer(const char *printer)
+static void print_notify_send_messages_to_printer(const char *printer, unsigned int timeout)
 {
 	char *buf;
 	struct notify_queue *pq, *pq_next;
@@ -67,7 +122,12 @@
 
 	/* Count the space needed to send the messages. */
 	for (pq = notify_queue_head; pq; pq = pq->next) {
-		if (strequal(printer, pq->printername)) {
+		if (strequal(printer, pq->msg->printer)) {
+			if (!flatten_message(pq)) {
+				DEBUG(0,("print_notify_send_messages: Out of memory\n"));
+				talloc_destroy_pool(send_ctx);
+				return;
+			}
 			offset += (pq->buflen + 4);
 			msg_count++;
 		}	
@@ -87,7 +147,7 @@
 	for (pq = notify_queue_head; pq; pq = pq_next) {
 		pq_next = pq->next;
 
-		if (strequal(printer, pq->printername)) {
+		if (strequal(printer, pq->msg->printer)) {
 			SIVAL(buf,offset,pq->buflen);
 			offset += 4;
 			memcpy(buf + offset, pq->buf, pq->buflen);
@@ -109,140 +169,165 @@
 		return;
 
 	for (i = 0; i < num_pids; i++)
-		message_send_pid(pid_list[i], MSG_PRINTER_NOTIFY2, buf, offset, True);
+		message_send_pid_with_timeout(pid_list[i], MSG_PRINTER_NOTIFY2, buf, offset, True, timeout);
 }
 
 /*******************************************************************
  Actually send the batched messages.
 *******************************************************************/
 
-void print_notify_send_messages(void)
+void print_notify_send_messages(unsigned int timeout)
 {
 	if (!print_notify_messages_pending())
 		return;
 
-	if (!send_ctx)
+	if (!create_send_ctx())
 		return;
 
 	while (print_notify_messages_pending())
-		print_notify_send_messages_to_printer(notify_queue_head->printername);
+		print_notify_send_messages_to_printer(notify_queue_head->msg->printer, timeout);
 
 	talloc_destroy_pool(send_ctx);
 }
 
+/**********************************************************************
+ deep copy a SPOOLSS_NOTIFY_MSG structure using a TALLOC_CTX
+ *********************************************************************/
+ 
+static BOOL copy_notify2_msg( SPOOLSS_NOTIFY_MSG *to, SPOOLSS_NOTIFY_MSG *from )
+{
+
+	if ( !to || !from )
+		return False;
+	
+	memcpy( to, from, sizeof(SPOOLSS_NOTIFY_MSG) );
+	
+	if ( from->len ) {
+		to->notify.data = talloc_memdup(send_ctx, from->notify.data, from->len );
+		if ( !to->notify.data ) {
+			DEBUG(0,("copy_notify2_msg: talloc_memdup() of size [%d] failed!\n", from->len ));
+			return False;
+		}
+	}
+	
+
+	return True;
+}
+
 /*******************************************************************
  Batch up print notify messages.
 *******************************************************************/
 
-static void send_spoolss_notify2_msg(struct spoolss_notify_msg *msg)
+static void send_spoolss_notify2_msg(SPOOLSS_NOTIFY_MSG *msg)
 {
-	char *buf = NULL;
-	size_t buflen = 0, len;
 	struct notify_queue *pnqueue, *tmp_ptr;
 
-	/* Let's not waste any time with this */
-
-	if (lp_disable_spoolss())
-		return;
-
-	if (!send_ctx)
-		send_ctx = talloc_init_named("print notify queue");
-
-	if (!send_ctx)
-		goto fail;
-
-	/* Flatten data into a message */
-
-again:
-	len = 0;
-
-	/* Pack header */
-
-	len += tdb_pack(buf + len, buflen - len, "f", msg->printer);
-
-	len += tdb_pack(buf + len, buflen - len, "ddddd",
-			msg->type, msg->field, msg->id, msg->len, msg->flags);
+	/*
+	 * Ensure we only have one message unique to each name/type/field/id/flags
+	 * tuple. There is no point in sending multiple messages that match
+	 * as they will just cause flickering updates in the client.
+	 */
 
-	/* Pack data */
+	for (tmp_ptr = notify_queue_head; tmp_ptr; tmp_ptr = tmp_ptr->next) {
+		if (tmp_ptr->msg->type == msg->type &&
+				tmp_ptr->msg->field == msg->field &&
+				tmp_ptr->msg->id == msg->id &&
+				tmp_ptr->msg->flags == msg->flags &&
+				strequal(tmp_ptr->msg->printer, msg->printer)) {
 
-	if (msg->len == 0)
-		len += tdb_pack(buf + len, buflen - len, "dd",
-				msg->notify.value[0], msg->notify.value[1]);
-	else
-		len += tdb_pack(buf + len, buflen - len, "B",
-				msg->len, msg->notify.data);
+			DEBUG(5, ("send_spoolss_notify2_msg: replacing message 0x%02x/0x%02x for printer %s \
+in notify_queue\n", msg->type, msg->field, msg->printer));
 
-	if (buflen != len) {
-		buf = talloc_realloc(send_ctx, buf, len);
-		if (!buf)
-			goto fail;
-		buflen = len;
-		goto again;
+			tmp_ptr->msg = msg;
+			return;
+		}
 	}
 
 	/* Store the message on the pending queue. */
 
 	pnqueue = talloc(send_ctx, sizeof(*pnqueue));
-	if (!pnqueue)
-		goto fail;
-
-	pnqueue->printername = talloc_strdup(send_ctx, msg->printer);
-	if (!pnqueue->printername)
-		 goto fail;
+	if (!pnqueue) {
+		DEBUG(0,("send_spoolss_notify2_msg: Out of memory.\n"));
+		return;
+	}
 
-	pnqueue->buf = buf;
-	pnqueue->buflen = buflen;
+	/* allocate a new msg structure and copy the fields */
+	
+	if ( !(pnqueue->msg = (SPOOLSS_NOTIFY_MSG*)talloc(send_ctx, sizeof(SPOOLSS_NOTIFY_MSG))) ) {
+		DEBUG(0,("send_spoolss_notify2_msg: talloc() of size [%d] failed!\n", 
+			sizeof(SPOOLSS_NOTIFY_MSG)));
+		return;
+	}
+	copy_notify2_msg(pnqueue->msg, msg);
+	pnqueue->buf = NULL;
+	pnqueue->buflen = 0;
 
 	DEBUG(5, ("send_spoolss_notify2_msg: appending message 0x%02x/0x%02x for printer %s \
 to notify_queue_head\n", msg->type, msg->field, msg->printer));
-		  
-	/* Note we add to the end of the list to ensure
+
+	/*
+	 * Note we add to the end of the list to ensure
 	 * the messages are sent in the order they were received. JRA.
 	 */
-	DLIST_ADD_END(notify_queue_head, pnqueue, tmp_ptr);
-
-	return;
 
-  fail:
-
-	DEBUG(0,("send_spoolss_notify2_msg: Out of memory.\n"));
+	DLIST_ADD_END(notify_queue_head, pnqueue, tmp_ptr);
 }
 
 static void send_notify_field_values(const char *printer_name, uint32 type,
 				     uint32 field, uint32 id, uint32 value1, 
 				     uint32 value2, uint32 flags)
 {
-	struct spoolss_notify_msg msg;
+	struct spoolss_notify_msg *msg;
+
+	if (lp_disable_spoolss())
+		return;
+
+	if (!create_send_ctx())
+		return;
 
-	ZERO_STRUCT(msg);
+	msg = (struct spoolss_notify_msg *)talloc(send_ctx, sizeof(struct spoolss_notify_msg));
+	if (!msg)
+		return;
+
+	ZERO_STRUCTP(msg);
 
-	fstrcpy(msg.printer, printer_name);
-	msg.type = type;
-	msg.field = field;
-	msg.id = id;
-	msg.notify.value[0] = value1;
-	msg.notify.value[1] = value2;
-	msg.flags = flags;
+	fstrcpy(msg->printer, printer_name);
+	msg->type = type;
+	msg->field = field;
+	msg->id = id;
+	msg->notify.value[0] = value1;
+	msg->notify.value[1] = value2;
+	msg->flags = flags;
 
-	send_spoolss_notify2_msg(&msg);
+	send_spoolss_notify2_msg(msg);
 }
 
 static void send_notify_field_buffer(const char *printer_name, uint32 type,
 				     uint32 field, uint32 id, uint32 len,
 				     char *buffer)
 {
-	struct spoolss_notify_msg msg;
+	struct spoolss_notify_msg *msg;
 
-	ZERO_STRUCT(msg);
+	if (lp_disable_spoolss())
+		return;
 
-	fstrcpy(msg.printer, printer_name);
-	msg.type = type;
-	msg.field = field;
-	msg.id = id;
-	msg.len = len;
-	msg.notify.data = buffer;
+	if (!create_send_ctx())
+		return;
+
+	msg = (struct spoolss_notify_msg *)talloc(send_ctx, sizeof(struct spoolss_notify_msg));
+	if (!msg)
+		return;
+
+	ZERO_STRUCTP(msg);
 
-	send_spoolss_notify2_msg(&msg);
+	fstrcpy(msg->printer, printer_name);
+	msg->type = type;
+	msg->field = field;
+	msg->id = id;
+	msg->len = len;
+	msg->notify.data = buffer;
+
+	send_spoolss_notify2_msg(msg);
 }
 
 /* Send a message that the printer status has changed */
@@ -383,7 +468,7 @@
 	if ( snum == -1 )
 		return;
 		
-	send_notify_field_buffer( printername, type, change, snum, strlen(value), value );
+	send_notify_field_buffer( printername, type, change, snum, strlen(value)+1, value );
 } 
 
 
@@ -447,5 +532,3 @@
 	SAFE_FREE(data.dptr);
 	return ret;
 }
-
-
diff -uNr samba-3.0alpha21.orig/source/printing/nt_printing.c samba-3.0alpha21/source/printing/nt_printing.c
--- samba-3.0alpha21.orig/source/printing/nt_printing.c	2003-02-16 19:06:32.000000000 -0600
+++ samba-3.0alpha21/source/printing/nt_printing.c	2003-02-16 19:05:46.000000000 -0600
@@ -77,7 +77,7 @@
 forms it wants and in the ORDER it wants them (note: DEVMODE papersize is an
 array index). Letter is always first, so (for the current code) additions
 always put things in the correct order. */
-static nt_forms_struct default_forms[] = {
+static const nt_forms_struct default_forms[] = {
 	{"Letter",0x1,0x34b5c,0x44368,0x0,0x0,0x34b5c,0x44368},
 	{"Letter Small",0x1,0x34b5c,0x44368,0x0,0x0,0x34b5c,0x44368},
 	{"Tabloid",0x1,0x44368,0x696b8,0x0,0x0,0x44368,0x696b8},
@@ -264,7 +264,7 @@
 BOOL nt_printing_init(void)
 {
 	static pid_t local_pid;
-	char *vstring = "INFO/version";
+	const char *vstring = "INFO/version";
 
 	if (tdb_drivers && tdb_printers && tdb_forms && local_pid == sys_getpid())
 		return True;
@@ -635,7 +635,7 @@
 
 traverse the database and look-up the matching names
 ****************************************************************************/
-int get_ntdrivers(fstring **list, char *architecture, uint32 version)
+int get_ntdrivers(fstring **list, const char *architecture, uint32 version)
 {
 	int total=0;
 	fstring short_archi;
@@ -668,11 +668,11 @@
 function to do the mapping between the long architecture name and
 the short one.
 ****************************************************************************/
-BOOL get_short_archi(char *short_archi, char *long_archi)
+BOOL get_short_archi(char *short_archi, const char *long_archi)
 {
 	struct table {
-		char *long_archi;
-		char *short_archi;
+		const char *long_archi;
+		const char *short_archi;
 	};
 	
 	struct table archi_table[]=
@@ -1585,7 +1585,7 @@
 	int len, buflen;
 	fstring architecture;
 	pstring directory;
-	pstring temp_name;
+	fstring temp_name;
 	pstring key;
 	char *buf;
 	int i, ret;
@@ -1714,7 +1714,7 @@
 
 /****************************************************************************
 ****************************************************************************/
-static WERROR get_a_printer_driver_3_default(NT_PRINTER_DRIVER_INFO_LEVEL_3 **info_ptr, fstring driver, fstring arch)
+static WERROR get_a_printer_driver_3_default(NT_PRINTER_DRIVER_INFO_LEVEL_3 **info_ptr, const char *driver, const char *arch)
 {
 	NT_PRINTER_DRIVER_INFO_LEVEL_3 info;
 
@@ -1741,7 +1741,7 @@
 
 /****************************************************************************
 ****************************************************************************/
-static WERROR get_a_printer_driver_3(NT_PRINTER_DRIVER_INFO_LEVEL_3 **info_ptr, fstring drivername, fstring arch, uint32 version)
+static WERROR get_a_printer_driver_3(NT_PRINTER_DRIVER_INFO_LEVEL_3 **info_ptr, fstring drivername, const char *arch, uint32 version)
 {
 	NT_PRINTER_DRIVER_INFO_LEVEL_3 driver;
 	TDB_DATA kbuf, dbuf;
@@ -2314,7 +2314,7 @@
  allocate and initialize a new slot in 
  ***************************************************************************/
  
-static int add_new_printer_key( NT_PRINTER_DATA *data, char *name )
+static int add_new_printer_key( NT_PRINTER_DATA *data, const char *name )
 {
 	NT_PRINTER_KEY	*d;
 	int		key_index;
@@ -2348,7 +2348,7 @@
  search for a registry key name in the existing printer data
  ***************************************************************************/
  
-int lookup_printerkey( NT_PRINTER_DATA *data, char *name )
+int lookup_printerkey( NT_PRINTER_DATA *data, const char *name )
 {
 	int		key_index = -1;
 	int		i;
@@ -2376,7 +2376,7 @@
 /****************************************************************************
  ***************************************************************************/
 
-uint32 get_printer_subkeys( NT_PRINTER_DATA *data, char* key, fstring **subkeys )
+uint32 get_printer_subkeys( NT_PRINTER_DATA *data, const char* key, fstring **subkeys )
 {
 	int	i, j;
 	int	key_len;
@@ -2442,11 +2442,330 @@
 
 	return num_subkeys;
 }
- 
+
+static void map_sz_into_ctr(REGVAL_CTR *ctr, const char *val_name, 
+			    const char *sz)
+{
+	smb_ucs2_t conv_str[1024];
+	size_t str_size;
+
+	regval_ctr_delvalue(ctr, val_name);
+	str_size = push_ucs2(NULL, conv_str, sz, sizeof(conv_str),
+			     STR_TERMINATE | STR_NOALIGN);
+	regval_ctr_addvalue(ctr, val_name, REG_SZ, 
+			    (char *) conv_str, str_size);
+}
+
+static void map_dword_into_ctr(REGVAL_CTR *ctr, const char *val_name, 
+			       uint32 dword)
+{
+	regval_ctr_delvalue(ctr, val_name);
+	regval_ctr_addvalue(ctr, val_name, REG_DWORD,
+			    (char *) &dword, sizeof(dword));
+}
+
+static void map_bool_into_ctr(REGVAL_CTR *ctr, const char *val_name,
+			      BOOL bool)
+{
+	uint8 bin_bool = (bool ? 1 : 0);
+	regval_ctr_delvalue(ctr, val_name);
+	regval_ctr_addvalue(ctr, val_name, REG_BINARY, 
+			    (char *) &bin_bool, sizeof(bin_bool));
+}
+
+static void map_single_multi_sz_into_ctr(REGVAL_CTR *ctr, const char *val_name,
+					 const char *multi_sz)
+{
+	smb_ucs2_t *conv_strs = NULL;
+	size_t str_size;
+
+	/* a multi-sz has to have a null string terminator, i.e., the last
+	   string must be followed by two nulls */
+	str_size = (strlen(multi_sz) + 2) * sizeof(smb_ucs2_t);
+	conv_strs = calloc(str_size, 1);
+
+	push_ucs2(NULL, conv_strs, multi_sz, str_size, 
+		  STR_TERMINATE | STR_NOALIGN);
+
+	regval_ctr_delvalue(ctr, val_name);
+	regval_ctr_addvalue(ctr, val_name, REG_MULTI_SZ, 
+			    (char *) conv_strs, str_size);	
+	safe_free(conv_strs);
+	
+}
+
+/****************************************************************************
+ * Map the NT_PRINTER_INFO_LEVEL_2 data into DsSpooler keys for publishing.
+ *
+ * @param info2 NT_PRINTER_INFO_LEVEL_2 describing printer - gets modified
+ * @return BOOL indicating success or failure
+ ***************************************************************************/
+
+static BOOL map_nt_printer_info2_to_dsspooler(NT_PRINTER_INFO_LEVEL_2 *info2)
+{
+	REGVAL_CTR *ctr = NULL;
+	fstring longname;
+	char *allocated_string = NULL;
+        const char *ascii_str;
+	int i;
+
+	if ((i = lookup_printerkey(&info2->data, SPOOL_DSSPOOLER_KEY)) < 0)
+		i = add_new_printer_key(&info2->data, SPOOL_DSSPOOLER_KEY);
+	ctr = &info2->data.keys[i].values;
+
+	map_sz_into_ctr(ctr, SPOOL_REG_PRINTERNAME, info2->sharename);
+	map_sz_into_ctr(ctr, SPOOL_REG_SHORTSERVERNAME, global_myname());
+
+	get_myfullname(longname);
+	map_sz_into_ctr(ctr, SPOOL_REG_SERVERNAME, longname);
+
+	asprintf(&allocated_string, "\\\\%s\\%s", longname, info2->sharename);
+	map_sz_into_ctr(ctr, SPOOL_REG_UNCNAME, allocated_string);
+	SAFE_FREE(allocated_string);
+
+	map_dword_into_ctr(ctr, SPOOL_REG_VERSIONNUMBER, 4);
+	map_sz_into_ctr(ctr, SPOOL_REG_DRIVERNAME, info2->drivername);
+	map_sz_into_ctr(ctr, SPOOL_REG_LOCATION, info2->location);
+	map_sz_into_ctr(ctr, SPOOL_REG_DESCRIPTION, info2->comment);
+	map_single_multi_sz_into_ctr(ctr, SPOOL_REG_PORTNAME, info2->portname);
+	map_sz_into_ctr(ctr, SPOOL_REG_PRINTSEPARATORFILE, info2->sepfile);
+	map_dword_into_ctr(ctr, SPOOL_REG_PRINTSTARTTIME, info2->starttime);
+	map_dword_into_ctr(ctr, SPOOL_REG_PRINTENDTIME, info2->untiltime);
+	map_dword_into_ctr(ctr, SPOOL_REG_PRIORITY, info2->priority);
+
+	map_bool_into_ctr(ctr, SPOOL_REG_PRINTKEEPPRINTEDJOBS,
+			  (info2->attributes & 
+			   PRINTER_ATTRIBUTE_KEEPPRINTEDJOBS));
+
+	switch (info2->attributes & 0x3) {
+	case 0:
+		ascii_str = SPOOL_REGVAL_PRINTWHILESPOOLING;
+		break;
+	case 1:
+		ascii_str = SPOOL_REGVAL_PRINTAFTERSPOOLED;
+		break;
+	case 2:
+		ascii_str = SPOOL_REGVAL_PRINTDIRECT;
+		break;
+	default:
+		ascii_str = "unknown";
+	}
+	map_sz_into_ctr(ctr, SPOOL_REG_PRINTSPOOLING, ascii_str);
+
+	return True;
+}
+
+#ifdef HAVE_ADS
+static void store_printer_guid(NT_PRINTER_INFO_LEVEL_2 *info2, GUID guid)
+{
+	int i;
+	REGVAL_CTR *ctr=NULL;
+
+	/* find the DsSpooler key */
+	if ((i = lookup_printerkey(&info2->data, SPOOL_DSSPOOLER_KEY)) < 0)
+		i = add_new_printer_key(&info2->data, SPOOL_DSSPOOLER_KEY);
+	ctr = &info2->data.keys[i].values;
+
+	regval_ctr_delvalue(ctr, "objectGUID");
+	regval_ctr_addvalue(ctr, "objectGUID", REG_BINARY, 
+			    (char *) &guid, sizeof(GUID));	
+}
+
+static WERROR publish_it(NT_PRINTER_INFO_LEVEL *printer)
+{
+	ADS_STATUS ads_rc;
+	TALLOC_CTX *ctx = talloc_init("publish_it");
+	ADS_MODLIST mods = ads_init_mods(ctx);
+	char *prt_dn = NULL, *srv_dn, **srv_cn;
+	void *res = NULL;
+	ADS_STRUCT *ads;
+	const char *attrs[] = {"objectGUID", NULL};
+	GUID guid;
+	WERROR win_rc = WERR_OK;
+
+	ZERO_STRUCT(guid);
+	/* set the DsSpooler info and attributes */
+	if (!(map_nt_printer_info2_to_dsspooler(printer->info_2)))
+			return WERR_NOMEM;
+	printer->info_2->attributes |= PRINTER_ATTRIBUTE_PUBLISHED;
+	win_rc = mod_a_printer(*printer, 2);
+	if (!W_ERROR_IS_OK(win_rc)) {
+		DEBUG(3, ("err %d saving data\n",
+				  W_ERROR_V(win_rc)));
+		return win_rc;
+	}
+
+	/* Build the ads mods */
+	get_local_printer_publishing_data(ctx, &mods, 
+					  &printer->info_2->data);
+	ads_mod_str(ctx, &mods, SPOOL_REG_PRINTERNAME, 
+		    printer->info_2->sharename);
+
+	/* connect to the ADS server */
+	ads = ads_init(NULL, NULL, lp_ads_server());
+	if (!ads) {
+		DEBUG(3, ("ads_init() failed\n"));
+		return WERR_SERVER_UNAVAILABLE;
+	}
+	ads_rc = ads_connect(ads);
+	if (!ADS_ERR_OK(ads_rc)) {
+		DEBUG(3, ("ads_connect failed: %s\n", ads_errstr(ads_rc)));
+		ads_destroy(&ads);
+		return WERR_ACCESS_DENIED;
+	}
+
+	/* figure out where to publish */
+	ads_find_machine_acct(ads, &res, global_myname());
+	srv_dn = ldap_get_dn(ads->ld, res);
+	ads_msgfree(ads, res);
+	srv_cn = ldap_explode_dn(srv_dn, 1);
+	asprintf(&prt_dn, "cn=%s-%s,%s", srv_cn[0], 
+		 printer->info_2->sharename, srv_dn);
+	ads_memfree(ads, srv_dn);
+
+	/* publish it */
+	ads_rc = ads_add_printer_entry(ads, prt_dn, ctx, &mods);
+	if (LDAP_ALREADY_EXISTS == ads_rc.err.rc)
+		ads_rc = ads_mod_printer_entry(ads, prt_dn, ctx,&mods);
+	
+	/* retreive the guid and store it locally */
+	if (ADS_ERR_OK(ads_search_dn(ads, &res, prt_dn, attrs))) {
+		ads_memfree(ads, prt_dn);
+		ads_pull_guid(ads, res, &guid);
+		ads_msgfree(ads, res);
+		store_printer_guid(printer->info_2, guid);
+		win_rc = mod_a_printer(*printer, 2);
+	} 
+
+	safe_free(prt_dn);
+	ads_destroy(&ads);
+
+	return WERR_OK;
+}
+
+WERROR unpublish_it(NT_PRINTER_INFO_LEVEL *printer)
+{
+	ADS_STATUS ads_rc;
+	ADS_STRUCT *ads;
+	void *res;
+	char *prt_dn = NULL;
+	WERROR win_rc;
+
+	printer->info_2->attributes ^= PRINTER_ATTRIBUTE_PUBLISHED;
+	win_rc = mod_a_printer(*printer, 2);
+	if (!W_ERROR_IS_OK(win_rc)) {
+		DEBUG(3, ("err %d saving data\n",
+				  W_ERROR_V(win_rc)));
+		return win_rc;
+	}
+	
+	ads = ads_init(NULL, NULL, lp_ads_server());
+	if (!ads) {
+		DEBUG(3, ("ads_init() failed\n"));
+		return WERR_SERVER_UNAVAILABLE;
+	}
+	ads_rc = ads_connect(ads);
+	if (!ADS_ERR_OK(ads_rc)) {
+		DEBUG(3, ("ads_connect failed: %s\n", ads_errstr(ads_rc)));
+		ads_destroy(&ads);
+		return WERR_ACCESS_DENIED;
+	}
+	
+	/* remove the printer from the directory */
+	ads_rc = ads_find_printer_on_server(ads, &res, 
+			    printer->info_2->sharename, global_myname());
+	if (ADS_ERR_OK(ads_rc) && ads_count_replies(ads, res)) {
+		prt_dn = ads_get_dn(ads, res);
+		ads_msgfree(ads, res);
+		ads_rc = ads_del_dn(ads, prt_dn);
+		ads_memfree(ads, prt_dn);
+	}
+
+	ads_destroy(&ads);
+	return WERR_OK;
+}
+
+/****************************************************************************
+ * Publish a printer in the directory
+ *
+ * @param snum describing printer service
+ * @return WERROR indicating status of publishing
+ ***************************************************************************/
+
+WERROR nt_printer_publish(int snum, int action)
+{
+	NT_PRINTER_INFO_LEVEL *printer = NULL;
+	WERROR win_rc;
+
+	win_rc = get_a_printer(&printer, 2, lp_servicename(snum));
+	if (!W_ERROR_IS_OK(win_rc))
+		return win_rc;
+
+	switch(action) {
+	case SPOOL_DS_PUBLISH:
+	case SPOOL_DS_UPDATE:
+		win_rc = publish_it(printer);
+		break;
+	case SPOOL_DS_UNPUBLISH:
+		win_rc = unpublish_it(printer);
+		break;
+	default:
+		win_rc = WERR_NOT_SUPPORTED;
+	}
+	
+
+	free_a_printer(&printer, 2);
+	return win_rc;
+}
+
+BOOL is_printer_published(int snum, GUID *guid)
+{
+	NT_PRINTER_INFO_LEVEL *printer = NULL;
+	REGVAL_CTR *ctr;
+	REGISTRY_VALUE *guid_val;
+	WERROR win_rc;
+	int i;
+
+
+	win_rc = get_a_printer(&printer, 2, lp_servicename(snum));
+	if (!W_ERROR_IS_OK(win_rc))
+		return False;
+
+	if (!(printer->info_2->attributes & PRINTER_ATTRIBUTE_PUBLISHED))
+		return False;
+
+	if ((i = lookup_printerkey(&printer->info_2->data, 
+				   SPOOL_DSSPOOLER_KEY)) < 0)
+		return False;
+
+	if (!(ctr = &printer->info_2->data.keys[i].values)) {
+		return False;
+	}
+
+	if (!(guid_val = regval_ctr_getvalue(ctr, "objectGUID"))) {
+		return False;
+	}
+
+	if (regval_size(guid_val) == sizeof(GUID))
+		memcpy(guid, regval_data_p(guid_val), sizeof(GUID));
+
+	return True;
+}
+	
+#else
+WERROR nt_printer_publish(int snum, int action)
+{
+	return WERR_OK;
+}
+BOOL is_printer_published(int snum, GUID *guid)
+{
+	return False;
+}
+#endif
 /****************************************************************************
  ***************************************************************************/
  
-WERROR delete_all_printer_data( NT_PRINTER_INFO_LEVEL_2 *p2, char *key )
+WERROR delete_all_printer_data( NT_PRINTER_INFO_LEVEL_2 *p2, const char *key )
 {
 	NT_PRINTER_DATA	*data;
 	int		i;
@@ -2544,7 +2863,7 @@
 /****************************************************************************
  ***************************************************************************/
  
-WERROR delete_printer_data( NT_PRINTER_INFO_LEVEL_2 *p2, char *key, char *value )
+WERROR delete_printer_data( NT_PRINTER_INFO_LEVEL_2 *p2, const char *key, const char *value )
 {
 	WERROR 		result = WERR_OK;
 	int		key_index;
@@ -2571,7 +2890,7 @@
 /****************************************************************************
  ***************************************************************************/
  
-WERROR add_printer_data( NT_PRINTER_INFO_LEVEL_2 *p2, char *key, char *value, 
+WERROR add_printer_data( NT_PRINTER_INFO_LEVEL_2 *p2, const char *key, const char *value, 
                            uint32 type, uint8 *data, int real_len )
 {
 	WERROR 		result = WERR_OK;
@@ -2603,7 +2922,7 @@
 /****************************************************************************
  ***************************************************************************/
  
-REGISTRY_VALUE* get_printer_data( NT_PRINTER_INFO_LEVEL_2 *p2, char *key, char *value )
+REGISTRY_VALUE* get_printer_data( NT_PRINTER_INFO_LEVEL_2 *p2, const char *key, const char *value )
 {
 	int		key_index;
 
@@ -2688,6 +3007,7 @@
 		
 		regval_ctr_addvalue( &printer_data->keys[key_index].values, valuename, type, data_p, size );
 
+		SAFE_FREE(data_p); /* 'B' option to tdb_unpack does a malloc() */
 		DEBUG(8,("specific: [%s:%s], len: %d\n", keyname, valuename, size));
 	}
 
@@ -2812,7 +3132,7 @@
 	fstrcpy(info.printprocessor, "winprint");
 	fstrcpy(info.datatype, "RAW");
 
-	info.attributes = PRINTER_ATTRIBUTE_SHARED | PRINTER_ATTRIBUTE_NETWORK;      /* attributes */
+	info.attributes = PRINTER_ATTRIBUTE_SAMBA;
 
 	info.starttime = 0; /* Minutes since 12:00am GMT */
 	info.untiltime = 0; /* Minutes since 12:00am GMT */
@@ -2904,7 +3224,7 @@
 			info.parameters);
 
 	/* Samba has to have shared raw drivers. */
-	info.attributes |= (PRINTER_ATTRIBUTE_SHARED | PRINTER_ATTRIBUTE_NETWORK); 
+	info.attributes |= PRINTER_ATTRIBUTE_SAMBA;
 
 	/* Restore the stripped strings. */
 	slprintf(info.servername, sizeof(info.servername)-1, "\\\\%s", get_called_name());
@@ -3398,7 +3718,7 @@
 		 * saved to tdb.
 		 */
 
-		if ((ctx = talloc_init()) == NULL)
+		if ((ctx = talloc_init("save_driver_init_2")) == NULL)
 			return WERR_NOMEM;
 
 		if ((nt_devmode = (NT_DEVICEMODE*)malloc(sizeof(NT_DEVICEMODE))) == NULL) {
@@ -3586,7 +3906,7 @@
 /****************************************************************************
 ****************************************************************************/
 WERROR get_a_printer_driver(NT_PRINTER_DRIVER_INFO_LEVEL *driver, uint32 level,
-                            fstring drivername, fstring architecture, uint32 version)
+                            fstring drivername, const char *architecture, uint32 version)
 {
 	WERROR result;
 	
@@ -4082,7 +4402,7 @@
 	fstring key;
 	WERROR status;
 
-	mem_ctx = talloc_init();
+	mem_ctx = talloc_init("nt_printing_setsec");
 	if (mem_ctx == NULL)
 		return WERR_NOMEM;
 
@@ -4240,9 +4560,8 @@
 	fstring key;
 	char *temp;
 
-	if ((temp = strchr(printername + 2, '\\'))) {
+	if (strlen(printername) > 2 && (temp = strchr(printername + 2, '\\')))
 		printername = temp + 1;
-	}
 
 	/* Fetch security descriptor from tdb */
 
@@ -4430,7 +4749,7 @@
 
 	/* Get printer security descriptor */
 
-	if(!(mem_ctx = talloc_init())) {
+	if(!(mem_ctx = talloc_init("print_access_check"))) {
 		errno = ENOMEM;
 		return False;
 	}
diff -uNr samba-3.0alpha21.orig/source/printing/pcap.c samba-3.0alpha21/source/printing/pcap.c
--- samba-3.0alpha21.orig/source/printing/pcap.c	2003-02-16 19:06:32.000000000 -0600
+++ samba-3.0alpha21/source/printing/pcap.c	2003-02-16 19:05:46.000000000 -0600
@@ -62,8 +62,6 @@
 
 #include "includes.h"
 
-#include "smb.h"
-
 #ifdef AIX
 /*  ******************************************
      Extend for AIX system and qconfig file
diff -uNr samba-3.0alpha21.orig/source/printing/print_cups.c samba-3.0alpha21/source/printing/print_cups.c
--- samba-3.0alpha21.orig/source/printing/print_cups.c	2003-02-16 19:06:32.000000000 -0600
+++ samba-3.0alpha21/source/printing/print_cups.c	2003-02-16 19:05:46.000000000 -0600
@@ -1,7 +1,7 @@
 /*
  * Support code for the Common UNIX Printing System ("CUPS")
  *
- * Copyright 1999-2001 by Michael R Sweet.
+ * Copyright 1999-2003 by Michael R Sweet.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -19,7 +19,6 @@
  */
 
 #include "printing.h"
-#include "smb.h"
 
 #ifdef HAVE_CUPS
 #include <cups/cups.h>
@@ -55,15 +54,13 @@
  * 'cups_passwd_cb()' - The CUPS password callback...
  */
 
-const char *				/* O - Password or NULL */
+static const char *				/* O - Password or NULL */
 cups_passwd_cb(const char *prompt)	/* I - Prompt */
 {
  /*
   * Always return NULL to indicate that no password is available...
   */
 
-  (void)prompt;
-
   return (NULL);
 }
 
@@ -197,12 +194,111 @@
  		if (info == NULL || !info[0])
 			(*fn)(name, make_model);
 		else
-			(*fn)(name,info);
+			(*fn)(name, info);
+		
+
+	}
+
+	ippDelete(response);
+
+
+       /*
+	* Build a CUPS_GET_CLASSES request, which requires the following
+	* attributes:
+	*
+	*    attributes-charset
+	*    attributes-natural-language
+	*    requested-attributes
+	*/
+
+	request = ippNew();
+
+	request->request.op.operation_id = CUPS_GET_CLASSES;
+	request->request.op.request_id   = 1;
+
+	language = cupsLangDefault();
+
+	ippAddString(request, IPP_TAG_OPERATION, IPP_TAG_CHARSET,
+                     "attributes-charset", NULL, cupsLangEncoding(language));
+
+	ippAddString(request, IPP_TAG_OPERATION, IPP_TAG_LANGUAGE,
+                     "attributes-natural-language", NULL, language->language);
+
+        ippAddStrings(request, IPP_TAG_OPERATION, IPP_TAG_NAME,
+	              "requested-attributes",
+		      (sizeof(requested) / sizeof(requested[0])),
+		      NULL, requested);
+
+       /*
+	* Do the request and get back a response...
+	*/
+
+	if ((response = cupsDoRequest(http, request, "/")) == NULL)
+	{
+		DEBUG(0,("Unable to get printer list - %s\n",
+			 ippErrorString(cupsLastError())));
+		httpClose(http);
+		return;
+	}
+
+	for (attr = response->attrs; attr != NULL;)
+	{
+	       /*
+		* Skip leading attributes until we hit a printer...
+		*/
+
+		while (attr != NULL && attr->group_tag != IPP_TAG_PRINTER)
+			attr = attr->next;
+
+		if (attr == NULL)
+        		break;
+
+	       /*
+		* Pull the needed attributes from this printer...
+		*/
+
+		name       = NULL;
+		make_model = NULL;
+		info       = NULL;
+
+		while (attr != NULL && attr->group_tag == IPP_TAG_PRINTER)
+		{
+        		if (strcmp(attr->name, "printer-name") == 0 &&
+			    attr->value_tag == IPP_TAG_NAME)
+				name = attr->values[0].string.text;
+
+        		if (strcmp(attr->name, "printer-make-and-model") == 0 &&
+			    attr->value_tag == IPP_TAG_TEXT)
+				make_model = attr->values[0].string.text;
+
+        		if (strcmp(attr->name, "printer-info") == 0 &&
+			    attr->value_tag == IPP_TAG_TEXT)
+				info = attr->values[0].string.text;
+
+        		attr = attr->next;
+		}
+
+	       /*
+		* See if we have everything needed...
+		*/
+
+		if (name == NULL)
+			break;
+
+ 		if (info == NULL || !info[0])
+			(*fn)(name, make_model);
+		else
+			(*fn)(name, info);
 		
 
 	}
 
 	ippDelete(response);
+
+       /*
+        * Close the connection to the server...
+	*/
+
 	httpClose(http);
 }
 
@@ -210,10 +306,10 @@
 /*
  * 'cups_printername_ok()' - Provide the equivalent of pcap_printername_ok()
  *                           for CUPS.
+ * O - 1 if printer name OK
+ * I - Name of printer 
  */
-
-int					/* O - 1 if printer name OK */
-cups_printername_ok(char *name)		/* I - Name of printer */
+int cups_printername_ok(const char *name)
 {
 	http_t		*http;		/* HTTP connection to server */
 	ipp_t		*request,	/* IPP Request */
@@ -236,7 +332,7 @@
 
 	if ((http = httpConnect(cupsServer(), ippPort())) == NULL)
 	{
-		DEBUG(0,("Unable to connect to CUPS server %s - %s\n", 
+		DEBUG(3,("Unable to connect to CUPS server %s - %s\n", 
 			 cupsServer(), strerror(errno)));
 		return (0);
 	}
@@ -278,7 +374,7 @@
 
 	if ((response = cupsDoRequest(http, request, "/")) == NULL)
 	{
-		DEBUG(0,("Unable to get printer status for %s - %s\n", name,
+		DEBUG(3,("Unable to get printer status for %s - %s\n", name,
 			 ippErrorString(cupsLastError())));
 		httpClose(http);
 		return (0);
@@ -288,7 +384,7 @@
 
 	if (response->request.status.status_code >= IPP_OK_CONFLICT)
 	{
-		DEBUG(0,("Unable to get printer status for %s - %s\n", name,
+		DEBUG(3,("Unable to get printer status for %s - %s\n", name,
 			 ippErrorString(response->request.status.status_code)));
 		ippDelete(response);
 		return (0);
@@ -638,6 +734,10 @@
 	ippAddString(request, IPP_TAG_OPERATION, IPP_TAG_NAME, "requesting-user-name",
         	     NULL, pjob->user);
 
+	ippAddString(request, IPP_TAG_OPERATION, IPP_TAG_NAME,
+	             "job-originating-host-name", NULL,
+		     get_remote_machine_name());
+
 	ippAddString(request, IPP_TAG_OPERATION, IPP_TAG_NAME, "job-name", NULL,
         	     pjob->jobname);
 
diff -uNr samba-3.0alpha21.orig/source/printing/print_svid.c samba-3.0alpha21/source/printing/print_svid.c
--- samba-3.0alpha21.orig/source/printing/print_svid.c	2003-02-16 19:06:32.000000000 -0600
+++ samba-3.0alpha21/source/printing/print_svid.c	2003-02-16 19:05:46.000000000 -0600
@@ -33,7 +33,6 @@
 
 
 #include "includes.h"
-#include "smb.h"
 
 #ifdef SYSV
 
diff -uNr samba-3.0alpha21.orig/source/printing/printfsp.c samba-3.0alpha21/source/printing/printfsp.c
--- samba-3.0alpha21.orig/source/printing/printfsp.c	2003-02-16 19:06:32.000000000 -0600
+++ samba-3.0alpha21/source/printing/printfsp.c	2003-02-16 19:05:46.000000000 -0600
@@ -52,8 +52,16 @@
 		return NULL;
 	}
 
+	/* Convert to RAP id. */
+	fsp->rap_print_jobid = pjobid_to_rap(SNUM(conn), jobid);
+	if (fsp->rap_print_jobid == 0) {
+		/* We need to delete the entry in the tdb. */
+		pjob_delete(SNUM(conn), jobid);
+		file_free(fsp);
+		return NULL;
+	}
+
 	/* setup a full fsp */
-	fsp->print_jobid = jobid;
 	fsp->fd = print_job_fd(SNUM(conn),jobid);
 	GetTimeOfDay(&fsp->open_time);
 	fsp->vuid = current_user.vuid;
@@ -69,7 +77,6 @@
 	fsp->sent_oplock_break = NO_BREAK_SENT;
 	fsp->is_directory = False;
 	fsp->directory_delete_on_close = False;
-	fsp->conn = conn;
 	string_set(&fsp->fsp_name,print_job_fname(SNUM(conn),jobid));
 	fsp->wbmpx_ptr = NULL;      
 	fsp->wcp = NULL; 
@@ -88,6 +95,9 @@
 ****************************************************************************/
 void print_fsp_end(files_struct *fsp, BOOL normal_close)
 {
+	uint32 jobid;
+	int snum;
+
 	if (fsp->share_mode == FILE_DELETE_ON_CLOSE) {
 		/*
 		 * Truncate the job. print_job_end will take
@@ -96,9 +106,15 @@
 		sys_ftruncate(fsp->fd, 0);
 	}
 
-	print_job_end(SNUM(fsp->conn),fsp->print_jobid, normal_close);
-
 	if (fsp->fsp_name) {
 		string_free(&fsp->fsp_name);
 	}
+
+	if (!rap_to_pjobid(fsp->rap_print_jobid, &snum, &jobid)) {
+		DEBUG(3,("print_fsp_end: Unable to convert RAP jobid %u to print jobid.\n",
+			(unsigned int)fsp->rap_print_jobid ));
+		return;
+	}
+
+	print_job_end(SNUM(fsp->conn),jobid, normal_close);
 }
diff -uNr samba-3.0alpha21.orig/source/printing/printing.c samba-3.0alpha21/source/printing/printing.c
--- samba-3.0alpha21.orig/source/printing/printing.c	2003-02-16 19:06:32.000000000 -0600
+++ samba-3.0alpha21/source/printing/printing.c	2003-02-16 19:05:46.000000000 -0600
@@ -53,6 +53,8 @@
 	TDB_DATA data, key;
 	char jinfo[8];
 
+	DEBUG(10,("pjobid_to_rap: called.\n"));
+
 	if (!rap_tdb) {
 		/* Create the in-memory tdb. */
 		rap_tdb = tdb_open_log(NULL, 0, TDB_INTERNAL, (O_RDWR|O_CREAT), 0644);
@@ -69,6 +71,9 @@
 	if (data.dptr && data.dsize == sizeof(uint16)) {
 		memcpy(&rap_jobid, data.dptr, sizeof(uint16));
 		SAFE_FREE(data.dptr);
+		DEBUG(10,("pjobid_to_rap: jobid %u maps to RAP jobid %u\n",
+				(unsigned int)jobid,
+				(unsigned int)rap_jobid));
 		return rap_jobid;
 	}
 	SAFE_FREE(data.dptr);
@@ -80,13 +85,18 @@
 	data.dsize = sizeof(rap_jobid);
 	tdb_store(rap_tdb, key, data, TDB_REPLACE);
 	tdb_store(rap_tdb, data, key, TDB_REPLACE);
+
+	DEBUG(10,("pjobid_to_rap: created jobid %u maps to RAP jobid %u\n",
+				(unsigned int)jobid,
+				(unsigned int)rap_jobid));
 	return rap_jobid;
 }
 
 BOOL rap_to_pjobid(uint16 rap_jobid, int *psnum, uint32 *pjobid)
 {
 	TDB_DATA data, key;
-	char jinfo[8];
+
+	DEBUG(10,("rap_to_pjobid called.\n"));
 
 	if (!rap_tdb)
 		return False;
@@ -94,12 +104,18 @@
 	key.dptr = (char *)&rap_jobid;
 	key.dsize = sizeof(rap_jobid);
 	data = tdb_fetch(rap_tdb, key);
-	if (data.dptr && data.dsize == sizeof(jinfo)) {
-		*psnum = IVAL(&jinfo,0);
-		*pjobid = IVAL(&jinfo,4);
+	if (data.dptr && data.dsize == 8) {
+		*psnum = IVAL(data.dptr,0);
+		*pjobid = IVAL(data.dptr,4);
+		DEBUG(10,("rap_to_pjobid: jobid %u maps to RAP jobid %u\n",
+				(unsigned int)*pjobid,
+				(unsigned int)rap_jobid));
 		SAFE_FREE(data.dptr);
 		return True;
 	}
+
+	DEBUG(10,("rap_to_pjobid: Failed to lookup RAP jobid %u\n",
+				(unsigned int)rap_jobid));
 	SAFE_FREE(data.dptr);
 	return False;
 }
@@ -110,6 +126,8 @@
 	uint16 rap_jobid;
 	char jinfo[8];
 
+	DEBUG(10,("rap_jobid_delete: called.\n"));
+
 	if (!rap_tdb)
 		return;
 
@@ -120,10 +138,15 @@
 	key.dsize = sizeof(jinfo);
 	data = tdb_fetch(rap_tdb, key);
 	if (!data.dptr || (data.dsize != sizeof(uint16))) {
+		DEBUG(10,("rap_jobid_delete: cannot find jobid %u\n",
+					(unsigned int)jobid ));
 		SAFE_FREE(data.dptr);
 		return;
 	}
 
+	DEBUG(10,("rap_jobid_delete: deleting jobid %u\n",
+				(unsigned int)jobid ));
+
 	memcpy(&rap_jobid, data.dptr, sizeof(uint16));
 	SAFE_FREE(data.dptr);
 	data.dptr = (char *)&rap_jobid;
@@ -142,7 +165,7 @@
 
 BOOL print_backend_init(void)
 {
-	char *sversion = "INFO/version";
+	const char *sversion = "INFO/version";
 	pstring printing_path;
 	int services = lp_numservices();
 	int snum;
@@ -496,7 +519,7 @@
  Remove a job structure from the database.
 ****************************************************************************/
 
-static void pjob_delete(int snum, uint32 jobid)
+void pjob_delete(int snum, uint32 jobid)
 {
 	struct printjob *pjob = print_job_find(snum, jobid);
 	uint32 job_status = 0;
@@ -587,6 +610,7 @@
 struct traverse_struct {
 	print_queue_struct *queue;
 	int qcount, snum, maxcount, total_jobs;
+	time_t lpq_time;
 };
 
 /****************************************************************************
@@ -651,17 +675,15 @@
 	   completed, so delete the database entry. */
 
 	if (i == ts->qcount) {
-		time_t cur_t = time(NULL);
 
 		/* A race can occur between the time a job is spooled and
 		   when it appears in the lpq output.  This happens when
 		   the job is added to printing.tdb when another smbd
 		   running print_queue_update() has completed a lpq and
 		   is currently traversing the printing tdb and deleting jobs.
-		   A workaround is to not delete the job if it has been 
-		   submitted less than lp_lpqcachetime() seconds ago. */
+		   Don't delete the job if it was submitted after the lpq_time. */
 
-		if ((cur_t - pjob.starttime) > lp_lpqcachetime())
+		if (pjob.starttime < ts->lpq_time)
 			pjob_delete(ts->snum, jobid);
 		else
 			ts->total_jobs++;
@@ -883,6 +905,7 @@
 	tstruct.qcount = qcount;
 	tstruct.snum = snum;
 	tstruct.total_jobs = 0;
+	tstruct.lpq_time = time(NULL);
 
 	tdb_traverse(pdb->tdb, traverse_fn_delete, (void *)&tstruct);
 
@@ -890,7 +913,8 @@
 
 	tdb_store_int32(pdb->tdb, "INFO/total_jobs", tstruct.total_jobs);
 
-	if( qcount != get_queue_status(snum, &old_status))
+	get_queue_status(snum, &old_status);
+	if (old_status.qcount != qcount)
 		DEBUG(10,("print_queue_update: queue status change %d jobs -> %d jobs for printer %s\n",
 					old_status.qcount, qcount, printer_name ));
 
@@ -1268,10 +1292,10 @@
 		*errcode = WERR_ACCESS_DENIED;
 
 		/* BEGIN_ADMIN_LOG */
-		sys_adminlog( LOG_ERR, (char *)
-			 "Permission denied-- user not allowed to delete, \
+		sys_adminlog( LOG_ERR, 
+			      "Permission denied-- user not allowed to delete, \
 pause, or resume print job. User name: %s. Printer name: %s.",
-				uidtoname(user->uid), PRINTERNAME(snum) );
+			      uidtoname(user->uid), PRINTERNAME(snum) );
 		/* END_ADMIN_LOG */
 
 		return False;
@@ -1333,7 +1357,7 @@
 		DEBUG(3, ("pause denied by security descriptor\n"));
 
 		/* BEGIN_ADMIN_LOG */
-		sys_adminlog( LOG_ERR, (char *)
+		sys_adminlog( LOG_ERR, 
 			"Permission denied-- user not allowed to delete, \
 pause, or resume print job. User name: %s. Printer name: %s.",
 				uidtoname(user->uid), PRINTERNAME(snum) );
@@ -1384,7 +1408,7 @@
 		*errcode = WERR_ACCESS_DENIED;
 
 		/* BEGIN_ADMIN_LOG */
-		sys_adminlog( LOG_ERR, (char *)
+		sys_adminlog( LOG_ERR, 
 			 "Permission denied-- user not allowed to delete, \
 pause, or resume print job. User name: %s. Printer name: %s.",
 			uidtoname(user->uid), PRINTERNAME(snum) );
@@ -1481,21 +1505,26 @@
 	TDB_DATA data, key;
 	const char *printername = lp_const_servicename(snum);
 	struct tdb_print_db *pdb = get_print_db_byname(printername);
+	int len;
+
 	if (!pdb)
 		return 0;
 
-	ZERO_STRUCTP(status);
-	slprintf(keystr, sizeof(keystr)-1, "STATUS/%s", printername);
-	key.dptr = keystr;
-	key.dsize = strlen(keystr);
-	data = tdb_fetch(pdb->tdb, key);
-	release_print_db(pdb);
-	if (data.dptr) {
-		if (data.dsize == sizeof(print_status_struct))
-			memcpy(status, data.dptr, sizeof(print_status_struct));
-		SAFE_FREE(data.dptr);
+	if (status) {
+		ZERO_STRUCTP(status);
+		slprintf(keystr, sizeof(keystr)-1, "STATUS/%s", printername);
+		key.dptr = keystr;
+		key.dsize = strlen(keystr);
+		data = tdb_fetch(pdb->tdb, key);
+		if (data.dptr) {
+			if (data.dsize == sizeof(print_status_struct))
+				memcpy(status, data.dptr, sizeof(print_status_struct));
+			SAFE_FREE(data.dptr);
+		}
 	}
-	return status->qcount;
+	len = tdb_fetch_int32(pdb->tdb, "INFO/total_jobs");
+	release_print_db(pdb);
+	return (len == -1 ? 0 : len);
 }
 
 /****************************************************************************
@@ -1514,12 +1543,80 @@
 	/* also fetch the queue status */
 	memset(&status, 0, sizeof(status));
 	len = get_queue_status(snum, &status);
+
 	if (pstatus)
 		*pstatus = status;
+
 	return len;
 }
 
 /***************************************************************************
+ Allocate a jobid. Hold the lock for as short a time as possible.
+***************************************************************************/
+
+static BOOL allocate_print_jobid(struct tdb_print_db *pdb, int snum, const char *printername, uint32 *pjobid)
+{
+	int i;
+	uint32 jobid;
+
+	*pjobid = (uint32)-1;
+
+	for (i = 0; i < 3; i++) {
+		/* Lock the database - only wait 20 seconds. */
+		if (tdb_lock_bystring(pdb->tdb, "INFO/nextjob", 20) == -1) {
+			DEBUG(0,("allocate_print_jobid: failed to lock printing database %s\n", printername ));
+			return False;
+		}
+
+		if (!tdb_fetch_uint32(pdb->tdb, "INFO/nextjob", &jobid)) {
+			if (tdb_error(pdb->tdb) != TDB_ERR_NOEXIST) {
+				DEBUG(0, ("allocate_print_jobid: failed to fetch INFO/nextjob for print queue %s\n",
+						printername ));
+				return False;
+			}
+			jobid = 0;
+		}
+
+		jobid = NEXT_JOBID(jobid);
+
+		if (tdb_store_int32(pdb->tdb, "INFO/nextjob", jobid)==-1) {
+			DEBUG(3, ("allocate_print_jobid: failed to store INFO/nextjob.\n"));
+			tdb_unlock_bystring(pdb->tdb, "INFO/nextjob");
+			return False;
+		}
+
+		/* We've finished with the INFO/nextjob lock. */
+		tdb_unlock_bystring(pdb->tdb, "INFO/nextjob");
+				
+		if (!print_job_exists(snum, jobid))
+			break;
+	}
+
+	if (i > 2) {
+		DEBUG(0, ("allocate_print_jobid: failed to allocate a print job for queue %s\n",
+				printername ));
+		/* Probably full... */
+		errno = ENOSPC;
+		return False;
+	}
+
+	/* Store a dummy placeholder. */
+	{
+		TDB_DATA dum;
+		dum.dptr = NULL;
+		dum.dsize = 0;
+		if (tdb_store(pdb->tdb, print_key(jobid), dum, TDB_INSERT) == -1) {
+			DEBUG(3, ("allocate_print_jobid: jobid (%d) failed to store placeholder.\n",
+				jobid ));
+			return False;
+		}
+	}
+
+	*pjobid = jobid;
+	return True;
+}
+
+/***************************************************************************
  Start spooling a job - return the jobid.
 ***************************************************************************/
 
@@ -1528,12 +1625,10 @@
 	uint32 jobid;
 	char *path;
 	struct printjob pjob;
-	int next_jobid;
 	user_struct *vuser;
-	int njobs = 0;
 	const char *printername = lp_const_servicename(snum);
 	struct tdb_print_db *pdb = get_print_db_byname(printername);
-	BOOL pdb_locked = False;
+	int njobs;
 
 	errno = 0;
 
@@ -1576,60 +1671,18 @@
 
 	/* Insure the maximum queue size is not violated */
 	if ((njobs = print_queue_length(snum,NULL)) > lp_maxprintjobs(snum)) {
-		DEBUG(3, ("print_job_start: number of jobs (%d) larger than max printjobs per queue (%d).\n",
-			njobs, lp_maxprintjobs(snum) ));
+		DEBUG(3, ("print_job_start: Queue %s number of jobs (%d) larger than max printjobs per queue (%d).\n",
+			printername, njobs, lp_maxprintjobs(snum) ));
 		release_print_db(pdb);
 		errno = ENOSPC;
 		return (uint32)-1;
 	}
 
-	/* Lock the database - only wait 20 seconds. */
-	if (tdb_lock_bystring(pdb->tdb, "INFO/nextjob", 20) == -1) {
-		DEBUG(0,("print_job_start: failed to lock printing database %s\n", printername ));
-		release_print_db(pdb);
-		return (uint32)-1;
-	}
-
-	pdb_locked = True;
+	DEBUG(10,("print_job_start: Queue %s number of jobs (%d), max printjobs = %d\n",
+			printername, njobs, lp_maxprintjobs(snum) ));
 
-	next_jobid = tdb_fetch_int32(pdb->tdb, "INFO/nextjob");
-	if (next_jobid == -1)
-		next_jobid = 1;
-
-	for (jobid = NEXT_JOBID(next_jobid); jobid != next_jobid; jobid = NEXT_JOBID(jobid)) {
-		if (!print_job_exists(snum, jobid))
-			break;
-	}
-				
-	if (jobid == next_jobid) {
-		DEBUG(3, ("print_job_start: jobid (%d)==next_jobid(%d).\n",
-				jobid, next_jobid ));
-		jobid = -1;
+	if (!allocate_print_jobid(pdb, snum, printername, &jobid))
 		goto fail;
-	}
-
-	/* Store a dummy placeholder. This must be quick as we have the lock. */
-	{
-		TDB_DATA dum;
-		dum.dptr = NULL;
-		dum.dsize = 0;
-		if (tdb_store(pdb->tdb, print_key(jobid), dum, TDB_INSERT) == -1) {
-			DEBUG(3, ("print_job_start: jobid (%d) failed to store placeholder.\n",
-				jobid ));
-			jobid = -1;
-			goto fail;
-		}
-	}
-
-	if (tdb_store_int32(pdb->tdb, "INFO/nextjob", jobid)==-1) {
-		DEBUG(3, ("print_job_start: failed to store INFO/nextjob.\n"));
-		jobid = -1;
-		goto fail;
-	}
-
-	/* We've finished with the INFO/nextjob lock. */
-	tdb_unlock_bystring(pdb->tdb, "INFO/nextjob");
-	pdb_locked = False;
 
 	/* create the database entry */
 	
@@ -1683,12 +1736,10 @@
 	if (jobid != -1)
 		pjob_delete(snum, jobid);
 
-	if (pdb_locked)
-		tdb_unlock_bystring(pdb->tdb, "INFO/nextjob");
 	release_print_db(pdb);
 
 	DEBUG(3, ("print_job_start: returning fail. Error = %s\n", strerror(errno) ));
-	return -1;
+	return (uint32)-1;
 }
 
 /****************************************************************************
@@ -1884,6 +1935,7 @@
 
 /****************************************************************************
  Get a printer queue listing.
+ set queue = NULL and status = NULL if you just want to update the cache
 ****************************************************************************/
 
 int print_queue_status(int snum, 
@@ -1894,18 +1946,26 @@
 	struct traverse_count_struct tsc;
 	fstring keystr;
 	TDB_DATA data, key;
-	const char *printername = lp_const_servicename(snum);
-	struct tdb_print_db *pdb = get_print_db_byname(printername);
-
-	*queue = NULL;
-	
-	if (!pdb)
-		return 0;
+	const char *printername;
+	struct tdb_print_db *pdb;
 
 	/* make sure the database is up to date */
+
 	if (print_cache_expired(snum))
 		print_queue_update(snum);
 
+	/* return if we are done */
+
+	if ( !queue || !status )
+		return 0;
+
+	*queue = NULL;
+	printername = lp_const_servicename(snum);
+	pdb = get_print_db_byname(printername);
+
+	if (!pdb)
+		return 0;
+
 	/*
 	 * Fetch the queue status.  We must do this first, as there may
 	 * be no jobs in the queue.
diff -uNr samba-3.0alpha21.orig/source/printing/printing_db.c samba-3.0alpha21/source/printing/printing_db.c
--- samba-3.0alpha21.orig/source/printing/printing_db.c	2003-02-16 19:06:32.000000000 -0600
+++ samba-3.0alpha21/source/printing/printing_db.c	2003-02-16 19:05:46.000000000 -0600
@@ -95,7 +95,7 @@
 		done_become_root = True;
 	}
 
-	p->tdb = tdb_open_log(printdb_path, 0, TDB_DEFAULT, O_RDWR|O_CREAT, 0600);
+	p->tdb = tdb_open_log(printdb_path, 5000, TDB_DEFAULT, O_RDWR|O_CREAT, 0600);
 
 	if (done_become_root)
 		unbecome_root();
diff -uNr samba-3.0alpha21.orig/source/python/py_common.c samba-3.0alpha21/source/python/py_common.c
--- samba-3.0alpha21.orig/source/python/py_common.c	2003-02-16 19:06:32.000000000 -0600
+++ samba-3.0alpha21/source/python/py_common.c	2003-02-16 19:05:46.000000000 -0600
@@ -45,9 +45,6 @@
 
 void py_samba_init(void)
 {
-	extern pstring global_myname;
-	char *p;
-
 	if (initialised)
 		return;
 
@@ -59,11 +56,7 @@
 	/* Misc other stuff */
 
 	load_interfaces();
-	
-	fstrcpy(global_myname, myhostname());
-	p = strchr(global_myname, '.');
-	if (p)
-		*p = 0;
+	init_names();
 
 	initialised = True;
 }
diff -uNr samba-3.0alpha21.orig/source/python/py_conv.c samba-3.0alpha21/source/python/py_conv.c
--- samba-3.0alpha21.orig/source/python/py_conv.c	2003-02-16 19:06:32.000000000 -0600
+++ samba-3.0alpha21/source/python/py_conv.c	2003-02-16 19:05:46.000000000 -0600
@@ -42,12 +42,12 @@
 		switch (conv[i].type) {
 		case PY_UNISTR: {
 			UNISTR *u = (UNISTR *)((char *)s + conv[i].offset);
-			fstring s = "";
+			fstring str = "";
 
 			if (u->buffer)
-				fstr_pull(s, u);
+				fstr_pull(str, u);
 
-			item = PyString_FromString(s);
+			item = PyString_FromString(str);
 			PyDict_SetItemString(obj, conv[i].name, item);
 
 			break;
@@ -122,13 +122,13 @@
 		switch (conv[i].type) {
 		case PY_UNISTR: {
 			UNISTR *u = (UNISTR *)((char *)s + conv[i].offset);
-			char *s = "";
+			char *str = "";
 
 			if (!PyString_Check(obj))
 				goto done;
 
-			s = PyString_AsString(obj);
-			init_unistr(u, s);
+			str = PyString_AsString(obj);
+			init_unistr(u, str);
 			
 			break;
 		}
diff -uNr samba-3.0alpha21.orig/source/python/py_conv.h samba-3.0alpha21/source/python/py_conv.h
--- samba-3.0alpha21.orig/source/python/py_conv.h	2003-02-16 19:06:32.000000000 -0600
+++ samba-3.0alpha21/source/python/py_conv.h	2003-02-16 19:05:46.000000000 -0600
@@ -31,6 +31,7 @@
 
 PyObject *from_struct(void *s, struct pyconv *conv);
 BOOL to_struct(void *s, PyObject *dict, struct pyconv *conv);
+PyObject *from_unistr_list(uint16 *dependentfiles);
 
 /* Another version of offsetof (-: */
 
diff -uNr samba-3.0alpha21.orig/source/python/py_lsa.c samba-3.0alpha21/source/python/py_lsa.c
--- samba-3.0alpha21.orig/source/python/py_lsa.c	2003-02-16 19:06:32.000000000 -0600
+++ samba-3.0alpha21/source/python/py_lsa.c	2003-02-16 19:05:46.000000000 -0600
@@ -84,7 +84,7 @@
 		return NULL;
 	}
 
-	if (!(mem_ctx = talloc_init())) {
+	if (!(mem_ctx = talloc_init("lsa_open_policy"))) {
 		PyErr_SetString(lsa_error, "unable to init talloc context\n");
 		goto done;
 	}
diff -uNr samba-3.0alpha21.orig/source/python/py_samr.c samba-3.0alpha21/source/python/py_samr.c
--- samba-3.0alpha21.orig/source/python/py_samr.c	2003-02-16 19:06:32.000000000 -0600
+++ samba-3.0alpha21/source/python/py_samr.c	2003-02-16 19:05:46.000000000 -0600
@@ -73,7 +73,7 @@
 		return NULL;
 	}
 
-	if (!(mem_ctx = talloc_init())) {
+	if (!(mem_ctx = talloc_init("samr_open_domain"))) {
 		PyErr_SetString(samr_error, "unable to init talloc context");
 		return NULL;
 	}
@@ -167,7 +167,7 @@
 		    args, kw, "", kwlist))
 		return NULL;
 
-	if (!(mem_ctx = talloc_init())) {
+	if (!(mem_ctx = talloc_init("samr_enum_dom_groups"))) {
 		PyErr_SetString(samr_error, "unable to init talloc context");
 		return NULL;
 	}
@@ -399,7 +399,7 @@
 		return NULL;
 	}
 
-	if (!(mem_ctx = talloc_init())) {
+	if (!(mem_ctx = talloc_init("samr_connect"))) {
 		PyErr_SetString(samr_ntstatus,
 				"unable to init talloc context\n");
 		goto done;
diff -uNr samba-3.0alpha21.orig/source/python/py_smb.c samba-3.0alpha21/source/python/py_smb.c
--- samba-3.0alpha21.orig/source/python/py_smb.c	2003-02-16 19:06:32.000000000 -0600
+++ samba-3.0alpha21/source/python/py_smb.c	2003-02-16 19:05:46.000000000 -0600
@@ -61,7 +61,6 @@
 	static char *kwlist[] = { "called", "calling", NULL };
 	char *calling_name = NULL, *called_name;
 	struct nmb_name calling, called;
-	extern pstring global_myname;
 	BOOL result;
 
 	if (!PyArg_ParseTupleAndKeywords(args, kw, "s|s", kwlist, &called_name, 
@@ -69,7 +68,7 @@
 		return NULL;
 
 	if (!calling_name)
-		calling_name = global_myname;
+		calling_name = global_myname();
 
 	make_nmb_name(&calling, calling_name, 0x00);
 	make_nmb_name(&called, called_name, 0x20);
@@ -233,7 +232,7 @@
 		    args, kw, "i", kwlist, &fnum))
 		return NULL;
 
-	mem_ctx = talloc_init();
+	mem_ctx = talloc_init("py_smb_query_secdesc");
 
 	secdesc = cli_query_secdesc(cli->cli, fnum, mem_ctx);
 
@@ -270,7 +269,7 @@
 	static char *kwlist[] = { "fnum", "security_descriptor", NULL };
 	PyObject *py_secdesc;
 	SEC_DESC *secdesc;
-	TALLOC_CTX *mem_ctx = talloc_init();
+	TALLOC_CTX *mem_ctx = talloc_init("py_smb_set_secdesc");
 	int fnum;
 	BOOL result;
 
diff -uNr samba-3.0alpha21.orig/source/python/py_spoolss_drivers.c samba-3.0alpha21/source/python/py_spoolss_drivers.c
--- samba-3.0alpha21.orig/source/python/py_spoolss_drivers.c	2003-02-16 19:06:32.000000000 -0600
+++ samba-3.0alpha21/source/python/py_spoolss_drivers.c	2003-02-16 19:05:46.000000000 -0600
@@ -63,7 +63,7 @@
 		goto done;
 	}
 
-	if (!(mem_ctx = talloc_init())) {
+	if (!(mem_ctx = talloc_init("spoolss_enumprinterdrivers"))) {
 		PyErr_SetString(
 			spoolss_error, "unable to init talloc context\n");
 		goto done;
@@ -267,7 +267,7 @@
 		goto done;
 	}
 	
-	if (!(mem_ctx = talloc_init())) {
+	if (!(mem_ctx = talloc_init("spoolss_getprinterdriverdir"))) {
 		PyErr_SetString(
 			spoolss_error, "unable to init talloc context\n");
 		goto done;
@@ -335,7 +335,7 @@
 		return NULL;
 	}
 
-	if (!(mem_ctx = talloc_init())) {
+	if (!(mem_ctx = talloc_init("spoolss_addprinterdriver"))) {
 		PyErr_SetString(
 			spoolss_error, "unable to init talloc context\n");
 		return NULL;
diff -uNr samba-3.0alpha21.orig/source/python/py_spoolss_ports.c samba-3.0alpha21/source/python/py_spoolss_ports.c
--- samba-3.0alpha21.orig/source/python/py_spoolss_ports.c	2003-02-16 19:06:32.000000000 -0600
+++ samba-3.0alpha21/source/python/py_spoolss_ports.c	2003-02-16 19:05:46.000000000 -0600
@@ -59,7 +59,7 @@
 		goto done;
 	}
 
-	if (!(mem_ctx = talloc_init())) {
+	if (!(mem_ctx = talloc_init("spoolss_enumports"))) {
 		PyErr_SetString(
 			spoolss_error, "unable to init talloc context\n");
 		goto done;
diff -uNr samba-3.0alpha21.orig/source/python/py_spoolss_printers.c samba-3.0alpha21/source/python/py_spoolss_printers.c
--- samba-3.0alpha21.orig/source/python/py_spoolss_printers.c	2003-02-16 19:06:32.000000000 -0600
+++ samba-3.0alpha21/source/python/py_spoolss_printers.c	2003-02-16 19:05:46.000000000 -0600
@@ -62,7 +62,7 @@
 		goto done;
 	}
 
-	if (!(mem_ctx = talloc_init())) {
+	if (!(mem_ctx = talloc_init("spoolss_openprinter"))) {
 		PyErr_SetString(spoolss_error, 
 				"unable to init talloc context\n");
 		goto done;
@@ -310,7 +310,7 @@
 		goto done;
 	}
 
-	if (!(mem_ctx = talloc_init())) {
+	if (!(mem_ctx = talloc_init("spoolss_enumprinters"))) {
 		PyErr_SetString(
 			spoolss_error, "unable to init talloc context\n");
 		goto done;
@@ -353,9 +353,9 @@
 
 		for (i = 0; i < num_printers; i++) {
 			PyObject *value;
-			fstring name;
+			fstring s;
 
-			rpcstr_pull(name, ctr.printers_0[i].printername.buffer,
+			rpcstr_pull(s, ctr.printers_0[i].printername.buffer,
 				    sizeof(fstring), -1, STR_TERMINATE);
 
 			py_from_PRINTER_INFO_0(&value, &ctr.printers_0[i]);
@@ -363,7 +363,7 @@
 			PyDict_SetItemString(
 				value, "level", PyInt_FromLong(0));
 
-			PyDict_SetItemString(result, name, value);
+			PyDict_SetItemString(result, s, value);
 		}
 
 		break;
@@ -372,9 +372,9 @@
 
 		for(i = 0; i < num_printers; i++) {
 			PyObject *value;
-			fstring name;
+			fstring s;
 
-			rpcstr_pull(name, ctr.printers_1[i].name.buffer,
+			rpcstr_pull(s, ctr.printers_1[i].name.buffer,
 				    sizeof(fstring), -1, STR_TERMINATE);
 
 			py_from_PRINTER_INFO_1(&value, &ctr.printers_1[i]);
@@ -382,7 +382,7 @@
 			PyDict_SetItemString(
 				value, "level", PyInt_FromLong(1));
 
-			PyDict_SetItemString(result, name, value);
+			PyDict_SetItemString(result, s, value);
 		}
 		
 		break;
@@ -391,9 +391,9 @@
 
 		for(i = 0; i < num_printers; i++) {
 			PyObject *value;
-			fstring name;
+			fstring s;
 
-			rpcstr_pull(name, ctr.printers_2[i].printername.buffer,
+			rpcstr_pull(s, ctr.printers_2[i].printername.buffer,
 				    sizeof(fstring), -1, STR_TERMINATE);
 
 			py_from_PRINTER_INFO_2(&value, &ctr.printers_2[i]);
@@ -401,7 +401,7 @@
 			PyDict_SetItemString(
 				value, "level", PyInt_FromLong(2));
 
-			PyDict_SetItemString(result, name, value);
+			PyDict_SetItemString(result, s, value);
 		}
 		
 		break;
@@ -445,7 +445,7 @@
 		goto done;
 	}
 
-	if (!(mem_ctx = talloc_init())) {
+	if (!(mem_ctx = talloc_init("spoolss_addprinterex"))) {
 		PyErr_SetString(
 			spoolss_error, "unable to init talloc context\n");
 		goto done;
diff -uNr samba-3.0alpha21.orig/source/python/py_spoolss_printers_conv.c samba-3.0alpha21/source/python/py_spoolss_printers_conv.c
--- samba-3.0alpha21.orig/source/python/py_spoolss_printers_conv.c	2003-02-16 19:06:32.000000000 -0600
+++ samba-3.0alpha21/source/python/py_spoolss_printers_conv.c	2003-02-16 19:05:46.000000000 -0600
@@ -217,10 +217,8 @@
 	PyObject *obj, *dict_copy = PyDict_Copy(dict);
 	BOOL result = False;
 
-	if (!(obj = PyDict_GetItemString(dict_copy, "level")))
-		goto done;
-
-	if (!PyInt_Check(obj))
+	if (!(obj = PyDict_GetItemString(dict_copy, "level")) ||
+	    !PyInt_Check(obj))
 		goto done;
 
 	PyDict_DelItemString(dict_copy, "level");
@@ -272,25 +270,25 @@
 	PyObject *obj, *dict_copy = PyDict_Copy(dict);
 	BOOL result = False;
 
-	/* Convert security descriptor */
+	/* Convert security descriptor - may be NULL */
 
-	if (!(obj = PyDict_GetItemString(dict_copy, "security_descriptor")))
-		goto done;
+	info->secdesc = NULL;
 
-	if (!PyDict_Check(obj))
-		goto done;
+	if ((obj = PyDict_GetItemString(dict_copy, "security_descriptor"))) {
 
-	if (!py_to_SECDESC(&info->secdesc, obj, mem_ctx))
-		goto done;
+		if (!PyDict_Check(obj))
+			goto done;
 
-	PyDict_DelItemString(dict_copy, "security_descriptor");
+		if (!py_to_SECDESC(&info->secdesc, obj, mem_ctx))
+			goto done;
 
-	/* Convert device mode */
+		PyDict_DelItemString(dict_copy, "security_descriptor");
+	}
 
-	if (!(obj = PyDict_GetItemString(dict_copy, "device_mode")))
-		goto done;
+	/* Convert device mode */
 
-	if (!PyDict_Check(obj))
+	if (!(obj = PyDict_GetItemString(dict_copy, "device_mode"))
+	    || !PyDict_Check(obj))
 		goto done;
 
 	info->devmode = talloc(mem_ctx, sizeof(DEVICEMODE));
@@ -300,6 +298,14 @@
 
 	PyDict_DelItemString(dict_copy, "device_mode");
 
+	/* Check info level */
+
+	if (!(obj = PyDict_GetItemString(dict_copy, "level")) ||
+	    !PyInt_Check(obj))
+		goto done;
+
+	PyDict_DelItemString(dict_copy, "level");
+
 	/* Convert remaining elements of dictionary */
 
 	if (!to_struct(info, dict_copy, py_PRINTER_INFO_2))
diff -uNr samba-3.0alpha21.orig/source/python/py_tdbpack.c samba-3.0alpha21/source/python/py_tdbpack.c
--- samba-3.0alpha21.orig/source/python/py_tdbpack.c	2003-02-16 19:06:32.000000000 -0600
+++ samba-3.0alpha21/source/python/py_tdbpack.c	2003-02-16 19:05:46.000000000 -0600
@@ -23,12 +23,23 @@
    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
 
+#include "Python.h"
 
+/* This module is supposed to be standalone, however for portability
+   it would be good to use the FUNCTION_MACRO preprocessor define. */
 
-#include "Python.h"
+#include "include/config.h"
+
+#ifdef HAVE_FUNCTION_MACRO
+#define FUNCTION_MACRO  (__FUNCTION__)
+#else
+#define FUNCTION_MACRO  (__FILE__)
+#endif
 
 static PyObject * pytdbpack_number(char ch, PyObject *val_iter, PyObject *packed_list);
-static PyObject * pytdbpack_str_850(PyObject *val_iter, PyObject *packed_list);
+static PyObject * pytdbpack_str(char ch,
+				PyObject *val_iter, PyObject *packed_list,
+				const char *encoding);
 static PyObject * pytdbpack_buffer(PyObject *val_iter, PyObject *packed_list);
 
 static PyObject *pytdbunpack_item(char, char **pbuf, int *plen, PyObject *);
@@ -37,6 +48,9 @@
 				     PyObject *val_seq,
 				     PyObject *val_list);
 
+static PyObject *
+pytdbunpack_string(char **pbuf, int *plen, const char *encoding);
+
 static void pack_le_uint32(unsigned long val_long, unsigned char *pbuf);
 
 
@@ -58,19 +72,17 @@
 Python strings are used to specify the format of data to be packed or
 unpacked.
 
-Strings are always stored in codepage 850.  Unicode objects are translated
-to cp850; plain strings are assumed to be in latin-1 and are also
-translated.
-
-This may be a problem in the future if it is different to the Samba codepage.
-It might be better to have the caller do the conversion, but that would conflict
-with existing CMI code.
+String encodings are implied by the database format: they may be either DOS
+codepage (currently hardcoded to 850), or Unix codepage (currently hardcoded
+to be the same as the default Python encoding).
 
 tdbpack format strings:
 
-    'f':  NULL-terminated string in codepage 850
+    'f': NUL-terminated string in codepage iso8859-1
+   
+    'P': same as 'f'
 
-    'P':  same as 'f'
+    'F': NUL-terminated string in iso-8859-1
 
     'd':  4 byte little-endian unsigned number
 
@@ -145,7 +157,11 @@
 ";
 
 
-const char *pytdb_string_encoding = "cp850";
+const char *pytdb_dos_encoding = "cp850";
+
+/* NULL, meaning that the Samba default encoding *must* be the same as the
+   Python default encoding. */
+const char *pytdb_unix_encoding = NULL;
 
 
 /*
@@ -228,7 +244,7 @@
 
 		case 'f':
 		case 'P':
-			if (!(packed_list = pytdbpack_str_850(val_iter, packed_list)))
+			if (!(packed_list = pytdbpack_str(ch, val_iter, packed_list, pytdb_unix_encoding)))
 				return NULL;
 			break;
 
@@ -240,7 +256,7 @@
 		default:
 			PyErr_Format(PyExc_ValueError,
 				     "%s: format character '%c' is not supported",
-				     __FUNCTION__, ch);
+				     FUNCTION_MACRO, ch);
 			return NULL;
 		}
 	}
@@ -287,27 +303,29 @@
 
 
 /*
- * Take one string from the iterator val_iter, convert it to 8-bit CP850, and
- * return it.
+ * Take one string from the iterator val_iter, convert it to 8-bit, and return
+ * it.
  *
  * If the input is neither a string nor Unicode, an exception is raised.
  *
- * If the input is Unicode, then it is converted to CP850.
+ * If the input is Unicode, then it is converted to the appropriate encoding.
  *
- * If the input is a String, then it is converted to Unicode using the default
- * decoding method, and then converted to CP850.  This in effect gives
- * conversion from latin-1 (currently the PSA's default) to CP850, without
- * needing a custom translation table.
+ * If the input is a String, and encoding is not null, then it is converted to
+ * Unicode using the default decoding method, and then converted to the
+ * encoding.  If the encoding is NULL, then the string is written out as-is --
+ * this is used when the default Python encoding is the same as the Samba
+ * encoding.
  *
  * I hope this approach avoids being too fragile w.r.t. being passed either
  * Unicode or String objects.
  */
 static PyObject *
-pytdbpack_str_850(PyObject *val_iter, PyObject *packed_list)
+pytdbpack_str(char ch,
+	      PyObject *val_iter, PyObject *packed_list, const char *encoding)
 {
 	PyObject *val_obj = NULL;
 	PyObject *unicode_obj = NULL;
-	PyObject *cp850_str = NULL;
+	PyObject *coded_str = NULL;
 	PyObject *nul_str = NULL;
 	PyObject *new_list = NULL;
 
@@ -315,31 +333,41 @@
 		goto out;
 
 	if (PyUnicode_Check(val_obj)) {
-		unicode_obj = val_obj;
+		if (!(coded_str = PyUnicode_AsEncodedString(val_obj, encoding, NULL)))
+			goto out;
 	}
-	else {
-		/* string */
+	else if (PyString_Check(val_obj) && !encoding) {
+		/* For efficiency, we assume that the Python interpreter has
+		   the same default string encoding as Samba's native string
+		   encoding.  On the PSA, both are always 8859-1. */
+		coded_str = val_obj;
+		Py_INCREF(coded_str);
+	}
+	else if (PyString_Check(val_obj)) {
+		/* String, but needs to be converted */
 		if (!(unicode_obj = PyString_AsDecodedObject(val_obj, NULL, NULL)))
 			goto out;
-		Py_XDECREF(val_obj);
-		val_obj = NULL;
+		if (!(coded_str = PyUnicode_AsEncodedString(unicode_obj, encoding, NULL)))
+			goto out;
 	}
-
-	if (!(cp850_str = PyUnicode_AsEncodedString(unicode_obj, pytdb_string_encoding, NULL)))
+	else {
+		pytdbpack_bad_type(ch, "String or Unicode", val_obj);
 		goto out;
+	}
 
 	if (!nul_str)
 		/* this is constant and often-used; hold it forever */
 		if (!(nul_str = PyString_FromStringAndSize("", 1)))
 			goto out;
 
-	if ((PyList_Append(packed_list, cp850_str) != -1)
+	if ((PyList_Append(packed_list, coded_str) != -1)
 	    && (PyList_Append(packed_list, nul_str) != -1))
 		new_list = packed_list;
 
   out:
+	Py_XDECREF(val_obj);
 	Py_XDECREF(unicode_obj);
-	Py_XDECREF(cp850_str);
+	Py_XDECREF(coded_str);
 
 	return new_list;
 }
@@ -361,7 +389,8 @@
 	if (!(packed_list = pytdbpack_number('d', val_iter, packed_list)))
 		return NULL;
 
-	/* this assumes that the string is the right length; the old code did the same. */
+	/* this assumes that the string is the right length; the old code did
+	   the same. */
 	if (!(val_obj = PyIter_Next(val_iter)))
 		return NULL;
 
@@ -457,7 +486,7 @@
 		if (i == 0) {
 			PyErr_Format(PyExc_ValueError,
 				     "%s: '$' may not be first character in format",
-				     __FUNCTION__);
+				     FUNCTION_MACRO);
 			return NULL;
 		} 
 		while (packed_len > 0)
@@ -491,7 +520,7 @@
 pytdbunpack_err_too_short(void)
 {
 	PyErr_Format(PyExc_IndexError,
-		     __FUNCTION__ ": data too short for unpack format");
+		     "%s: data too short for unpack format", FUNCTION_MACRO);
 }
 
 
@@ -537,7 +566,7 @@
 
 
 static PyObject *
-pytdbunpack_string(char **pbuf, int *plen)
+pytdbunpack_string(char **pbuf, int *plen, const char *encoding)
 {
 	int len;
 	char *nul_ptr, *start;
@@ -555,7 +584,7 @@
 	*pbuf += len + 1;	/* skip \0 */
 	*plen -= len + 1;
 
-	return PyString_Decode(start, len, pytdb_string_encoding, NULL);
+	return PyString_Decode(start, len, encoding, NULL);
 }
 
 
@@ -578,7 +607,7 @@
 
 	if (slen < 0) { /* surely you jest */
 		PyErr_Format(PyExc_ValueError,
-			     __FUNCTION__ ": buffer seems to have negative length");
+			     "%s: buffer seems to have negative length", FUNCTION_MACRO);
 		return NULL;
 	}
 
@@ -588,8 +617,8 @@
 
 	if (*plen < slen) {
 		PyErr_Format(PyExc_IndexError,
-			     __FUNCTION__ ": not enough data to unpack buffer: "
-			     "need %d bytes, have %d",
+			     "%s: not enough data to unpack buffer: "
+			     "need %d bytes, have %d", FUNCTION_MACRO,
 			     (int) slen, *plen);
 		return NULL;
 	}
@@ -627,38 +656,43 @@
    Returns a reference to None, or NULL for failure.
 */
 static PyObject *pytdbunpack_item(char ch,
-				       char **pbuf,
-				       int *plen,
-				       PyObject *val_list)
+				  char **pbuf,
+				  int *plen,
+				  PyObject *val_list)
 {
-	PyObject *result;
+	PyObject *unpacked;
 	
 	if (ch == 'w') {	/* 16-bit int */
-		result = pytdbunpack_int16(pbuf, plen);
+		unpacked = pytdbunpack_int16(pbuf, plen);
 	}
 	else if (ch == 'd' || ch == 'p') { /* 32-bit int */
 		/* pointers can just come through as integers */
-		result = pytdbunpack_uint32(pbuf, plen);
+		unpacked = pytdbunpack_uint32(pbuf, plen);
 	}
 	else if (ch == 'f' || ch == 'P') { /* nul-term string  */
-		result = pytdbunpack_string(pbuf, plen);
+		unpacked = pytdbunpack_string(pbuf, plen, pytdb_unix_encoding);
 	}
 	else if (ch == 'B') { /* length, buffer */
 		return pytdbunpack_buffer(pbuf, plen, val_list);
 	}
 	else {
 		PyErr_Format(PyExc_ValueError,
-			     __FUNCTION__ ": format character '%c' is not supported",
-			     ch);
+			     "%s: format character '%c' is not supported", 
+                             FUNCTION_MACRO, ch);
 		
 		return NULL;
 	}
 
 	/* otherwise OK */
-	if (!result)
-		return NULL;
-	if (PyList_Append(val_list, result) == -1)
+	if (!unpacked)
 		return NULL;
+
+	if (PyList_Append(val_list, unpacked) == -1)
+		val_list = NULL;
+
+	/* PyList_Append takes a new reference to the inserted object.
+	   Therefore, we no longer need the original reference. */
+	Py_DECREF(unpacked);
 	
 	return val_list;
 }
diff -uNr samba-3.0alpha21.orig/source/python/py_winbind.c samba-3.0alpha21/source/python/py_winbind.c
--- samba-3.0alpha21.orig/source/python/py_winbind.c	2003-02-16 19:06:32.000000000 -0600
+++ samba-3.0alpha21/source/python/py_winbind.c	2003-02-16 19:05:46.000000000 -0600
@@ -412,13 +412,18 @@
 
 /* Challenge/response authentication */
 
-static PyObject *py_auth_crap(PyObject *self, PyObject *args)
+static PyObject *py_auth_crap(PyObject *self, PyObject *args, PyObject *kw)
 {
+	static char *kwlist[] = 
+		{"username", "password", "use_lm_hash", "use_nt_hash", NULL };
 	struct winbindd_request request;
 	struct winbindd_response response;
 	char *username, *password;
+	int use_lm_hash = 1, use_nt_hash = 1;
 
-	if (!PyArg_ParseTuple(args, "ss", &username, &password))
+	if (!PyArg_ParseTupleAndKeywords(
+		    args, kw, "ss|ii", kwlist, &username, &password, 
+		    &use_lm_hash, &use_nt_hash))
 		return NULL;
 
 	ZERO_STRUCT(request);
@@ -428,13 +433,17 @@
 
 	generate_random_buffer(request.data.auth_crap.chal, 8, False);
         
-        SMBencrypt((uchar *)password, request.data.auth_crap.chal, 
-                   (uchar *)request.data.auth_crap.lm_resp);
-        SMBNTencrypt((uchar *)password, request.data.auth_crap.chal,
-                     (uchar *)request.data.auth_crap.nt_resp);
+	if (use_lm_hash) {
+		SMBencrypt((uchar *)password, request.data.auth_crap.chal, 
+			   (uchar *)request.data.auth_crap.lm_resp);
+		request.data.auth_crap.lm_resp_len = 24;
+	}
 
-        request.data.auth_crap.lm_resp_len = 24;
-        request.data.auth_crap.nt_resp_len = 24;
+	if (use_nt_hash) {
+		SMBNTencrypt((uchar *)password, request.data.auth_crap.chal,
+			     (uchar *)request.data.auth_crap.nt_resp);
+		request.data.auth_crap.nt_resp_len = 24;
+	}
 
 	if (winbindd_request(WINBINDD_PAM_AUTH_CRAP, &request, &response) 
 	    != NSS_STATUS_SUCCESS) {
diff -uNr samba-3.0alpha21.orig/source/python/setup.py samba-3.0alpha21/source/python/setup.py
--- samba-3.0alpha21.orig/source/python/setup.py	2003-02-16 19:06:32.000000000 -0600
+++ samba-3.0alpha21/source/python/setup.py	2003-02-16 19:05:46.000000000 -0600
@@ -179,6 +179,7 @@
     # tdbpack/unpack extensions.  Does not actually link to any Samba
     # code, although it implements a compatible data format.
     Extension(name = "tdbpack",
-              sources = [os.path.join(samba_srcdir, "python", "py_tdbpack.c")]),
+              sources = [os.path.join(samba_srcdir, "python", "py_tdbpack.c")],
+              extra_compile_args = ["-I."])
     ],
 )
diff -uNr samba-3.0alpha21.orig/source/registry/reg_objects.c samba-3.0alpha21/source/registry/reg_objects.c
--- samba-3.0alpha21.orig/source/registry/reg_objects.c	2003-02-16 19:06:32.000000000 -0600
+++ samba-3.0alpha21/source/registry/reg_objects.c	2003-02-16 19:05:46.000000000 -0600
@@ -33,14 +33,14 @@
 void regsubkey_ctr_init( REGSUBKEY_CTR *ctr )
 {
 	if ( !ctr->ctx )
-		ctr->ctx = talloc_init();
+		ctr->ctx = talloc_init("regsubkey_ctr_init for ctr %p", ctr);
 }
 
 /***********************************************************************
  Add a new key to the array
  **********************************************************************/
 
-int regsubkey_ctr_addkey( REGSUBKEY_CTR *ctr, char *keyname )
+int regsubkey_ctr_addkey( REGSUBKEY_CTR *ctr, const char *keyname )
 {
 	uint32 len;
 	char **pp;
@@ -114,7 +114,7 @@
 void regval_ctr_init( REGVAL_CTR *ctr )
 {
 	if ( !ctr->ctx )
-		ctr->ctx = talloc_init();
+		ctr->ctx = talloc_init("regval_ctr_init for ctr %p", ctr);
 }
 
 /***********************************************************************
@@ -234,8 +234,8 @@
  Add a new registry value to the array
  **********************************************************************/
 
-int regval_ctr_addvalue( REGVAL_CTR *ctr, char *name, uint16 type, 
-                         char *data_p, size_t size )
+int regval_ctr_addvalue( REGVAL_CTR *ctr, const char *name, uint16 type, 
+                         const char *data_p, size_t size )
 {
 	REGISTRY_VALUE **ppreg;
 	
@@ -308,11 +308,13 @@
  No need to free memory since it is talloc'd.
  **********************************************************************/
 
-int regval_ctr_delvalue( REGVAL_CTR *ctr, char *name )
+int regval_ctr_delvalue( REGVAL_CTR *ctr, const char *name )
 {
 	int 	i;
 	
 	/* search for the value */
+	if (!(ctr->num_values))
+		return 0;
 	
 	for ( i=0; i<ctr->num_values; i++ ) {
 		if ( strcmp( ctr->values[i]->valuename, name ) == 0)
@@ -343,7 +345,7 @@
  No need to free memory since it is talloc'd.
  **********************************************************************/
 
-REGISTRY_VALUE* regval_ctr_getvalue( REGVAL_CTR *ctr, char *name )
+REGISTRY_VALUE* regval_ctr_getvalue( REGVAL_CTR *ctr, const char *name )
 {
 	int 	i;
 	
diff -uNr samba-3.0alpha21.orig/source/registry/reg_printing.c samba-3.0alpha21/source/registry/reg_printing.c
--- samba-3.0alpha21.orig/source/registry/reg_printing.c	2003-02-16 19:06:32.000000000 -0600
+++ samba-3.0alpha21/source/registry/reg_printing.c	2003-02-16 19:05:46.000000000 -0600
@@ -84,7 +84,7 @@
  
 static int print_subpath_environments( char *key, REGSUBKEY_CTR *subkeys )
 {
-	char *environments[] = {
+	const char *environments[] = {
 		"Windows 4.0",
 		"Windows NT x86",
 		"Windows NT R4000",
diff -uNr samba-3.0alpha21.orig/source/rpc_client/cli_lsarpc.c samba-3.0alpha21/source/rpc_client/cli_lsarpc.c
--- samba-3.0alpha21.orig/source/rpc_client/cli_lsarpc.c	2003-02-16 19:06:32.000000000 -0600
+++ samba-3.0alpha21/source/rpc_client/cli_lsarpc.c	2003-02-16 19:05:46.000000000 -0600
@@ -1150,6 +1150,148 @@
 	return result;
 }
 
+
+/* Enumerate account rights This is similar to enum_privileges but
+   takes a SID directly, avoiding the open_account call.
+*/
+
+NTSTATUS cli_lsa_enum_account_rights(struct cli_state *cli, TALLOC_CTX *mem_ctx,
+				     POLICY_HND *pol, DOM_SID sid,
+				     uint32 *count, char ***privs_name)
+{
+	prs_struct qbuf, rbuf;
+	LSA_Q_ENUM_ACCT_RIGHTS q;
+	LSA_R_ENUM_ACCT_RIGHTS r;
+	NTSTATUS result;
+	int i;
+
+	ZERO_STRUCT(q);
+	ZERO_STRUCT(r);
+
+	/* Initialise parse structures */
+
+	prs_init(&qbuf, MAX_PDU_FRAG_LEN, mem_ctx, MARSHALL);
+	prs_init(&rbuf, 0, mem_ctx, UNMARSHALL);
+
+	/* Marshall data and send request */
+	init_q_enum_acct_rights(&q, pol, 2, &sid);
+
+	if (!lsa_io_q_enum_acct_rights("", &q, &qbuf, 0) ||
+	    !rpc_api_pipe_req(cli, LSA_ENUMACCTRIGHTS, &qbuf, &rbuf)) {
+		result = NT_STATUS_UNSUCCESSFUL;
+		goto done;
+	}
+
+	if (!lsa_io_r_enum_acct_rights("", &r, &rbuf, 0)) {
+		result = NT_STATUS_UNSUCCESSFUL;
+		goto done;
+	}
+
+	if (!NT_STATUS_IS_OK(result = r.status)) {
+		goto done;
+	}
+
+	*count = r.count;
+	if (! *count) {
+		goto done;
+	}
+
+	*privs_name = (char **)talloc(mem_ctx, (*count) * sizeof(char **));
+	for (i=0;i<*count;i++) {
+		pull_ucs2_talloc(mem_ctx, &(*privs_name)[i], r.rights.strings[i].string.buffer);
+	}
+
+done:
+
+	return result;
+}
+
+
+
+/* add account rights to an account. */
+
+NTSTATUS cli_lsa_add_account_rights(struct cli_state *cli, TALLOC_CTX *mem_ctx,
+				    POLICY_HND *pol, DOM_SID sid,
+				    uint32 count, const char **privs_name)
+{
+	prs_struct qbuf, rbuf;
+	LSA_Q_ADD_ACCT_RIGHTS q;
+	LSA_R_ADD_ACCT_RIGHTS r;
+	NTSTATUS result;
+
+	ZERO_STRUCT(q);
+
+	/* Initialise parse structures */
+	prs_init(&qbuf, MAX_PDU_FRAG_LEN, mem_ctx, MARSHALL);
+	prs_init(&rbuf, 0, mem_ctx, UNMARSHALL);
+
+	/* Marshall data and send request */
+	init_q_add_acct_rights(&q, pol, &sid, count, privs_name);
+
+	if (!lsa_io_q_add_acct_rights("", &q, &qbuf, 0) ||
+	    !rpc_api_pipe_req(cli, LSA_ADDACCTRIGHTS, &qbuf, &rbuf)) {
+		result = NT_STATUS_UNSUCCESSFUL;
+		goto done;
+	}
+
+	/* Unmarshall response */
+
+	if (!lsa_io_r_add_acct_rights("", &r, &rbuf, 0)) {
+		result = NT_STATUS_UNSUCCESSFUL;
+		goto done;
+	}
+
+	if (!NT_STATUS_IS_OK(result = r.status)) {
+		goto done;
+	}
+done:
+
+	return result;
+}
+
+
+/* remove account rights for an account. */
+
+NTSTATUS cli_lsa_remove_account_rights(struct cli_state *cli, TALLOC_CTX *mem_ctx,
+				       POLICY_HND *pol, DOM_SID sid, BOOL removeall,
+				       uint32 count, const char **privs_name)
+{
+	prs_struct qbuf, rbuf;
+	LSA_Q_REMOVE_ACCT_RIGHTS q;
+	LSA_R_REMOVE_ACCT_RIGHTS r;
+	NTSTATUS result;
+
+	ZERO_STRUCT(q);
+
+	/* Initialise parse structures */
+	prs_init(&qbuf, MAX_PDU_FRAG_LEN, mem_ctx, MARSHALL);
+	prs_init(&rbuf, 0, mem_ctx, UNMARSHALL);
+
+	/* Marshall data and send request */
+	init_q_remove_acct_rights(&q, pol, &sid, removeall?1:0, count, privs_name);
+
+	if (!lsa_io_q_remove_acct_rights("", &q, &qbuf, 0) ||
+	    !rpc_api_pipe_req(cli, LSA_REMOVEACCTRIGHTS, &qbuf, &rbuf)) {
+		result = NT_STATUS_UNSUCCESSFUL;
+		goto done;
+	}
+
+	/* Unmarshall response */
+
+	if (!lsa_io_r_remove_acct_rights("", &r, &rbuf, 0)) {
+		result = NT_STATUS_UNSUCCESSFUL;
+		goto done;
+	}
+
+	if (!NT_STATUS_IS_OK(result = r.status)) {
+		goto done;
+	}
+done:
+
+	return result;
+}
+
+
 #if 0
 
 /** An example of how to use the routines in this file.  Fetch a DOMAIN
diff -uNr samba-3.0alpha21.orig/source/rpc_client/cli_pipe.c samba-3.0alpha21/source/rpc_client/cli_pipe.c
--- samba-3.0alpha21.orig/source/rpc_client/cli_pipe.c	2003-02-16 19:06:32.000000000 -0600
+++ samba-3.0alpha21/source/rpc_client/cli_pipe.c	2003-02-16 19:05:46.000000000 -0600
@@ -844,7 +844,7 @@
 		uint32 data_len, send_size;
 		uint8 flags = 0;
 		uint32 crc32 = 0;
-		uint32 callid;
+		uint32 callid = 0;
 
 		/*
 		 * how much will we send this time
@@ -862,10 +862,9 @@
 			return False;
 		}
 
-		if (data_left == prs_offset(data)) {
+		if (data_left == prs_offset(data))
 			flags |= RPC_FLG_FIRST;
-			callid = 0;
-		}
+
 		if (data_left < max_data)
 			flags |= RPC_FLG_LAST;
 		/*
@@ -1007,7 +1006,7 @@
  check the rpc bind acknowledge response
 ****************************************************************************/
 
-char* get_pipe_name_from_index( const int pipe_index )
+const char* get_pipe_name_from_index( const int pipe_index )
 {
 
 	if ( (pipe_index < 0) || (pipe_index >= PI_MAX_PIPES) )
@@ -1267,16 +1266,6 @@
 }
 
 /****************************************************************************
- Set ntlmssp negotiation flags.
- ****************************************************************************/
-
-void cli_nt_set_ntlmssp_flgs(struct cli_state *cli, uint32 ntlmssp_flgs)
-{
-	cli->ntlmssp_cli_flgs = ntlmssp_flgs;
-}
-
-
-/****************************************************************************
  Open a session.
  ****************************************************************************/
 
@@ -1284,6 +1273,9 @@
 {
 	int fnum;
 
+	/* At the moment we can't have more than one pipe open over
+           a cli connection. )-: */
+
 	SMB_ASSERT(cli->nt_pipe_fnum == 0);
 	
 	/* The pipe index must fall within our array */
diff -uNr samba-3.0alpha21.orig/source/rpc_client/cli_reg.c samba-3.0alpha21/source/rpc_client/cli_reg.c
--- samba-3.0alpha21.orig/source/rpc_client/cli_reg.c	2003-02-16 19:06:32.000000000 -0600
+++ samba-3.0alpha21/source/rpc_client/cli_reg.c	2003-02-16 19:05:46.000000000 -0600
@@ -28,7 +28,8 @@
 /* Shutdown a server */
 
 NTSTATUS cli_reg_shutdown(struct cli_state * cli, TALLOC_CTX *mem_ctx,
-                          const char *msg, uint32 timeout, uint16 flags)
+                          const char *msg, uint32 timeout, BOOL do_reboot,
+			  BOOL force)
 {
 	prs_struct qbuf;
 	prs_struct rbuf; 
@@ -46,7 +47,7 @@
 
 	/* Marshall data and send request */
 
-	init_reg_q_shutdown(&q_s, msg, timeout, flags);
+	init_reg_q_shutdown(&q_s, msg, timeout, do_reboot, force);
 
 	if (!reg_io_q_shutdown("", &q_s, &qbuf, 0) ||
 	    !rpc_api_pipe_req(cli, REG_SHUTDOWN, &qbuf, &rbuf))
diff -uNr samba-3.0alpha21.orig/source/rpc_client/cli_samr.c samba-3.0alpha21/source/rpc_client/cli_samr.c
--- samba-3.0alpha21.orig/source/rpc_client/cli_samr.c	2003-02-16 19:06:32.000000000 -0600
+++ samba-3.0alpha21/source/rpc_client/cli_samr.c	2003-02-16 19:05:46.000000000 -0600
@@ -358,7 +358,7 @@
 
 NTSTATUS cli_samr_query_groupinfo(struct cli_state *cli, TALLOC_CTX *mem_ctx,
                                   POLICY_HND *group_pol, uint32 info_level, 
-                                  GROUP_INFO_CTR *ctr)
+                                  GROUP_INFO_CTR **ctr)
 {
 	prs_struct qbuf, rbuf;
 	SAMR_Q_QUERY_GROUPINFO q;
@@ -383,11 +383,11 @@
 
 	/* Unmarshall response */
 
-	r.ctr = ctr;
-
 	if (!samr_io_r_query_groupinfo("", &r, &rbuf, 0))
 		goto done;
 
+	*ctr = r.ctr;
+
 	/* Return output parameters */
 
 	result = r.status;
@@ -961,12 +961,45 @@
 	return result;
 }
 
+/* This function returns the bizzare set of (max_entries, max_size) required
+   for the QueryDisplayInfo RPC to actually work against a domain controller
+   with large (10k and higher) numbers of users.  These values were 
+   obtained by inspection using ethereal and NT4 running User Manager. */
+
+void get_query_dispinfo_params(int loop_count, uint32 *max_entries,
+			       uint32 *max_size)
+{
+	switch(loop_count) {
+	case 0:
+		*max_entries = 512;
+		*max_size = 16383;
+		break;
+	case 1:
+		*max_entries = 1024;
+		*max_size = 32766;
+		break;
+	case 2:
+		*max_entries = 2048;
+		*max_size = 65532;
+		break;
+	case 3:
+		*max_entries = 4096;
+		*max_size = 131064;
+		break;
+	default:              /* loop_count >= 4 */
+		*max_entries = 4096;
+		*max_size = 131071;
+		break;
+	}
+}		     
+
 /* Query display info */
 
 NTSTATUS cli_samr_query_dispinfo(struct cli_state *cli, TALLOC_CTX *mem_ctx, 
                                  POLICY_HND *domain_pol, uint32 *start_idx,
                                  uint16 switch_value, uint32 *num_entries,
-                                 uint32 max_entries, SAM_DISPINFO_CTR *ctr)
+                                 uint32 max_entries, uint32 max_size,
+				 SAM_DISPINFO_CTR *ctr)
 {
 	prs_struct qbuf, rbuf;
 	SAMR_Q_QUERY_DISPINFO q;
@@ -984,7 +1017,7 @@
 	/* Marshall data and send request */
 
 	init_samr_q_query_dispinfo(&q, domain_pol, switch_value,
-				   *start_idx, max_entries);
+				   *start_idx, max_entries, max_size);
 
 	if (!samr_io_q_query_dispinfo("", &q, &qbuf, 0) ||
 	    !rpc_api_pipe_req(cli, SAMR_QUERY_DISPINFO, &qbuf, &rbuf)) {
diff -uNr samba-3.0alpha21.orig/source/rpc_client/cli_spoolss.c samba-3.0alpha21/source/rpc_client/cli_spoolss.c
--- samba-3.0alpha21.orig/source/rpc_client/cli_spoolss.c	2003-02-16 19:06:32.000000000 -0600
+++ samba-3.0alpha21/source/rpc_client/cli_spoolss.c	2003-02-16 19:05:46.000000000 -0600
@@ -58,7 +58,7 @@
         inf=(PRINTER_INFO_0 *)talloc(mem_ctx, returned*sizeof(PRINTER_INFO_0));
 	memset(inf, 0, returned*sizeof(PRINTER_INFO_0));
 
-        buffer->prs.data_offset=0;
+	prs_set_offset(&buffer->prs,0);
 
         for (i=0; i<returned; i++) {
                 smb_io_printer_info_0("", buffer, &inf[i], 0);
@@ -78,7 +78,7 @@
         inf=(PRINTER_INFO_1 *)talloc(mem_ctx, returned*sizeof(PRINTER_INFO_1));
 	memset(inf, 0, returned*sizeof(PRINTER_INFO_1));
 
-        buffer->prs.data_offset=0;
+	prs_set_offset(&buffer->prs,0);
 
         for (i=0; i<returned; i++) {
                 smb_io_printer_info_1("", buffer, &inf[i], 0);
@@ -98,7 +98,7 @@
         inf=(PRINTER_INFO_2 *)talloc(mem_ctx, returned*sizeof(PRINTER_INFO_2));
 	memset(inf, 0, returned*sizeof(PRINTER_INFO_2));
 
-        buffer->prs.data_offset=0;
+	prs_set_offset(&buffer->prs,0);
 
         for (i=0; i<returned; i++) {
 		/* a little initialization as we go */
@@ -120,7 +120,7 @@
         inf=(PRINTER_INFO_3 *)talloc(mem_ctx, returned*sizeof(PRINTER_INFO_3));
 	memset(inf, 0, returned*sizeof(PRINTER_INFO_3));
 
-        buffer->prs.data_offset=0;
+	prs_set_offset(&buffer->prs,0);
 
         for (i=0; i<returned; i++) {
 		inf[i].secdesc = NULL;
@@ -181,7 +181,7 @@
         inf=(DRIVER_INFO_1 *)talloc(mem_ctx, returned*sizeof(DRIVER_INFO_1));
 	memset(inf, 0, returned*sizeof(DRIVER_INFO_1));
 
-        buffer->prs.data_offset=0;
+	prs_set_offset(&buffer->prs,0);
 
         for (i=0; i<returned; i++) {
                 smb_io_printer_driver_info_1("", buffer, &(inf[i]), 0);
@@ -201,7 +201,7 @@
         inf=(DRIVER_INFO_2 *)talloc(mem_ctx, returned*sizeof(DRIVER_INFO_2));
 	memset(inf, 0, returned*sizeof(DRIVER_INFO_2));
 
-        buffer->prs.data_offset=0;
+	prs_set_offset(&buffer->prs,0);
 
         for (i=0; i<returned; i++) {
                 smb_io_printer_driver_info_2("", buffer, &(inf[i]), 0);
@@ -221,7 +221,7 @@
         inf=(DRIVER_INFO_3 *)talloc(mem_ctx, returned*sizeof(DRIVER_INFO_3));
 	memset(inf, 0, returned*sizeof(DRIVER_INFO_3));
 
-        buffer->prs.data_offset=0;
+	prs_set_offset(&buffer->prs,0);
 
         for (i=0; i<returned; i++) {
                 smb_io_printer_driver_info_3("", buffer, &(inf[i]), 0);
@@ -275,8 +275,8 @@
  ********************************************************************************/
 
 WERROR cli_spoolss_open_printer_ex(struct cli_state *cli, TALLOC_CTX *mem_ctx,
-				char *printername, char *datatype, uint32 access_required,
-				char *station, char *username, POLICY_HND *pol)
+				const char *printername, const char *datatype, uint32 access_required,
+				const char *station, const char *username, POLICY_HND *pol)
 {
 	prs_struct qbuf, rbuf;
 	SPOOL_Q_OPEN_PRINTER_EX q;
@@ -720,7 +720,7 @@
 				    TALLOC_CTX *mem_ctx, 
 				    uint32 offered, uint32 *needed,
 				    POLICY_HND *pol, uint32 level, 
-				    char *env, PRINTER_DRIVER_CTR *ctr)
+				    const char *env, PRINTER_DRIVER_CTR *ctr)
 {
 	prs_struct qbuf, rbuf;
 	SPOOL_Q_GETPRINTERDRIVER2 q;
@@ -799,7 +799,7 @@
 WERROR cli_spoolss_enumprinterdrivers (struct cli_state *cli, 
 				       TALLOC_CTX *mem_ctx,
 				       uint32 offered, uint32 *needed,
-				       uint32 level, char *env,
+				       uint32 level, const char *env,
 				       uint32 *num_drivers,
 				       PRINTER_DRIVER_CTR *ctr)
 {
@@ -1067,8 +1067,8 @@
  * the driver files
  */
 WERROR cli_spoolss_deleteprinterdriver (struct cli_state *cli, 
-					TALLOC_CTX *mem_ctx, char *arch,
-					char *driver)
+					TALLOC_CTX *mem_ctx, const char *arch,
+					const char *driver)
 {
 	prs_struct 			qbuf, rbuf;
 	SPOOL_Q_DELETEPRINTERDRIVER	q;
@@ -1424,7 +1424,7 @@
 	int i;
 
 	*forms = (FORM_1 *)talloc(mem_ctx, num_forms * sizeof(FORM_1));
-	buffer->prs.data_offset = 0;
+	prs_set_offset(&buffer->prs,0);
 
 	for (i = 0; i < num_forms; i++)
 		smb_io_form_1("", buffer, &((*forms)[i]), 0);
@@ -1506,7 +1506,7 @@
 	uint32 i;
 
 	*jobs = (JOB_INFO_1 *)talloc(mem_ctx, num_jobs * sizeof(JOB_INFO_1));
-	buffer->prs.data_offset = 0;
+	prs_set_offset(&buffer->prs,0);
 
 	for (i = 0; i < num_jobs; i++) 
 		smb_io_job_info_1("", buffer, &((*jobs)[i]), 0);
@@ -1518,7 +1518,7 @@
 	uint32 i;
 
 	*jobs = (JOB_INFO_2 *)talloc(mem_ctx, num_jobs * sizeof(JOB_INFO_2));
-	buffer->prs.data_offset = 0;
+	prs_set_offset(&buffer->prs,0);
 
 	for (i = 0; i < num_jobs; i++) 
 		smb_io_job_info_2("", buffer, &((*jobs)[i]), 0);
@@ -2163,7 +2163,7 @@
 
 WERROR cli_spoolss_enumprinterdataex(struct cli_state *cli, TALLOC_CTX *mem_ctx,
 				     uint32 offered, uint32 *needed,
-				     POLICY_HND *hnd, char *keyname, 
+				     POLICY_HND *hnd, const char *keyname, 
 				     REGVAL_CTR *ctr)
 {
 	prs_struct qbuf, rbuf;
@@ -2364,7 +2364,7 @@
 
 WERROR cli_spoolss_enumprinterkey(struct cli_state *cli, TALLOC_CTX *mem_ctx,
 				  uint32 offered, uint32 *needed,
-				  POLICY_HND *hnd, char *keyname,
+				  POLICY_HND *hnd, const char *keyname,
 				  uint16 **keylist, uint32 *len)
 {
 	prs_struct qbuf, rbuf;
diff -uNr samba-3.0alpha21.orig/source/rpc_client/cli_spoolss_notify.c samba-3.0alpha21/source/rpc_client/cli_spoolss_notify.c
--- samba-3.0alpha21.orig/source/rpc_client/cli_spoolss_notify.c	2003-02-16 19:06:32.000000000 -0600
+++ samba-3.0alpha21/source/rpc_client/cli_spoolss_notify.c	2003-02-16 19:05:46.000000000 -0600
@@ -212,6 +212,8 @@
 
 	if (r.unknown0 == 0x00080000)
 		DEBUG(8,("cli_spoolss_reply_rrpcn: I think the spooler resonded that the notification was ignored.\n"));
+	else if ( r.unknown0 != 0x0 )
+		DEBUG(8,("cli_spoolss_reply_rrpcn: unknown0 is non-zero [0x%x]\n", r.unknown0));
 	
 	result = r.status;
 
diff -uNr samba-3.0alpha21.orig/source/rpc_parse/parse_dfs.c samba-3.0alpha21/source/rpc_parse/parse_dfs.c
--- samba-3.0alpha21.orig/source/rpc_parse/parse_dfs.c	2003-02-16 19:06:32.000000000 -0600
+++ samba-3.0alpha21/source/rpc_parse/parse_dfs.c	2003-02-16 19:05:46.000000000 -0600
@@ -41,7 +41,7 @@
  Read/write a DFS_Q_DFS_EXIST structure - dummy...
  ************************************************************/
 
-BOOL dfs_io_q_dfs_exist(char *desc, DFS_Q_DFS_EXIST *q_d, prs_struct *ps, int depth)
+BOOL dfs_io_q_dfs_exist(const char *desc, DFS_Q_DFS_EXIST *q_d, prs_struct *ps, int depth)
 {
 	if(q_d == NULL)
 		return False;
@@ -55,7 +55,7 @@
  Read/write a DFS_R_DFS_EXIST structure
  ************************************************************/
 
-BOOL dfs_io_r_dfs_exist(char *desc, DFS_R_DFS_EXIST *q_d, prs_struct *ps, int depth)
+BOOL dfs_io_r_dfs_exist(const char *desc, DFS_R_DFS_EXIST *q_d, prs_struct *ps, int depth)
 {
 	if(q_d == NULL)
 		return False;
@@ -91,7 +91,7 @@
 Read/write a DFS_Q_DFS_REMOVE structure
 *******************************************************************/
 
-BOOL dfs_io_q_dfs_remove(char *desc, DFS_Q_DFS_REMOVE *q_d, prs_struct *ps, int depth)
+BOOL dfs_io_q_dfs_remove(const char *desc, DFS_Q_DFS_REMOVE *q_d, prs_struct *ps, int depth)
 {
 	if(q_d == NULL)
 		return False;
@@ -131,7 +131,7 @@
 Read/write a DFS_R_DFS_REMOVE structure
 *******************************************************************/
 
-BOOL dfs_io_r_dfs_remove(char *desc, DFS_R_DFS_REMOVE *r_d, prs_struct *ps, int depth)
+BOOL dfs_io_r_dfs_remove(const char *desc, DFS_R_DFS_REMOVE *r_d, prs_struct *ps, int depth)
 {
 	if(r_d == NULL)	
 		return False;
@@ -172,7 +172,7 @@
  Read/write a DFS_Q_DFS_ADD structure
  ************************************************************/
 
-BOOL dfs_io_q_dfs_add(char *desc, DFS_Q_DFS_ADD *q_d, prs_struct *ps, int depth)
+BOOL dfs_io_q_dfs_add(const char *desc, DFS_Q_DFS_ADD *q_d, prs_struct *ps, int depth)
 {
 	if(q_d == NULL)
 		return False;
@@ -217,7 +217,7 @@
  Read/write a DFS_R_DFS_ADD structure 
  ************************************************************/
 
-BOOL dfs_io_r_dfs_add(char *desc, DFS_R_DFS_ADD *r_d, prs_struct *ps, int depth)
+BOOL dfs_io_r_dfs_add(const char *desc, DFS_R_DFS_ADD *r_d, prs_struct *ps, int depth)
 {
 	if(r_d == NULL)
 		return False;
@@ -248,7 +248,7 @@
  Read/write a DFS_Q_GET_INFO structure
  ************************************************************/
 
-BOOL dfs_io_q_dfs_get_info(char* desc, DFS_Q_DFS_GET_INFO* q_i, prs_struct* ps, int depth)
+BOOL dfs_io_q_dfs_get_info(const char *desc, DFS_Q_DFS_GET_INFO* q_i, prs_struct* ps, int depth)
 {
 	if(q_i == NULL)
 		return False;
@@ -288,7 +288,7 @@
  Read/write a DFS_R_GET_INFO structure
  ************************************************************/
 
-BOOL dfs_io_r_dfs_get_info(char* desc, DFS_R_DFS_GET_INFO* r_i, prs_struct* ps, int depth)
+BOOL dfs_io_r_dfs_get_info(const char *desc, DFS_R_DFS_GET_INFO* r_i, prs_struct* ps, int depth)
 {
 	if(r_i == NULL)
 		return False;
@@ -327,7 +327,7 @@
  Read or write the DFS_Q_DFS_ENUM structure 
  ************************************************************/
 
-BOOL dfs_io_q_dfs_enum(char *desc, DFS_Q_DFS_ENUM *q_d, prs_struct *ps, int depth)
+BOOL dfs_io_q_dfs_enum(const char *desc, DFS_Q_DFS_ENUM *q_d, prs_struct *ps, int depth)
 {
 	if(q_d == NULL)
 		return False;
@@ -364,7 +364,7 @@
  Read/write a DFS_INFO_CTR structure
  ************************************************************/
 
-BOOL dfs_io_dfs_info_ctr(char* desc, DFS_INFO_CTR* ctr, uint32 num_entries, uint32 level, prs_struct* ps, int depth)
+BOOL dfs_io_dfs_info_ctr(const char *desc, DFS_INFO_CTR* ctr, uint32 num_entries, uint32 level, prs_struct* ps, int depth)
 {
 	int i=0;
 
@@ -464,7 +464,7 @@
  Read/write a DFS_R_DFS_ENUM structure
  ************************************************************/
 
-BOOL dfs_io_r_dfs_enum(char *desc, DFS_R_DFS_ENUM *q_d, prs_struct *ps, int depth)
+BOOL dfs_io_r_dfs_enum(const char *desc, DFS_R_DFS_ENUM *q_d, prs_struct *ps, int depth)
 {
 	DFS_INFO_CTR *ctr;
 	if(q_d == NULL)
@@ -506,7 +506,7 @@
 	return True;
 }
 
-BOOL dfs_io_dfs_storage_info(char *desc, DFS_INFO_3* info3, prs_struct *ps, int depth)
+BOOL dfs_io_dfs_storage_info(const char *desc, DFS_INFO_3* info3, prs_struct *ps, int depth)
 {
 	int i=0;
 	if(info3 == NULL)
diff -uNr samba-3.0alpha21.orig/source/rpc_parse/parse_ds.c samba-3.0alpha21/source/rpc_parse/parse_ds.c
--- samba-3.0alpha21.orig/source/rpc_parse/parse_ds.c	2003-02-16 19:06:32.000000000 -0600
+++ samba-3.0alpha21/source/rpc_parse/parse_ds.c	2003-02-16 19:05:46.000000000 -0600
@@ -20,7 +20,7 @@
 
 #include "includes.h"
 
-static BOOL ds_io_dominfobasic( char *desc, prs_struct *ps, int depth, DSROLE_PRIMARY_DOMAIN_INFO_BASIC **basic)
+static BOOL ds_io_dominfobasic( const char *desc, prs_struct *ps, int depth, DSROLE_PRIMARY_DOMAIN_INFO_BASIC **basic)
 {
 	DSROLE_PRIMARY_DOMAIN_INFO_BASIC *p = *basic;
 	
@@ -68,7 +68,7 @@
 		
 }
 
-BOOL ds_io_q_getprimdominfo( char *desc, DS_Q_GETPRIMDOMINFO *q_u, prs_struct *ps, int depth)
+BOOL ds_io_q_getprimdominfo( const char *desc, DS_Q_GETPRIMDOMINFO *q_u, prs_struct *ps, int depth)
 {
 	prs_debug(ps, depth, desc, "ds_io_q_getprimdominfo");
 	depth++;
@@ -82,7 +82,7 @@
 	return True;
 }
 
-BOOL ds_io_r_getprimdominfo( char *desc, DS_R_GETPRIMDOMINFO *r_u, prs_struct *ps, int depth)
+BOOL ds_io_r_getprimdominfo( const char *desc, DS_R_GETPRIMDOMINFO *r_u, prs_struct *ps, int depth)
 {
 	prs_debug(ps, depth, desc, "ds_io_r_getprimdominfo");
 	depth++;
diff -uNr samba-3.0alpha21.orig/source/rpc_parse/parse_lsa.c samba-3.0alpha21/source/rpc_parse/parse_lsa.c
--- samba-3.0alpha21.orig/source/rpc_parse/parse_lsa.c	2003-02-16 19:06:32.000000000 -0600
+++ samba-3.0alpha21/source/rpc_parse/parse_lsa.c	2003-02-16 19:05:46.000000000 -0600
@@ -27,14 +27,14 @@
 #undef DBGC_CLASS
 #define DBGC_CLASS DBGC_RPC_PARSE
 
-static BOOL lsa_io_trans_names(char *desc, LSA_TRANS_NAME_ENUM *trn, prs_struct *ps, int depth);
+static BOOL lsa_io_trans_names(const char *desc, LSA_TRANS_NAME_ENUM *trn, prs_struct *ps, int depth);
 
 /*******************************************************************
  Inits a LSA_TRANS_NAME structure.
 ********************************************************************/
 
 void init_lsa_trans_name(LSA_TRANS_NAME *trn, UNISTR2 *uni_name,
-			 uint16 sid_name_use, char *name, uint32 idx)
+			 uint16 sid_name_use, const char *name, uint32 idx)
 {
 	int len_name = strlen(name);
 
@@ -51,7 +51,7 @@
  Reads or writes a LSA_TRANS_NAME structure.
 ********************************************************************/
 
-static BOOL lsa_io_trans_name(char *desc, LSA_TRANS_NAME *trn, prs_struct *ps, 
+static BOOL lsa_io_trans_name(const char *desc, LSA_TRANS_NAME *trn, prs_struct *ps, 
 			      int depth)
 {
 	prs_debug(ps, depth, desc, "lsa_io_trans_name");
@@ -77,7 +77,7 @@
  Reads or writes a DOM_R_REF structure.
 ********************************************************************/
 
-static BOOL lsa_io_dom_r_ref(char *desc, DOM_R_REF *r_r, prs_struct *ps, 
+static BOOL lsa_io_dom_r_ref(const char *desc, DOM_R_REF *r_r, prs_struct *ps, 
 			     int depth)
 {
 	int i;
@@ -156,7 +156,7 @@
  Reads or writes an LSA_SEC_QOS structure.
 ********************************************************************/
 
-static BOOL lsa_io_sec_qos(char *desc,  LSA_SEC_QOS *qos, prs_struct *ps, 
+static BOOL lsa_io_sec_qos(const char *desc,  LSA_SEC_QOS *qos, prs_struct *ps, 
 			   int depth)
 {
 	uint32 start;
@@ -216,7 +216,7 @@
  Reads or writes an LSA_OBJ_ATTR structure.
 ********************************************************************/
 
-static BOOL lsa_io_obj_attr(char *desc, LSA_OBJ_ATTR *attr, prs_struct *ps, 
+static BOOL lsa_io_obj_attr(const char *desc, LSA_OBJ_ATTR *attr, prs_struct *ps, 
 			    int depth)
 {
 	uint32 start;
@@ -290,7 +290,7 @@
  Reads or writes an LSA_Q_OPEN_POL structure.
 ********************************************************************/
 
-BOOL lsa_io_q_open_pol(char *desc, LSA_Q_OPEN_POL *r_q, prs_struct *ps, 
+BOOL lsa_io_q_open_pol(const char *desc, LSA_Q_OPEN_POL *r_q, prs_struct *ps, 
 		       int depth)
 {
 	prs_debug(ps, depth, desc, "lsa_io_q_open_pol");
@@ -316,7 +316,7 @@
  Reads or writes an LSA_R_OPEN_POL structure.
 ********************************************************************/
 
-BOOL lsa_io_r_open_pol(char *desc, LSA_R_OPEN_POL *r_p, prs_struct *ps, 
+BOOL lsa_io_r_open_pol(const char *desc, LSA_R_OPEN_POL *r_p, prs_struct *ps, 
 		       int depth)
 {
 	prs_debug(ps, depth, desc, "lsa_io_r_open_pol");
@@ -335,7 +335,7 @@
  Inits an LSA_Q_OPEN_POL2 structure.
 ********************************************************************/
 
-void init_q_open_pol2(LSA_Q_OPEN_POL2 *r_q, char *server_name,
+void init_q_open_pol2(LSA_Q_OPEN_POL2 *r_q, const char *server_name,
 			uint32 attributes, uint32 desired_access,
 			LSA_SEC_QOS *qos)
 {
@@ -356,7 +356,7 @@
  Reads or writes an LSA_Q_OPEN_POL2 structure.
 ********************************************************************/
 
-BOOL lsa_io_q_open_pol2(char *desc, LSA_Q_OPEN_POL2 *r_q, prs_struct *ps, 
+BOOL lsa_io_q_open_pol2(const char *desc, LSA_Q_OPEN_POL2 *r_q, prs_struct *ps, 
 			int depth)
 {
 	prs_debug(ps, depth, desc, "lsa_io_q_open_pol2");
@@ -380,7 +380,7 @@
  Reads or writes an LSA_R_OPEN_POL2 structure.
 ********************************************************************/
 
-BOOL lsa_io_r_open_pol2(char *desc, LSA_R_OPEN_POL2 *r_p, prs_struct *ps, 
+BOOL lsa_io_r_open_pol2(const char *desc, LSA_R_OPEN_POL2 *r_p, prs_struct *ps, 
 			int depth)
 {
 	prs_debug(ps, depth, desc, "lsa_io_r_open_pol2");
@@ -414,7 +414,7 @@
  Reads or writes an LSA_Q_QUERY_SEC_OBJ structure.
 ********************************************************************/
 
-BOOL lsa_io_q_query_sec_obj(char *desc, LSA_Q_QUERY_SEC_OBJ *q_q, 
+BOOL lsa_io_q_query_sec_obj(const char *desc, LSA_Q_QUERY_SEC_OBJ *q_q, 
 			    prs_struct *ps, int depth)
 {
 	prs_debug(ps, depth, desc, "lsa_io_q_query_sec_obj");
@@ -433,7 +433,7 @@
  Reads or writes a LSA_R_QUERY_SEC_OBJ structure.
 ********************************************************************/
 
-BOOL lsa_io_r_query_sec_obj(char *desc, LSA_R_QUERY_SEC_OBJ *r_u, 
+BOOL lsa_io_r_query_sec_obj(const char *desc, LSA_R_QUERY_SEC_OBJ *r_u, 
 			    prs_struct *ps, int depth)
 {
 	prs_debug(ps, depth, desc, "lsa_io_r_query_sec_obj");
@@ -473,7 +473,7 @@
  Reads or writes an LSA_Q_QUERY_INFO structure.
 ********************************************************************/
 
-BOOL lsa_io_q_query(char *desc, LSA_Q_QUERY_INFO *q_q, prs_struct *ps, 
+BOOL lsa_io_q_query(const char *desc, LSA_Q_QUERY_INFO *q_q, prs_struct *ps, 
 		    int depth)
 {
 	prs_debug(ps, depth, desc, "lsa_io_q_query");
@@ -507,7 +507,7 @@
  Reads or writes an LSA_Q_ENUM_TRUST_DOM structure.
 ********************************************************************/
 
-BOOL lsa_io_q_enum_trust_dom(char *desc, LSA_Q_ENUM_TRUST_DOM *q_e, 
+BOOL lsa_io_q_enum_trust_dom(const char *desc, LSA_Q_ENUM_TRUST_DOM *q_e, 
 			     prs_struct *ps, int depth)
 {
 	prs_debug(ps, depth, desc, "lsa_io_q_enum_trust_dom");
@@ -580,7 +580,7 @@
  Reads or writes an LSA_R_ENUM_TRUST_DOM structure.
 ********************************************************************/
 
-BOOL lsa_io_r_enum_trust_dom(char *desc, LSA_R_ENUM_TRUST_DOM *r_e, 
+BOOL lsa_io_r_enum_trust_dom(const char *desc, LSA_R_ENUM_TRUST_DOM *r_e, 
 			     prs_struct *ps, int depth)
 {
 	prs_debug(ps, depth, desc, "lsa_io_r_enum_trust_dom");
@@ -639,7 +639,7 @@
 reads or writes a dom query structure.
 ********************************************************************/
 
-static BOOL lsa_io_dom_query(char *desc, DOM_QUERY *d_q, prs_struct *ps, int depth)
+static BOOL lsa_io_dom_query(const char *desc, DOM_QUERY *d_q, prs_struct *ps, int depth)
 {
 	if (d_q == NULL)
 		return False;
@@ -680,7 +680,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-static BOOL lsa_io_dom_query_2(char *desc, DOM_QUERY_2 *d_q, prs_struct *ps, int depth)
+static BOOL lsa_io_dom_query_2(const char *desc, DOM_QUERY_2 *d_q, prs_struct *ps, int depth)
 {
 	uint32 ptr = 1;
 
@@ -721,7 +721,7 @@
  Reads or writes a dom query structure.
 ********************************************************************/
 
-static BOOL lsa_io_dom_query_3(char *desc, DOM_QUERY_3 *d_q, prs_struct *ps, int depth)
+static BOOL lsa_io_dom_query_3(const char *desc, DOM_QUERY_3 *d_q, prs_struct *ps, int depth)
 {
 	return lsa_io_dom_query("", d_q, ps, depth);
 }
@@ -730,7 +730,7 @@
  Reads or writes a dom query structure.
 ********************************************************************/
 
-static BOOL lsa_io_dom_query_5(char *desc, DOM_QUERY_5 *d_q, prs_struct *ps, int depth)
+static BOOL lsa_io_dom_query_5(const char *desc, DOM_QUERY_5 *d_q, prs_struct *ps, int depth)
 {
 	return lsa_io_dom_query("", d_q, ps, depth);
 }
@@ -739,7 +739,7 @@
  Reads or writes a dom query structure.
 ********************************************************************/
 
-static BOOL lsa_io_dom_query_6(char *desc, DOM_QUERY_6 *d_q, prs_struct *ps, int depth)
+static BOOL lsa_io_dom_query_6(const char *desc, DOM_QUERY_6 *d_q, prs_struct *ps, int depth)
 {
 	if (d_q == NULL)
 		return False;
@@ -757,7 +757,7 @@
  Reads or writes an LSA_R_QUERY_INFO structure.
 ********************************************************************/
 
-BOOL lsa_io_r_query(char *desc, LSA_R_QUERY_INFO *r_q, prs_struct *ps,
+BOOL lsa_io_r_query(const char *desc, LSA_R_QUERY_INFO *r_q, prs_struct *ps,
 		    int depth)
 {
 	prs_debug(ps, depth, desc, "lsa_io_r_query");
@@ -848,7 +848,7 @@
  Reads or writes a LSA_SID_ENUM structure.
 ********************************************************************/
 
-static BOOL lsa_io_sid_enum(char *desc, LSA_SID_ENUM *sen, prs_struct *ps, 
+static BOOL lsa_io_sid_enum(const char *desc, LSA_SID_ENUM *sen, prs_struct *ps, 
 			    int depth)
 {
 	int i;
@@ -936,7 +936,7 @@
  Reads or writes a LSA_Q_LOOKUP_SIDS structure.
 ********************************************************************/
 
-BOOL lsa_io_q_lookup_sids(char *desc, LSA_Q_LOOKUP_SIDS *q_s, prs_struct *ps,
+BOOL lsa_io_q_lookup_sids(const char *desc, LSA_Q_LOOKUP_SIDS *q_s, prs_struct *ps,
 			  int depth)
 {
 	prs_debug(ps, depth, desc, "lsa_io_q_lookup_sids");
@@ -964,7 +964,7 @@
  Reads or writes a structure.
 ********************************************************************/
 
-static BOOL lsa_io_trans_names(char *desc, LSA_TRANS_NAME_ENUM *trn,
+static BOOL lsa_io_trans_names(const char *desc, LSA_TRANS_NAME_ENUM *trn,
                 prs_struct *ps, int depth)
 {
 	int i;
@@ -1025,7 +1025,7 @@
  Reads or writes a structure.
 ********************************************************************/
 
-BOOL lsa_io_r_lookup_sids(char *desc, LSA_R_LOOKUP_SIDS *r_s, 
+BOOL lsa_io_r_lookup_sids(const char *desc, LSA_R_LOOKUP_SIDS *r_s, 
 			  prs_struct *ps, int depth)
 {
 	prs_debug(ps, depth, desc, "lsa_io_r_lookup_sids");
@@ -1099,7 +1099,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-BOOL lsa_io_q_lookup_names(char *desc, LSA_Q_LOOKUP_NAMES *q_r, 
+BOOL lsa_io_q_lookup_names(const char *desc, LSA_Q_LOOKUP_NAMES *q_r, 
 			   prs_struct *ps, int depth)
 {
 	int i;
@@ -1163,7 +1163,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-BOOL lsa_io_r_lookup_names(char *desc, LSA_R_LOOKUP_NAMES *r_r, 
+BOOL lsa_io_r_lookup_names(const char *desc, LSA_R_LOOKUP_NAMES *r_r, 
 			   prs_struct *ps, int depth)
 {
 	int i;
@@ -1233,7 +1233,7 @@
  Reads or writes an LSA_Q_CLOSE structure.
 ********************************************************************/
 
-BOOL lsa_io_q_close(char *desc, LSA_Q_CLOSE *q_c, prs_struct *ps, int depth)
+BOOL lsa_io_q_close(const char *desc, LSA_Q_CLOSE *q_c, prs_struct *ps, int depth)
 {
 	prs_debug(ps, depth, desc, "lsa_io_q_close");
 	depth++;
@@ -1248,7 +1248,7 @@
  Reads or writes an LSA_R_CLOSE structure.
 ********************************************************************/
 
-BOOL lsa_io_r_close(char *desc,  LSA_R_CLOSE *r_c, prs_struct *ps, int depth)
+BOOL lsa_io_r_close(const char *desc,  LSA_R_CLOSE *r_c, prs_struct *ps, int depth)
 {
 	prs_debug(ps, depth, desc, "lsa_io_r_close");
 	depth++;
@@ -1266,7 +1266,7 @@
  Reads or writes an LSA_Q_OPEN_SECRET structure.
 ********************************************************************/
 
-BOOL lsa_io_q_open_secret(char *desc, LSA_Q_OPEN_SECRET *q_c, prs_struct *ps, int depth)
+BOOL lsa_io_q_open_secret(const char *desc, LSA_Q_OPEN_SECRET *q_c, prs_struct *ps, int depth)
 {
 	prs_debug(ps, depth, desc, "lsa_io_q_open_secret");
 	depth++;
@@ -1279,7 +1279,7 @@
  Reads or writes an LSA_R_OPEN_SECRET structure.
 ********************************************************************/
 
-BOOL lsa_io_r_open_secret(char *desc, LSA_R_OPEN_SECRET *r_c, prs_struct *ps, int depth)
+BOOL lsa_io_r_open_secret(const char *desc, LSA_R_OPEN_SECRET *r_c, prs_struct *ps, int depth)
 {
 	prs_debug(ps, depth, desc, "lsa_io_r_open_secret");
 	depth++;
@@ -1318,7 +1318,7 @@
 /*******************************************************************
 reads or writes a structure.
 ********************************************************************/
-BOOL lsa_io_q_enum_privs(char *desc, LSA_Q_ENUM_PRIVS *q_q, prs_struct *ps, int depth)
+BOOL lsa_io_q_enum_privs(const char *desc, LSA_Q_ENUM_PRIVS *q_q, prs_struct *ps, int depth)
 {
 	if (q_q == NULL)
 		return False;
@@ -1340,7 +1340,7 @@
 /*******************************************************************
 reads or writes a structure.
 ********************************************************************/
-static BOOL lsa_io_priv_entries(char *desc, LSA_PRIV_ENTRY *entries, uint32 count, prs_struct *ps, int depth)
+static BOOL lsa_io_priv_entries(const char *desc, LSA_PRIV_ENTRY *entries, uint32 count, prs_struct *ps, int depth)
 {
 	uint32 i;
 
@@ -1395,7 +1395,7 @@
 /*******************************************************************
 reads or writes a structure.
 ********************************************************************/
-BOOL lsa_io_r_enum_privs(char *desc, LSA_R_ENUM_PRIVS *r_q, prs_struct *ps, int depth)
+BOOL lsa_io_r_enum_privs(const char *desc, LSA_R_ENUM_PRIVS *r_q, prs_struct *ps, int depth)
 {
 	if (r_q == NULL)
 		return False;
@@ -1434,7 +1434,7 @@
 	return True;
 }
 
-void init_lsa_priv_get_dispname(LSA_Q_PRIV_GET_DISPNAME *trn, POLICY_HND *hnd, char *name, uint16 lang_id, uint16 lang_id_sys)
+void init_lsa_priv_get_dispname(LSA_Q_PRIV_GET_DISPNAME *trn, POLICY_HND *hnd, const char *name, uint16 lang_id, uint16 lang_id_sys)
 {
 	int len_name = strlen(name);
 
@@ -1452,7 +1452,7 @@
 /*******************************************************************
 reads or writes a structure.
 ********************************************************************/
-BOOL lsa_io_q_priv_get_dispname(char *desc, LSA_Q_PRIV_GET_DISPNAME *q_q, prs_struct *ps, int depth)
+BOOL lsa_io_q_priv_get_dispname(const char *desc, LSA_Q_PRIV_GET_DISPNAME *q_q, prs_struct *ps, int depth)
 {
 	if (q_q == NULL)
 		return False;
@@ -1483,7 +1483,7 @@
 /*******************************************************************
 reads or writes a structure.
 ********************************************************************/
-BOOL lsa_io_r_priv_get_dispname(char *desc, LSA_R_PRIV_GET_DISPNAME *r_q, prs_struct *ps, int depth)
+BOOL lsa_io_r_priv_get_dispname(const char *desc, LSA_R_PRIV_GET_DISPNAME *r_q, prs_struct *ps, int depth)
 {
 	if (r_q == NULL)
 		return False;
@@ -1519,6 +1519,9 @@
 	return True;
 }
 
+/*
+  initialise a LSA_Q_ENUM_ACCOUNTS structure
+*/
 void init_lsa_q_enum_accounts(LSA_Q_ENUM_ACCOUNTS *trn, POLICY_HND *hnd, uint32 enum_context, uint32 pref_max_length)
 {
 	memcpy(&trn->pol, hnd, sizeof(trn->pol));
@@ -1530,7 +1533,7 @@
 /*******************************************************************
 reads or writes a structure.
 ********************************************************************/
-BOOL lsa_io_q_enum_accounts(char *desc, LSA_Q_ENUM_ACCOUNTS *q_q, prs_struct *ps, int depth)
+BOOL lsa_io_q_enum_accounts(const char *desc, LSA_Q_ENUM_ACCOUNTS *q_q, prs_struct *ps, int depth)
 {
 	if (q_q == NULL)
 		return False;
@@ -1549,6 +1552,7 @@
 	return True;
 }
 
+
 /*******************************************************************
  Inits an LSA_R_ENUM_PRIVS structure.
 ********************************************************************/
@@ -1572,7 +1576,7 @@
 /*******************************************************************
 reads or writes a structure.
 ********************************************************************/
-BOOL lsa_io_r_enum_accounts(char *desc, LSA_R_ENUM_ACCOUNTS *r_q, prs_struct *ps, int depth)
+BOOL lsa_io_r_enum_accounts(const char *desc, LSA_R_ENUM_ACCOUNTS *r_q, prs_struct *ps, int depth)
 {
 	if (r_q == NULL)
 		return False;
@@ -1603,7 +1607,7 @@
  Reads or writes an LSA_Q_UNK_GET_CONNUSER structure.
 ********************************************************************/
 
-BOOL lsa_io_q_unk_get_connuser(char *desc, LSA_Q_UNK_GET_CONNUSER *q_c, prs_struct *ps, int depth)
+BOOL lsa_io_q_unk_get_connuser(const char *desc, LSA_Q_UNK_GET_CONNUSER *q_c, prs_struct *ps, int depth)
 {
 	prs_debug(ps, depth, desc, "lsa_io_q_unk_get_connuser");
 	depth++;
@@ -1635,7 +1639,7 @@
  Reads or writes an LSA_R_UNK_GET_CONNUSER structure.
 ********************************************************************/
 
-BOOL lsa_io_r_unk_get_connuser(char *desc, LSA_R_UNK_GET_CONNUSER *r_c, prs_struct *ps, int depth)
+BOOL lsa_io_r_unk_get_connuser(const char *desc, LSA_R_UNK_GET_CONNUSER *r_c, prs_struct *ps, int depth)
 {
 	prs_debug(ps, depth, desc, "lsa_io_r_unk_get_connuser");
 	depth++;
@@ -1684,7 +1688,7 @@
  Reads or writes an LSA_Q_OPENACCOUNT structure.
 ********************************************************************/
 
-BOOL lsa_io_q_open_account(char *desc, LSA_Q_OPENACCOUNT *r_c, prs_struct *ps, int depth)
+BOOL lsa_io_q_open_account(const char *desc, LSA_Q_OPENACCOUNT *r_c, prs_struct *ps, int depth)
 {
 	prs_debug(ps, depth, desc, "lsa_io_q_open_account");
 	depth++;
@@ -1708,7 +1712,7 @@
  Reads or writes an LSA_R_OPENACCOUNT structure.
 ********************************************************************/
 
-BOOL lsa_io_r_open_account(char *desc, LSA_R_OPENACCOUNT  *r_c, prs_struct *ps, int depth)
+BOOL lsa_io_r_open_account(const char *desc, LSA_R_OPENACCOUNT  *r_c, prs_struct *ps, int depth)
 {
 	prs_debug(ps, depth, desc, "lsa_io_r_open_account");
 	depth++;
@@ -1736,7 +1740,7 @@
  Reads or writes an LSA_Q_ENUMPRIVSACCOUNT structure.
 ********************************************************************/
 
-BOOL lsa_io_q_enum_privsaccount(char *desc, LSA_Q_ENUMPRIVSACCOUNT *r_c, prs_struct *ps, int depth)
+BOOL lsa_io_q_enum_privsaccount(const char *desc, LSA_Q_ENUMPRIVSACCOUNT *r_c, prs_struct *ps, int depth)
 {
 	prs_debug(ps, depth, desc, "lsa_io_q_enum_privsaccount");
 	depth++;
@@ -1754,7 +1758,7 @@
  Reads or writes an LUID structure.
 ********************************************************************/
 
-static BOOL lsa_io_luid(char *desc, LUID *r_c, prs_struct *ps, int depth)
+static BOOL lsa_io_luid(const char *desc, LUID *r_c, prs_struct *ps, int depth)
 {
 	prs_debug(ps, depth, desc, "lsa_io_luid");
 	depth++;
@@ -1775,7 +1779,7 @@
  Reads or writes an LUID_ATTR structure.
 ********************************************************************/
 
-static BOOL lsa_io_luid_attr(char *desc, LUID_ATTR *r_c, prs_struct *ps, int depth)
+static BOOL lsa_io_luid_attr(const char *desc, LUID_ATTR *r_c, prs_struct *ps, int depth)
 {
 	prs_debug(ps, depth, desc, "lsa_io_luid_attr");
 	depth++;
@@ -1796,7 +1800,7 @@
  Reads or writes an PRIVILEGE_SET structure.
 ********************************************************************/
 
-static BOOL lsa_io_privilege_set(char *desc, PRIVILEGE_SET *r_c, prs_struct *ps, int depth)
+static BOOL lsa_io_privilege_set(const char *desc, PRIVILEGE_SET *r_c, prs_struct *ps, int depth)
 {
 	uint32 i;
 
@@ -1833,7 +1837,7 @@
  Reads or writes an LSA_R_ENUMPRIVSACCOUNT structure.
 ********************************************************************/
 
-BOOL lsa_io_r_enum_privsaccount(char *desc, LSA_R_ENUMPRIVSACCOUNT *r_c, prs_struct *ps, int depth)
+BOOL lsa_io_r_enum_privsaccount(const char *desc, LSA_R_ENUMPRIVSACCOUNT *r_c, prs_struct *ps, int depth)
 {
 	prs_debug(ps, depth, desc, "lsa_io_r_enum_privsaccount");
 	depth++;
@@ -1872,7 +1876,7 @@
  Reads or writes an  LSA_Q_GETSYSTEMACCOUNTstructure.
 ********************************************************************/
 
-BOOL lsa_io_q_getsystemaccount(char *desc, LSA_Q_GETSYSTEMACCOUNT  *r_c, prs_struct *ps, int depth)
+BOOL lsa_io_q_getsystemaccount(const char *desc, LSA_Q_GETSYSTEMACCOUNT  *r_c, prs_struct *ps, int depth)
 {
 	prs_debug(ps, depth, desc, "lsa_io_q_getsystemaccount");
 	depth++;
@@ -1890,7 +1894,7 @@
  Reads or writes an  LSA_R_GETSYSTEMACCOUNTstructure.
 ********************************************************************/
 
-BOOL lsa_io_r_getsystemaccount(char *desc, LSA_R_GETSYSTEMACCOUNT  *r_c, prs_struct *ps, int depth)
+BOOL lsa_io_r_getsystemaccount(const char *desc, LSA_R_GETSYSTEMACCOUNT  *r_c, prs_struct *ps, int depth)
 {
 	prs_debug(ps, depth, desc, "lsa_io_r_getsystemaccount");
 	depth++;
@@ -1912,7 +1916,7 @@
  Reads or writes an LSA_Q_SETSYSTEMACCOUNT structure.
 ********************************************************************/
 
-BOOL lsa_io_q_setsystemaccount(char *desc, LSA_Q_SETSYSTEMACCOUNT  *r_c, prs_struct *ps, int depth)
+BOOL lsa_io_q_setsystemaccount(const char *desc, LSA_Q_SETSYSTEMACCOUNT  *r_c, prs_struct *ps, int depth)
 {
 	prs_debug(ps, depth, desc, "lsa_io_q_setsystemaccount");
 	depth++;
@@ -1933,7 +1937,7 @@
  Reads or writes an LSA_R_SETSYSTEMACCOUNT structure.
 ********************************************************************/
 
-BOOL lsa_io_r_setsystemaccount(char *desc, LSA_R_SETSYSTEMACCOUNT  *r_c, prs_struct *ps, int depth)
+BOOL lsa_io_r_setsystemaccount(const char *desc, LSA_R_SETSYSTEMACCOUNT  *r_c, prs_struct *ps, int depth)
 {
 	prs_debug(ps, depth, desc, "lsa_io_r_setsystemaccount");
 	depth++;
@@ -1948,7 +1952,7 @@
 }
 
 
-void init_lsa_q_lookupprivvalue(LSA_Q_LOOKUPPRIVVALUE *trn, POLICY_HND *hnd, char *name)
+void init_lsa_q_lookupprivvalue(LSA_Q_LOOKUPPRIVVALUE *trn, POLICY_HND *hnd, const char *name)
 {
 	int len_name = strlen(name);
 	memcpy(&trn->pol, hnd, sizeof(trn->pol));
@@ -1964,7 +1968,7 @@
  Reads or writes an LSA_Q_LOOKUPPRIVVALUE  structure.
 ********************************************************************/
 
-BOOL lsa_io_q_lookupprivvalue(char *desc, LSA_Q_LOOKUPPRIVVALUE  *r_c, prs_struct *ps, int depth)
+BOOL lsa_io_q_lookupprivvalue(const char *desc, LSA_Q_LOOKUPPRIVVALUE  *r_c, prs_struct *ps, int depth)
 {
 	prs_debug(ps, depth, desc, "lsa_io_q_lookupprivvalue");
 	depth++;
@@ -1986,7 +1990,7 @@
  Reads or writes an  LSA_R_LOOKUPPRIVVALUE structure.
 ********************************************************************/
 
-BOOL lsa_io_r_lookupprivvalue(char *desc, LSA_R_LOOKUPPRIVVALUE  *r_c, prs_struct *ps, int depth)
+BOOL lsa_io_r_lookupprivvalue(const char *desc, LSA_R_LOOKUPPRIVVALUE  *r_c, prs_struct *ps, int depth)
 {
 	prs_debug(ps, depth, desc, "lsa_io_r_lookupprivvalue");
 	depth++;
@@ -2008,7 +2012,7 @@
  Reads or writes an LSA_Q_ADDPRIVS structure.
 ********************************************************************/
 
-BOOL lsa_io_q_addprivs(char *desc, LSA_Q_ADDPRIVS *r_c, prs_struct *ps, int depth)
+BOOL lsa_io_q_addprivs(const char *desc, LSA_Q_ADDPRIVS *r_c, prs_struct *ps, int depth)
 {
 	prs_debug(ps, depth, desc, "lsa_io_q_addprivs");
 	depth++;
@@ -2037,7 +2041,7 @@
  Reads or writes an LSA_R_ADDPRIVS structure.
 ********************************************************************/
 
-BOOL lsa_io_r_addprivs(char *desc, LSA_R_ADDPRIVS *r_c, prs_struct *ps, int depth)
+BOOL lsa_io_r_addprivs(const char *desc, LSA_R_ADDPRIVS *r_c, prs_struct *ps, int depth)
 {
 	prs_debug(ps, depth, desc, "lsa_io_r_addprivs");
 	depth++;
@@ -2055,7 +2059,7 @@
  Reads or writes an LSA_Q_REMOVEPRIVS structure.
 ********************************************************************/
 
-BOOL lsa_io_q_removeprivs(char *desc, LSA_Q_REMOVEPRIVS *r_c, prs_struct *ps, int depth)
+BOOL lsa_io_q_removeprivs(const char *desc, LSA_Q_REMOVEPRIVS *r_c, prs_struct *ps, int depth)
 {
 	prs_debug(ps, depth, desc, "lsa_io_q_removeprivs");
 	depth++;
@@ -2097,7 +2101,7 @@
  Reads or writes an LSA_R_REMOVEPRIVS structure.
 ********************************************************************/
 
-BOOL lsa_io_r_removeprivs(char *desc, LSA_R_REMOVEPRIVS *r_c, prs_struct *ps, int depth)
+BOOL lsa_io_r_removeprivs(const char *desc, LSA_R_REMOVEPRIVS *r_c, prs_struct *ps, int depth)
 {
 	prs_debug(ps, depth, desc, "lsa_io_r_removeprivs");
 	depth++;
@@ -2123,7 +2127,7 @@
  Reads or writes an LSA_DNS_DOM_INFO structure.
 ********************************************************************/
 
-BOOL lsa_io_dns_dom_info(char *desc, LSA_DNS_DOM_INFO *info,
+BOOL lsa_io_dns_dom_info(const char *desc, LSA_DNS_DOM_INFO *info,
 			 prs_struct *ps, int depth)
 {
 	prs_debug(ps, depth, desc, "lsa_io_dns_dom_info");
@@ -2182,7 +2186,7 @@
  Reads or writes an LSA_Q_QUERY_DNSDOMINFO structure.
 ********************************************************************/
 
-BOOL lsa_io_q_query_info2(char *desc, LSA_Q_QUERY_INFO2 *q_c,
+BOOL lsa_io_q_query_info2(const char *desc, LSA_Q_QUERY_INFO2 *q_c,
 			  prs_struct *ps, int depth)
 {
 	prs_debug(ps, depth, desc, "lsa_io_q_query_info2");
@@ -2204,7 +2208,7 @@
  Reads or writes an LSA_R_QUERY_DNSDOMINFO structure.
 ********************************************************************/
 
-BOOL lsa_io_r_query_info2(char *desc, LSA_R_QUERY_INFO2 *r_c,
+BOOL lsa_io_r_query_info2(const char *desc, LSA_R_QUERY_INFO2 *r_c,
 			  prs_struct *ps, int depth)
 {
 	prs_debug(ps, depth, desc, "lsa_io_r_query_info2");
@@ -2236,3 +2240,180 @@
 
 	return True;
 }
+
+
+/*******************************************************************
+ Inits an LSA_Q_ENUM_ACCT_RIGHTS structure.
+********************************************************************/
+void init_q_enum_acct_rights(LSA_Q_ENUM_ACCT_RIGHTS *q_q, 
+			     POLICY_HND *hnd, 
+			     uint32 count, 
+			     DOM_SID *sid)
+{
+	DEBUG(5, ("init_q_enum_acct_rights\n"));
+
+	q_q->pol = *hnd;
+	init_dom_sid2(&q_q->sid, sid);
+}
+
+/*******************************************************************
+reads or writes a LSA_Q_ENUM_ACCT_RIGHTS structure.
+********************************************************************/
+BOOL lsa_io_q_enum_acct_rights(const char *desc, LSA_Q_ENUM_ACCT_RIGHTS *q_q, prs_struct *ps, int depth)
+{
+	
+	if (q_q == NULL)
+		return False;
+
+	prs_debug(ps, depth, desc, "lsa_io_q_enum_acct_rights");
+	depth++;
+
+	if (!smb_io_pol_hnd("", &q_q->pol, ps, depth))
+		return False;
+
+	if(!smb_io_dom_sid2("sid", &q_q->sid, ps, depth))
+		return False;
+
+	return True;
+}
+
+
+/*******************************************************************
+reads or writes a LSA_R_ENUM_ACCT_RIGHTS structure.
+********************************************************************/
+BOOL lsa_io_r_enum_acct_rights(const char *desc, LSA_R_ENUM_ACCT_RIGHTS *r_c, prs_struct *ps, int depth)
+{
+	prs_debug(ps, depth, desc, "lsa_io_r_enum_acct_rights");
+	depth++;
+
+	if(!prs_uint32("count   ", ps, depth, &r_c->count))
+		return False;
+
+	if(!smb_io_unistr2_array("rights", &r_c->rights, ps, depth))
+		return False;
+
+	if(!prs_align(ps))
+		return False;
+
+	if(!prs_ntstatus("status", ps, depth, &r_c->status))
+		return False;
+
+	return True;
+}
+
+
+/*******************************************************************
+ Inits an LSA_Q_ADD_ACCT_RIGHTS structure.
+********************************************************************/
+void init_q_add_acct_rights(LSA_Q_ADD_ACCT_RIGHTS *q_q, 
+			    POLICY_HND *hnd, 
+			    DOM_SID *sid,
+			    uint32 count, 
+			    const char **rights)
+{
+	DEBUG(5, ("init_q_add_acct_rights\n"));
+
+	q_q->pol = *hnd;
+	init_dom_sid2(&q_q->sid, sid);
+	init_unistr2_array(&q_q->rights, count, rights);
+	q_q->count = 5;
+}
+
+
+/*******************************************************************
+reads or writes a LSA_Q_ADD_ACCT_RIGHTS structure.
+********************************************************************/
+BOOL lsa_io_q_add_acct_rights(const char *desc, LSA_Q_ADD_ACCT_RIGHTS *q_q, prs_struct *ps, int depth)
+{
+	prs_debug(ps, depth, desc, "lsa_io_q_add_acct_rights");
+	depth++;
+
+	if (!smb_io_pol_hnd("", &q_q->pol, ps, depth))
+		return False;
+
+	if(!smb_io_dom_sid2("sid", &q_q->sid, ps, depth))
+		return False;
+
+	if(!prs_uint32("count", ps, depth, &q_q->rights.count))
+		return False;
+
+	if(!smb_io_unistr2_array("rights", &q_q->rights, ps, depth))
+		return False;
+
+	return True;
+}
+
+/*******************************************************************
+reads or writes a LSA_R_ENUM_ACCT_RIGHTS structure.
+********************************************************************/
+BOOL lsa_io_r_add_acct_rights(const char *desc, LSA_R_ADD_ACCT_RIGHTS *r_c, prs_struct *ps, int depth)
+{
+	prs_debug(ps, depth, desc, "lsa_io_r_add_acct_rights");
+	depth++;
+
+	if(!prs_ntstatus("status", ps, depth, &r_c->status))
+		return False;
+
+	return True;
+}
+
+
+/*******************************************************************
+ Inits an LSA_Q_REMOVE_ACCT_RIGHTS structure.
+********************************************************************/
+void init_q_remove_acct_rights(LSA_Q_REMOVE_ACCT_RIGHTS *q_q, 
+			       POLICY_HND *hnd, 
+			       DOM_SID *sid,
+			       uint32 removeall,
+			       uint32 count, 
+			       const char **rights)
+{
+	DEBUG(5, ("init_q_remove_acct_rights\n"));
+
+	q_q->pol = *hnd;
+	init_dom_sid2(&q_q->sid, sid);
+	q_q->removeall = removeall;
+	init_unistr2_array(&q_q->rights, count, rights);
+	q_q->count = 5;
+}
+
+
+/*******************************************************************
+reads or writes a LSA_Q_REMOVE_ACCT_RIGHTS structure.
+********************************************************************/
+BOOL lsa_io_q_remove_acct_rights(const char *desc, LSA_Q_REMOVE_ACCT_RIGHTS *q_q, prs_struct *ps, int depth)
+{
+	prs_debug(ps, depth, desc, "lsa_io_q_remove_acct_rights");
+	depth++;
+
+	if (!smb_io_pol_hnd("", &q_q->pol, ps, depth))
+		return False;
+
+	if(!smb_io_dom_sid2("sid", &q_q->sid, ps, depth))
+		return False;
+
+	if(!prs_uint32("removeall", ps, depth, &q_q->removeall))
+		return False;
+
+	if(!prs_uint32("count", ps, depth, &q_q->rights.count))
+		return False;
+
+	if(!smb_io_unistr2_array("rights", &q_q->rights, ps, depth))
+		return False;
+
+	return True;
+}
+
+/*******************************************************************
+reads or writes a LSA_R_ENUM_ACCT_RIGHTS structure.
+********************************************************************/
+BOOL lsa_io_r_remove_acct_rights(const char *desc, LSA_R_REMOVE_ACCT_RIGHTS *r_c, prs_struct *ps, int depth)
+{
+	prs_debug(ps, depth, desc, "lsa_io_r_remove_acct_rights");
+	depth++;
+
+	if(!prs_ntstatus("status", ps, depth, &r_c->status))
+		return False;
+
+	return True;
+}
diff -uNr samba-3.0alpha21.orig/source/rpc_parse/parse_misc.c samba-3.0alpha21/source/rpc_parse/parse_misc.c
--- samba-3.0alpha21.orig/source/rpc_parse/parse_misc.c	2003-02-16 19:06:32.000000000 -0600
+++ samba-3.0alpha21/source/rpc_parse/parse_misc.c	2003-02-16 19:05:46.000000000 -0600
@@ -63,7 +63,7 @@
 TALLOC_CTX *main_loop_talloc_get(void)
 {
     if (!main_loop_talloc) {
-        main_loop_talloc = talloc_init_named("main loop talloc (mainly parse_misc)");
+        main_loop_talloc = talloc_init("main loop talloc (mainly parse_misc)");
         if (!main_loop_talloc)
             smb_panic("main_loop_talloc: malloc fail\n");
     }
@@ -91,7 +91,7 @@
  Reads or writes a UTIME type.
 ********************************************************************/
 
-static BOOL smb_io_utime(char *desc, UTIME *t, prs_struct *ps, int depth)
+static BOOL smb_io_utime(const char *desc, UTIME *t, prs_struct *ps, int depth)
 {
 	if (t == NULL)
 		return False;
@@ -112,7 +112,7 @@
  Reads or writes an NTTIME structure.
 ********************************************************************/
 
-BOOL smb_io_time(char *desc, NTTIME *nttime, prs_struct *ps, int depth)
+BOOL smb_io_time(const char *desc, NTTIME *nttime, prs_struct *ps, int depth)
 {
 	if (nttime == NULL)
 		return False;
@@ -135,7 +135,7 @@
  Reads or writes a LOOKUP_LEVEL structure.
 ********************************************************************/
 
-BOOL smb_io_lookup_level(char *desc, LOOKUP_LEVEL *level, prs_struct *ps, int depth)
+BOOL smb_io_lookup_level(const char *desc, LOOKUP_LEVEL *level, prs_struct *ps, int depth)
 {
 	if (level == NULL)
 		return False;
@@ -178,7 +178,7 @@
  Reads or writes an ENUM_HND structure.
 ********************************************************************/
 
-BOOL smb_io_enum_hnd(char *desc, ENUM_HND *hnd, prs_struct *ps, int depth)
+BOOL smb_io_enum_hnd(const char *desc, ENUM_HND *hnd, prs_struct *ps, int depth)
 {
 	if (hnd == NULL)
 		return False;
@@ -204,7 +204,7 @@
  Reads or writes a DOM_SID structure.
 ********************************************************************/
 
-BOOL smb_io_dom_sid(char *desc, DOM_SID *sid, prs_struct *ps, int depth)
+BOOL smb_io_dom_sid(const char *desc, DOM_SID *sid, prs_struct *ps, int depth)
 {
 	int i;
 
@@ -216,6 +216,7 @@
 
 	if(!prs_uint8 ("sid_rev_num", ps, depth, &sid->sid_rev_num))
 		return False;
+
 	if(!prs_uint8 ("num_auths  ", ps, depth, &sid->num_auths))
 		return False;
 
@@ -301,7 +302,7 @@
  Reads or writes a DOM_SID2 structure.
 ********************************************************************/
 
-BOOL smb_io_dom_sid2(char *desc, DOM_SID2 *sid, prs_struct *ps, int depth)
+BOOL smb_io_dom_sid2(const char *desc, DOM_SID2 *sid, prs_struct *ps, int depth)
 {
 	if (sid == NULL)
 		return False;
@@ -336,7 +337,7 @@
  Reads or writes a STRHDR structure.
 ********************************************************************/
 
-BOOL smb_io_strhdr(char *desc,  STRHDR *hdr, prs_struct *ps, int depth)
+BOOL smb_io_strhdr(const char *desc,  STRHDR *hdr, prs_struct *ps, int depth)
 {
 	if (hdr == NULL)
 		return False;
@@ -371,7 +372,7 @@
  Reads or writes a UNIHDR structure.
 ********************************************************************/
 
-BOOL smb_io_unihdr(char *desc, UNIHDR *hdr, prs_struct *ps, int depth)
+BOOL smb_io_unihdr(const char *desc, UNIHDR *hdr, prs_struct *ps, int depth)
 {
 	if (hdr == NULL)
 		return False;
@@ -407,7 +408,7 @@
  uint16 should be stored, or gets the size if reading.
  ********************************************************************/
 
-BOOL smb_io_hdrbuf_pre(char *desc, BUFHDR *hdr, prs_struct *ps, int depth, uint32 *offset)
+BOOL smb_io_hdrbuf_pre(const char *desc, BUFHDR *hdr, prs_struct *ps, int depth, uint32 *offset)
 {
 	(*offset) = prs_offset(ps);
 	if (ps->io) {
@@ -433,7 +434,7 @@
  Does nothing on reading, as that is already handled by ...._pre()
  ********************************************************************/
 
-BOOL smb_io_hdrbuf_post(char *desc, BUFHDR *hdr, prs_struct *ps, int depth, 
+BOOL smb_io_hdrbuf_post(const char *desc, BUFHDR *hdr, prs_struct *ps, int depth, 
 				uint32 ptr_hdrbuf, uint32 max_len, uint32 len)
 {
 	if (!ps->io) {
@@ -458,7 +459,7 @@
  Reads or writes a BUFHDR structure.
 ********************************************************************/
 
-BOOL smb_io_hdrbuf(char *desc, BUFHDR *hdr, prs_struct *ps, int depth)
+BOOL smb_io_hdrbuf(const char *desc, BUFHDR *hdr, prs_struct *ps, int depth)
 {
 	if (hdr == NULL)
 		return False;
@@ -491,7 +492,7 @@
  Reads or writes a UNIHDR2 structure.
 ********************************************************************/
 
-BOOL smb_io_unihdr2(char *desc, UNIHDR2 *hdr2, prs_struct *ps, int depth)
+BOOL smb_io_unihdr2(const char *desc, UNIHDR2 *hdr2, prs_struct *ps, int depth)
 {
 	if (hdr2 == NULL)
 		return False;
@@ -542,7 +543,7 @@
 XXXX NOTE: UNISTR structures NEED to be null-terminated.
 ********************************************************************/
 
-BOOL smb_io_unistr(char *desc, UNISTR *uni, prs_struct *ps, int depth)
+BOOL smb_io_unistr(const char *desc, UNISTR *uni, prs_struct *ps, int depth)
 {
 	if (uni == NULL)
 		return False;
@@ -639,7 +640,7 @@
    the uni_str_len member tells you how much of the buffer is really used.
 ********************************************************************/
 
-BOOL smb_io_buffer3(char *desc, BUFFER3 *buf3, prs_struct *ps, int depth)
+BOOL smb_io_buffer3(const char *desc, BUFFER3 *buf3, prs_struct *ps, int depth)
 {
 	if (buf3 == NULL)
 		return False;
@@ -672,7 +673,7 @@
 reads or writes a BUFFER5 structure.
 the buf_len member tells you how large the buffer is.
 ********************************************************************/
-BOOL smb_io_buffer5(char *desc, BUFFER5 *buf5, prs_struct *ps, int depth)
+BOOL smb_io_buffer5(const char *desc, BUFFER5 *buf5, prs_struct *ps, int depth)
 {
 	prs_debug(ps, depth, desc, "smb_io_buffer5");
 	depth++;
@@ -721,7 +722,7 @@
    the uni_str_len member tells you how much of the buffer is really used.
 ********************************************************************/
 
-BOOL smb_io_buffer2(char *desc, BUFFER2 *buf2, uint32 buffer, prs_struct *ps, int depth)
+BOOL smb_io_buffer2(const char *desc, BUFFER2 *buf2, uint32 buffer, prs_struct *ps, int depth)
 {
 	if (buf2 == NULL)
 		return False;
@@ -844,7 +845,7 @@
    the str_max_len member tells you how large the buffer is.
 ********************************************************************/
 
-BOOL smb_io_string2(char *desc, STRING2 *str2, uint32 buffer, prs_struct *ps, int depth)
+BOOL smb_io_string2(const char *desc, STRING2 *str2, uint32 buffer, prs_struct *ps, int depth)
 {
 	if (str2 == NULL)
 		return False;
@@ -1006,7 +1007,7 @@
    the uni_max_len member tells you how large the buffer is.
 ********************************************************************/
 
-BOOL smb_io_unistr2(char *desc, UNISTR2 *uni2, uint32 buffer, prs_struct *ps, int depth)
+BOOL smb_io_unistr2(const char *desc, UNISTR2 *uni2, uint32 buffer, prs_struct *ps, int depth)
 {
 	if (uni2 == NULL)
 		return False;
@@ -1042,6 +1043,85 @@
 	return True;
 }
 
+
+/*
+  initialise a UNISTR_ARRAY from a char**
+*/
+BOOL init_unistr2_array(UNISTR2_ARRAY *array, 
+		       uint32 count, const char **strings)
+{
+	int i;
+
+	array->count = count;
+	array->ref_id = count?1:0;
+	if (array->count == 0) {
+		return True;
+	}
+
+	array->strings = (UNISTR2_ARRAY_EL *)talloc_zero(get_talloc_ctx(), count * sizeof(UNISTR2_ARRAY_EL));
+	if (!array->strings) {
+		return False;
+	}
+
+	for (i=0;i<count;i++) {
+		init_unistr2(&array->strings[i].string, strings[i], strlen(strings[i]));
+		array->strings[i].size = array->strings[i].string.uni_max_len*2;
+		array->strings[i].length = array->strings[i].size;
+		array->strings[i].ref_id = 1;
+	}
+
+	return True;
+}
+
+/*******************************************************************
+ Reads or writes a UNISTR2_ARRAY structure.
+********************************************************************/
+BOOL smb_io_unistr2_array(const char *desc, UNISTR2_ARRAY *array, prs_struct *ps, int depth)
+{
+	int i;
+
+	prs_debug(ps, depth, desc, "smb_io_unistr2_array");
+	depth++;
+
+	if(!prs_uint32("ref_id", ps, depth, &array->ref_id))
+		return False;
+
+	if (! array->ref_id) {
+		return True;
+	}
+
+	if(!prs_uint32("count", ps, depth, &array->count))
+		return False;
+
+	if (array->count == 0) {
+		return True;
+	}
+
+	if (UNMARSHALLING(ps)) {
+		array->strings = talloc_zero(get_talloc_ctx(), array->count * sizeof(array->strings[0]));
+	}
+	if (! array->strings) {
+		return False;
+	}
+
+	for (i=0;i<array->count;i++) {
+		if(!prs_uint16("length", ps, depth, &array->strings[i].length))
+			return False;
+		if(!prs_uint16("size", ps, depth, &array->strings[i].size))
+			return False;
+		if(!prs_uint32("ref_id", ps, depth, &array->strings[i].ref_id))
+			return False;
+	}
+
+	for (i=0;i<array->count;i++) {
+		if (! smb_io_unistr2("string", &array->strings[i].string, array->strings[i].ref_id, ps, depth)) 
+			return False;
+	}
+	
+	return True;
+}
+
+
 /*******************************************************************
  Inits a DOM_RID2 structure.
 ********************************************************************/
@@ -1057,7 +1137,7 @@
  Reads or writes a DOM_RID2 structure.
 ********************************************************************/
 
-BOOL smb_io_dom_rid2(char *desc, DOM_RID2 *rid2, prs_struct *ps, int depth)
+BOOL smb_io_dom_rid2(const char *desc, DOM_RID2 *rid2, prs_struct *ps, int depth)
 {
 	if (rid2 == NULL)
 		return False;
@@ -1097,7 +1177,7 @@
 reads or writes a DOM_RID3 structure.
 ********************************************************************/
 
-BOOL smb_io_dom_rid3(char *desc, DOM_RID3 *rid3, prs_struct *ps, int depth)
+BOOL smb_io_dom_rid3(const char *desc, DOM_RID3 *rid3, prs_struct *ps, int depth)
 {
 	if (rid3 == NULL)
 		return False;
@@ -1160,7 +1240,7 @@
  Inits or writes a DOM_CLNT_SRV structure.
 ********************************************************************/
 
-static BOOL smb_io_clnt_srv(char *desc, DOM_CLNT_SRV *log, prs_struct *ps, int depth)
+static BOOL smb_io_clnt_srv(const char *desc, DOM_CLNT_SRV *log, prs_struct *ps, int depth)
 {
 	if (log == NULL)
 		return False;
@@ -1216,7 +1296,7 @@
  Reads or writes a DOM_LOG_INFO structure.
 ********************************************************************/
 
-BOOL smb_io_log_info(char *desc, DOM_LOG_INFO *log, prs_struct *ps, int depth)
+BOOL smb_io_log_info(const char *desc, DOM_LOG_INFO *log, prs_struct *ps, int depth)
 {
 	if (log == NULL)
 		return False;
@@ -1248,7 +1328,7 @@
  Reads or writes a DOM_CHAL structure.
 ********************************************************************/
 
-BOOL smb_io_chal(char *desc, DOM_CHAL *chal, prs_struct *ps, int depth)
+BOOL smb_io_chal(const char *desc, DOM_CHAL *chal, prs_struct *ps, int depth)
 {
 	if (chal == NULL)
 		return False;
@@ -1266,7 +1346,7 @@
  Reads or writes a DOM_CRED structure.
 ********************************************************************/
 
-BOOL smb_io_cred(char *desc,  DOM_CRED *cred, prs_struct *ps, int depth)
+BOOL smb_io_cred(const char *desc,  DOM_CRED *cred, prs_struct *ps, int depth)
 {
 	if (cred == NULL)
 		return False;
@@ -1310,7 +1390,7 @@
  Reads or writes a DOM_CLNT_INFO2 structure.
 ********************************************************************/
 
-BOOL smb_io_clnt_info2(char *desc, DOM_CLNT_INFO2 *clnt, prs_struct *ps, int depth)
+BOOL smb_io_clnt_info2(const char *desc, DOM_CLNT_INFO2 *clnt, prs_struct *ps, int depth)
 {
 	if (clnt == NULL)
 		return False;
@@ -1354,7 +1434,7 @@
  Reads or writes a DOM_CLNT_INFO structure.
 ********************************************************************/
 
-BOOL smb_io_clnt_info(char *desc,  DOM_CLNT_INFO *clnt, prs_struct *ps, int depth)
+BOOL smb_io_clnt_info(const char *desc,  DOM_CLNT_INFO *clnt, prs_struct *ps, int depth)
 {
 	if (clnt == NULL)
 		return False;
@@ -1389,7 +1469,7 @@
  Reads or writes a DOM_LOGON_ID structure.
 ********************************************************************/
 
-BOOL smb_io_logon_id(char *desc, DOM_LOGON_ID *log, prs_struct *ps, int depth)
+BOOL smb_io_logon_id(const char *desc, DOM_LOGON_ID *log, prs_struct *ps, int depth)
 {
 	if (log == NULL)
 		return False;
@@ -1426,7 +1506,7 @@
  Reads or writes an OWF_INFO structure.
 ********************************************************************/
 
-BOOL smb_io_owf_info(char *desc, OWF_INFO *hash, prs_struct *ps, int depth)
+BOOL smb_io_owf_info(const char *desc, OWF_INFO *hash, prs_struct *ps, int depth)
 {
 	if (hash == NULL)
 		return False;
@@ -1447,7 +1527,7 @@
  Reads or writes a DOM_GID structure.
 ********************************************************************/
 
-BOOL smb_io_gid(char *desc,  DOM_GID *gid, prs_struct *ps, int depth)
+BOOL smb_io_gid(const char *desc,  DOM_GID *gid, prs_struct *ps, int depth)
 {
 	if (gid == NULL)
 		return False;
@@ -1470,7 +1550,7 @@
  Reads or writes an POLICY_HND structure.
 ********************************************************************/
 
-BOOL smb_io_pol_hnd(char *desc, POLICY_HND *pol, prs_struct *ps, int depth)
+BOOL smb_io_pol_hnd(const char *desc, POLICY_HND *pol, prs_struct *ps, int depth)
 {
 	if (pol == NULL)
 		return False;
@@ -1532,7 +1612,7 @@
  Reads or writes a UNISTR3 structure.
 ********************************************************************/
 
-BOOL smb_io_unistr3(char *desc, UNISTR3 *name, prs_struct *ps, int depth)
+BOOL smb_io_unistr3(const char *desc, UNISTR3 *name, prs_struct *ps, int depth)
 {
 	if (name == NULL)
 		return False;
@@ -1559,7 +1639,7 @@
 /*******************************************************************
  Stream a uint64_struct
  ********************************************************************/
-BOOL prs_uint64(char *name, prs_struct *ps, int depth, UINT64_S *data64)
+BOOL prs_uint64(const char *name, prs_struct *ps, int depth, UINT64_S *data64)
 {
 	return prs_uint32(name, ps, depth+1, &data64->low) &&
 		prs_uint32(name, ps, depth+1, &data64->high);
@@ -1568,7 +1648,7 @@
 /*******************************************************************
 reads or writes a BUFHDR2 structure.
 ********************************************************************/
-BOOL smb_io_bufhdr2(char *desc, BUFHDR2 *hdr, prs_struct *ps, int depth)
+BOOL smb_io_bufhdr2(const char *desc, BUFHDR2 *hdr, prs_struct *ps, int depth)
 {
 	prs_debug(ps, depth, desc, "smb_io_bufhdr2");
 	depth++;
@@ -1584,7 +1664,7 @@
 /*******************************************************************
 reads or writes a BUFFER4 structure.
 ********************************************************************/
-BOOL smb_io_buffer4(char *desc, BUFFER4 *buf4, uint32 buffer, prs_struct *ps, int depth)
+BOOL smb_io_buffer4(const char *desc, BUFFER4 *buf4, uint32 buffer, prs_struct *ps, int depth)
 {
 	prs_debug(ps, depth, desc, "smb_io_buffer4");
 	depth++;
diff -uNr samba-3.0alpha21.orig/source/rpc_parse/parse_net.c samba-3.0alpha21/source/rpc_parse/parse_net.c
--- samba-3.0alpha21.orig/source/rpc_parse/parse_net.c	2003-02-16 19:06:32.000000000 -0600
+++ samba-3.0alpha21/source/rpc_parse/parse_net.c	2003-02-16 19:05:46.000000000 -0600
@@ -30,7 +30,7 @@
  Reads or writes a structure.
 ********************************************************************/
 
-static BOOL net_io_neg_flags(char *desc, NEG_FLAGS *neg, prs_struct *ps, int depth)
+static BOOL net_io_neg_flags(const char *desc, NEG_FLAGS *neg, prs_struct *ps, int depth)
 {
 	if (neg == NULL)
 		return False;
@@ -66,7 +66,7 @@
  Reads or writes a NETLOGON_INFO_3 structure.
 ********************************************************************/
 
-static BOOL net_io_netinfo_3(char *desc,  NETLOGON_INFO_3 *info, prs_struct *ps, int depth)
+static BOOL net_io_netinfo_3(const char *desc,  NETLOGON_INFO_3 *info, prs_struct *ps, int depth)
 {
 	if (info == NULL)
 		return False;
@@ -110,7 +110,7 @@
  Reads or writes a NETLOGON_INFO_1 structure.
 ********************************************************************/
 
-static BOOL net_io_netinfo_1(char *desc, NETLOGON_INFO_1 *info, prs_struct *ps, int depth)
+static BOOL net_io_netinfo_1(const char *desc, NETLOGON_INFO_1 *info, prs_struct *ps, int depth)
 {
 	if (info == NULL)
 		return False;
@@ -152,7 +152,7 @@
  Reads or writes a NETLOGON_INFO_2 structure.
 ********************************************************************/
 
-static BOOL net_io_netinfo_2(char *desc, NETLOGON_INFO_2 *info, prs_struct *ps, int depth)
+static BOOL net_io_netinfo_2(const char *desc, NETLOGON_INFO_2 *info, prs_struct *ps, int depth)
 {
 	if (info == NULL)
 		return False;
@@ -187,7 +187,7 @@
  Reads or writes an NET_Q_LOGON_CTRL2 structure.
 ********************************************************************/
 
-BOOL net_io_q_logon_ctrl2(char *desc, NET_Q_LOGON_CTRL2 *q_l, prs_struct *ps, int depth)
+BOOL net_io_q_logon_ctrl2(const char *desc, NET_Q_LOGON_CTRL2 *q_l, prs_struct *ps, int depth)
 {
 	if (q_l == NULL)
 		return False;
@@ -278,7 +278,7 @@
  Reads or writes an NET_R_LOGON_CTRL2 structure.
 ********************************************************************/
 
-BOOL net_io_r_logon_ctrl2(char *desc, NET_R_LOGON_CTRL2 *r_l, prs_struct *ps, int depth)
+BOOL net_io_r_logon_ctrl2(const char *desc, NET_R_LOGON_CTRL2 *r_l, prs_struct *ps, int depth)
 {
 	if (r_l == NULL)
 		return False;
@@ -322,7 +322,7 @@
  Reads or writes an NET_Q_LOGON_CTRL structure.
 ********************************************************************/
 
-BOOL net_io_q_logon_ctrl(char *desc, NET_Q_LOGON_CTRL *q_l, prs_struct *ps, 
+BOOL net_io_q_logon_ctrl(const char *desc, NET_Q_LOGON_CTRL *q_l, prs_struct *ps, 
 			 int depth)
 {
 	prs_debug(ps, depth, desc, "net_io_q_logon_ctrl");
@@ -395,7 +395,7 @@
  Reads or writes an NET_R_LOGON_CTRL structure.
 ********************************************************************/
 
-BOOL net_io_r_logon_ctrl(char *desc, NET_R_LOGON_CTRL *r_l, prs_struct *ps, 
+BOOL net_io_r_logon_ctrl(const char *desc, NET_R_LOGON_CTRL *r_l, prs_struct *ps, 
 			 int depth)
 {
 	prs_debug(ps, depth, desc, "net_io_r_logon_ctrl");
@@ -459,7 +459,7 @@
  Reads or writes an NET_R_TRUST_DOM_LIST structure.
 ********************************************************************/
 
-BOOL net_io_r_trust_dom(char *desc, NET_R_TRUST_DOM_LIST *r_t, prs_struct *ps, int depth)
+BOOL net_io_r_trust_dom(const char *desc, NET_R_TRUST_DOM_LIST *r_t, prs_struct *ps, int depth)
 {
 	uint32 value;
 
@@ -511,7 +511,7 @@
  Reads or writes an NET_Q_TRUST_DOM_LIST structure.
 ********************************************************************/
 
-BOOL net_io_q_trust_dom(char *desc, NET_Q_TRUST_DOM_LIST *q_l, prs_struct *ps, int depth)
+BOOL net_io_q_trust_dom(const char *desc, NET_Q_TRUST_DOM_LIST *q_l, prs_struct *ps, int depth)
 {
 	if (q_l == NULL)
 		 return False;
@@ -551,7 +551,7 @@
  Reads or writes an NET_Q_REQ_CHAL structure.
 ********************************************************************/
 
-BOOL net_io_q_req_chal(char *desc,  NET_Q_REQ_CHAL *q_c, prs_struct *ps, int depth)
+BOOL net_io_q_req_chal(const char *desc,  NET_Q_REQ_CHAL *q_c, prs_struct *ps, int depth)
 {
 	if (q_c == NULL)
 		return False;
@@ -580,7 +580,7 @@
  Reads or writes a structure.
 ********************************************************************/
 
-BOOL net_io_r_req_chal(char *desc, NET_R_REQ_CHAL *r_c, prs_struct *ps, int depth)
+BOOL net_io_r_req_chal(const char *desc, NET_R_REQ_CHAL *r_c, prs_struct *ps, int depth)
 {
 	if (r_c == NULL)
 		return False;
@@ -605,7 +605,7 @@
  Reads or writes a structure.
 ********************************************************************/
 
-BOOL net_io_q_auth(char *desc, NET_Q_AUTH *q_a, prs_struct *ps, int depth)
+BOOL net_io_q_auth(const char *desc, NET_Q_AUTH *q_a, prs_struct *ps, int depth)
 {
 	if (q_a == NULL)
 		return False;
@@ -628,7 +628,7 @@
  Reads or writes a structure.
 ********************************************************************/
 
-BOOL net_io_r_auth(char *desc, NET_R_AUTH *r_a, prs_struct *ps, int depth)
+BOOL net_io_r_auth(const char *desc, NET_R_AUTH *r_a, prs_struct *ps, int depth)
 {
 	if (r_a == NULL)
 		return False;
@@ -669,7 +669,7 @@
  Reads or writes a structure.
 ********************************************************************/
 
-BOOL net_io_q_auth_2(char *desc, NET_Q_AUTH_2 *q_a, prs_struct *ps, int depth)
+BOOL net_io_q_auth_2(const char *desc, NET_Q_AUTH_2 *q_a, prs_struct *ps, int depth)
 {
 	if (q_a == NULL)
 		return False;
@@ -694,7 +694,7 @@
  Reads or writes a structure.
 ********************************************************************/
 
-BOOL net_io_r_auth_2(char *desc, NET_R_AUTH_2 *r_a, prs_struct *ps, int depth)
+BOOL net_io_r_auth_2(const char *desc, NET_R_AUTH_2 *r_a, prs_struct *ps, int depth)
 {
 	if (r_a == NULL)
 		return False;
@@ -737,7 +737,7 @@
  Reads or writes a structure.
 ********************************************************************/
 
-BOOL net_io_q_auth_3(char *desc, NET_Q_AUTH_3 *q_a, prs_struct *ps, int depth)
+BOOL net_io_q_auth_3(const char *desc, NET_Q_AUTH_3 *q_a, prs_struct *ps, int depth)
 {
 	if (q_a == NULL)
 		return False;
@@ -762,7 +762,7 @@
  Reads or writes a structure.
 ********************************************************************/
 
-BOOL net_io_r_auth_3(char *desc, NET_R_AUTH_3 *r_a, prs_struct *ps, int depth)
+BOOL net_io_r_auth_3(const char *desc, NET_R_AUTH_3 *r_a, prs_struct *ps, int depth)
 {
 	if (r_a == NULL)
 		return False;
@@ -812,7 +812,7 @@
  Reads or writes a structure.
 ********************************************************************/
 
-BOOL net_io_q_srv_pwset(char *desc, NET_Q_SRV_PWSET *q_s, prs_struct *ps, int depth)
+BOOL net_io_q_srv_pwset(const char *desc, NET_Q_SRV_PWSET *q_s, prs_struct *ps, int depth)
 {
 	if (q_s == NULL)
 		return False;
@@ -835,7 +835,7 @@
  Reads or writes a structure.
 ********************************************************************/
 
-BOOL net_io_r_srv_pwset(char *desc, NET_R_SRV_PWSET *r_s, prs_struct *ps, int depth)
+BOOL net_io_r_srv_pwset(const char *desc, NET_R_SRV_PWSET *r_s, prs_struct *ps, int depth)
 {
 	if (r_s == NULL)
 		return False;
@@ -967,7 +967,7 @@
  Reads or writes an NET_ID_INFO_1 structure.
 ********************************************************************/
 
-static BOOL net_io_id_info1(char *desc,  NET_ID_INFO_1 *id, prs_struct *ps, int depth)
+static BOOL net_io_id_info1(const char *desc,  NET_ID_INFO_1 *id, prs_struct *ps, int depth)
 {
 	if (id == NULL)
 		return False;
@@ -1083,7 +1083,7 @@
  Reads or writes an NET_ID_INFO_2 structure.
 ********************************************************************/
 
-static BOOL net_io_id_info2(char *desc,  NET_ID_INFO_2 *id, prs_struct *ps, int depth)
+static BOOL net_io_id_info2(const char *desc,  NET_ID_INFO_2 *id, prs_struct *ps, int depth)
 {
 	if (id == NULL)
 		return False;
@@ -1169,7 +1169,7 @@
  Reads or writes a DOM_SAM_INFO structure.
 ********************************************************************/
 
-static BOOL net_io_id_info_ctr(char *desc, NET_ID_INFO_CTR **pp_ctr, prs_struct *ps, int depth)
+static BOOL net_io_id_info_ctr(const char *desc, NET_ID_INFO_CTR **pp_ctr, prs_struct *ps, int depth)
 {
 	NET_ID_INFO_CTR *ctr = *pp_ctr;
 
@@ -1212,7 +1212,7 @@
  Reads or writes a DOM_SAM_INFO structure.
  ********************************************************************/
 
-static BOOL smb_io_sam_info(char *desc, DOM_SAM_INFO *sam, prs_struct *ps, int depth)
+static BOOL smb_io_sam_info(const char *desc, DOM_SAM_INFO *sam, prs_struct *ps, int depth)
 {
 	if (sam == NULL)
 		return False;
@@ -1271,7 +1271,7 @@
 			 
 			 uint16 logon_count, uint16 bad_pw_count,
  		 	 uint32 num_groups, const DOM_GID *gids,
-			 uint32 user_flgs, uchar *sess_key,
+			 uint32 user_flgs, uchar sess_key[16],
  			 const char *logon_srv, const char *logon_dom,
 			 const DOM_SID *dom_sid, const char *other_sids)
 {
@@ -1448,7 +1448,7 @@
 	if(!prs_uint32("user_flgs     ", ps, depth, &usr->user_flgs))     /* user flags */
 		return False;
 
-	if(!prs_uint8s(False, "user_sess_key", ps, depth, usr->user_sess_key, 16)) /* unused user session key */
+	if(!prs_uint8s(False, "user_sess_key", ps, depth, usr->user_sess_key, 16)) /* user session key */
 		return False;
 
 	if(!smb_io_unihdr("hdr_logon_srv", &usr->hdr_logon_srv, ps, depth)) /* logon server unicode string header */
@@ -1544,7 +1544,7 @@
  Reads or writes a structure.
 ********************************************************************/
 
-BOOL net_io_q_sam_logon(char *desc, NET_Q_SAM_LOGON *q_l, prs_struct *ps, int depth)
+BOOL net_io_q_sam_logon(const char *desc, NET_Q_SAM_LOGON *q_l, prs_struct *ps, int depth)
 {
 	if (q_l == NULL)
 		return False;
@@ -1568,7 +1568,7 @@
  Reads or writes a structure.
 ********************************************************************/
 
-BOOL net_io_r_sam_logon(char *desc, NET_R_SAM_LOGON *r_l, prs_struct *ps, int depth)
+BOOL net_io_r_sam_logon(const char *desc, NET_R_SAM_LOGON *r_l, prs_struct *ps, int depth)
 {
 	if (r_l == NULL)
 		return False;
@@ -1612,7 +1612,7 @@
  Reads or writes a structure.
 ********************************************************************/
 
-BOOL net_io_q_sam_logoff(char *desc,  NET_Q_SAM_LOGOFF *q_l, prs_struct *ps, int depth)
+BOOL net_io_q_sam_logoff(const char *desc,  NET_Q_SAM_LOGOFF *q_l, prs_struct *ps, int depth)
 {
 	if (q_l == NULL)
 		return False;
@@ -1633,7 +1633,7 @@
  Reads or writes a structure.
 ********************************************************************/
 
-BOOL net_io_r_sam_logoff(char *desc, NET_R_SAM_LOGOFF *r_l, prs_struct *ps, int depth)
+BOOL net_io_r_sam_logoff(const char *desc, NET_R_SAM_LOGOFF *r_l, prs_struct *ps, int depth)
 {
 	if (r_l == NULL)
 		return False;
@@ -1687,7 +1687,7 @@
 /*******************************************************************
 reads or writes a structure.
 ********************************************************************/
-BOOL net_io_q_sam_sync(char *desc, NET_Q_SAM_SYNC * q_s, prs_struct *ps,
+BOOL net_io_q_sam_sync(const char *desc, NET_Q_SAM_SYNC * q_s, prs_struct *ps,
 		       int depth)
 {
 	prs_debug(ps, depth, desc, "net_io_q_sam_sync");
@@ -1719,7 +1719,7 @@
 /*******************************************************************
 reads or writes a structure.
 ********************************************************************/
-static BOOL net_io_sam_delta_hdr(char *desc, SAM_DELTA_HDR * delta,
+static BOOL net_io_sam_delta_hdr(const char *desc, SAM_DELTA_HDR * delta,
 				 prs_struct *ps, int depth)
 {
 	prs_debug(ps, depth, desc, "net_io_sam_delta_hdr");
@@ -1749,7 +1749,7 @@
 /*******************************************************************
 reads or writes a structure.
 ********************************************************************/
-static BOOL net_io_sam_delta_mod_count(char *desc, SAM_DELTA_MOD_COUNT *info,
+static BOOL net_io_sam_delta_mod_count(const char *desc, SAM_DELTA_MOD_COUNT *info,
                                    prs_struct *ps, int depth)
 {
 	prs_debug(ps, depth, desc, "net_io_sam_delta_stamp");
@@ -1773,7 +1773,7 @@
 /*******************************************************************
 reads or writes a structure.
 ********************************************************************/
-static BOOL net_io_sam_domain_info(char *desc, SAM_DOMAIN_INFO * info,
+static BOOL net_io_sam_domain_info(const char *desc, SAM_DOMAIN_INFO * info,
 				   prs_struct *ps, int depth)
 {
 	prs_debug(ps, depth, desc, "net_io_sam_domain_info");
@@ -1804,9 +1804,9 @@
 	if (!smb_io_unihdr("hdr_unknown", &info->hdr_unknown, ps, depth))
                 return False;
 
-	if (ps->data_offset + 40 > ps->buffer_size)
+	if (prs_offset(ps) + 40 > prs_data_size(ps))
                 return False;
-        ps->data_offset += 40;
+        prs_set_offset(ps, prs_offset(ps) + 40);
 
 	if (!smb_io_unistr2("uni_dom_name", &info->uni_dom_name,
                             info->hdr_dom_name.buffer, ps, depth))
@@ -1828,7 +1828,7 @@
 /*******************************************************************
 reads or writes a structure.
 ********************************************************************/
-static BOOL net_io_sam_group_info(char *desc, SAM_GROUP_INFO * info,
+static BOOL net_io_sam_group_info(const char *desc, SAM_GROUP_INFO * info,
 				  prs_struct *ps, int depth)
 {
 	prs_debug(ps, depth, desc, "net_io_sam_group_info");
@@ -1843,9 +1843,9 @@
 	if (!smb_io_bufhdr2("hdr_sec_desc", &info->hdr_sec_desc, ps, depth))
                 return False;
 
-        if (ps->data_offset + 48 > ps->buffer_size)
+	if (prs_offset(ps) + 48 > prs_data_size(ps))
                 return False;
-	ps->data_offset += 48;
+        prs_set_offset(ps, prs_offset(ps) + 48);
 
 	if (!smb_io_unistr2("uni_grp_name", &info->uni_grp_name,
                             info->hdr_grp_name.buffer, ps, depth))
@@ -1863,7 +1863,7 @@
 /*******************************************************************
 reads or writes a structure.
 ********************************************************************/
-static BOOL net_io_sam_passwd_info(char *desc, SAM_PWD * pwd,
+static BOOL net_io_sam_passwd_info(const char *desc, SAM_PWD * pwd,
 				   prs_struct *ps, int depth)
 {
 	prs_debug(ps, depth, desc, "net_io_sam_passwd_info");
@@ -1973,7 +1973,7 @@
 /*******************************************************************
 reads or writes a structure.
 ********************************************************************/
-static BOOL net_io_sam_account_info(char *desc, uint8 sess_key[16],
+static BOOL net_io_sam_account_info(const char *desc, uint8 sess_key[16],
 				    SAM_ACCOUNT_INFO * info, prs_struct *ps,
 				    int depth)
 {
@@ -2124,13 +2124,13 @@
 		uint32 len = 0x44;
 		if (!prs_uint32("pwd_len", ps, depth, &len))
                         return False;
-		old_offset = ps->data_offset;
+		old_offset = prs_offset(ps);
 		if (len == 0x44)
 		{
 			if (ps->io)
 			{
 				/* reading */
-                                if (!prs_hash1(ps, ps->data_offset, sess_key))
+                                if (!prs_hash1(ps, prs_offset(ps), sess_key))
                                         return False;
 			}
 			if (!net_io_sam_passwd_info("pass", &info->pass, 
@@ -2144,9 +2144,9 @@
                                         return False;
 			}
 		}
-                if (old_offset + len > ps->buffer_size)
+                if (old_offset + len > prs_data_size(ps))
                         return False;
-		ps->data_offset = old_offset + len;
+		prs_set_offset(ps, old_offset + len);
 	}
 	if (!smb_io_buffer4("buf_sec_desc", &info->buf_sec_desc,
                             info->hdr_sec_desc.buffer, ps, depth))
@@ -2164,7 +2164,7 @@
 /*******************************************************************
 reads or writes a structure.
 ********************************************************************/
-static BOOL net_io_sam_group_mem_info(char *desc, SAM_GROUP_MEM_INFO * info,
+static BOOL net_io_sam_group_mem_info(const char *desc, SAM_GROUP_MEM_INFO * info,
 				      prs_struct *ps, int depth)
 {
 	uint32 i;
@@ -2181,9 +2181,9 @@
 	if (!prs_uint32("num_members", ps, depth, &info->num_members))
                 return False;
 
-        if (ps->data_offset + 16 > ps->buffer_size)
+        if (prs_offset(ps) + 16 > prs_data_size(ps))
                 return False;
-	ps->data_offset += 16;
+	prs_set_offset(ps, prs_offset(ps) + 16);
 
 	if (info->ptr_rids != 0)
 	{
@@ -2248,7 +2248,7 @@
 /*******************************************************************
 reads or writes a structure.
 ********************************************************************/
-static BOOL net_io_sam_alias_info(char *desc, SAM_ALIAS_INFO * info,
+static BOOL net_io_sam_alias_info(const char *desc, SAM_ALIAS_INFO * info,
 				  prs_struct *ps, int depth)
 {
 	prs_debug(ps, depth, desc, "net_io_sam_alias_info");
@@ -2263,9 +2263,9 @@
 	if (!smb_io_unihdr("hdr_als_desc", &info->hdr_als_desc, ps, depth))
                 return False;
 
-        if (ps->data_offset + 40 > ps->buffer_size)
+        if (prs_offset(ps) + 40 > prs_data_size(ps))
                 return False;
-	ps->data_offset += 40;
+	prs_set_offset(ps, prs_offset(ps) + 40);
 
 	if (!smb_io_unistr2("uni_als_name", &info->uni_als_name,
                             info->hdr_als_name.buffer, ps, depth))
@@ -2283,7 +2283,7 @@
 /*******************************************************************
 reads or writes a structure.
 ********************************************************************/
-static BOOL net_io_sam_alias_mem_info(char *desc, SAM_ALIAS_MEM_INFO * info,
+static BOOL net_io_sam_alias_mem_info(const char *desc, SAM_ALIAS_MEM_INFO * info,
 				      prs_struct *ps, int depth)
 {
 	uint32 i;
@@ -2300,9 +2300,9 @@
 
 	if (info->ptr_members != 0)
 	{
-                if (ps->data_offset + 16 > ps->buffer_size)
+                if (prs_offset(ps) + 16 > prs_data_size(ps))
                         return False;
-                ps->data_offset += 16;
+                prs_set_offset(ps, prs_offset(ps) + 16);
 
 		if (!prs_uint32("num_sids", ps, depth, &info->num_sids))
                         return False;
@@ -2356,7 +2356,7 @@
 /*******************************************************************
 reads or writes a structure.
 ********************************************************************/
-static BOOL net_io_sam_policy_info(char *desc, SAM_DELTA_POLICY *info,
+static BOOL net_io_sam_policy_info(const char *desc, SAM_DELTA_POLICY *info,
 				      prs_struct *ps, int depth)
 {
 	int i;
@@ -2442,7 +2442,7 @@
 /*******************************************************************
 reads or writes a structure.
 ********************************************************************/
-static BOOL net_io_sam_trustdoms_info(char *desc, SAM_DELTA_TRUSTDOMS *info,
+static BOOL net_io_sam_trustdoms_info(const char *desc, SAM_DELTA_TRUSTDOMS *info,
 				      prs_struct *ps, int depth)
 {
 	int i;
@@ -2490,7 +2490,7 @@
 /*******************************************************************
 reads or writes a structure.
 ********************************************************************/
-static BOOL net_io_sam_secret_info(char *desc, SAM_DELTA_SECRET *info,
+static BOOL net_io_sam_secret_info(const char *desc, SAM_DELTA_SECRET *info,
 				   prs_struct *ps, int depth)
 {
 	int i;
@@ -2577,7 +2577,7 @@
 /*******************************************************************
 reads or writes a structure.
 ********************************************************************/
-static BOOL net_io_sam_privs_info(char *desc, SAM_DELTA_PRIVS *info,
+static BOOL net_io_sam_privs_info(const char *desc, SAM_DELTA_PRIVS *info,
 				      prs_struct *ps, int depth)
 {
 	int i;
@@ -2664,7 +2664,7 @@
 /*******************************************************************
 reads or writes a structure.
 ********************************************************************/
-static BOOL net_io_sam_delta_ctr(char *desc, uint8 sess_key[16],
+static BOOL net_io_sam_delta_ctr(const char *desc, uint8 sess_key[16],
 				 SAM_DELTA_CTR * delta, uint16 type,
 				 prs_struct *ps, int depth)
 {
@@ -2746,7 +2746,7 @@
 /*******************************************************************
 reads or writes a structure.
 ********************************************************************/
-BOOL net_io_r_sam_sync(char *desc, uint8 sess_key[16],
+BOOL net_io_r_sam_sync(const char *desc, uint8 sess_key[16],
 		       NET_R_SAM_SYNC * r_s, prs_struct *ps, int depth)
 {
 	uint32 i;
@@ -2859,7 +2859,7 @@
 /*******************************************************************
 reads or writes a structure.
 ********************************************************************/
-BOOL net_io_q_sam_deltas(char *desc, NET_Q_SAM_DELTAS *q_s, prs_struct *ps,
+BOOL net_io_q_sam_deltas(const char *desc, NET_Q_SAM_DELTAS *q_s, prs_struct *ps,
                          int depth)
 {
 	prs_debug(ps, depth, desc, "net_io_q_sam_deltas");
@@ -2888,7 +2888,7 @@
 /*******************************************************************
 reads or writes a structure.
 ********************************************************************/
-BOOL net_io_r_sam_deltas(char *desc, uint8 sess_key[16],
+BOOL net_io_r_sam_deltas(const char *desc, uint8 sess_key[16],
                          NET_R_SAM_DELTAS *r_s, prs_struct *ps, int depth)
 {
         int i;
diff -uNr samba-3.0alpha21.orig/source/rpc_parse/parse_prs.c samba-3.0alpha21/source/rpc_parse/parse_prs.c
--- samba-3.0alpha21.orig/source/rpc_parse/parse_prs.c	2003-02-16 19:06:32.000000000 -0600
+++ samba-3.0alpha21/source/rpc_parse/parse_prs.c	2003-02-16 19:05:46.000000000 -0600
@@ -76,7 +76,7 @@
  XXXX side-effect of this function is to increase the debug depth XXXX
 
  ********************************************************************/
-void prs_debug(prs_struct *ps, int depth, const char *desc, char *fn_name)
+void prs_debug(prs_struct *ps, int depth, const char *desc, const char *fn_name)
 {
 	DEBUG(5+depth, ("%s%06x %s %s\n", tab_depth(depth), ps->data_offset, fn_name, desc));
 }
@@ -116,25 +116,6 @@
 }
 
 /*******************************************************************
- read from a socket into memory.
- ********************************************************************/
-BOOL prs_read(prs_struct *ps, int fd, size_t len, int timeout)
-{
-	BOOL ok;
-	size_t prev_size = ps->buffer_size;
-	if (!prs_grow(ps, len))
-		return False;
-
-	if (timeout > 0) {
-		ok = (read_with_timeout(fd, &ps->data_p[prev_size],
-		                            len, len,timeout) == len);
-	} else {
-		ok = (read_data(fd, &ps->data_p[prev_size], len) == len);
-	}
-	return ok;
-}
-
-/*******************************************************************
  Delete the memory in a parse structure - if we own it.
  ********************************************************************/
 
@@ -153,7 +134,8 @@
 
 void prs_mem_clear(prs_struct *ps)
 {
-	memset(ps->data_p, '\0', (size_t)ps->buffer_size);
+	if (ps->buffer_size)
+		memset(ps->data_p, '\0', (size_t)ps->buffer_size);
 }
 
 /*******************************************************************
@@ -162,11 +144,13 @@
 
 char *prs_alloc_mem(prs_struct *ps, size_t size)
 {
-	char *ret = talloc(ps->mem_ctx, size);
-
-	if (ret)
-		memset(ret, '\0', size);
+	char *ret = NULL;
 
+	if (size) {
+		ret = talloc(ps->mem_ctx, size);
+		if (ret)
+			memset(ret, '\0', size);
+	}
 	return ret;
 }
 
@@ -327,7 +311,7 @@
 
 /*******************************************************************
  Get the data pointer (external interface).
- ********************************************************************/
+********************************************************************/
 
 char *prs_data_p(prs_struct *ps)
 {
@@ -376,10 +360,13 @@
 
 BOOL prs_append_prs_data(prs_struct *dst, prs_struct *src)
 {
+	if (prs_offset(src) == 0)
+		return True;
+
 	if(!prs_grow(dst, prs_offset(src)))
 		return False;
 
-	memcpy(&dst->data_p[dst->data_offset], prs_data_p(src), (size_t)prs_offset(src));
+	memcpy(&dst->data_p[dst->data_offset], src->data_p, (size_t)prs_offset(src));
 	dst->data_offset += prs_offset(src);
 
 	return True;
@@ -397,7 +384,7 @@
 	if(!prs_grow(dst, len))
 		return False;
 	
-	memcpy(&dst->data_p[dst->data_offset], prs_data_p(src)+start, (size_t)len);
+	memcpy(&dst->data_p[dst->data_offset], src->data_p + start, (size_t)len);
 	dst->data_offset += len;
 
 	return True;
@@ -407,8 +394,11 @@
  Append the data from a buffer into a parse_struct.
  ********************************************************************/
 
-BOOL prs_append_data(prs_struct *dst, char *src, uint32 len)
+BOOL prs_copy_data_in(prs_struct *dst, char *src, uint32 len)
 {
+	if (len == 0)
+		return True;
+
 	if(!prs_grow(dst, len))
 		return False;
 
@@ -419,6 +409,39 @@
 }
 
 /*******************************************************************
+ Copy some data from a parse_struct into a buffer.
+ ********************************************************************/
+
+BOOL prs_copy_data_out(char *dst, prs_struct *src, uint32 len)
+{
+	if (len == 0)
+		return True;
+
+	if(!prs_mem_get(src, len))
+		return False;
+
+	memcpy(dst, &src->data_p[src->data_offset], (size_t)len);
+	src->data_offset += len;
+
+	return True;
+}
+
+/*******************************************************************
+ Copy all the data from a parse_struct into a buffer.
+ ********************************************************************/
+
+BOOL prs_copy_all_data_out(char *dst, prs_struct *src)
+{
+	uint32 len = prs_offset(src);
+
+	if (!len)
+		return True;
+
+	prs_set_offset(src, 0);
+	return prs_copy_data_out(dst, src, len);
+}
+
+/*******************************************************************
  Set the data as X-endian (external interface).
  ********************************************************************/
 
@@ -539,7 +562,7 @@
  Stream a uint8.
  ********************************************************************/
 
-BOOL prs_uint8(char *name, prs_struct *ps, int depth, uint8 *data8)
+BOOL prs_uint8(const char *name, prs_struct *ps, int depth, uint8 *data8)
 {
 	char *q = prs_mem_get(ps, 1);
 	if (q == NULL)
@@ -561,7 +584,7 @@
  Stream a uint16.
  ********************************************************************/
 
-BOOL prs_uint16(char *name, prs_struct *ps, int depth, uint16 *data16)
+BOOL prs_uint16(const char *name, prs_struct *ps, int depth, uint16 *data16)
 {
 	char *q = prs_mem_get(ps, sizeof(uint16));
 	if (q == NULL)
@@ -590,7 +613,7 @@
  Stream a uint32.
  ********************************************************************/
 
-BOOL prs_uint32(char *name, prs_struct *ps, int depth, uint32 *data32)
+BOOL prs_uint32(const char *name, prs_struct *ps, int depth, uint32 *data32)
 {
 	char *q = prs_mem_get(ps, sizeof(uint32));
 	if (q == NULL)
@@ -619,7 +642,7 @@
  Stream a NTSTATUS
  ********************************************************************/
 
-BOOL prs_ntstatus(char *name, prs_struct *ps, int depth, NTSTATUS *status)
+BOOL prs_ntstatus(const char *name, prs_struct *ps, int depth, NTSTATUS *status)
 {
 	char *q = prs_mem_get(ps, sizeof(uint32));
 	if (q == NULL)
@@ -649,7 +672,7 @@
  Stream a WERROR
  ********************************************************************/
 
-BOOL prs_werror(char *name, prs_struct *ps, int depth, WERROR *status)
+BOOL prs_werror(const char *name, prs_struct *ps, int depth, WERROR *status)
 {
 	char *q = prs_mem_get(ps, sizeof(uint32));
 	if (q == NULL)
@@ -680,7 +703,7 @@
  Stream an array of uint8s. Length is number of uint8s.
  ********************************************************************/
 
-BOOL prs_uint8s(BOOL charmode, char *name, prs_struct *ps, int depth, uint8 *data8s, int len)
+BOOL prs_uint8s(BOOL charmode, const char *name, prs_struct *ps, int depth, uint8 *data8s, int len)
 {
 	int i;
 	char *q = prs_mem_get(ps, len);
@@ -713,7 +736,7 @@
  Stream an array of uint16s. Length is number of uint16s.
  ********************************************************************/
 
-BOOL prs_uint16s(BOOL charmode, char *name, prs_struct *ps, int depth, uint16 *data16s, int len)
+BOOL prs_uint16s(BOOL charmode, const char *name, prs_struct *ps, int depth, uint16 *data16s, int len)
 {
 	int i;
 	char *q = prs_mem_get(ps, len * sizeof(uint16));
@@ -757,7 +780,7 @@
  output must be little-endian, if marshalling, input must be little-endian.
  ********************************************************************/
 
-static void dbg_rw_punival(BOOL charmode, char *name, int depth, prs_struct *ps,
+static void dbg_rw_punival(BOOL charmode, const char *name, int depth, prs_struct *ps,
 							char *in_buf, char *out_buf, int len)
 {
 	int i;
@@ -794,7 +817,7 @@
  Stream a unistr. Always little endian.
  ********************************************************************/
 
-BOOL prs_uint16uni(BOOL charmode, char *name, prs_struct *ps, int depth, uint16 *data16s, int len)
+BOOL prs_uint16uni(BOOL charmode, const char *name, prs_struct *ps, int depth, uint16 *data16s, int len)
 {
 	char *q = prs_mem_get(ps, len * sizeof(uint16));
 	if (q == NULL)
@@ -810,7 +833,7 @@
  Stream an array of uint32s. Length is number of uint32s.
  ********************************************************************/
 
-BOOL prs_uint32s(BOOL charmode, char *name, prs_struct *ps, int depth, uint32 *data32s, int len)
+BOOL prs_uint32s(BOOL charmode, const char *name, prs_struct *ps, int depth, uint32 *data32s, int len)
 {
 	int i;
 	char *q = prs_mem_get(ps, len * sizeof(uint32));
@@ -854,7 +877,7 @@
  in uint16 chars. The unicode string is already in little-endian format.
  ********************************************************************/
 
-BOOL prs_buffer5(BOOL charmode, char *name, prs_struct *ps, int depth, BUFFER5 *str)
+BOOL prs_buffer5(BOOL charmode, const char *name, prs_struct *ps, int depth, BUFFER5 *str)
 {
 	char *p;
 	char *q = prs_mem_get(ps, str->buf_len * sizeof(uint16));
@@ -885,7 +908,7 @@
  in byte chars. String is in little-endian format.
  ********************************************************************/
 
-BOOL prs_buffer2(BOOL charmode, char *name, prs_struct *ps, int depth, BUFFER2 *str)
+BOOL prs_buffer2(BOOL charmode, const char *name, prs_struct *ps, int depth, BUFFER2 *str)
 {
 	char *p;
 	char *q = prs_mem_get(ps, str->buf_len);
@@ -913,7 +936,7 @@
  in uint8 chars.
  ********************************************************************/
 
-BOOL prs_string2(BOOL charmode, char *name, prs_struct *ps, int depth, STRING2 *str)
+BOOL prs_string2(BOOL charmode, const char *name, prs_struct *ps, int depth, STRING2 *str)
 {
 	int i;
 	char *q = prs_mem_get(ps, str->str_max_len);
@@ -953,7 +976,7 @@
  in uint16 chars. The unicode string is already in little-endian format.
  ********************************************************************/
 
-BOOL prs_unistr2(BOOL charmode, char *name, prs_struct *ps, int depth, UNISTR2 *str)
+BOOL prs_unistr2(BOOL charmode, const char *name, prs_struct *ps, int depth, UNISTR2 *str)
 {
 	char *p;
 	char *q = prs_mem_get(ps, str->uni_str_len * sizeof(uint16));
@@ -984,7 +1007,7 @@
  in uint16 chars. The unicode string is already in little-endian format.
  ********************************************************************/
 
-BOOL prs_unistr3(BOOL charmode, char *name, UNISTR3 *str, prs_struct *ps, int depth)
+BOOL prs_unistr3(BOOL charmode, const char *name, UNISTR3 *str, prs_struct *ps, int depth)
 {
 	char *p;
 	char *q = prs_mem_get(ps, str->uni_str_len * sizeof(uint16));
@@ -1010,7 +1033,7 @@
  in little-endian format then do it as a stream of bytes.
  ********************************************************************/
 
-BOOL prs_unistr(char *name, prs_struct *ps, int depth, UNISTR *str)
+BOOL prs_unistr(const char *name, prs_struct *ps, int depth, UNISTR *str)
 {
 	int len = 0;
 	unsigned char *p = (unsigned char *)str->buffer;
@@ -1068,7 +1091,7 @@
 	else { /* unmarshalling */
 	
 		uint32 alloc_len = 0;
-		q = prs_data_p(ps) + prs_offset(ps);
+		q = ps->data_p + prs_offset(ps);
 
 		/*
 		 * Work out how much space we need and talloc it.
@@ -1136,7 +1159,7 @@
  not include the null-termination character.
  ********************************************************************/
 
-BOOL prs_string(char *name, prs_struct *ps, int depth, char *str, int len, int max_buf_size)
+BOOL prs_string(const char *name, prs_struct *ps, int depth, char *str, int len, int max_buf_size)
 {
 	char *q;
 	int i;
@@ -1173,7 +1196,7 @@
  uint16 should be stored, or gets the size if reading.
  ********************************************************************/
 
-BOOL prs_uint16_pre(char *name, prs_struct *ps, int depth, uint16 *data16, uint32 *offset)
+BOOL prs_uint16_pre(const char *name, prs_struct *ps, int depth, uint16 *data16, uint32 *offset)
 {
 	*offset = ps->data_offset;
 	if (UNMARSHALLING(ps)) {
@@ -1193,7 +1216,7 @@
  does nothing on reading, as that is already handled by ...._pre()
  ********************************************************************/
 
-BOOL prs_uint16_post(char *name, prs_struct *ps, int depth, uint16 *data16,
+BOOL prs_uint16_post(const char *name, prs_struct *ps, int depth, uint16 *data16,
 				uint32 ptr_uint16, uint32 start_offset)
 {
 	if (MARSHALLING(ps)) {
@@ -1220,7 +1243,7 @@
  uint32 should be stored, or gets the size if reading.
  ********************************************************************/
 
-BOOL prs_uint32_pre(char *name, prs_struct *ps, int depth, uint32 *data32, uint32 *offset)
+BOOL prs_uint32_pre(const char *name, prs_struct *ps, int depth, uint32 *data32, uint32 *offset)
 {
 	*offset = ps->data_offset;
 	if (UNMARSHALLING(ps) && (data32 != NULL)) {
@@ -1237,7 +1260,7 @@
  does nothing on reading, as that is already handled by ...._pre()
  ********************************************************************/
 
-BOOL prs_uint32_post(char *name, prs_struct *ps, int depth, uint32 *data32,
+BOOL prs_uint32_post(const char *name, prs_struct *ps, int depth, uint32 *data32,
 				uint32 ptr_uint32, uint32 data_size)
 {
 	if (MARSHALLING(ps)) {
@@ -1261,7 +1284,7 @@
     TDB_DATA kbuf, dbuf;
     kbuf.dptr = keystr;
     kbuf.dsize = strlen(keystr)+1;
-    dbuf.dptr = prs_data_p(ps);
+    dbuf.dptr = ps->data_p;
     dbuf.dsize = prs_offset(ps);
     return tdb_store(tdb, kbuf, dbuf, TDB_REPLACE);
 }
@@ -1291,7 +1314,7 @@
 {
 	char *q;
 
-	q = prs_data_p(ps);
+	q = ps->data_p;
         q = &q[offset];
 
 #ifdef DEBUG_PASSWORD
diff -uNr samba-3.0alpha21.orig/source/rpc_parse/parse_reg.c samba-3.0alpha21/source/rpc_parse/parse_reg.c
--- samba-3.0alpha21.orig/source/rpc_parse/parse_reg.c	2003-02-16 19:06:32.000000000 -0600
+++ samba-3.0alpha21/source/rpc_parse/parse_reg.c	2003-02-16 19:05:46.000000000 -0600
@@ -62,7 +62,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-BOOL reg_io_q_open_hkcr(char *desc,  REG_Q_OPEN_HKCR *r_q, prs_struct *ps, int depth)
+BOOL reg_io_q_open_hkcr(const char *desc,  REG_Q_OPEN_HKCR *r_q, prs_struct *ps, int depth)
 {
 	if (r_q == NULL)
 		return False;
@@ -93,7 +93,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-BOOL reg_io_r_open_hkcr(char *desc,  REG_R_OPEN_HKCR *r_r, prs_struct *ps, int depth)
+BOOL reg_io_r_open_hkcr(const char *desc,  REG_R_OPEN_HKCR *r_r, prs_struct *ps, int depth)
 {
 	if (r_r == NULL)
 		return False;
@@ -130,7 +130,7 @@
 /*******************************************************************
 reads or writes a structure.
 ********************************************************************/
-BOOL reg_io_q_open_hklm(char *desc, REG_Q_OPEN_HKLM * r_q, prs_struct *ps,
+BOOL reg_io_q_open_hklm(const char *desc, REG_Q_OPEN_HKLM * r_q, prs_struct *ps,
 			int depth)
 {
 	if (r_q == NULL)
@@ -161,7 +161,7 @@
 /*******************************************************************
 reads or writes a structure.
 ********************************************************************/
-BOOL reg_io_r_open_hklm(char *desc, REG_R_OPEN_HKLM * r_r, prs_struct *ps,
+BOOL reg_io_r_open_hklm(const char *desc, REG_R_OPEN_HKLM * r_r, prs_struct *ps,
 			int depth)
 {
 	if (r_r == NULL)
@@ -198,7 +198,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-BOOL reg_io_q_flush_key(char *desc,  REG_Q_FLUSH_KEY *r_q, prs_struct *ps, int depth)
+BOOL reg_io_q_flush_key(const char *desc,  REG_Q_FLUSH_KEY *r_q, prs_struct *ps, int depth)
 {
 	if (r_q == NULL)
 		return False;
@@ -219,7 +219,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-BOOL reg_io_r_flush_key(char *desc,  REG_R_FLUSH_KEY *r_r, prs_struct *ps, int depth)
+BOOL reg_io_r_flush_key(const char *desc,  REG_R_FLUSH_KEY *r_r, prs_struct *ps, int depth)
 {
 	if (r_r == NULL)
 		return False;
@@ -311,7 +311,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-BOOL reg_io_q_create_key(char *desc,  REG_Q_CREATE_KEY *r_q, prs_struct *ps, int depth)
+BOOL reg_io_q_create_key(const char *desc,  REG_Q_CREATE_KEY *r_q, prs_struct *ps, int depth)
 {
 	if (r_q == NULL)
 		return False;
@@ -367,7 +367,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-BOOL reg_io_r_create_key(char *desc,  REG_R_CREATE_KEY *r_r, prs_struct *ps, int depth)
+BOOL reg_io_r_create_key(const char *desc,  REG_R_CREATE_KEY *r_r, prs_struct *ps, int depth)
 {
 	if (r_r == NULL)
 		return False;
@@ -410,7 +410,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-BOOL reg_io_q_delete_val(char *desc,  REG_Q_DELETE_VALUE *r_q, prs_struct *ps, int depth)
+BOOL reg_io_q_delete_val(const char *desc,  REG_Q_DELETE_VALUE *r_q, prs_struct *ps, int depth)
 {
 	if (r_q == NULL)
 		return False;
@@ -439,7 +439,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-BOOL reg_io_r_delete_val(char *desc,  REG_R_DELETE_VALUE *r_r, prs_struct *ps, int depth)
+BOOL reg_io_r_delete_val(const char *desc,  REG_R_DELETE_VALUE *r_r, prs_struct *ps, int depth)
 {
 	if (r_r == NULL)
 		return False;
@@ -476,7 +476,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-BOOL reg_io_q_delete_key(char *desc,  REG_Q_DELETE_KEY *r_q, prs_struct *ps, int depth)
+BOOL reg_io_q_delete_key(const char *desc,  REG_Q_DELETE_KEY *r_q, prs_struct *ps, int depth)
 {
 	if (r_q == NULL)
 		return False;
@@ -504,7 +504,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-BOOL reg_io_r_delete_key(char *desc,  REG_R_DELETE_KEY *r_r, prs_struct *ps, int depth)
+BOOL reg_io_r_delete_key(const char *desc,  REG_R_DELETE_KEY *r_r, prs_struct *ps, int depth)
 {
 	if (r_r == NULL)
 		return False;
@@ -539,7 +539,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-BOOL reg_io_q_query_key(char *desc,  REG_Q_QUERY_KEY *r_q, prs_struct *ps, int depth)
+BOOL reg_io_q_query_key(const char *desc,  REG_Q_QUERY_KEY *r_q, prs_struct *ps, int depth)
 {
 	if (r_q == NULL)
 		return False;
@@ -568,7 +568,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-BOOL reg_io_r_query_key(char *desc,  REG_R_QUERY_KEY *r_r, prs_struct *ps, int depth)
+BOOL reg_io_r_query_key(const char *desc,  REG_R_QUERY_KEY *r_r, prs_struct *ps, int depth)
 {
 	if (r_r == NULL)
 		return False;
@@ -624,7 +624,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-BOOL reg_io_q_unknown_1a(char *desc,  REG_Q_UNKNOWN_1A *r_q, prs_struct *ps, int depth)
+BOOL reg_io_q_unknown_1a(const char *desc,  REG_Q_UNKNOWN_1A *r_q, prs_struct *ps, int depth)
 {
 	if (r_q == NULL)
 		return False;
@@ -645,7 +645,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-BOOL reg_io_r_unknown_1a(char *desc,  REG_R_UNKNOWN_1A *r_r, prs_struct *ps, int depth)
+BOOL reg_io_r_unknown_1a(const char *desc,  REG_R_UNKNOWN_1A *r_r, prs_struct *ps, int depth)
 {
 	if (r_r == NULL)
 		return False;
@@ -669,7 +669,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-BOOL reg_io_q_save_key(char *desc,  REG_Q_SAVE_KEY *r_q, prs_struct *ps, int depth)
+BOOL reg_io_q_save_key(const char *desc,  REG_Q_SAVE_KEY *r_q, prs_struct *ps, int depth)
 {
 	if (r_q == NULL)
 		return False;
@@ -698,7 +698,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-BOOL reg_io_r_save_key(char *desc,  REG_R_SAVE_KEY *r_r, prs_struct *ps, int depth)
+BOOL reg_io_r_save_key(const char *desc,  REG_R_SAVE_KEY *r_r, prs_struct *ps, int depth)
 {
 	if (r_r == NULL)
 		return False;
@@ -732,7 +732,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-BOOL reg_io_q_open_hku(char *desc,  REG_Q_OPEN_HKU *r_q, prs_struct *ps, int depth)
+BOOL reg_io_q_open_hku(const char *desc,  REG_Q_OPEN_HKU *r_q, prs_struct *ps, int depth)
 {
 	if (r_q == NULL)
 		return False;
@@ -761,7 +761,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-BOOL reg_io_r_open_hku(char *desc,  REG_R_OPEN_HKU *r_r, prs_struct *ps, int depth)
+BOOL reg_io_r_open_hku(const char *desc,  REG_R_OPEN_HKU *r_r, prs_struct *ps, int depth)
 {
 	if (r_r == NULL)
 		return False;
@@ -796,7 +796,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-BOOL reg_io_q_close(char *desc,  REG_Q_CLOSE *q_u, prs_struct *ps, int depth)
+BOOL reg_io_q_close(const char *desc,  REG_Q_CLOSE *q_u, prs_struct *ps, int depth)
 {
 	if (q_u == NULL)
 		return False;
@@ -819,7 +819,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-BOOL reg_io_r_close(char *desc,  REG_R_CLOSE *r_u, prs_struct *ps, int depth)
+BOOL reg_io_r_close(const char *desc,  REG_R_CLOSE *r_u, prs_struct *ps, int depth)
 {
 	if (r_u == NULL)
 		return False;
@@ -860,7 +860,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-BOOL reg_io_q_set_key_sec(char *desc,  REG_Q_SET_KEY_SEC *r_q, prs_struct *ps, int depth)
+BOOL reg_io_q_set_key_sec(const char *desc,  REG_Q_SET_KEY_SEC *r_q, prs_struct *ps, int depth)
 {
 	if (r_q == NULL)
 		return False;
@@ -889,7 +889,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-BOOL reg_io_r_set_key_sec(char *desc, REG_R_SET_KEY_SEC *r_q, prs_struct *ps, int depth)
+BOOL reg_io_r_set_key_sec(const char *desc, REG_R_SET_KEY_SEC *r_q, prs_struct *ps, int depth)
 {
 	if (r_q == NULL)
 		return False;
@@ -930,7 +930,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-BOOL reg_io_q_get_key_sec(char *desc,  REG_Q_GET_KEY_SEC *r_q, prs_struct *ps, int depth)
+BOOL reg_io_q_get_key_sec(const char *desc,  REG_Q_GET_KEY_SEC *r_q, prs_struct *ps, int depth)
 {
 	if (r_q == NULL)
 		return False;
@@ -975,7 +975,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-BOOL reg_io_r_get_key_sec(char *desc,  REG_R_GET_KEY_SEC *r_q, prs_struct *ps, int depth)
+BOOL reg_io_r_get_key_sec(const char *desc,  REG_R_GET_KEY_SEC *r_q, prs_struct *ps, int depth)
 {
 	if (r_q == NULL)
 		return False;
@@ -1041,7 +1041,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-BOOL reg_io_q_info(char *desc,  REG_Q_INFO *r_q, prs_struct *ps, int depth)
+BOOL reg_io_q_info(const char *desc,  REG_Q_INFO *r_q, prs_struct *ps, int depth)
 {
 	if (r_q == NULL)
 		return False;
@@ -1174,7 +1174,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-BOOL reg_io_r_info(char *desc, REG_R_INFO *r_r, prs_struct *ps, int depth)
+BOOL reg_io_r_info(const char *desc, REG_R_INFO *r_r, prs_struct *ps, int depth)
 {
 	if (r_r == NULL)
 		return False;
@@ -1298,7 +1298,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-BOOL reg_io_q_enum_val(char *desc,  REG_Q_ENUM_VALUE *q_q, prs_struct *ps, int depth)
+BOOL reg_io_q_enum_val(const char *desc,  REG_Q_ENUM_VALUE *q_q, prs_struct *ps, int depth)
 {
 	if (q_q == NULL)
 		return False;
@@ -1357,7 +1357,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-BOOL reg_io_r_enum_val(char *desc,  REG_R_ENUM_VALUE *r_q, prs_struct *ps, int depth)
+BOOL reg_io_r_enum_val(const char *desc,  REG_R_ENUM_VALUE *r_q, prs_struct *ps, int depth)
 {
 	if (r_q == NULL)
 		return False;
@@ -1435,7 +1435,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-BOOL reg_io_q_create_val(char *desc,  REG_Q_CREATE_VALUE *q_q, prs_struct *ps, int depth)
+BOOL reg_io_q_create_val(const char *desc,  REG_Q_CREATE_VALUE *q_q, prs_struct *ps, int depth)
 {
 	if (q_q == NULL)
 		return False;
@@ -1470,7 +1470,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-BOOL reg_io_r_create_val(char *desc,  REG_R_CREATE_VALUE *r_q, prs_struct *ps, int depth)
+BOOL reg_io_r_create_val(const char *desc,  REG_R_CREATE_VALUE *r_q, prs_struct *ps, int depth)
 {
 	if (r_q == NULL)
 		return False;
@@ -1537,7 +1537,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-BOOL reg_io_q_enum_key(char *desc,  REG_Q_ENUM_KEY *q_q, prs_struct *ps, int depth)
+BOOL reg_io_q_enum_key(const char *desc,  REG_Q_ENUM_KEY *q_q, prs_struct *ps, int depth)
 {
 	if (q_q == NULL)
 		return False;
@@ -1591,7 +1591,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-BOOL reg_io_r_enum_key(char *desc,  REG_R_ENUM_KEY *r_q, prs_struct *ps, int depth)
+BOOL reg_io_r_enum_key(const char *desc,  REG_R_ENUM_KEY *r_q, prs_struct *ps, int depth)
 {
 	if (r_q == NULL)
 		return False;
@@ -1665,7 +1665,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-BOOL reg_io_q_open_entry(char *desc,  REG_Q_OPEN_ENTRY *r_q, prs_struct *ps, int depth)
+BOOL reg_io_q_open_entry(const char *desc,  REG_Q_OPEN_ENTRY *r_q, prs_struct *ps, int depth)
 {
 	if (r_q == NULL)
 		return False;
@@ -1713,7 +1713,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-BOOL reg_io_r_open_entry(char *desc,  REG_R_OPEN_ENTRY *r_r, prs_struct *ps, int depth)
+BOOL reg_io_r_open_entry(const char *desc,  REG_R_OPEN_ENTRY *r_r, prs_struct *ps, int depth)
 {
 	if (r_r == NULL)
 		return False;
@@ -1736,8 +1736,8 @@
 /*******************************************************************
 Inits a structure.
 ********************************************************************/
-void init_reg_q_shutdown(REG_Q_SHUTDOWN * q_s,
-			 const char *msg, uint32 timeout, uint16 flags)
+void init_reg_q_shutdown(REG_Q_SHUTDOWN * q_s, const char *msg,
+			uint32 timeout, BOOL do_reboot, BOOL force)
 {
 	int msg_len;
 	msg_len = strlen(msg);
@@ -1750,14 +1750,16 @@
 	init_unistr2(&(q_s->uni_msg), msg, msg_len);
 
 	q_s->timeout = timeout;
-	q_s->flags = flags;
+
+	q_s->reboot = do_reboot ? 1 : 0;
+	q_s->force = force ? 1 : 0;
 
 }
 
 /*******************************************************************
 reads or writes a structure.
 ********************************************************************/
-BOOL reg_io_q_shutdown(char *desc, REG_Q_SHUTDOWN * q_s, prs_struct *ps,
+BOOL reg_io_q_shutdown(const char *desc, REG_Q_SHUTDOWN * q_s, prs_struct *ps,
 		       int depth)
 {
 	if (q_s == NULL)
@@ -1785,7 +1787,9 @@
 
 	if (!prs_uint32("timeout", ps, depth, &(q_s->timeout)))
 		return False;
-	if (!prs_uint16("flags  ", ps, depth, &(q_s->flags)))
+	if (!prs_uint8("force  ", ps, depth, &(q_s->force)))
+		return False;
+	if (!prs_uint8("reboot ", ps, depth, &(q_s->reboot)))
 		return False;
 
 	return True;
@@ -1794,7 +1798,7 @@
 /*******************************************************************
 reads or writes a structure.
 ********************************************************************/
-BOOL reg_io_r_shutdown(char *desc, REG_R_SHUTDOWN * r_s, prs_struct *ps,
+BOOL reg_io_r_shutdown(const char *desc, REG_R_SHUTDOWN * r_s, prs_struct *ps,
 		       int depth)
 {
 	if (r_s == NULL)
@@ -1825,7 +1829,7 @@
 /*******************************************************************
 reads or writes a structure.
 ********************************************************************/
-BOOL reg_io_q_abort_shutdown(char *desc, REG_Q_ABORT_SHUTDOWN * q_s,
+BOOL reg_io_q_abort_shutdown(const char *desc, REG_Q_ABORT_SHUTDOWN * q_s,
 			     prs_struct *ps, int depth)
 {
 	if (q_s == NULL)
@@ -1849,7 +1853,7 @@
 /*******************************************************************
 reads or writes a structure.
 ********************************************************************/
-BOOL reg_io_r_abort_shutdown(char *desc, REG_R_ABORT_SHUTDOWN * r_s,
+BOOL reg_io_r_abort_shutdown(const char *desc, REG_R_ABORT_SHUTDOWN * r_s,
 			     prs_struct *ps, int depth)
 {
 	if (r_s == NULL)
diff -uNr samba-3.0alpha21.orig/source/rpc_parse/parse_rpc.c samba-3.0alpha21/source/rpc_parse/parse_rpc.c
--- samba-3.0alpha21.orig/source/rpc_parse/parse_rpc.c	2003-02-16 19:06:32.000000000 -0600
+++ samba-3.0alpha21/source/rpc_parse/parse_rpc.c	2003-02-16 19:05:46.000000000 -0600
@@ -143,7 +143,7 @@
  * update the index #defines in smb.h.
  */
 
-struct pipe_id_info pipe_names [] =
+const struct pipe_id_info pipe_names [] =
 {
 	/* client pipe , abstract syntax       , server pipe   , transfer syntax */
 	{ PIPE_LSARPC  , SYNT_LSARPC_V0        , PIPE_LSASS    , TRANS_SYNT_V2 },
@@ -182,7 +182,7 @@
  Reads or writes an RPC_HDR structure.
 ********************************************************************/
 
-BOOL smb_io_rpc_hdr(char *desc,  RPC_HDR *rpc, prs_struct *ps, int depth)
+BOOL smb_io_rpc_hdr(const char *desc,  RPC_HDR *rpc, prs_struct *ps, int depth)
 {
 	if (rpc == NULL)
 		return False;
@@ -236,7 +236,7 @@
  Reads or writes an RPC_IFACE structure.
 ********************************************************************/
 
-static BOOL smb_io_rpc_iface(char *desc, RPC_IFACE *ifc, prs_struct *ps, int depth)
+static BOOL smb_io_rpc_iface(const char *desc, RPC_IFACE *ifc, prs_struct *ps, int depth)
 {
 	if (ifc == NULL)
 		return False;
@@ -266,7 +266,7 @@
  Inits an RPC_ADDR_STR structure.
 ********************************************************************/
 
-static void init_rpc_addr_str(RPC_ADDR_STR *str, char *name)
+static void init_rpc_addr_str(RPC_ADDR_STR *str, const char *name)
 {
 	str->len = strlen(name) + 1;
 	fstrcpy(str->str, name);
@@ -276,7 +276,7 @@
  Reads or writes an RPC_ADDR_STR structure.
 ********************************************************************/
 
-static BOOL smb_io_rpc_addr_str(char *desc,  RPC_ADDR_STR *str, prs_struct *ps, int depth)
+static BOOL smb_io_rpc_addr_str(const char *desc,  RPC_ADDR_STR *str, prs_struct *ps, int depth)
 {
 	if (str == NULL)
 		return False;
@@ -308,7 +308,7 @@
  Reads or writes an RPC_HDR_BBA structure.
 ********************************************************************/
 
-static BOOL smb_io_rpc_hdr_bba(char *desc,  RPC_HDR_BBA *rpc, prs_struct *ps, int depth)
+static BOOL smb_io_rpc_hdr_bba(const char *desc,  RPC_HDR_BBA *rpc, prs_struct *ps, int depth)
 {
 	if (rpc == NULL)
 		return False;
@@ -351,7 +351,7 @@
  Reads or writes an RPC_HDR_RB structure.
 ********************************************************************/
 
-BOOL smb_io_rpc_hdr_rb(char *desc, RPC_HDR_RB *rpc, prs_struct *ps, int depth)
+BOOL smb_io_rpc_hdr_rb(const char *desc, RPC_HDR_RB *rpc, prs_struct *ps, int depth)
 {
 	if (rpc == NULL)
 		return False;
@@ -397,7 +397,7 @@
  lkclXXXX only one reason at the moment!
 ********************************************************************/
 
-static BOOL smb_io_rpc_results(char *desc, RPC_RESULTS *res, prs_struct *ps, int depth)
+static BOOL smb_io_rpc_results(const char *desc, RPC_RESULTS *res, prs_struct *ps, int depth)
 {
 	if (res == NULL)
 		return False;
@@ -430,7 +430,7 @@
 
 void init_rpc_hdr_ba(RPC_HDR_BA *rpc, 
 				uint16 max_tsize, uint16 max_rsize, uint32 assoc_gid,
-				char *pipe_addr,
+				const char *pipe_addr,
 				uint8 num_results, uint16 result, uint16 reason,
 				RPC_IFACE *transfer)
 {
@@ -446,7 +446,7 @@
  Reads or writes an RPC_HDR_BA structure.
 ********************************************************************/
 
-BOOL smb_io_rpc_hdr_ba(char *desc, RPC_HDR_BA *rpc, prs_struct *ps, int depth)
+BOOL smb_io_rpc_hdr_ba(const char *desc, RPC_HDR_BA *rpc, prs_struct *ps, int depth)
 {
 	if (rpc == NULL)
 		return False;
@@ -480,7 +480,7 @@
  Reads or writes an RPC_HDR_REQ structure.
 ********************************************************************/
 
-BOOL smb_io_rpc_hdr_req(char *desc, RPC_HDR_REQ *rpc, prs_struct *ps, int depth)
+BOOL smb_io_rpc_hdr_req(const char *desc, RPC_HDR_REQ *rpc, prs_struct *ps, int depth)
 {
 	if (rpc == NULL)
 		return False;
@@ -501,7 +501,7 @@
  Reads or writes an RPC_HDR_RESP structure.
 ********************************************************************/
 
-BOOL smb_io_rpc_hdr_resp(char *desc, RPC_HDR_RESP *rpc, prs_struct *ps, int depth)
+BOOL smb_io_rpc_hdr_resp(const char *desc, RPC_HDR_RESP *rpc, prs_struct *ps, int depth)
 {
 	if (rpc == NULL)
 		return False;
@@ -524,7 +524,7 @@
  Reads or writes an RPC_HDR_FAULT structure.
 ********************************************************************/
 
-BOOL smb_io_rpc_hdr_fault(char *desc, RPC_HDR_FAULT *rpc, prs_struct *ps, int depth)
+BOOL smb_io_rpc_hdr_fault(const char *desc, RPC_HDR_FAULT *rpc, prs_struct *ps, int depth)
 {
 	if (rpc == NULL)
 		return False;
@@ -564,7 +564,7 @@
  Reads or writes an RPC_HDR_AUTHA structure.
 ********************************************************************/
 
-BOOL smb_io_rpc_hdr_autha(char *desc, RPC_HDR_AUTHA *rai, prs_struct *ps, int depth)
+BOOL smb_io_rpc_hdr_autha(const char *desc, RPC_HDR_AUTHA *rai, prs_struct *ps, int depth)
 {
 	if (rai == NULL)
 		return False;
@@ -622,7 +622,7 @@
  Reads or writes an RPC_HDR_AUTH structure.
 ********************************************************************/
 
-BOOL smb_io_rpc_hdr_auth(char *desc, RPC_HDR_AUTH *rai, prs_struct *ps, int depth)
+BOOL smb_io_rpc_hdr_auth(const char *desc, RPC_HDR_AUTH *rai, prs_struct *ps, int depth)
 {
 	if (rai == NULL)
 		return False;
@@ -653,7 +653,7 @@
 ********************************************************************/
 
 BOOL rpc_auth_verifier_chk(RPC_AUTH_VERIFIER *rav,
-				char *signature, uint32 msg_type)
+				const char *signature, uint32 msg_type)
 {
 	return (strequal(rav->signature, signature) && rav->msg_type == msg_type);
 }
@@ -663,7 +663,7 @@
 ********************************************************************/
 
 void init_rpc_auth_verifier(RPC_AUTH_VERIFIER *rav,
-				char *signature, uint32 msg_type)
+				const char *signature, uint32 msg_type)
 {
 	fstrcpy(rav->signature, signature); /* "NTLMSSP" */
 	rav->msg_type = msg_type; /* NTLMSSP_MESSAGE_TYPE */
@@ -673,7 +673,7 @@
  Reads or writes an RPC_AUTH_VERIFIER structure.
 ********************************************************************/
 
-BOOL smb_io_rpc_auth_verifier(char *desc, RPC_AUTH_VERIFIER *rav, prs_struct *ps, int depth)
+BOOL smb_io_rpc_auth_verifier(const char *desc, RPC_AUTH_VERIFIER *rav, prs_struct *ps, int depth)
 {
 	if (rav == NULL)
 		return False;
@@ -717,7 +717,7 @@
  *** lkclXXXX HACK ALERT! ***
 ********************************************************************/
 
-BOOL smb_io_rpc_auth_ntlmssp_neg(char *desc, RPC_AUTH_NTLMSSP_NEG *neg, prs_struct *ps, int depth)
+BOOL smb_io_rpc_auth_ntlmssp_neg(const char *desc, RPC_AUTH_NTLMSSP_NEG *neg, prs_struct *ps, int depth)
 {
 	uint32 start_offset = prs_offset(ps);
 	if (neg == NULL)
@@ -804,7 +804,7 @@
  Reads or writes an RPC_AUTH_NTLMSSP_CHAL structure.
 ********************************************************************/
 
-BOOL smb_io_rpc_auth_ntlmssp_chal(char *desc, RPC_AUTH_NTLMSSP_CHAL *chl, prs_struct *ps, int depth)
+BOOL smb_io_rpc_auth_ntlmssp_chal(const char *desc, RPC_AUTH_NTLMSSP_CHAL *chl, prs_struct *ps, int depth)
 {
 	if (chl == NULL)
 		return False;
@@ -908,7 +908,7 @@
  *** lkclXXXX the actual offset is at the start of the auth verifier    ***
 ********************************************************************/
 
-BOOL smb_io_rpc_auth_ntlmssp_resp(char *desc, RPC_AUTH_NTLMSSP_RESP *rsp, prs_struct *ps, int depth)
+BOOL smb_io_rpc_auth_ntlmssp_resp(const char *desc, RPC_AUTH_NTLMSSP_RESP *rsp, prs_struct *ps, int depth)
 {
 	if (rsp == NULL)
 		return False;
@@ -1082,7 +1082,7 @@
  Reads or writes an RPC_AUTH_NTLMSSP_CHK structure.
 ********************************************************************/
 
-BOOL smb_io_rpc_auth_ntlmssp_chk(char *desc, RPC_AUTH_NTLMSSP_CHK *chk, prs_struct *ps, int depth)
+BOOL smb_io_rpc_auth_ntlmssp_chk(const char *desc, RPC_AUTH_NTLMSSP_CHK *chk, prs_struct *ps, int depth)
 {
 	if (chk == NULL)
 		return False;
diff -uNr samba-3.0alpha21.orig/source/rpc_parse/parse_samr.c samba-3.0alpha21/source/rpc_parse/parse_samr.c
--- samba-3.0alpha21.orig/source/rpc_parse/parse_samr.c	2003-02-16 19:06:32.000000000 -0600
+++ samba-3.0alpha21/source/rpc_parse/parse_samr.c	2003-02-16 19:05:46.000000000 -0600
@@ -47,7 +47,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-BOOL samr_io_q_close_hnd(char *desc, SAMR_Q_CLOSE_HND * q_u,
+BOOL samr_io_q_close_hnd(const char *desc, SAMR_Q_CLOSE_HND * q_u,
 			 prs_struct *ps, int depth)
 {
 	if (q_u == NULL)
@@ -66,7 +66,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-BOOL samr_io_r_close_hnd(char *desc, SAMR_R_CLOSE_HND * r_u,
+BOOL samr_io_r_close_hnd(const char *desc, SAMR_R_CLOSE_HND * r_u,
 			 prs_struct *ps, int depth)
 {
 	if (r_u == NULL)
@@ -107,7 +107,7 @@
 /*******************************************************************
 reads or writes a structure.
 ********************************************************************/
-BOOL samr_io_q_lookup_domain(char *desc, SAMR_Q_LOOKUP_DOMAIN * q_u,
+BOOL samr_io_q_lookup_domain(const char *desc, SAMR_Q_LOOKUP_DOMAIN * q_u,
 			     prs_struct *ps, int depth)
 {
 	if (q_u == NULL)
@@ -152,7 +152,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-BOOL samr_io_r_lookup_domain(char *desc, SAMR_R_LOOKUP_DOMAIN * r_u,
+BOOL samr_io_r_lookup_domain(const char *desc, SAMR_R_LOOKUP_DOMAIN * r_u,
 			     prs_struct *ps, int depth)
 {
 	if (r_u == NULL)
@@ -196,7 +196,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-BOOL samr_io_q_unknown_2d(char *desc, SAMR_Q_UNKNOWN_2D * q_u,
+BOOL samr_io_q_unknown_2d(const char *desc, SAMR_Q_UNKNOWN_2D * q_u,
 			  prs_struct *ps, int depth)
 {
 	if (q_u == NULL)
@@ -224,7 +224,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-BOOL samr_io_r_unknown_2d(char *desc, SAMR_R_UNKNOWN_2D * r_u,
+BOOL samr_io_r_unknown_2d(const char *desc, SAMR_R_UNKNOWN_2D * r_u,
 			  prs_struct *ps, int depth)
 {
 	if (r_u == NULL)
@@ -261,7 +261,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-BOOL samr_io_q_open_domain(char *desc, SAMR_Q_OPEN_DOMAIN * q_u,
+BOOL samr_io_q_open_domain(const char *desc, SAMR_Q_OPEN_DOMAIN * q_u,
 			   prs_struct *ps, int depth)
 {
 	if (q_u == NULL)
@@ -289,7 +289,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-BOOL samr_io_r_open_domain(char *desc, SAMR_R_OPEN_DOMAIN * r_u,
+BOOL samr_io_r_open_domain(const char *desc, SAMR_R_OPEN_DOMAIN * r_u,
 			   prs_struct *ps, int depth)
 {
 	if (r_u == NULL)
@@ -326,7 +326,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-BOOL samr_io_q_get_usrdom_pwinfo(char *desc, SAMR_Q_GET_USRDOM_PWINFO * q_u,
+BOOL samr_io_q_get_usrdom_pwinfo(const char *desc, SAMR_Q_GET_USRDOM_PWINFO * q_u,
 				 prs_struct *ps, int depth)
 {
 	if (q_u == NULL)
@@ -368,7 +368,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-BOOL samr_io_r_get_usrdom_pwinfo(char *desc, SAMR_R_GET_USRDOM_PWINFO * r_u,
+BOOL samr_io_r_get_usrdom_pwinfo(const char *desc, SAMR_R_GET_USRDOM_PWINFO * r_u,
 				 prs_struct *ps, int depth)
 {
 	if (r_u == NULL)
@@ -397,7 +397,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-BOOL samr_io_q_set_sec_obj(char *desc, SAMR_Q_SET_SEC_OBJ * q_u,
+BOOL samr_io_q_set_sec_obj(const char *desc, SAMR_Q_SET_SEC_OBJ * q_u,
 			     prs_struct *ps, int depth)
 {
 	if (q_u == NULL)
@@ -440,7 +440,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-BOOL samr_io_q_query_sec_obj(char *desc, SAMR_Q_QUERY_SEC_OBJ * q_u,
+BOOL samr_io_q_query_sec_obj(const char *desc, SAMR_Q_QUERY_SEC_OBJ * q_u,
 			     prs_struct *ps, int depth)
 {
 	if (q_u == NULL)
@@ -478,7 +478,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-BOOL samr_io_q_query_dom_info(char *desc, SAMR_Q_QUERY_DOMAIN_INFO * q_u,
+BOOL samr_io_q_query_dom_info(const char *desc, SAMR_Q_QUERY_DOMAIN_INFO * q_u,
 			      prs_struct *ps, int depth)
 {
 	if (q_u == NULL)
@@ -514,7 +514,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-static BOOL sam_io_unk_info3(char *desc, SAM_UNK_INFO_3 * u_3,
+static BOOL sam_io_unk_info3(const char *desc, SAM_UNK_INFO_3 * u_3,
 			     prs_struct *ps, int depth)
 {
 	if (u_3 == NULL)
@@ -544,7 +544,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-static BOOL sam_io_unk_info6(char *desc, SAM_UNK_INFO_6 * u_6,
+static BOOL sam_io_unk_info6(const char *desc, SAM_UNK_INFO_6 * u_6,
 			     prs_struct *ps, int depth)
 {
 	if (u_6 == NULL)
@@ -576,7 +576,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-static BOOL sam_io_unk_info7(char *desc, SAM_UNK_INFO_7 * u_7,
+static BOOL sam_io_unk_info7(const char *desc, SAM_UNK_INFO_7 * u_7,
 			     prs_struct *ps, int depth)
 {
 	if (u_7 == NULL)
@@ -609,7 +609,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-static BOOL sam_io_unk_info12(char *desc, SAM_UNK_INFO_12 * u_12,
+static BOOL sam_io_unk_info12(const char *desc, SAM_UNK_INFO_12 * u_12,
 			      prs_struct *ps, int depth)
 {
 	if (u_12 == NULL)
@@ -644,7 +644,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-static BOOL sam_io_unk_info5(char *desc, SAM_UNK_INFO_5 * u_5,
+static BOOL sam_io_unk_info5(const char *desc, SAM_UNK_INFO_5 * u_5,
 			     prs_struct *ps, int depth)
 {
 	if (u_5 == NULL)
@@ -700,7 +700,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-static BOOL sam_io_unk_info2(char *desc, SAM_UNK_INFO_2 * u_2,
+static BOOL sam_io_unk_info2(const char *desc, SAM_UNK_INFO_2 * u_2,
 			     prs_struct *ps, int depth)
 {
 	if (u_2 == NULL)
@@ -745,8 +745,14 @@
 	if(!prs_uint32("num_local_grps", ps, depth, &u_2->num_local_grps))
 		return False;
 
-	if(!prs_uint8s(False, "padding", ps, depth, u_2->padding,sizeof(u_2->padding)))
-		return False;
+	if (u_2->ptr_0) {
+		/* this was originally marked as 'padding'. It isn't
+		   padding, it is some sort of optional 12 byte
+		   structure. When it is present it contains zeros
+		   !? */
+		if(!prs_uint8s(False, "unknown", ps, depth, u_2->padding,sizeof(u_2->padding)))
+			return False;
+	}
 
 	if(!smb_io_unistr2("uni_domain", &u_2->uni_domain, u_2->hdr_domain.buffer, ps, depth))
 		return False;
@@ -781,7 +787,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-static BOOL sam_io_unk_info1(char *desc, SAM_UNK_INFO_1 * u_1,
+static BOOL sam_io_unk_info1(const char *desc, SAM_UNK_INFO_1 * u_1,
 			     prs_struct *ps, int depth)
 {
 	if (u_1 == NULL)
@@ -829,7 +835,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-BOOL samr_io_r_query_dom_info(char *desc, SAMR_R_QUERY_DOMAIN_INFO * r_u,
+BOOL samr_io_r_query_dom_info(const char *desc, SAMR_R_QUERY_DOMAIN_INFO * r_u,
 			      prs_struct *ps, int depth)
 {
         if (r_u == NULL)
@@ -900,7 +906,7 @@
 reads or writes a SAMR_R_SET_SEC_OBJ structure.
 ********************************************************************/
 
-BOOL samr_io_r_set_sec_obj(char *desc, SAMR_R_SET_SEC_OBJ * r_u,
+BOOL samr_io_r_set_sec_obj(const char *desc, SAMR_R_SET_SEC_OBJ * r_u,
 			     prs_struct *ps, int depth)
 {
 	if (r_u == NULL)
@@ -922,7 +928,7 @@
 reads or writes a SAMR_R_QUERY_SEC_OBJ structure.
 ********************************************************************/
 
-BOOL samr_io_r_query_sec_obj(char *desc, SAMR_R_QUERY_SEC_OBJ * r_u,
+BOOL samr_io_r_query_sec_obj(const char *desc, SAMR_R_QUERY_SEC_OBJ * r_u,
 			     prs_struct *ps, int depth)
 {
 	if (r_u == NULL)
@@ -951,7 +957,7 @@
 reads or writes a SAM_STR1 structure.
 ********************************************************************/
 
-static BOOL sam_io_sam_str1(char *desc, SAM_STR1 * sam, uint32 acct_buf,
+static BOOL sam_io_sam_str1(const char *desc, SAM_STR1 * sam, uint32 acct_buf,
 			    uint32 name_buf, uint32 desc_buf,
 			    prs_struct *ps, int depth)
 {
@@ -1001,7 +1007,7 @@
 reads or writes a SAM_ENTRY1 structure.
 ********************************************************************/
 
-static BOOL sam_io_sam_entry1(char *desc, SAM_ENTRY1 * sam,
+static BOOL sam_io_sam_entry1(const char *desc, SAM_ENTRY1 * sam,
 			      prs_struct *ps, int depth)
 {
 	if (sam == NULL)
@@ -1038,7 +1044,7 @@
 reads or writes a SAM_STR2 structure.
 ********************************************************************/
 
-static BOOL sam_io_sam_str2(char *desc, SAM_STR2 * sam, uint32 acct_buf,
+static BOOL sam_io_sam_str2(const char *desc, SAM_STR2 * sam, uint32 acct_buf,
 			    uint32 desc_buf, prs_struct *ps, int depth)
 {
 	if (sam == NULL)
@@ -1079,7 +1085,7 @@
 reads or writes a SAM_ENTRY2 structure.
 ********************************************************************/
 
-static BOOL sam_io_sam_entry2(char *desc, SAM_ENTRY2 * sam,
+static BOOL sam_io_sam_entry2(const char *desc, SAM_ENTRY2 * sam,
 			      prs_struct *ps, int depth)
 {
 	if (sam == NULL)
@@ -1114,7 +1120,7 @@
 reads or writes a SAM_STR3 structure.
 ********************************************************************/
 
-static BOOL sam_io_sam_str3(char *desc, SAM_STR3 * sam, uint32 acct_buf,
+static BOOL sam_io_sam_str3(const char *desc, SAM_STR3 * sam, uint32 acct_buf,
 			    uint32 desc_buf, prs_struct *ps, int depth)
 {
 	if (sam == NULL)
@@ -1156,7 +1162,7 @@
 reads or writes a SAM_ENTRY3 structure.
 ********************************************************************/
 
-static BOOL sam_io_sam_entry3(char *desc, SAM_ENTRY3 * sam,
+static BOOL sam_io_sam_entry3(const char *desc, SAM_ENTRY3 * sam,
 			      prs_struct *ps, int depth)
 {
 	if (sam == NULL)
@@ -1201,7 +1207,7 @@
 reads or writes a SAM_ENTRY4 structure.
 ********************************************************************/
 
-static BOOL sam_io_sam_entry4(char *desc, SAM_ENTRY4 * sam,
+static BOOL sam_io_sam_entry4(const char *desc, SAM_ENTRY4 * sam,
 			      prs_struct *ps, int depth)
 {
 	if (sam == NULL)
@@ -1239,7 +1245,7 @@
 reads or writes a SAM_ENTRY5 structure.
 ********************************************************************/
 
-static BOOL sam_io_sam_entry5(char *desc, SAM_ENTRY5 * sam,
+static BOOL sam_io_sam_entry5(const char *desc, SAM_ENTRY5 * sam,
 			      prs_struct *ps, int depth)
 {
 	if (sam == NULL)
@@ -1275,7 +1281,7 @@
 reads or writes a SAM_ENTRY structure.
 ********************************************************************/
 
-static BOOL sam_io_sam_entry(char *desc, SAM_ENTRY * sam,
+static BOOL sam_io_sam_entry(const char *desc, SAM_ENTRY * sam,
 			     prs_struct *ps, int depth)
 {
 	if (sam == NULL)
@@ -1316,7 +1322,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-BOOL samr_io_q_enum_dom_users(char *desc, SAMR_Q_ENUM_DOM_USERS * q_e,
+BOOL samr_io_q_enum_dom_users(const char *desc, SAMR_Q_ENUM_DOM_USERS * q_e,
 			      prs_struct *ps, int depth)
 {
 	if (q_e == NULL)
@@ -1374,7 +1380,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-BOOL samr_io_r_enum_dom_users(char *desc, SAMR_R_ENUM_DOM_USERS * r_u,
+BOOL samr_io_r_enum_dom_users(const char *desc, SAMR_R_ENUM_DOM_USERS * r_u,
 			      prs_struct *ps, int depth)
 {
 	uint32 i;
@@ -1442,7 +1448,7 @@
 
 void init_samr_q_query_dispinfo(SAMR_Q_QUERY_DISPINFO * q_e, POLICY_HND *pol,
 				uint16 switch_level, uint32 start_idx,
-				uint32 max_entries)
+				uint32 max_entries, uint32 max_size)
 {
 	DEBUG(5, ("init_samr_q_query_dispinfo\n"));
 
@@ -1452,14 +1458,14 @@
 
 	q_e->start_idx = start_idx;
 	q_e->max_entries = max_entries;
-	q_e->max_size = 0xffff;	/* Not especially useful */
+	q_e->max_size = max_size;
 }
 
 /*******************************************************************
 reads or writes a structure.
 ********************************************************************/
 
-BOOL samr_io_q_query_dispinfo(char *desc, SAMR_Q_QUERY_DISPINFO * q_e,
+BOOL samr_io_q_query_dispinfo(const char *desc, SAMR_Q_QUERY_DISPINFO * q_e,
 			      prs_struct *ps, int depth)
 {
 	if (q_e == NULL)
@@ -1579,7 +1585,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-static BOOL sam_io_sam_dispinfo_1(char *desc, SAM_DISPINFO_1 * sam,
+static BOOL sam_io_sam_dispinfo_1(const char *desc, SAM_DISPINFO_1 * sam,
 				  uint32 num_entries,
 				  prs_struct *ps, int depth)
 {
@@ -1696,7 +1702,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-static BOOL sam_io_sam_dispinfo_2(char *desc, SAM_DISPINFO_2 * sam,
+static BOOL sam_io_sam_dispinfo_2(const char *desc, SAM_DISPINFO_2 * sam,
 				  uint32 num_entries,
 				  prs_struct *ps, int depth)
 {
@@ -1790,7 +1796,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-static BOOL sam_io_sam_dispinfo_3(char *desc, SAM_DISPINFO_3 * sam,
+static BOOL sam_io_sam_dispinfo_3(const char *desc, SAM_DISPINFO_3 * sam,
 				  uint32 num_entries,
 				  prs_struct *ps, int depth)
 {
@@ -1882,7 +1888,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-static BOOL sam_io_sam_dispinfo_4(char *desc, SAM_DISPINFO_4 * sam,
+static BOOL sam_io_sam_dispinfo_4(const char *desc, SAM_DISPINFO_4 * sam,
 				  uint32 num_entries,
 				  prs_struct *ps, int depth)
 {
@@ -1972,7 +1978,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-static BOOL sam_io_sam_dispinfo_5(char *desc, SAM_DISPINFO_5 * sam,
+static BOOL sam_io_sam_dispinfo_5(const char *desc, SAM_DISPINFO_5 * sam,
 				  uint32 num_entries,
 				  prs_struct *ps, int depth)
 {
@@ -2051,7 +2057,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-BOOL samr_io_r_query_dispinfo(char *desc, SAMR_R_QUERY_DISPINFO * r_u,
+BOOL samr_io_r_query_dispinfo(const char *desc, SAMR_R_QUERY_DISPINFO * r_u,
 			      prs_struct *ps, int depth)
 {
 	if (r_u == NULL)
@@ -2149,7 +2155,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-BOOL samr_io_q_open_group(char *desc, SAMR_Q_OPEN_GROUP * q_u,
+BOOL samr_io_q_open_group(const char *desc, SAMR_Q_OPEN_GROUP * q_u,
 			  prs_struct *ps, int depth)
 {
 	if (q_u == NULL)
@@ -2176,7 +2182,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-BOOL samr_io_r_open_group(char *desc, SAMR_R_OPEN_GROUP * r_u,
+BOOL samr_io_r_open_group(const char *desc, SAMR_R_OPEN_GROUP * r_u,
 			  prs_struct *ps, int depth)
 {
 	if (r_u == NULL)
@@ -2225,7 +2231,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-BOOL samr_io_group_info1(char *desc, GROUP_INFO1 * gr1,
+BOOL samr_io_group_info1(const char *desc, GROUP_INFO1 * gr1,
 			 prs_struct *ps, int depth)
 {
 	if (gr1 == NULL)
@@ -2274,7 +2280,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-BOOL samr_io_group_info3(char *desc, GROUP_INFO3 *gr3, prs_struct *ps, int depth)
+BOOL samr_io_group_info3(const char *desc, GROUP_INFO3 *gr3, prs_struct *ps, int depth)
 {
 	if (gr3 == NULL)
 		return False;
@@ -2309,7 +2315,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-BOOL samr_io_group_info4(char *desc, GROUP_INFO4 * gr4,
+BOOL samr_io_group_info4(const char *desc, GROUP_INFO4 * gr4,
 			 prs_struct *ps, int depth)
 {
 	if (gr4 == NULL)
@@ -2334,7 +2340,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-static BOOL samr_group_info_ctr(char *desc, GROUP_INFO_CTR **ctr,
+static BOOL samr_group_info_ctr(const char *desc, GROUP_INFO_CTR **ctr,
 				prs_struct *ps, int depth)
 {
 	if (UNMARSHALLING(ps))
@@ -2394,7 +2400,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-BOOL samr_io_q_create_dom_group(char *desc, SAMR_Q_CREATE_DOM_GROUP * q_e,
+BOOL samr_io_q_create_dom_group(const char *desc, SAMR_Q_CREATE_DOM_GROUP * q_e,
 				prs_struct *ps, int depth)
 {
 	if (q_e == NULL)
@@ -2427,7 +2433,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-BOOL samr_io_r_create_dom_group(char *desc, SAMR_R_CREATE_DOM_GROUP * r_u,
+BOOL samr_io_r_create_dom_group(const char *desc, SAMR_R_CREATE_DOM_GROUP * r_u,
 				prs_struct *ps, int depth)
 {
 	if (r_u == NULL)
@@ -2466,7 +2472,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-BOOL samr_io_q_delete_dom_group(char *desc, SAMR_Q_DELETE_DOM_GROUP * q_u,
+BOOL samr_io_q_delete_dom_group(const char *desc, SAMR_Q_DELETE_DOM_GROUP * q_u,
 				prs_struct *ps, int depth)
 {
 	if (q_u == NULL)
@@ -2488,7 +2494,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-BOOL samr_io_r_delete_dom_group(char *desc, SAMR_R_DELETE_DOM_GROUP * r_u,
+BOOL samr_io_r_delete_dom_group(const char *desc, SAMR_R_DELETE_DOM_GROUP * r_u,
 				prs_struct *ps, int depth)
 {
 	if (r_u == NULL)
@@ -2526,7 +2532,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-BOOL samr_io_q_del_groupmem(char *desc, SAMR_Q_DEL_GROUPMEM * q_e,
+BOOL samr_io_q_del_groupmem(const char *desc, SAMR_Q_DEL_GROUPMEM * q_e,
 			    prs_struct *ps, int depth)
 {
 	if (q_e == NULL)
@@ -2563,7 +2569,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-BOOL samr_io_r_del_groupmem(char *desc, SAMR_R_DEL_GROUPMEM * r_u,
+BOOL samr_io_r_del_groupmem(const char *desc, SAMR_R_DEL_GROUPMEM * r_u,
 			    prs_struct *ps, int depth)
 {
 	if (r_u == NULL)
@@ -2599,7 +2605,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-BOOL samr_io_q_add_groupmem(char *desc, SAMR_Q_ADD_GROUPMEM * q_e,
+BOOL samr_io_q_add_groupmem(const char *desc, SAMR_Q_ADD_GROUPMEM * q_e,
 			    prs_struct *ps, int depth)
 {
 	if (q_e == NULL)
@@ -2638,7 +2644,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-BOOL samr_io_r_add_groupmem(char *desc, SAMR_R_ADD_GROUPMEM * r_u,
+BOOL samr_io_r_add_groupmem(const char *desc, SAMR_R_ADD_GROUPMEM * r_u,
 			    prs_struct *ps, int depth)
 {
 	if (r_u == NULL)
@@ -2673,7 +2679,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-BOOL samr_io_q_set_groupinfo(char *desc, SAMR_Q_SET_GROUPINFO * q_e,
+BOOL samr_io_q_set_groupinfo(const char *desc, SAMR_Q_SET_GROUPINFO * q_e,
 			     prs_struct *ps, int depth)
 {
 	if (q_e == NULL)
@@ -2709,7 +2715,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-BOOL samr_io_r_set_groupinfo(char *desc, SAMR_R_SET_GROUPINFO * r_u,
+BOOL samr_io_r_set_groupinfo(const char *desc, SAMR_R_SET_GROUPINFO * r_u,
 			     prs_struct *ps, int depth)
 {
 	if (r_u == NULL)
@@ -2745,7 +2751,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-BOOL samr_io_q_query_groupinfo(char *desc, SAMR_Q_QUERY_GROUPINFO * q_e,
+BOOL samr_io_q_query_groupinfo(const char *desc, SAMR_Q_QUERY_GROUPINFO * q_e,
 			       prs_struct *ps, int depth)
 {
 	if (q_e == NULL)
@@ -2784,7 +2790,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-BOOL samr_io_r_query_groupinfo(char *desc, SAMR_R_QUERY_GROUPINFO * r_u,
+BOOL samr_io_r_query_groupinfo(const char *desc, SAMR_R_QUERY_GROUPINFO * r_u,
 			       prs_struct *ps, int depth)
 {
 	if (r_u == NULL)
@@ -2827,7 +2833,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-BOOL samr_io_q_query_groupmem(char *desc, SAMR_Q_QUERY_GROUPMEM * q_u,
+BOOL samr_io_q_query_groupmem(const char *desc, SAMR_Q_QUERY_GROUPMEM * q_u,
 			      prs_struct *ps, int depth)
 {
 	if (q_u == NULL)
@@ -2879,7 +2885,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-BOOL samr_io_r_query_groupmem(char *desc, SAMR_R_QUERY_GROUPMEM * r_u,
+BOOL samr_io_r_query_groupmem(const char *desc, SAMR_R_QUERY_GROUPMEM * r_u,
 			      prs_struct *ps, int depth)
 {
 	uint32 i;
@@ -2961,7 +2967,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-BOOL samr_io_q_query_usergroups(char *desc, SAMR_Q_QUERY_USERGROUPS * q_u,
+BOOL samr_io_q_query_usergroups(const char *desc, SAMR_Q_QUERY_USERGROUPS * q_u,
 				prs_struct *ps, int depth)
 {
 	if (q_u == NULL)
@@ -3010,7 +3016,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-BOOL samr_io_gids(char *desc, uint32 *num_gids, DOM_GID ** gid,
+BOOL samr_io_gids(const char *desc, uint32 *num_gids, DOM_GID ** gid,
 		  prs_struct *ps, int depth)
 {
 	uint32 i;
@@ -3048,7 +3054,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-BOOL samr_io_r_query_usergroups(char *desc, SAMR_R_QUERY_USERGROUPS * r_u,
+BOOL samr_io_r_query_usergroups(const char *desc, SAMR_R_QUERY_USERGROUPS * r_u,
 				prs_struct *ps, int depth)
 {
 	if (r_u == NULL)
@@ -3103,7 +3109,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-BOOL samr_io_q_enum_domains(char *desc, SAMR_Q_ENUM_DOMAINS * q_e,
+BOOL samr_io_q_enum_domains(const char *desc, SAMR_Q_ENUM_DOMAINS * q_e,
 			    prs_struct *ps, int depth)
 {
 	if (q_e == NULL)
@@ -3155,7 +3161,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-BOOL samr_io_r_enum_domains(char *desc, SAMR_R_ENUM_DOMAINS * r_u,
+BOOL samr_io_r_enum_domains(const char *desc, SAMR_R_ENUM_DOMAINS * r_u,
 			    prs_struct *ps, int depth)
 {
 	uint32 i;
@@ -3242,7 +3248,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-BOOL samr_io_q_enum_dom_groups(char *desc, SAMR_Q_ENUM_DOM_GROUPS * q_e,
+BOOL samr_io_q_enum_dom_groups(const char *desc, SAMR_Q_ENUM_DOM_GROUPS * q_e,
 			       prs_struct *ps, int depth)
 {
 	if (q_e == NULL)
@@ -3294,7 +3300,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-BOOL samr_io_r_enum_dom_groups(char *desc, SAMR_R_ENUM_DOM_GROUPS * r_u,
+BOOL samr_io_r_enum_dom_groups(const char *desc, SAMR_R_ENUM_DOM_GROUPS * r_u,
 			       prs_struct *ps, int depth)
 {
 	uint32 i;
@@ -3377,7 +3383,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-BOOL samr_io_q_enum_dom_aliases(char *desc, SAMR_Q_ENUM_DOM_ALIASES * q_e,
+BOOL samr_io_q_enum_dom_aliases(const char *desc, SAMR_Q_ENUM_DOM_ALIASES * q_e,
 				prs_struct *ps, int depth)
 {
 	if (q_e == NULL)
@@ -3428,7 +3434,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-BOOL samr_io_r_enum_dom_aliases(char *desc, SAMR_R_ENUM_DOM_ALIASES * r_u,
+BOOL samr_io_r_enum_dom_aliases(const char *desc, SAMR_R_ENUM_DOM_ALIASES * r_u,
 				prs_struct *ps, int depth)
 {
 	uint32 i;
@@ -3515,7 +3521,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-BOOL samr_io_alias_info1(char *desc, ALIAS_INFO1 * al1,
+BOOL samr_io_alias_info1(const char *desc, ALIAS_INFO1 * al1,
 			 prs_struct *ps, int depth)
 {
 	if (al1 == NULL)
@@ -3566,7 +3572,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-BOOL samr_io_alias_info3(char *desc, ALIAS_INFO3 * al3,
+BOOL samr_io_alias_info3(const char *desc, ALIAS_INFO3 * al3,
 			 prs_struct *ps, int depth)
 {
 	if (al3 == NULL)
@@ -3591,7 +3597,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-BOOL samr_alias_info_ctr(char *desc, ALIAS_INFO_CTR * ctr,
+BOOL samr_alias_info_ctr(const char *desc, ALIAS_INFO_CTR * ctr,
 			 prs_struct *ps, int depth)
 {
 	if (ctr == NULL)
@@ -3639,7 +3645,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-BOOL samr_io_q_query_aliasinfo(char *desc, SAMR_Q_QUERY_ALIASINFO * q_e,
+BOOL samr_io_q_query_aliasinfo(const char *desc, SAMR_Q_QUERY_ALIASINFO * q_e,
 			       prs_struct *ps, int depth)
 {
 	if (q_e == NULL)
@@ -3678,7 +3684,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-BOOL samr_io_r_query_aliasinfo(char *desc, SAMR_R_QUERY_ALIASINFO * r_u,
+BOOL samr_io_r_query_aliasinfo(const char *desc, SAMR_R_QUERY_ALIASINFO * r_u,
 			       prs_struct *ps, int depth)
 {
 	if (r_u == NULL)
@@ -3723,7 +3729,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-BOOL samr_io_q_set_aliasinfo(char *desc, SAMR_Q_SET_ALIASINFO * q_u,
+BOOL samr_io_q_set_aliasinfo(const char *desc, SAMR_Q_SET_ALIASINFO * q_u,
 			     prs_struct *ps, int depth)
 {
 	if (q_u == NULL)
@@ -3747,7 +3753,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-BOOL samr_io_r_set_aliasinfo(char *desc, SAMR_R_SET_ALIASINFO * r_u,
+BOOL samr_io_r_set_aliasinfo(const char *desc, SAMR_R_SET_ALIASINFO * r_u,
 			     prs_struct *ps, int depth)
 {
 	if (r_u == NULL)
@@ -3789,7 +3795,7 @@
 reads or writes a SAMR_Q_QUERY_USERALIASES structure.
 ********************************************************************/
 
-BOOL samr_io_q_query_useraliases(char *desc, SAMR_Q_QUERY_USERALIASES * q_u,
+BOOL samr_io_q_query_useraliases(const char *desc, SAMR_Q_QUERY_USERALIASES * q_u,
 				 prs_struct *ps, int depth)
 {
 	fstring tmp;
@@ -3874,7 +3880,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-BOOL samr_io_rids(char *desc, uint32 *num_rids, uint32 **rid,
+BOOL samr_io_rids(const char *desc, uint32 *num_rids, uint32 **rid,
 		  prs_struct *ps, int depth)
 {
 	fstring tmp;
@@ -3913,7 +3919,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-BOOL samr_io_r_query_useraliases(char *desc, SAMR_R_QUERY_USERALIASES * r_u,
+BOOL samr_io_r_query_useraliases(const char *desc, SAMR_R_QUERY_USERALIASES * r_u,
 				 prs_struct *ps, int depth)
 {
 	if (r_u == NULL)
@@ -3961,7 +3967,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-BOOL samr_io_q_open_alias(char *desc, SAMR_Q_OPEN_ALIAS * q_u,
+BOOL samr_io_q_open_alias(const char *desc, SAMR_Q_OPEN_ALIAS * q_u,
 			  prs_struct *ps, int depth)
 {
 	if (q_u == NULL)
@@ -3988,7 +3994,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-BOOL samr_io_r_open_alias(char *desc, SAMR_R_OPEN_ALIAS * r_u,
+BOOL samr_io_r_open_alias(const char *desc, SAMR_R_OPEN_ALIAS * r_u,
 			  prs_struct *ps, int depth)
 {
 	if (r_u == NULL)
@@ -4038,7 +4044,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-BOOL samr_io_q_lookup_rids(char *desc, SAMR_Q_LOOKUP_RIDS * q_u,
+BOOL samr_io_q_lookup_rids(const char *desc, SAMR_Q_LOOKUP_RIDS * q_u,
 			   prs_struct *ps, int depth)
 {
 	uint32 i;
@@ -4124,7 +4130,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-BOOL samr_io_r_lookup_rids(char *desc, SAMR_R_LOOKUP_RIDS * r_u,
+BOOL samr_io_r_lookup_rids(const char *desc, SAMR_R_LOOKUP_RIDS * r_u,
 			   prs_struct *ps, int depth)
 {
 	uint32 i;
@@ -4218,7 +4224,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-BOOL samr_io_q_delete_alias(char *desc, SAMR_Q_DELETE_DOM_ALIAS * q_u,
+BOOL samr_io_q_delete_alias(const char *desc, SAMR_Q_DELETE_DOM_ALIAS * q_u,
 			    prs_struct *ps, int depth)
 {
 	if (q_u == NULL)
@@ -4240,7 +4246,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-BOOL samr_io_r_delete_alias(char *desc, SAMR_R_DELETE_DOM_ALIAS * r_u,
+BOOL samr_io_r_delete_alias(const char *desc, SAMR_R_DELETE_DOM_ALIAS * r_u,
 			    prs_struct *ps, int depth)
 {
 	if (r_u == NULL)
@@ -4283,7 +4289,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-BOOL samr_io_q_create_dom_alias(char *desc, SAMR_Q_CREATE_DOM_ALIAS * q_u,
+BOOL samr_io_q_create_dom_alias(const char *desc, SAMR_Q_CREATE_DOM_ALIAS * q_u,
 				prs_struct *ps, int depth)
 {
 	if (q_u == NULL)
@@ -4316,7 +4322,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-BOOL samr_io_r_create_dom_alias(char *desc, SAMR_R_CREATE_DOM_ALIAS * r_u,
+BOOL samr_io_r_create_dom_alias(const char *desc, SAMR_R_CREATE_DOM_ALIAS * r_u,
 				prs_struct *ps, int depth)
 {
 	if (r_u == NULL)
@@ -4357,7 +4363,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-BOOL samr_io_q_add_aliasmem(char *desc, SAMR_Q_ADD_ALIASMEM * q_u,
+BOOL samr_io_q_add_aliasmem(const char *desc, SAMR_Q_ADD_ALIASMEM * q_u,
 			    prs_struct *ps, int depth)
 {
 	if (q_u == NULL)
@@ -4381,7 +4387,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-BOOL samr_io_r_add_aliasmem(char *desc, SAMR_R_ADD_ALIASMEM * r_u,
+BOOL samr_io_r_add_aliasmem(const char *desc, SAMR_R_ADD_ALIASMEM * r_u,
 			    prs_struct *ps, int depth)
 {
 	if (r_u == NULL)
@@ -4416,7 +4422,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-BOOL samr_io_q_del_aliasmem(char *desc, SAMR_Q_DEL_ALIASMEM * q_u,
+BOOL samr_io_q_del_aliasmem(const char *desc, SAMR_Q_DEL_ALIASMEM * q_u,
 			    prs_struct *ps, int depth)
 {
 	if (q_u == NULL)
@@ -4440,7 +4446,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-BOOL samr_io_r_del_aliasmem(char *desc, SAMR_R_DEL_ALIASMEM * r_u,
+BOOL samr_io_r_del_aliasmem(const char *desc, SAMR_R_DEL_ALIASMEM * r_u,
 			    prs_struct *ps, int depth)
 {
 	if (r_u == NULL)
@@ -4474,7 +4480,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-BOOL samr_io_q_delete_dom_alias(char *desc, SAMR_Q_DELETE_DOM_ALIAS * q_u,
+BOOL samr_io_q_delete_dom_alias(const char *desc, SAMR_Q_DELETE_DOM_ALIAS * q_u,
 				prs_struct *ps, int depth)
 {
 	if (q_u == NULL)
@@ -4508,7 +4514,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-BOOL samr_io_r_delete_dom_alias(char *desc, SAMR_R_DELETE_DOM_ALIAS * r_u,
+BOOL samr_io_r_delete_dom_alias(const char *desc, SAMR_R_DELETE_DOM_ALIAS * r_u,
 				prs_struct *ps, int depth)
 {
 	if (r_u == NULL)
@@ -4542,7 +4548,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-BOOL samr_io_q_query_aliasmem(char *desc, SAMR_Q_QUERY_ALIASMEM * q_u,
+BOOL samr_io_q_query_aliasmem(const char *desc, SAMR_Q_QUERY_ALIASMEM * q_u,
 			      prs_struct *ps, int depth)
 {
 	if (q_u == NULL)
@@ -4588,7 +4594,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-BOOL samr_io_r_query_aliasmem(char *desc, SAMR_R_QUERY_ALIASMEM * r_u,
+BOOL samr_io_r_query_aliasmem(const char *desc, SAMR_R_QUERY_ALIASMEM * r_u,
 			      prs_struct *ps, int depth)
 {
 	uint32 i;
@@ -4676,7 +4682,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-BOOL samr_io_q_lookup_names(char *desc, SAMR_Q_LOOKUP_NAMES * q_u,
+BOOL samr_io_q_lookup_names(const char *desc, SAMR_Q_LOOKUP_NAMES * q_u,
 			    prs_struct *ps, int depth)
 {
 	uint32 i;
@@ -4785,7 +4791,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-BOOL samr_io_r_lookup_names(char *desc, SAMR_R_LOOKUP_NAMES * r_u,
+BOOL samr_io_r_lookup_names(const char *desc, SAMR_R_LOOKUP_NAMES * r_u,
 			    prs_struct *ps, int depth)
 {
 	uint32 i;
@@ -4883,7 +4889,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-BOOL samr_io_q_delete_dom_user(char *desc, SAMR_Q_DELETE_DOM_USER * q_u,
+BOOL samr_io_q_delete_dom_user(const char *desc, SAMR_Q_DELETE_DOM_USER * q_u,
 			       prs_struct *ps, int depth)
 {
 	if (q_u == NULL)
@@ -4905,7 +4911,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-BOOL samr_io_r_delete_dom_user(char *desc, SAMR_R_DELETE_DOM_USER * r_u,
+BOOL samr_io_r_delete_dom_user(const char *desc, SAMR_R_DELETE_DOM_USER * r_u,
 			       prs_struct *ps, int depth)
 {
 	if (r_u == NULL)
@@ -4944,7 +4950,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-BOOL samr_io_q_open_user(char *desc, SAMR_Q_OPEN_USER * q_u,
+BOOL samr_io_q_open_user(const char *desc, SAMR_Q_OPEN_USER * q_u,
 			 prs_struct *ps, int depth)
 {
 	if (q_u == NULL)
@@ -4971,7 +4977,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-BOOL samr_io_r_open_user(char *desc, SAMR_R_OPEN_USER * r_u,
+BOOL samr_io_r_open_user(const char *desc, SAMR_R_OPEN_USER * r_u,
 			 prs_struct *ps, int depth)
 {
 	if (r_u == NULL)
@@ -5020,7 +5026,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-BOOL samr_io_q_create_user(char *desc, SAMR_Q_CREATE_USER * q_u,
+BOOL samr_io_q_create_user(const char *desc, SAMR_Q_CREATE_USER * q_u,
 			   prs_struct *ps, int depth)
 {
 	if (q_u == NULL)
@@ -5054,7 +5060,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-BOOL samr_io_r_create_user(char *desc, SAMR_R_CREATE_USER * r_u,
+BOOL samr_io_r_create_user(const char *desc, SAMR_R_CREATE_USER * r_u,
 			   prs_struct *ps, int depth)
 {
 	if (r_u == NULL)
@@ -5096,7 +5102,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-BOOL samr_io_q_query_userinfo(char *desc, SAMR_Q_QUERY_USERINFO * q_u,
+BOOL samr_io_q_query_userinfo(const char *desc, SAMR_Q_QUERY_USERINFO * q_u,
 			      prs_struct *ps, int depth)
 {
 	if (q_u == NULL)
@@ -5121,7 +5127,7 @@
 reads or writes a LOGON_HRS structure.
 ********************************************************************/
 
-static BOOL sam_io_logon_hrs(char *desc, LOGON_HRS * hrs,
+static BOOL sam_io_logon_hrs(const char *desc, LOGON_HRS * hrs,
 			     prs_struct *ps, int depth)
 {
 	if (hrs == NULL)
@@ -5166,7 +5172,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-static BOOL sam_io_user_info12(char *desc, SAM_USER_INFO_12 * u,
+static BOOL sam_io_user_info12(const char *desc, SAM_USER_INFO_12 * u,
 			prs_struct *ps, int depth)
 {
 	if (u == NULL)
@@ -5206,7 +5212,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-static BOOL sam_io_user_info10(char *desc, SAM_USER_INFO_10 * usr,
+static BOOL sam_io_user_info10(const char *desc, SAM_USER_INFO_10 * usr,
 			prs_struct *ps, int depth)
 {
 	if (usr == NULL)
@@ -5274,7 +5280,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-static BOOL sam_io_user_info11(char *desc, SAM_USER_INFO_11 * usr,
+static BOOL sam_io_user_info11(const char *desc, SAM_USER_INFO_11 * usr,
 			prs_struct *ps, int depth)
 {
 	if (usr == NULL)
@@ -5370,7 +5376,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-static BOOL sam_io_user_info24(char *desc, SAM_USER_INFO_24 * usr,
+static BOOL sam_io_user_info24(const char *desc, SAM_USER_INFO_24 * usr,
 			       prs_struct *ps, int depth)
 {
 	if (usr == NULL)
@@ -5519,7 +5525,7 @@
 			   char *user_name,	/* NULL */
 			   char *full_name,
 			   char *home_dir, char *dir_drive, char *log_scr,
-			   char *prof_path, char *desc, char *wkstas,
+			   char *prof_path, const char *desc, char *wkstas,
 			   char *unk_str, char *mung_dial, uint32 user_rid,	/* 0x0000 0000 */
 			   uint32 group_rid, uint32 acb_info,
 			   uint32 unknown_3, uint16 logon_divs,
@@ -5600,7 +5606,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-static BOOL sam_io_user_info23(char *desc, SAM_USER_INFO_23 * usr,
+static BOOL sam_io_user_info23(const char *desc, SAM_USER_INFO_23 * usr,
 			       prs_struct *ps, int depth)
 {
 	if (usr == NULL)
@@ -5736,7 +5742,7 @@
  way than normal... And there are definately other problems. JRA.
 ********************************************************************/
 
-static BOOL sam_io_user_info25(char *desc, SAM_USER_INFO_25 * usr, prs_struct *ps, int depth)
+static BOOL sam_io_user_info25(const char *desc, SAM_USER_INFO_25 * usr, prs_struct *ps, int depth)
 {
 	if (usr == NULL)
 		return False;
@@ -6114,7 +6120,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-static BOOL sam_io_user_info21(char *desc, SAM_USER_INFO_21 * usr,
+static BOOL sam_io_user_info21(const char *desc, SAM_USER_INFO_21 * usr,
 			prs_struct *ps, int depth)
 {
 	if (usr == NULL)
@@ -6247,7 +6253,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-static BOOL sam_io_user_info20(char *desc, SAM_USER_INFO_20 *usr,
+static BOOL sam_io_user_info20(const char *desc, SAM_USER_INFO_20 *usr,
 			prs_struct *ps, int depth)
 {
 	if (usr == NULL)
@@ -6368,7 +6374,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-static BOOL samr_io_userinfo_ctr(char *desc, SAM_USERINFO_CTR **ppctr,
+static BOOL samr_io_userinfo_ctr(const char *desc, SAM_USERINFO_CTR **ppctr,
 				 prs_struct *ps, int depth)
 {
 	BOOL ret;
@@ -6508,7 +6514,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-BOOL samr_io_r_query_userinfo(char *desc, SAMR_R_QUERY_USERINFO * r_u,
+BOOL samr_io_r_query_userinfo(const char *desc, SAMR_R_QUERY_USERINFO * r_u,
 			      prs_struct *ps, int depth)
 {
 	if (r_u == NULL)
@@ -6555,7 +6561,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-BOOL samr_io_q_set_userinfo(char *desc, SAMR_Q_SET_USERINFO * q_u,
+BOOL samr_io_q_set_userinfo(const char *desc, SAMR_Q_SET_USERINFO * q_u,
 			    prs_struct *ps, int depth)
 {
 	if (q_u == NULL)
@@ -6592,7 +6598,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-BOOL samr_io_r_set_userinfo(char *desc, SAMR_R_SET_USERINFO * r_u,
+BOOL samr_io_r_set_userinfo(const char *desc, SAMR_R_SET_USERINFO * r_u,
 			    prs_struct *ps, int depth)
 {
 	if (r_u == NULL)
@@ -6642,7 +6648,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-BOOL samr_io_q_set_userinfo2(char *desc, SAMR_Q_SET_USERINFO2 * q_u,
+BOOL samr_io_q_set_userinfo2(const char *desc, SAMR_Q_SET_USERINFO2 * q_u,
 			     prs_struct *ps, int depth)
 {
 	if (q_u == NULL)
@@ -6680,7 +6686,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-BOOL samr_io_r_set_userinfo2(char *desc, SAMR_R_SET_USERINFO2 * r_u,
+BOOL samr_io_r_set_userinfo2(const char *desc, SAMR_R_SET_USERINFO2 * r_u,
 			     prs_struct *ps, int depth)
 {
 	if (r_u == NULL)
@@ -6721,7 +6727,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-BOOL samr_io_q_connect(char *desc, SAMR_Q_CONNECT * q_u,
+BOOL samr_io_q_connect(const char *desc, SAMR_Q_CONNECT * q_u,
 		       prs_struct *ps, int depth)
 {
 	if (q_u == NULL)
@@ -6750,7 +6756,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-BOOL samr_io_r_connect(char *desc, SAMR_R_CONNECT * r_u,
+BOOL samr_io_r_connect(const char *desc, SAMR_R_CONNECT * r_u,
 		       prs_struct *ps, int depth)
 {
 	if (r_u == NULL)
@@ -6797,7 +6803,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-BOOL samr_io_q_connect4(char *desc, SAMR_Q_CONNECT4 * q_u,
+BOOL samr_io_q_connect4(const char *desc, SAMR_Q_CONNECT4 * q_u,
 			prs_struct *ps, int depth)
 {
 	if (q_u == NULL)
@@ -6828,7 +6834,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-BOOL samr_io_r_connect4(char *desc, SAMR_R_CONNECT4 * r_u,
+BOOL samr_io_r_connect4(const char *desc, SAMR_R_CONNECT4 * r_u,
 			prs_struct *ps, int depth)
 {
 	if (r_u == NULL)
@@ -6867,7 +6873,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-BOOL samr_io_q_connect_anon(char *desc, SAMR_Q_CONNECT_ANON * q_u,
+BOOL samr_io_q_connect_anon(const char *desc, SAMR_Q_CONNECT_ANON * q_u,
 			    prs_struct *ps, int depth)
 {
 	if (q_u == NULL)
@@ -6895,7 +6901,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-BOOL samr_io_r_connect_anon(char *desc, SAMR_R_CONNECT_ANON * r_u,
+BOOL samr_io_r_connect_anon(const char *desc, SAMR_R_CONNECT_ANON * r_u,
 			    prs_struct *ps, int depth)
 {
 	if (r_u == NULL)
@@ -6936,7 +6942,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-BOOL samr_io_q_get_dom_pwinfo(char *desc, SAMR_Q_GET_DOM_PWINFO * q_u,
+BOOL samr_io_q_get_dom_pwinfo(const char *desc, SAMR_Q_GET_DOM_PWINFO * q_u,
 			      prs_struct *ps, int depth)
 {
 	if (q_u == NULL)
@@ -6964,7 +6970,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-BOOL samr_io_r_get_dom_pwinfo(char *desc, SAMR_R_GET_DOM_PWINFO * r_u,
+BOOL samr_io_r_get_dom_pwinfo(const char *desc, SAMR_R_GET_DOM_PWINFO * r_u,
 			      prs_struct *ps, int depth)
 {
 	if (r_u == NULL)
@@ -7014,7 +7020,7 @@
 reads or writes a SAMR_ENC_PASSWD structure.
 ********************************************************************/
 
-BOOL samr_io_enc_passwd(char *desc, SAMR_ENC_PASSWD * pwd,
+BOOL samr_io_enc_passwd(const char *desc, SAMR_ENC_PASSWD * pwd,
 			prs_struct *ps, int depth)
 {
 	if (pwd == NULL)
@@ -7057,7 +7063,7 @@
 reads or writes a SAMR_ENC_HASH structure.
 ********************************************************************/
 
-BOOL samr_io_enc_hash(char *desc, SAMR_ENC_HASH * hsh,
+BOOL samr_io_enc_hash(const char *desc, SAMR_ENC_HASH * hsh,
 		      prs_struct *ps, int depth)
 {
 	if (hsh == NULL)
@@ -7114,7 +7120,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-BOOL samr_io_q_chgpasswd_user(char *desc, SAMR_Q_CHGPASSWD_USER * q_u,
+BOOL samr_io_q_chgpasswd_user(const char *desc, SAMR_Q_CHGPASSWD_USER * q_u,
 			      prs_struct *ps, int depth)
 {
 	if (q_u == NULL)
@@ -7172,7 +7178,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-BOOL samr_io_r_chgpasswd_user(char *desc, SAMR_R_CHGPASSWD_USER * r_u,
+BOOL samr_io_r_chgpasswd_user(const char *desc, SAMR_R_CHGPASSWD_USER * r_u,
 			      prs_struct *ps, int depth)
 {
 	if (r_u == NULL)
@@ -7207,7 +7213,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-BOOL samr_io_q_unknown_2e(char *desc, SAMR_Q_UNKNOWN_2E *q_u,
+BOOL samr_io_q_unknown_2e(const char *desc, SAMR_Q_UNKNOWN_2E *q_u,
 			      prs_struct *ps, int depth)
 {
 	if (q_u == NULL)
@@ -7253,7 +7259,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-BOOL samr_io_r_samr_unknown_2e(char *desc, SAMR_R_UNKNOWN_2E * r_u,
+BOOL samr_io_r_samr_unknown_2e(const char *desc, SAMR_R_UNKNOWN_2E * r_u,
 			      prs_struct *ps, int depth)
 {
         if (r_u == NULL)
@@ -7342,7 +7348,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-BOOL samr_io_q_set_domain_info(char *desc, SAMR_Q_SET_DOMAIN_INFO *q_u,
+BOOL samr_io_q_set_domain_info(const char *desc, SAMR_Q_SET_DOMAIN_INFO *q_u,
 			      prs_struct *ps, int depth)
 {
 	if (q_u == NULL)
@@ -7423,7 +7429,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-BOOL samr_io_r_set_domain_info(char *desc, SAMR_R_SET_DOMAIN_INFO * r_u,
+BOOL samr_io_r_set_domain_info(const char *desc, SAMR_R_SET_DOMAIN_INFO * r_u,
 			      prs_struct *ps, int depth)
 {
         if (r_u == NULL)
diff -uNr samba-3.0alpha21.orig/source/rpc_parse/parse_sec.c samba-3.0alpha21/source/rpc_parse/parse_sec.c
--- samba-3.0alpha21.orig/source/rpc_parse/parse_sec.c	2003-02-16 19:06:32.000000000 -0600
+++ samba-3.0alpha21/source/rpc_parse/parse_sec.c	2003-02-16 19:05:46.000000000 -0600
@@ -40,7 +40,7 @@
  Reads or writes a SEC_ACCESS structure.
 ********************************************************************/
 
-BOOL sec_io_access(char *desc, SEC_ACCESS *t, prs_struct *ps, int depth)
+BOOL sec_io_access(const char *desc, SEC_ACCESS *t, prs_struct *ps, int depth)
 {
 	if (t == NULL)
 		return False;
@@ -103,7 +103,7 @@
  Reads or writes a SEC_ACE structure.
 ********************************************************************/
 
-BOOL sec_io_ace(char *desc, SEC_ACE *psa, prs_struct *ps, int depth)
+BOOL sec_io_ace(const char *desc, SEC_ACE *psa, prs_struct *ps, int depth)
 {
 	uint32 old_offset;
 	uint32 offset_ace_size;
@@ -281,7 +281,7 @@
  for you as it reads them.
 ********************************************************************/
 
-BOOL sec_io_acl(char *desc, SEC_ACL **ppsa, prs_struct *ps, int depth)
+BOOL sec_io_acl(const char *desc, SEC_ACL **ppsa, prs_struct *ps, int depth)
 {
 	int i;
 	uint32 old_offset;
@@ -720,7 +720,7 @@
  If reading and the *ppsd = NULL, allocates the structure.
 ********************************************************************/
 
-BOOL sec_io_desc(char *desc, SEC_DESC **ppsd, prs_struct *ps, int depth)
+BOOL sec_io_desc(const char *desc, SEC_DESC **ppsd, prs_struct *ps, int depth)
 {
 	uint32 old_offset;
 	uint32 max_offset = 0; /* after we're done, move offset to end */
@@ -782,7 +782,7 @@
 
 	if (psd->off_owner_sid != 0) {
 
-		tmp_offset = ps->data_offset;
+		tmp_offset = prs_offset(ps);
 		if(!prs_set_offset(ps, old_offset + psd->off_owner_sid))
 			return False;
 
@@ -803,7 +803,7 @@
 
 	if (psd->off_grp_sid != 0) {
 
-		tmp_offset = ps->data_offset;
+		tmp_offset = prs_offset(ps);
 		if(!prs_set_offset(ps, old_offset + psd->off_grp_sid))
 			return False;
 
@@ -823,7 +823,7 @@
 	}
 
 	if ((psd->type & SEC_DESC_SACL_PRESENT) && psd->off_sacl) {
-		tmp_offset = ps->data_offset;
+		tmp_offset = prs_offset(ps);
 		if(!prs_set_offset(ps, old_offset + psd->off_sacl))
 			return False;
 		if(!sec_io_acl("sacl", &psd->sacl, ps, depth))
@@ -835,7 +835,7 @@
 
 
 	if ((psd->type & SEC_DESC_DACL_PRESENT) && psd->off_dacl != 0) {
-		tmp_offset = ps->data_offset;
+		tmp_offset = prs_offset(ps);
 		if(!prs_set_offset(ps, old_offset + psd->off_dacl))
 			return False;
 		if(!sec_io_acl("dacl", &psd->dacl, ps, depth))
@@ -890,7 +890,7 @@
  Reads or writes a SEC_DESC_BUF structure.
 ********************************************************************/
 
-BOOL sec_io_desc_buf(char *desc, SEC_DESC_BUF **ppsdb, prs_struct *ps, int depth)
+BOOL sec_io_desc_buf(const char *desc, SEC_DESC_BUF **ppsdb, prs_struct *ps, int depth)
 {
 	uint32 off_len;
 	uint32 off_max_len;
diff -uNr samba-3.0alpha21.orig/source/rpc_parse/parse_spoolss.c samba-3.0alpha21/source/rpc_parse/parse_spoolss.c
--- samba-3.0alpha21.orig/source/rpc_parse/parse_spoolss.c	2003-02-16 19:06:33.000000000 -0600
+++ samba-3.0alpha21/source/rpc_parse/parse_spoolss.c	2003-02-16 19:05:46.000000000 -0600
@@ -48,7 +48,7 @@
 This should be moved in a more generic lib.
 ********************************************************************/  
 
-BOOL spoolss_io_system_time(char *desc, prs_struct *ps, int depth, SYSTEMTIME *systime)
+BOOL spoolss_io_system_time(const char *desc, prs_struct *ps, int depth, SYSTEMTIME *systime)
 {
 	if(!prs_uint16("year", ps, depth, &systime->year))
 		return False;
@@ -91,7 +91,7 @@
 reads or writes an DOC_INFO structure.
 ********************************************************************/  
 
-static BOOL smb_io_doc_info_1(char *desc, DOC_INFO_1 *info_1, prs_struct *ps, int depth)
+static BOOL smb_io_doc_info_1(const char *desc, DOC_INFO_1 *info_1, prs_struct *ps, int depth)
 {
 	if (info_1 == NULL) return False;
 
@@ -122,7 +122,7 @@
 reads or writes an DOC_INFO structure.
 ********************************************************************/  
 
-static BOOL smb_io_doc_info(char *desc, DOC_INFO *info, prs_struct *ps, int depth)
+static BOOL smb_io_doc_info(const char *desc, DOC_INFO *info, prs_struct *ps, int depth)
 {
 	uint32 useless_ptr=0;
 	
@@ -171,7 +171,7 @@
 reads or writes an DOC_INFO_CONTAINER structure.
 ********************************************************************/  
 
-static BOOL smb_io_doc_info_container(char *desc, DOC_INFO_CONTAINER *cont, prs_struct *ps, int depth)
+static BOOL smb_io_doc_info_container(const char *desc, DOC_INFO_CONTAINER *cont, prs_struct *ps, int depth)
 {
 	if (cont == NULL) return False;
 
@@ -198,7 +198,7 @@
    structure.  The _TYPE structure is really the deferred referrants (i.e
    the notify fields array) of the _TYPE structure. -tpot */
 
-static BOOL smb_io_notify_option_type(char *desc, SPOOL_NOTIFY_OPTION_TYPE *type, prs_struct *ps, int depth)
+static BOOL smb_io_notify_option_type(const char *desc, SPOOL_NOTIFY_OPTION_TYPE *type, prs_struct *ps, int depth)
 {
 	prs_debug(ps, depth, desc, "smb_io_notify_option_type");
 	depth++;
@@ -226,7 +226,7 @@
 reads or writes an NOTIFY OPTION TYPE DATA.
 ********************************************************************/  
 
-static BOOL smb_io_notify_option_type_data(char *desc, SPOOL_NOTIFY_OPTION_TYPE *type, prs_struct *ps, int depth)
+static BOOL smb_io_notify_option_type_data(const char *desc, SPOOL_NOTIFY_OPTION_TYPE *type, prs_struct *ps, int depth)
 {
 	int i;
 
@@ -257,7 +257,7 @@
 reads or writes an NOTIFY OPTION structure.
 ********************************************************************/  
 
-static BOOL smb_io_notify_option_type_ctr(char *desc, SPOOL_NOTIFY_OPTION_TYPE_CTR *ctr , prs_struct *ps, int depth)
+static BOOL smb_io_notify_option_type_ctr(const char *desc, SPOOL_NOTIFY_OPTION_TYPE_CTR *ctr , prs_struct *ps, int depth)
 {		
 	int i;
 	
@@ -289,7 +289,7 @@
 reads or writes an NOTIFY OPTION structure.
 ********************************************************************/  
 
-static BOOL smb_io_notify_option(char *desc, SPOOL_NOTIFY_OPTION *option, prs_struct *ps, int depth)
+static BOOL smb_io_notify_option(const char *desc, SPOOL_NOTIFY_OPTION *option, prs_struct *ps, int depth)
 {
 	prs_debug(ps, depth, desc, "smb_io_notify_option");
 	depth++;
@@ -320,7 +320,7 @@
 reads or writes an NOTIFY INFO DATA structure.
 ********************************************************************/  
 
-static BOOL smb_io_notify_info_data(char *desc,SPOOL_NOTIFY_INFO_DATA *data, prs_struct *ps, int depth)
+static BOOL smb_io_notify_info_data(const char *desc,SPOOL_NOTIFY_INFO_DATA *data, prs_struct *ps, int depth)
 {
 	uint32 useless_ptr=0x0FF0ADDE;
 
@@ -399,7 +399,7 @@
 reads or writes an NOTIFY INFO DATA structure.
 ********************************************************************/  
 
-BOOL smb_io_notify_info_data_strings(char *desc,SPOOL_NOTIFY_INFO_DATA *data,
+BOOL smb_io_notify_info_data_strings(const char *desc,SPOOL_NOTIFY_INFO_DATA *data,
                                      prs_struct *ps, int depth)
 {
 	prs_debug(ps, depth, desc, "smb_io_notify_info_data_strings");
@@ -530,7 +530,7 @@
 reads or writes an NOTIFY INFO structure.
 ********************************************************************/  
 
-static BOOL smb_io_notify_info(char *desc, SPOOL_NOTIFY_INFO *info, prs_struct *ps, int depth)
+static BOOL smb_io_notify_info(const char *desc, SPOOL_NOTIFY_INFO *info, prs_struct *ps, int depth)
 {
 	int i;
 
@@ -566,7 +566,7 @@
 /*******************************************************************
 ********************************************************************/  
 
-static BOOL spool_io_user_level_1(char *desc, SPOOL_USER_1 *q_u, prs_struct *ps, int depth)
+static BOOL spool_io_user_level_1(const char *desc, SPOOL_USER_1 *q_u, prs_struct *ps, int depth)
 {
 	prs_debug(ps, depth, desc, "");
 	depth++;
@@ -605,7 +605,7 @@
 /*******************************************************************
 ********************************************************************/  
 
-static BOOL spool_io_user_level(char *desc, SPOOL_USER_CTR *q_u, prs_struct *ps, int depth)
+static BOOL spool_io_user_level(const char *desc, SPOOL_USER_CTR *q_u, prs_struct *ps, int depth)
 {
 	if (q_u==NULL)
 		return False;
@@ -615,6 +615,10 @@
 
 	if (!prs_align(ps))
 		return False;
+
+	/* From looking at many captures in ethereal, it looks like
+	   the level and ptr fields should be transposed.  -tpot */
+
 	if (!prs_uint32("level", ps, depth, &q_u->level))
 		return False;
 	if (!prs_uint32("ptr", ps, depth, &q_u->ptr))
@@ -639,7 +643,7 @@
 
 #define DM_NUM_OPTIONAL_FIELDS 		8
 
-BOOL spoolss_io_devmode(char *desc, prs_struct *ps, int depth, DEVICEMODE *devmode)
+BOOL spoolss_io_devmode(const char *desc, prs_struct *ps, int depth, DEVICEMODE *devmode)
 {
 	uint32 available_space;		/* size of the device mode left to parse */
 					/* only important on unmarshalling       */
@@ -825,7 +829,7 @@
  Read or write a DEVICEMODE container
 ********************************************************************/  
 
-static BOOL spoolss_io_devmode_cont(char *desc, DEVMODE_CTR *dm_c, prs_struct *ps, int depth)
+static BOOL spoolss_io_devmode_cont(const char *desc, DEVMODE_CTR *dm_c, prs_struct *ps, int depth)
 {
 	if (dm_c==NULL)
 		return False;
@@ -870,7 +874,7 @@
 /*******************************************************************
 ********************************************************************/  
 
-static BOOL spoolss_io_printer_default(char *desc, PRINTER_DEFAULT *pd, prs_struct *ps, int depth)
+static BOOL spoolss_io_printer_default(const char *desc, PRINTER_DEFAULT *pd, prs_struct *ps, int depth)
 {
 	if (pd==NULL)
 		return False;
@@ -1055,7 +1059,7 @@
  * called from spoolss_q_open_printer_ex (srv_spoolss.c)
  ********************************************************************/
 
-BOOL spoolss_io_q_open_printer(char *desc, SPOOL_Q_OPEN_PRINTER *q_u, prs_struct *ps, int depth)
+BOOL spoolss_io_q_open_printer(const char *desc, SPOOL_Q_OPEN_PRINTER *q_u, prs_struct *ps, int depth)
 {
 	if (q_u == NULL)
 		return False;
@@ -1086,7 +1090,7 @@
  * called from spoolss_open_printer_ex (cli_spoolss.c)
  ********************************************************************/
 
-BOOL spoolss_io_r_open_printer(char *desc, SPOOL_R_OPEN_PRINTER *r_u, prs_struct *ps, int depth)
+BOOL spoolss_io_r_open_printer(const char *desc, SPOOL_R_OPEN_PRINTER *r_u, prs_struct *ps, int depth)
 {
 	if (r_u == NULL) return False;
 
@@ -1111,7 +1115,7 @@
  * called from spoolss_q_open_printer_ex (srv_spoolss.c)
  ********************************************************************/
 
-BOOL spoolss_io_q_open_printer_ex(char *desc, SPOOL_Q_OPEN_PRINTER_EX *q_u, prs_struct *ps, int depth)
+BOOL spoolss_io_q_open_printer_ex(const char *desc, SPOOL_Q_OPEN_PRINTER_EX *q_u, prs_struct *ps, int depth)
 {
 	if (q_u == NULL)
 		return False;
@@ -1147,7 +1151,7 @@
  * called from spoolss_open_printer_ex (cli_spoolss.c)
  ********************************************************************/
 
-BOOL spoolss_io_r_open_printer_ex(char *desc, SPOOL_R_OPEN_PRINTER_EX *r_u, prs_struct *ps, int depth)
+BOOL spoolss_io_r_open_printer_ex(const char *desc, SPOOL_R_OPEN_PRINTER_EX *r_u, prs_struct *ps, int depth)
 {
 	if (r_u == NULL) return False;
 
@@ -1236,7 +1240,7 @@
  * called from spoolss_q_getprinterdata (srv_spoolss.c)
  ********************************************************************/
 
-BOOL spoolss_io_q_getprinterdata(char *desc, SPOOL_Q_GETPRINTERDATA *q_u, prs_struct *ps, int depth)
+BOOL spoolss_io_q_getprinterdata(const char *desc, SPOOL_Q_GETPRINTERDATA *q_u, prs_struct *ps, int depth)
 {
 	if (q_u == NULL)
 		return False;
@@ -1265,7 +1269,7 @@
  * called from spoolss_q_deleteprinterdata (srv_spoolss.c)
  ********************************************************************/
 
-BOOL spoolss_io_q_deleteprinterdata(char *desc, SPOOL_Q_DELETEPRINTERDATA *q_u, prs_struct *ps, int depth)
+BOOL spoolss_io_q_deleteprinterdata(const char *desc, SPOOL_Q_DELETEPRINTERDATA *q_u, prs_struct *ps, int depth)
 {
 	if (q_u == NULL)
 		return False;
@@ -1290,7 +1294,7 @@
  * called from spoolss_r_deleteprinterdata (srv_spoolss.c)
  ********************************************************************/
 
-BOOL spoolss_io_r_deleteprinterdata(char *desc, SPOOL_R_DELETEPRINTERDATA *r_u, prs_struct *ps, int depth)
+BOOL spoolss_io_r_deleteprinterdata(const char *desc, SPOOL_R_DELETEPRINTERDATA *r_u, prs_struct *ps, int depth)
 {
 	prs_debug(ps, depth, desc, "spoolss_io_r_deleteprinterdata");
 	depth++;
@@ -1305,7 +1309,7 @@
  * called from spoolss_q_deleteprinterdataex (srv_spoolss.c)
  ********************************************************************/
 
-BOOL spoolss_io_q_deleteprinterdataex(char *desc, SPOOL_Q_DELETEPRINTERDATAEX *q_u, prs_struct *ps, int depth)
+BOOL spoolss_io_q_deleteprinterdataex(const char *desc, SPOOL_Q_DELETEPRINTERDATAEX *q_u, prs_struct *ps, int depth)
 {
 	if (q_u == NULL)
 		return False;
@@ -1331,7 +1335,7 @@
  * called from spoolss_r_deleteprinterdataex (srv_spoolss.c)
  ********************************************************************/
 
-BOOL spoolss_io_r_deleteprinterdataex(char *desc, SPOOL_R_DELETEPRINTERDATAEX *r_u, prs_struct *ps, int depth)
+BOOL spoolss_io_r_deleteprinterdataex(const char *desc, SPOOL_R_DELETEPRINTERDATAEX *r_u, prs_struct *ps, int depth)
 {
 	prs_debug(ps, depth, desc, "spoolss_io_r_deleteprinterdataex");
 	depth++;
@@ -1347,7 +1351,7 @@
  * called from spoolss_r_getprinterdata (srv_spoolss.c)
  ********************************************************************/
 
-BOOL spoolss_io_r_getprinterdata(char *desc, SPOOL_R_GETPRINTERDATA *r_u, prs_struct *ps, int depth)
+BOOL spoolss_io_r_getprinterdata(const char *desc, SPOOL_R_GETPRINTERDATA *r_u, prs_struct *ps, int depth)
 {
 	if (r_u == NULL)
 		return False;
@@ -1403,7 +1407,7 @@
  * called from spoolss_abortprinter (cli_spoolss.c)
  ********************************************************************/
 
-BOOL spoolss_io_q_abortprinter(char *desc, SPOOL_Q_ABORTPRINTER *q_u, prs_struct *ps, int depth)
+BOOL spoolss_io_q_abortprinter(const char *desc, SPOOL_Q_ABORTPRINTER *q_u, prs_struct *ps, int depth)
 {
 	if (q_u == NULL) return False;
 
@@ -1424,7 +1428,7 @@
  * called from spoolss_r_abortprinter (srv_spoolss.c)
  ********************************************************************/
 
-BOOL spoolss_io_r_abortprinter(char *desc, SPOOL_R_ABORTPRINTER *r_u, prs_struct *ps, int depth)
+BOOL spoolss_io_r_abortprinter(const char *desc, SPOOL_R_ABORTPRINTER *r_u, prs_struct *ps, int depth)
 {
 	prs_debug(ps, depth, desc, "spoolss_io_r_abortprinter");
 	depth++;
@@ -1440,7 +1444,7 @@
  * called from spoolss_deleteprinter (cli_spoolss.c)
  ********************************************************************/
 
-BOOL spoolss_io_q_deleteprinter(char *desc, SPOOL_Q_DELETEPRINTER *q_u, prs_struct *ps, int depth)
+BOOL spoolss_io_q_deleteprinter(const char *desc, SPOOL_Q_DELETEPRINTER *q_u, prs_struct *ps, int depth)
 {
 	if (q_u == NULL) return False;
 
@@ -1462,7 +1466,7 @@
  * called from spoolss_deleteprinter (cli_spoolss.c)
  ********************************************************************/
 
-BOOL spoolss_io_r_deleteprinter(char *desc, SPOOL_R_DELETEPRINTER *r_u, prs_struct *ps, int depth)
+BOOL spoolss_io_r_deleteprinter(const char *desc, SPOOL_R_DELETEPRINTER *r_u, prs_struct *ps, int depth)
 {
 	prs_debug(ps, depth, desc, "spoolss_io_r_deleteprinter");
 	depth++;
@@ -1485,7 +1489,7 @@
  * called from spoolss_deleteprinterdriver (cli_spoolss.c)
  ********************************************************************/
 
-BOOL spoolss_io_q_deleteprinterdriver(char *desc, SPOOL_Q_DELETEPRINTERDRIVER *q_u, prs_struct *ps, int depth)
+BOOL spoolss_io_q_deleteprinterdriver(const char *desc, SPOOL_Q_DELETEPRINTERDRIVER *q_u, prs_struct *ps, int depth)
 {
 	if (q_u == NULL) return False;
 
@@ -1512,7 +1516,7 @@
 /*******************************************************************
  * write a structure.
  ********************************************************************/
-BOOL spoolss_io_r_deleteprinterdriver(char *desc, SPOOL_R_DELETEPRINTERDRIVER *r_u, prs_struct *ps, int depth)
+BOOL spoolss_io_r_deleteprinterdriver(const char *desc, SPOOL_R_DELETEPRINTERDRIVER *r_u, prs_struct *ps, int depth)
 {
 	if (r_u == NULL) return False;
 
@@ -1535,7 +1539,7 @@
  * called from spoolss_deleteprinterdriver (cli_spoolss.c)
  ********************************************************************/
 
-BOOL spoolss_io_q_deleteprinterdriverex(char *desc, SPOOL_Q_DELETEPRINTERDRIVEREX *q_u, prs_struct *ps, int depth)
+BOOL spoolss_io_q_deleteprinterdriverex(const char *desc, SPOOL_Q_DELETEPRINTERDRIVEREX *q_u, prs_struct *ps, int depth)
 {
 	if (q_u == NULL) return False;
 
@@ -1570,7 +1574,7 @@
 /*******************************************************************
  * write a structure.
  ********************************************************************/
-BOOL spoolss_io_r_deleteprinterdriverex(char *desc, SPOOL_R_DELETEPRINTERDRIVEREX *r_u, prs_struct *ps, int depth)
+BOOL spoolss_io_r_deleteprinterdriverex(const char *desc, SPOOL_R_DELETEPRINTERDRIVEREX *r_u, prs_struct *ps, int depth)
 {
 	if (r_u == NULL) return False;
 
@@ -1594,7 +1598,7 @@
  * called from spoolss_closeprinter (cli_spoolss.c)
  ********************************************************************/
 
-BOOL spoolss_io_q_closeprinter(char *desc, SPOOL_Q_CLOSEPRINTER *q_u, prs_struct *ps, int depth)
+BOOL spoolss_io_q_closeprinter(const char *desc, SPOOL_Q_CLOSEPRINTER *q_u, prs_struct *ps, int depth)
 {
 	if (q_u == NULL) return False;
 
@@ -1616,7 +1620,7 @@
  * called from spoolss_closeprinter (cli_spoolss.c)
  ********************************************************************/
 
-BOOL spoolss_io_r_closeprinter(char *desc, SPOOL_R_CLOSEPRINTER *r_u, prs_struct *ps, int depth)
+BOOL spoolss_io_r_closeprinter(const char *desc, SPOOL_R_CLOSEPRINTER *r_u, prs_struct *ps, int depth)
 {
 	prs_debug(ps, depth, desc, "spoolss_io_r_closeprinter");
 	depth++;
@@ -1637,7 +1641,7 @@
  * called from spoolss_q_startdocprinter (srv_spoolss.c)
  ********************************************************************/
 
-BOOL spoolss_io_q_startdocprinter(char *desc, SPOOL_Q_STARTDOCPRINTER *q_u, prs_struct *ps, int depth)
+BOOL spoolss_io_q_startdocprinter(const char *desc, SPOOL_Q_STARTDOCPRINTER *q_u, prs_struct *ps, int depth)
 {
 	if (q_u == NULL) return False;
 
@@ -1661,7 +1665,7 @@
  * called from spoolss_r_startdocprinter (srv_spoolss.c)
  ********************************************************************/
 
-BOOL spoolss_io_r_startdocprinter(char *desc, SPOOL_R_STARTDOCPRINTER *r_u, prs_struct *ps, int depth)
+BOOL spoolss_io_r_startdocprinter(const char *desc, SPOOL_R_STARTDOCPRINTER *r_u, prs_struct *ps, int depth)
 {
 	prs_debug(ps, depth, desc, "spoolss_io_r_startdocprinter");
 	depth++;
@@ -1678,7 +1682,7 @@
  * called from spoolss_q_enddocprinter (srv_spoolss.c)
  ********************************************************************/
 
-BOOL spoolss_io_q_enddocprinter(char *desc, SPOOL_Q_ENDDOCPRINTER *q_u, prs_struct *ps, int depth)
+BOOL spoolss_io_q_enddocprinter(const char *desc, SPOOL_Q_ENDDOCPRINTER *q_u, prs_struct *ps, int depth)
 {
 	if (q_u == NULL) return False;
 
@@ -1699,7 +1703,7 @@
  * called from spoolss_r_enddocprinter (srv_spoolss.c)
  ********************************************************************/
 
-BOOL spoolss_io_r_enddocprinter(char *desc, SPOOL_R_ENDDOCPRINTER *r_u, prs_struct *ps, int depth)
+BOOL spoolss_io_r_enddocprinter(const char *desc, SPOOL_R_ENDDOCPRINTER *r_u, prs_struct *ps, int depth)
 {
 	prs_debug(ps, depth, desc, "spoolss_io_r_enddocprinter");
 	depth++;
@@ -1714,7 +1718,7 @@
  * called from spoolss_q_startpageprinter (srv_spoolss.c)
  ********************************************************************/
 
-BOOL spoolss_io_q_startpageprinter(char *desc, SPOOL_Q_STARTPAGEPRINTER *q_u, prs_struct *ps, int depth)
+BOOL spoolss_io_q_startpageprinter(const char *desc, SPOOL_Q_STARTPAGEPRINTER *q_u, prs_struct *ps, int depth)
 {
 	if (q_u == NULL) return False;
 
@@ -1735,7 +1739,7 @@
  * called from spoolss_r_startpageprinter (srv_spoolss.c)
  ********************************************************************/
 
-BOOL spoolss_io_r_startpageprinter(char *desc, SPOOL_R_STARTPAGEPRINTER *r_u, prs_struct *ps, int depth)
+BOOL spoolss_io_r_startpageprinter(const char *desc, SPOOL_R_STARTPAGEPRINTER *r_u, prs_struct *ps, int depth)
 {
 	prs_debug(ps, depth, desc, "spoolss_io_r_startpageprinter");
 	depth++;
@@ -1750,7 +1754,7 @@
  * called from spoolss_q_endpageprinter (srv_spoolss.c)
  ********************************************************************/
 
-BOOL spoolss_io_q_endpageprinter(char *desc, SPOOL_Q_ENDPAGEPRINTER *q_u, prs_struct *ps, int depth)
+BOOL spoolss_io_q_endpageprinter(const char *desc, SPOOL_Q_ENDPAGEPRINTER *q_u, prs_struct *ps, int depth)
 {
 	if (q_u == NULL) return False;
 
@@ -1771,7 +1775,7 @@
  * called from spoolss_r_endpageprinter (srv_spoolss.c)
  ********************************************************************/
 
-BOOL spoolss_io_r_endpageprinter(char *desc, SPOOL_R_ENDPAGEPRINTER *r_u, prs_struct *ps, int depth)
+BOOL spoolss_io_r_endpageprinter(const char *desc, SPOOL_R_ENDPAGEPRINTER *r_u, prs_struct *ps, int depth)
 {
 	prs_debug(ps, depth, desc, "spoolss_io_r_endpageprinter");
 	depth++;
@@ -1786,7 +1790,7 @@
  * called from spoolss_q_writeprinter (srv_spoolss.c)
  ********************************************************************/
 
-BOOL spoolss_io_q_writeprinter(char *desc, SPOOL_Q_WRITEPRINTER *q_u, prs_struct *ps, int depth)
+BOOL spoolss_io_q_writeprinter(const char *desc, SPOOL_Q_WRITEPRINTER *q_u, prs_struct *ps, int depth)
 {
 	if (q_u == NULL) return False;
 
@@ -1823,7 +1827,7 @@
  * called from spoolss_r_writeprinter (srv_spoolss.c)
  ********************************************************************/
 
-BOOL spoolss_io_r_writeprinter(char *desc, SPOOL_R_WRITEPRINTER *r_u, prs_struct *ps, int depth)
+BOOL spoolss_io_r_writeprinter(const char *desc, SPOOL_R_WRITEPRINTER *r_u, prs_struct *ps, int depth)
 {
 	prs_debug(ps, depth, desc, "spoolss_io_r_writeprinter");
 	depth++;
@@ -1840,7 +1844,7 @@
  * called from spoolss_q_rffpcnex (srv_spoolss.c)
  ********************************************************************/
 
-BOOL spoolss_io_q_rffpcnex(char *desc, SPOOL_Q_RFFPCNEX *q_u, prs_struct *ps, int depth)
+BOOL spoolss_io_q_rffpcnex(const char *desc, SPOOL_Q_RFFPCNEX *q_u, prs_struct *ps, int depth)
 {
 	prs_debug(ps, depth, desc, "spoolss_io_q_rffpcnex");
 	depth++;
@@ -1886,7 +1890,7 @@
  * called from spoolss_r_rffpcnex (srv_spoolss.c)
  ********************************************************************/
 
-BOOL spoolss_io_r_rffpcnex(char *desc, SPOOL_R_RFFPCNEX *r_u, prs_struct *ps, int depth)
+BOOL spoolss_io_r_rffpcnex(const char *desc, SPOOL_R_RFFPCNEX *r_u, prs_struct *ps, int depth)
 {
 	prs_debug(ps, depth, desc, "spoolss_io_r_rffpcnex");
 	depth++;
@@ -1902,7 +1906,7 @@
  * called from spoolss_q_rfnpcnex (srv_spoolss.c)
  ********************************************************************/
 
-BOOL spoolss_io_q_rfnpcnex(char *desc, SPOOL_Q_RFNPCNEX *q_u, prs_struct *ps, int depth)
+BOOL spoolss_io_q_rfnpcnex(const char *desc, SPOOL_Q_RFNPCNEX *q_u, prs_struct *ps, int depth)
 {
 	prs_debug(ps, depth, desc, "spoolss_io_q_rfnpcnex");
 	depth++;
@@ -1937,7 +1941,7 @@
  * called from spoolss_r_rfnpcnex (srv_spoolss.c)
  ********************************************************************/
 
-BOOL spoolss_io_r_rfnpcnex(char *desc, SPOOL_R_RFNPCNEX *r_u, prs_struct *ps, int depth)
+BOOL spoolss_io_r_rfnpcnex(const char *desc, SPOOL_R_RFNPCNEX *r_u, prs_struct *ps, int depth)
 {
 	prs_debug(ps, depth, desc, "spoolss_io_r_rfnpcnex");
 	depth++;
@@ -2057,7 +2061,7 @@
  *
  ********************************************************************/
 
-static BOOL smb_io_relstr(char *desc, NEW_BUFFER *buffer, int depth, UNISTR *string)
+static BOOL smb_io_relstr(const char *desc, NEW_BUFFER *buffer, int depth, UNISTR *string)
 {
 	prs_struct *ps=&buffer->prs;
 	
@@ -2119,7 +2123,7 @@
  * used by 2 RPC structs
  ********************************************************************/
 
-static BOOL smb_io_relarraystr(char *desc, NEW_BUFFER *buffer, int depth, uint16 **string)
+static BOOL smb_io_relarraystr(const char *desc, NEW_BUFFER *buffer, int depth, uint16 **string)
 {
 	UNISTR chaine;
 	
@@ -2247,7 +2251,7 @@
  Parse a DEVMODE structure and its relative pointer.
 ********************************************************************/
 
-static BOOL smb_io_relsecdesc(char *desc, NEW_BUFFER *buffer, int depth, SEC_DESC **secdesc)
+static BOOL smb_io_relsecdesc(const char *desc, NEW_BUFFER *buffer, int depth, SEC_DESC **secdesc)
 {
 	prs_struct *ps= &buffer->prs;
 
@@ -2308,7 +2312,7 @@
  Parse a DEVMODE structure and its relative pointer.
 ********************************************************************/
 
-static BOOL smb_io_reldevmode(char *desc, NEW_BUFFER *buffer, int depth, DEVICEMODE **devmode)
+static BOOL smb_io_reldevmode(const char *desc, NEW_BUFFER *buffer, int depth, DEVICEMODE **devmode)
 {
 	prs_struct *ps=&buffer->prs;
 
@@ -2376,7 +2380,7 @@
  Parse a PRINTER_INFO_0 structure.
 ********************************************************************/  
 
-BOOL smb_io_printer_info_0(char *desc, NEW_BUFFER *buffer, PRINTER_INFO_0 *info, int depth)
+BOOL smb_io_printer_info_0(const char *desc, NEW_BUFFER *buffer, PRINTER_INFO_0 *info, int depth)
 {
 	prs_struct *ps=&buffer->prs;
 
@@ -2477,7 +2481,7 @@
  Parse a PRINTER_INFO_1 structure.
 ********************************************************************/  
 
-BOOL smb_io_printer_info_1(char *desc, NEW_BUFFER *buffer, PRINTER_INFO_1 *info, int depth)
+BOOL smb_io_printer_info_1(const char *desc, NEW_BUFFER *buffer, PRINTER_INFO_1 *info, int depth)
 {
 	prs_struct *ps=&buffer->prs;
 
@@ -2502,7 +2506,7 @@
  Parse a PRINTER_INFO_2 structure.
 ********************************************************************/  
 
-BOOL smb_io_printer_info_2(char *desc, NEW_BUFFER *buffer, PRINTER_INFO_2 *info, int depth)
+BOOL smb_io_printer_info_2(const char *desc, NEW_BUFFER *buffer, PRINTER_INFO_2 *info, int depth)
 {
 	prs_struct *ps=&buffer->prs;
 	uint32 dm_offset, sd_offset, current_offset;
@@ -2593,7 +2597,7 @@
  Parse a PRINTER_INFO_3 structure.
 ********************************************************************/  
 
-BOOL smb_io_printer_info_3(char *desc, NEW_BUFFER *buffer, PRINTER_INFO_3 *info, int depth)
+BOOL smb_io_printer_info_3(const char *desc, NEW_BUFFER *buffer, PRINTER_INFO_3 *info, int depth)
 {
 	prs_struct *ps=&buffer->prs;
 
@@ -2614,7 +2618,7 @@
  Parse a PRINTER_INFO_4 structure.
 ********************************************************************/  
 
-BOOL smb_io_printer_info_4(char *desc, NEW_BUFFER *buffer, PRINTER_INFO_4 *info, int depth)
+BOOL smb_io_printer_info_4(const char *desc, NEW_BUFFER *buffer, PRINTER_INFO_4 *info, int depth)
 {
 	prs_struct *ps=&buffer->prs;
 
@@ -2636,7 +2640,7 @@
  Parse a PRINTER_INFO_5 structure.
 ********************************************************************/  
 
-BOOL smb_io_printer_info_5(char *desc, NEW_BUFFER *buffer, PRINTER_INFO_5 *info, int depth)
+BOOL smb_io_printer_info_5(const char *desc, NEW_BUFFER *buffer, PRINTER_INFO_5 *info, int depth)
 {
 	prs_struct *ps=&buffer->prs;
 
@@ -2659,10 +2663,30 @@
 }
 
 /*******************************************************************
+ Parse a PRINTER_INFO_7 structure.
+********************************************************************/  
+
+BOOL smb_io_printer_info_7(const char *desc, NEW_BUFFER *buffer, PRINTER_INFO_7 *info, int depth)
+{
+	prs_struct *ps=&buffer->prs;
+
+	prs_debug(ps, depth, desc, "smb_io_printer_info_7");
+	depth++;	
+	
+	buffer->struct_start=prs_offset(ps);
+	
+	if (!smb_io_relstr("guid", buffer, depth, &info->guid))
+		return False;
+	if (!prs_uint32("action", ps, depth, &info->action))
+		return False;
+	return True;
+}
+
+/*******************************************************************
  Parse a PORT_INFO_1 structure.
 ********************************************************************/  
 
-BOOL smb_io_port_info_1(char *desc, NEW_BUFFER *buffer, PORT_INFO_1 *info, int depth)
+BOOL smb_io_port_info_1(const char *desc, NEW_BUFFER *buffer, PORT_INFO_1 *info, int depth)
 {
 	prs_struct *ps=&buffer->prs;
 
@@ -2681,7 +2705,7 @@
  Parse a PORT_INFO_2 structure.
 ********************************************************************/  
 
-BOOL smb_io_port_info_2(char *desc, NEW_BUFFER *buffer, PORT_INFO_2 *info, int depth)
+BOOL smb_io_port_info_2(const char *desc, NEW_BUFFER *buffer, PORT_INFO_2 *info, int depth)
 {
 	prs_struct *ps=&buffer->prs;
 
@@ -2708,7 +2732,7 @@
  Parse a DRIVER_INFO_1 structure.
 ********************************************************************/
 
-BOOL smb_io_printer_driver_info_1(char *desc, NEW_BUFFER *buffer, DRIVER_INFO_1 *info, int depth) 
+BOOL smb_io_printer_driver_info_1(const char *desc, NEW_BUFFER *buffer, DRIVER_INFO_1 *info, int depth) 
 {
 	prs_struct *ps=&buffer->prs;
 
@@ -2727,7 +2751,7 @@
  Parse a DRIVER_INFO_2 structure.
 ********************************************************************/
 
-BOOL smb_io_printer_driver_info_2(char *desc, NEW_BUFFER *buffer, DRIVER_INFO_2 *info, int depth) 
+BOOL smb_io_printer_driver_info_2(const char *desc, NEW_BUFFER *buffer, DRIVER_INFO_2 *info, int depth) 
 {
 	prs_struct *ps=&buffer->prs;
 
@@ -2756,7 +2780,7 @@
  Parse a DRIVER_INFO_3 structure.
 ********************************************************************/
 
-BOOL smb_io_printer_driver_info_3(char *desc, NEW_BUFFER *buffer, DRIVER_INFO_3 *info, int depth)
+BOOL smb_io_printer_driver_info_3(const char *desc, NEW_BUFFER *buffer, DRIVER_INFO_3 *info, int depth)
 {
 	prs_struct *ps=&buffer->prs;
 
@@ -2795,7 +2819,7 @@
  Parse a DRIVER_INFO_6 structure.
 ********************************************************************/
 
-BOOL smb_io_printer_driver_info_6(char *desc, NEW_BUFFER *buffer, DRIVER_INFO_6 *info, int depth)
+BOOL smb_io_printer_driver_info_6(const char *desc, NEW_BUFFER *buffer, DRIVER_INFO_6 *info, int depth)
 {
 	prs_struct *ps=&buffer->prs;
 
@@ -2860,7 +2884,7 @@
  Parse a JOB_INFO_1 structure.
 ********************************************************************/  
 
-BOOL smb_io_job_info_1(char *desc, NEW_BUFFER *buffer, JOB_INFO_1 *info, int depth)
+BOOL smb_io_job_info_1(const char *desc, NEW_BUFFER *buffer, JOB_INFO_1 *info, int depth)
 {
 	prs_struct *ps=&buffer->prs;
 
@@ -2903,7 +2927,7 @@
  Parse a JOB_INFO_2 structure.
 ********************************************************************/  
 
-BOOL smb_io_job_info_2(char *desc, NEW_BUFFER *buffer, JOB_INFO_2 *info, int depth)
+BOOL smb_io_job_info_2(const char *desc, NEW_BUFFER *buffer, JOB_INFO_2 *info, int depth)
 {	
 	uint32 pipo=0;
 	prs_struct *ps=&buffer->prs;
@@ -2970,7 +2994,7 @@
 /*******************************************************************
 ********************************************************************/  
 
-BOOL smb_io_form_1(char *desc, NEW_BUFFER *buffer, FORM_1 *info, int depth)
+BOOL smb_io_form_1(const char *desc, NEW_BUFFER *buffer, FORM_1 *info, int depth)
 {
 	prs_struct *ps=&buffer->prs;
 	
@@ -3005,7 +3029,7 @@
  Read/write a BUFFER struct.
 ********************************************************************/  
 
-static BOOL spoolss_io_buffer(char *desc, prs_struct *ps, int depth, NEW_BUFFER **pp_buffer)
+static BOOL spoolss_io_buffer(const char *desc, prs_struct *ps, int depth, NEW_BUFFER **pp_buffer)
 {
 	NEW_BUFFER *buffer = *pp_buffer;
 
@@ -3117,7 +3141,7 @@
  Parse a DRIVER_DIRECTORY_1 structure.
 ********************************************************************/  
 
-BOOL smb_io_driverdir_1(char *desc, NEW_BUFFER *buffer, DRIVER_DIRECTORY_1 *info, int depth)
+BOOL smb_io_driverdir_1(const char *desc, NEW_BUFFER *buffer, DRIVER_DIRECTORY_1 *info, int depth)
 {
 	prs_struct *ps=&buffer->prs;
 
@@ -3136,7 +3160,7 @@
  Parse a PORT_INFO_1 structure.
 ********************************************************************/  
 
-BOOL smb_io_port_1(char *desc, NEW_BUFFER *buffer, PORT_INFO_1 *info, int depth)
+BOOL smb_io_port_1(const char *desc, NEW_BUFFER *buffer, PORT_INFO_1 *info, int depth)
 {
 	prs_struct *ps=&buffer->prs;
 
@@ -3155,7 +3179,7 @@
  Parse a PORT_INFO_2 structure.
 ********************************************************************/  
 
-BOOL smb_io_port_2(char *desc, NEW_BUFFER *buffer, PORT_INFO_2 *info, int depth)
+BOOL smb_io_port_2(const char *desc, NEW_BUFFER *buffer, PORT_INFO_2 *info, int depth)
 {
 	prs_struct *ps=&buffer->prs;
 
@@ -3181,7 +3205,7 @@
 /*******************************************************************
 ********************************************************************/  
 
-BOOL smb_io_printprocessor_info_1(char *desc, NEW_BUFFER *buffer, PRINTPROCESSOR_1 *info, int depth)
+BOOL smb_io_printprocessor_info_1(const char *desc, NEW_BUFFER *buffer, PRINTPROCESSOR_1 *info, int depth)
 {
 	prs_struct *ps=&buffer->prs;
 
@@ -3199,7 +3223,7 @@
 /*******************************************************************
 ********************************************************************/  
 
-BOOL smb_io_printprocdatatype_info_1(char *desc, NEW_BUFFER *buffer, PRINTPROCDATATYPE_1 *info, int depth)
+BOOL smb_io_printprocdatatype_info_1(const char *desc, NEW_BUFFER *buffer, PRINTPROCDATATYPE_1 *info, int depth)
 {
 	prs_struct *ps=&buffer->prs;
 
@@ -3217,7 +3241,7 @@
 /*******************************************************************
 ********************************************************************/  
 
-BOOL smb_io_printmonitor_info_1(char *desc, NEW_BUFFER *buffer, PRINTMONITOR_1 *info, int depth)
+BOOL smb_io_printmonitor_info_1(const char *desc, NEW_BUFFER *buffer, PRINTMONITOR_1 *info, int depth)
 {
 	prs_struct *ps=&buffer->prs;
 
@@ -3235,7 +3259,7 @@
 /*******************************************************************
 ********************************************************************/  
 
-BOOL smb_io_printmonitor_info_2(char *desc, NEW_BUFFER *buffer, PRINTMONITOR_2 *info, int depth)
+BOOL smb_io_printmonitor_info_2(const char *desc, NEW_BUFFER *buffer, PRINTMONITOR_2 *info, int depth)
 {
 	prs_struct *ps=&buffer->prs;
 
@@ -3425,6 +3449,19 @@
 return the size required by a struct in the stream
 ********************************************************************/
 
+uint32 spoolss_size_printer_info_7(PRINTER_INFO_7 *info)
+{
+	uint32 size=0;
+		
+	size+=size_of_relative_string( &info->guid );
+	size+=size_of_uint32( &info->action );
+	return size;
+}
+
+/*******************************************************************
+return the size required by a struct in the stream
+********************************************************************/
+
 uint32 spoolss_size_printer_driver_info_1(DRIVER_INFO_1 *info)
 {
 	int size=0;
@@ -3769,7 +3806,7 @@
  * called from spoolss_getprinterdriver2 (srv_spoolss.c)
  ********************************************************************/
 
-BOOL spoolss_io_q_getprinterdriver2(char *desc, SPOOL_Q_GETPRINTERDRIVER2 *q_u, prs_struct *ps, int depth)
+BOOL spoolss_io_q_getprinterdriver2(const char *desc, SPOOL_Q_GETPRINTERDRIVER2 *q_u, prs_struct *ps, int depth)
 {
 	prs_debug(ps, depth, desc, "spoolss_io_q_getprinterdriver2");
 	depth++;
@@ -3811,7 +3848,7 @@
  * called from spoolss_getprinterdriver2 (srv_spoolss.c)
  ********************************************************************/
 
-BOOL spoolss_io_r_getprinterdriver2(char *desc, SPOOL_R_GETPRINTERDRIVER2 *r_u, prs_struct *ps, int depth)
+BOOL spoolss_io_r_getprinterdriver2(const char *desc, SPOOL_R_GETPRINTERDRIVER2 *r_u, prs_struct *ps, int depth)
 {
 	prs_debug(ps, depth, desc, "spoolss_io_r_getprinterdriver2");
 	depth++;
@@ -3884,7 +3921,7 @@
  * called from spoolss_enumprinters (srv_spoolss.c)
  ********************************************************************/
 
-BOOL spoolss_io_q_enumprinters(char *desc, SPOOL_Q_ENUMPRINTERS *q_u, prs_struct *ps, int depth)
+BOOL spoolss_io_q_enumprinters(const char *desc, SPOOL_Q_ENUMPRINTERS *q_u, prs_struct *ps, int depth)
 {
 	prs_debug(ps, depth, desc, "spoolss_io_q_enumprinters");
 	depth++;
@@ -3920,7 +3957,7 @@
  Parse a SPOOL_R_ENUMPRINTERS structure.
  ********************************************************************/
 
-BOOL spoolss_io_r_enumprinters(char *desc, SPOOL_R_ENUMPRINTERS *r_u, prs_struct *ps, int depth)
+BOOL spoolss_io_r_enumprinters(const char *desc, SPOOL_R_ENUMPRINTERS *r_u, prs_struct *ps, int depth)
 {
 	prs_debug(ps, depth, desc, "spoolss_io_r_enumprinters");
 	depth++;
@@ -3952,7 +3989,7 @@
  *
  ********************************************************************/
 
-BOOL spoolss_io_r_getprinter(char *desc, SPOOL_R_GETPRINTER *r_u, prs_struct *ps, int depth)
+BOOL spoolss_io_r_getprinter(const char *desc, SPOOL_R_GETPRINTER *r_u, prs_struct *ps, int depth)
 {	
 	prs_debug(ps, depth, desc, "spoolss_io_r_getprinter");
 	depth++;
@@ -3980,7 +4017,7 @@
  * called from spoolss_getprinter (srv_spoolss.c)
  ********************************************************************/
 
-BOOL spoolss_io_q_getprinter(char *desc, SPOOL_Q_GETPRINTER *q_u, prs_struct *ps, int depth)
+BOOL spoolss_io_q_getprinter(const char *desc, SPOOL_Q_GETPRINTER *q_u, prs_struct *ps, int depth)
 {
 	prs_debug(ps, depth, desc, "spoolss_io_q_getprinter");
 	depth++;
@@ -4092,7 +4129,7 @@
 /*******************************************************************
 ********************************************************************/  
 
-BOOL spoolss_io_r_setprinter(char *desc, SPOOL_R_SETPRINTER *r_u, prs_struct *ps, int depth)
+BOOL spoolss_io_r_setprinter(const char *desc, SPOOL_R_SETPRINTER *r_u, prs_struct *ps, int depth)
 {		
 	prs_debug(ps, depth, desc, "spoolss_io_r_setprinter");
 	depth++;
@@ -4110,7 +4147,7 @@
  Marshall/unmarshall a SPOOL_Q_SETPRINTER struct.
 ********************************************************************/  
 
-BOOL spoolss_io_q_setprinter(char *desc, SPOOL_Q_SETPRINTER *q_u, prs_struct *ps, int depth)
+BOOL spoolss_io_q_setprinter(const char *desc, SPOOL_Q_SETPRINTER *q_u, prs_struct *ps, int depth)
 {
 	uint32 ptr_sec_desc = 0;
 
@@ -4173,7 +4210,7 @@
 /*******************************************************************
 ********************************************************************/  
 
-BOOL spoolss_io_r_fcpn(char *desc, SPOOL_R_FCPN *r_u, prs_struct *ps, int depth)
+BOOL spoolss_io_r_fcpn(const char *desc, SPOOL_R_FCPN *r_u, prs_struct *ps, int depth)
 {		
 	prs_debug(ps, depth, desc, "spoolss_io_r_fcpn");
 	depth++;
@@ -4190,7 +4227,7 @@
 /*******************************************************************
 ********************************************************************/  
 
-BOOL spoolss_io_q_fcpn(char *desc, SPOOL_Q_FCPN *q_u, prs_struct *ps, int depth)
+BOOL spoolss_io_q_fcpn(const char *desc, SPOOL_Q_FCPN *q_u, prs_struct *ps, int depth)
 {
 
 	prs_debug(ps, depth, desc, "spoolss_io_q_fcpn");
@@ -4209,7 +4246,7 @@
 /*******************************************************************
 ********************************************************************/  
 
-BOOL spoolss_io_r_addjob(char *desc, SPOOL_R_ADDJOB *r_u, prs_struct *ps, int depth)
+BOOL spoolss_io_r_addjob(const char *desc, SPOOL_R_ADDJOB *r_u, prs_struct *ps, int depth)
 {		
 	prs_debug(ps, depth, desc, "");
 	depth++;
@@ -4235,7 +4272,7 @@
 /*******************************************************************
 ********************************************************************/  
 
-BOOL spoolss_io_q_addjob(char *desc, SPOOL_Q_ADDJOB *q_u, prs_struct *ps, int depth)
+BOOL spoolss_io_q_addjob(const char *desc, SPOOL_Q_ADDJOB *q_u, prs_struct *ps, int depth)
 {
 	prs_debug(ps, depth, desc, "");
 	depth++;
@@ -4263,7 +4300,7 @@
 /*******************************************************************
 ********************************************************************/  
 
-BOOL spoolss_io_r_enumjobs(char *desc, SPOOL_R_ENUMJOBS *r_u, prs_struct *ps, int depth)
+BOOL spoolss_io_r_enumjobs(const char *desc, SPOOL_R_ENUMJOBS *r_u, prs_struct *ps, int depth)
 {		
 	prs_debug(ps, depth, desc, "spoolss_io_r_enumjobs");
 	depth++;
@@ -4315,7 +4352,7 @@
 /*******************************************************************
 ********************************************************************/  
 
-BOOL spoolss_io_q_enumjobs(char *desc, SPOOL_Q_ENUMJOBS *q_u, prs_struct *ps, int depth)
+BOOL spoolss_io_q_enumjobs(const char *desc, SPOOL_Q_ENUMJOBS *q_u, prs_struct *ps, int depth)
 {
 	prs_debug(ps, depth, desc, "spoolss_io_q_enumjobs");
 	depth++;
@@ -4348,7 +4385,7 @@
 /*******************************************************************
 ********************************************************************/  
 
-BOOL spoolss_io_r_schedulejob(char *desc, SPOOL_R_SCHEDULEJOB *r_u, prs_struct *ps, int depth)
+BOOL spoolss_io_r_schedulejob(const char *desc, SPOOL_R_SCHEDULEJOB *r_u, prs_struct *ps, int depth)
 {		
 	prs_debug(ps, depth, desc, "spoolss_io_r_schedulejob");
 	depth++;
@@ -4365,7 +4402,7 @@
 /*******************************************************************
 ********************************************************************/  
 
-BOOL spoolss_io_q_schedulejob(char *desc, SPOOL_Q_SCHEDULEJOB *q_u, prs_struct *ps, int depth)
+BOOL spoolss_io_q_schedulejob(const char *desc, SPOOL_Q_SCHEDULEJOB *q_u, prs_struct *ps, int depth)
 {
 	prs_debug(ps, depth, desc, "spoolss_io_q_schedulejob");
 	depth++;
@@ -4384,7 +4421,7 @@
 /*******************************************************************
 ********************************************************************/  
 
-BOOL spoolss_io_r_setjob(char *desc, SPOOL_R_SETJOB *r_u, prs_struct *ps, int depth)
+BOOL spoolss_io_r_setjob(const char *desc, SPOOL_R_SETJOB *r_u, prs_struct *ps, int depth)
 {		
 	prs_debug(ps, depth, desc, "spoolss_io_r_setjob");
 	depth++;
@@ -4401,7 +4438,7 @@
 /*******************************************************************
 ********************************************************************/  
 
-BOOL spoolss_io_q_setjob(char *desc, SPOOL_Q_SETJOB *q_u, prs_struct *ps, int depth)
+BOOL spoolss_io_q_setjob(const char *desc, SPOOL_Q_SETJOB *q_u, prs_struct *ps, int depth)
 {
 	prs_debug(ps, depth, desc, "spoolss_io_q_setjob");
 	depth++;
@@ -4429,7 +4466,7 @@
  Parse a SPOOL_R_ENUMPRINTERDRIVERS structure.
 ********************************************************************/  
 
-BOOL spoolss_io_r_enumprinterdrivers(char *desc, SPOOL_R_ENUMPRINTERDRIVERS *r_u, prs_struct *ps, int depth)
+BOOL spoolss_io_r_enumprinterdrivers(const char *desc, SPOOL_R_ENUMPRINTERDRIVERS *r_u, prs_struct *ps, int depth)
 {
 	prs_debug(ps, depth, desc, "spoolss_io_r_enumprinterdrivers");
 	depth++;
@@ -4479,7 +4516,7 @@
  Parse a SPOOL_Q_ENUMPRINTERDRIVERS structure.
 ********************************************************************/  
 
-BOOL spoolss_io_q_enumprinterdrivers(char *desc, SPOOL_Q_ENUMPRINTERDRIVERS *q_u, prs_struct *ps, int depth)
+BOOL spoolss_io_q_enumprinterdrivers(const char *desc, SPOOL_Q_ENUMPRINTERDRIVERS *q_u, prs_struct *ps, int depth)
 {
 
 	prs_debug(ps, depth, desc, "spoolss_io_q_enumprinterdrivers");
@@ -4520,7 +4557,7 @@
 /*******************************************************************
 ********************************************************************/  
 
-BOOL spoolss_io_q_enumforms(char *desc, SPOOL_Q_ENUMFORMS *q_u, prs_struct *ps, int depth)
+BOOL spoolss_io_q_enumforms(const char *desc, SPOOL_Q_ENUMFORMS *q_u, prs_struct *ps, int depth)
 {
 
 	prs_debug(ps, depth, desc, "spoolss_io_q_enumforms");
@@ -4547,7 +4584,7 @@
 /*******************************************************************
 ********************************************************************/  
 
-BOOL spoolss_io_r_enumforms(char *desc, SPOOL_R_ENUMFORMS *r_u, prs_struct *ps, int depth)
+BOOL spoolss_io_r_enumforms(const char *desc, SPOOL_R_ENUMFORMS *r_u, prs_struct *ps, int depth)
 {
 	prs_debug(ps, depth, desc, "spoolss_io_r_enumforms");
 	depth++;
@@ -4576,7 +4613,7 @@
 /*******************************************************************
 ********************************************************************/  
 
-BOOL spoolss_io_q_getform(char *desc, SPOOL_Q_GETFORM *q_u, prs_struct *ps, int depth)
+BOOL spoolss_io_q_getform(const char *desc, SPOOL_Q_GETFORM *q_u, prs_struct *ps, int depth)
 {
 
 	prs_debug(ps, depth, desc, "spoolss_io_q_getform");
@@ -4609,7 +4646,7 @@
 /*******************************************************************
 ********************************************************************/  
 
-BOOL spoolss_io_r_getform(char *desc, SPOOL_R_GETFORM *r_u, prs_struct *ps, int depth)
+BOOL spoolss_io_r_getform(const char *desc, SPOOL_R_GETFORM *r_u, prs_struct *ps, int depth)
 {
 	prs_debug(ps, depth, desc, "spoolss_io_r_getform");
 	depth++;
@@ -4636,7 +4673,7 @@
  Parse a SPOOL_R_ENUMPORTS structure.
 ********************************************************************/  
 
-BOOL spoolss_io_r_enumports(char *desc, SPOOL_R_ENUMPORTS *r_u, prs_struct *ps, int depth)
+BOOL spoolss_io_r_enumports(const char *desc, SPOOL_R_ENUMPORTS *r_u, prs_struct *ps, int depth)
 {
 	prs_debug(ps, depth, desc, "spoolss_io_r_enumports");
 	depth++;
@@ -4665,7 +4702,7 @@
 /*******************************************************************
 ********************************************************************/  
 
-BOOL spoolss_io_q_enumports(char *desc, SPOOL_Q_ENUMPORTS *q_u, prs_struct *ps, int depth)
+BOOL spoolss_io_q_enumports(const char *desc, SPOOL_Q_ENUMPORTS *q_u, prs_struct *ps, int depth)
 {
 	prs_debug(ps, depth, desc, "");
 	depth++;
@@ -4698,7 +4735,7 @@
  Parse a SPOOL_PRINTER_INFO_LEVEL_1 structure.
 ********************************************************************/  
 
-BOOL spool_io_printer_info_level_1(char *desc, SPOOL_PRINTER_INFO_LEVEL_1 *il, prs_struct *ps, int depth)
+BOOL spool_io_printer_info_level_1(const char *desc, SPOOL_PRINTER_INFO_LEVEL_1 *il, prs_struct *ps, int depth)
 {	
 	prs_debug(ps, depth, desc, "spool_io_printer_info_level_1");
 	depth++;
@@ -4729,7 +4766,7 @@
  Parse a SPOOL_PRINTER_INFO_LEVEL_3 structure.
 ********************************************************************/  
 
-BOOL spool_io_printer_info_level_3(char *desc, SPOOL_PRINTER_INFO_LEVEL_3 *il, prs_struct *ps, int depth)
+BOOL spool_io_printer_info_level_3(const char *desc, SPOOL_PRINTER_INFO_LEVEL_3 *il, prs_struct *ps, int depth)
 {	
 	prs_debug(ps, depth, desc, "spool_io_printer_info_level_3");
 	depth++;
@@ -4747,7 +4784,7 @@
  Parse a SPOOL_PRINTER_INFO_LEVEL_2 structure.
 ********************************************************************/  
 
-BOOL spool_io_printer_info_level_2(char *desc, SPOOL_PRINTER_INFO_LEVEL_2 *il, prs_struct *ps, int depth)
+BOOL spool_io_printer_info_level_2(const char *desc, SPOOL_PRINTER_INFO_LEVEL_2 *il, prs_struct *ps, int depth)
 {	
 	prs_debug(ps, depth, desc, "spool_io_printer_info_level_2");
 	depth++;
@@ -4826,10 +4863,28 @@
 	return True;
 }
 
+BOOL spool_io_printer_info_level_7(const char *desc, SPOOL_PRINTER_INFO_LEVEL_7 *il, prs_struct *ps, int depth)
+{	
+	prs_debug(ps, depth, desc, "spool_io_printer_info_level_7");
+	depth++;
+		
+	if(!prs_align(ps))
+		return False;
+
+	if(!prs_uint32("guid_ptr", ps, depth, &il->guid_ptr))
+		return False;
+	if(!prs_uint32("action", ps, depth, &il->action))
+		return False;
+
+	if(!smb_io_unistr2("servername", &il->guid, il->guid_ptr, ps, depth))
+		return False;
+	return True;
+}
+
 /*******************************************************************
 ********************************************************************/  
 
-BOOL spool_io_printer_info_level(char *desc, SPOOL_PRINTER_INFO_LEVEL *il, prs_struct *ps, int depth)
+BOOL spool_io_printer_info_level(const char *desc, SPOOL_PRINTER_INFO_LEVEL *il, prs_struct *ps, int depth)
 {
 	prs_debug(ps, depth, desc, "spool_io_printer_info_level");
 	depth++;
@@ -4891,6 +4946,13 @@
 				return False;
 			break;		
 		}
+		case 7:
+			if (UNMARSHALLING(ps))
+				if ((il->info_7=(SPOOL_PRINTER_INFO_LEVEL_7 *)prs_alloc_mem(ps,sizeof(SPOOL_PRINTER_INFO_LEVEL_7))) == NULL)
+					return False;
+			if (!spool_io_printer_info_level_7("", il->info_7, ps, depth))
+				return False;
+			break;
 	}
 
 	return True;
@@ -4899,7 +4961,7 @@
 /*******************************************************************
 ********************************************************************/  
 
-BOOL spoolss_io_q_addprinterex(char *desc, SPOOL_Q_ADDPRINTEREX *q_u, prs_struct *ps, int depth)
+BOOL spoolss_io_q_addprinterex(const char *desc, SPOOL_Q_ADDPRINTEREX *q_u, prs_struct *ps, int depth)
 {
 	uint32 ptr_sec_desc = 0;
 
@@ -4963,7 +5025,7 @@
 /*******************************************************************
 ********************************************************************/  
 
-BOOL spoolss_io_r_addprinterex(char *desc, SPOOL_R_ADDPRINTEREX *r_u, 
+BOOL spoolss_io_r_addprinterex(const char *desc, SPOOL_R_ADDPRINTEREX *r_u, 
 			       prs_struct *ps, int depth)
 {
 	prs_debug(ps, depth, desc, "spoolss_io_r_addprinterex");
@@ -4981,7 +5043,7 @@
 /*******************************************************************
 ********************************************************************/  
 
-BOOL spool_io_printer_driver_info_level_3(char *desc, SPOOL_PRINTER_DRIVER_INFO_LEVEL_3 **q_u, 
+BOOL spool_io_printer_driver_info_level_3(const char *desc, SPOOL_PRINTER_DRIVER_INFO_LEVEL_3 **q_u, 
                                           prs_struct *ps, int depth)
 {	
 	SPOOL_PRINTER_DRIVER_INFO_LEVEL_3 *il;
@@ -5059,7 +5121,7 @@
 parse a SPOOL_PRINTER_DRIVER_INFO_LEVEL_6 structure
 ********************************************************************/  
 
-BOOL spool_io_printer_driver_info_level_6(char *desc, SPOOL_PRINTER_DRIVER_INFO_LEVEL_6 **q_u, 
+BOOL spool_io_printer_driver_info_level_6(const char *desc, SPOOL_PRINTER_DRIVER_INFO_LEVEL_6 **q_u, 
                                           prs_struct *ps, int depth)
 {	
 	SPOOL_PRINTER_DRIVER_INFO_LEVEL_6 *il;
@@ -5250,7 +5312,7 @@
  and size of array at beginning
 ********************************************************************/  
 
-BOOL smb_io_unibuffer(char *desc, UNISTR2 *buffer, prs_struct *ps, int depth)
+BOOL smb_io_unibuffer(const char *desc, UNISTR2 *buffer, prs_struct *ps, int depth)
 {
 	if (buffer==NULL) return False;
 
@@ -5269,7 +5331,7 @@
 /*******************************************************************
 ********************************************************************/  
 
-BOOL spool_io_printer_driver_info_level(char *desc, SPOOL_PRINTER_DRIVER_INFO_LEVEL *il, prs_struct *ps, int depth)
+BOOL spool_io_printer_driver_info_level(const char *desc, SPOOL_PRINTER_DRIVER_INFO_LEVEL *il, prs_struct *ps, int depth)
 {
 	prs_debug(ps, depth, desc, "spool_io_printer_driver_info_level");
 	depth++;
@@ -5418,7 +5480,7 @@
  fill in the prs_struct for a ADDPRINTERDRIVER request PDU
  ********************************************************************/  
 
-BOOL spoolss_io_q_addprinterdriver(char *desc, SPOOL_Q_ADDPRINTERDRIVER *q_u, prs_struct *ps, int depth)
+BOOL spoolss_io_q_addprinterdriver(const char *desc, SPOOL_Q_ADDPRINTERDRIVER *q_u, prs_struct *ps, int depth)
 {
 	prs_debug(ps, depth, desc, "spoolss_io_q_addprinterdriver");
 	depth++;
@@ -5445,7 +5507,7 @@
 /*******************************************************************
 ********************************************************************/  
 
-BOOL spoolss_io_r_addprinterdriver(char *desc, SPOOL_R_ADDPRINTERDRIVER *q_u, prs_struct *ps, int depth)
+BOOL spoolss_io_r_addprinterdriver(const char *desc, SPOOL_R_ADDPRINTERDRIVER *q_u, prs_struct *ps, int depth)
 {
 	prs_debug(ps, depth, desc, "spoolss_io_r_addprinterdriver");
 	depth++;
@@ -5460,7 +5522,7 @@
  fill in the prs_struct for a ADDPRINTERDRIVER request PDU
  ********************************************************************/  
 
-BOOL spoolss_io_q_addprinterdriverex(char *desc, SPOOL_Q_ADDPRINTERDRIVEREX *q_u, prs_struct *ps, int depth)
+BOOL spoolss_io_q_addprinterdriverex(const char *desc, SPOOL_Q_ADDPRINTERDRIVEREX *q_u, prs_struct *ps, int depth)
 {
 	prs_debug(ps, depth, desc, "spoolss_io_q_addprinterdriverex");
 	depth++;
@@ -5492,7 +5554,7 @@
 /*******************************************************************
 ********************************************************************/  
 
-BOOL spoolss_io_r_addprinterdriverex(char *desc, SPOOL_R_ADDPRINTERDRIVEREX *q_u, prs_struct *ps, int depth)
+BOOL spoolss_io_r_addprinterdriverex(const char *desc, SPOOL_R_ADDPRINTERDRIVEREX *q_u, prs_struct *ps, int depth)
 {
 	prs_debug(ps, depth, desc, "spoolss_io_r_addprinterdriverex");
 	depth++;
@@ -5675,7 +5737,7 @@
  Parse a SPOOL_Q_GETPRINTERDRIVERDIR structure.
 ********************************************************************/  
 
-BOOL spoolss_io_q_getprinterdriverdir(char *desc, SPOOL_Q_GETPRINTERDRIVERDIR *q_u, prs_struct *ps, int depth)
+BOOL spoolss_io_q_getprinterdriverdir(const char *desc, SPOOL_Q_GETPRINTERDRIVERDIR *q_u, prs_struct *ps, int depth)
 {
 	prs_debug(ps, depth, desc, "spoolss_io_q_getprinterdriverdir");
 	depth++;
@@ -5717,7 +5779,7 @@
  Parse a SPOOL_R_GETPRINTERDRIVERDIR structure.
 ********************************************************************/  
 
-BOOL spoolss_io_r_getprinterdriverdir(char *desc, SPOOL_R_GETPRINTERDRIVERDIR *r_u, prs_struct *ps, int depth)
+BOOL spoolss_io_r_getprinterdriverdir(const char *desc, SPOOL_R_GETPRINTERDRIVERDIR *r_u, prs_struct *ps, int depth)
 {		
 	prs_debug(ps, depth, desc, "spoolss_io_r_getprinterdriverdir");
 	depth++;
@@ -5743,7 +5805,7 @@
 /*******************************************************************
 ********************************************************************/  
 
-BOOL spoolss_io_r_enumprintprocessors(char *desc, SPOOL_R_ENUMPRINTPROCESSORS *r_u, prs_struct *ps, int depth)
+BOOL spoolss_io_r_enumprintprocessors(const char *desc, SPOOL_R_ENUMPRINTPROCESSORS *r_u, prs_struct *ps, int depth)
 {		
 	prs_debug(ps, depth, desc, "spoolss_io_r_enumprintprocessors");
 	depth++;
@@ -5772,7 +5834,7 @@
 /*******************************************************************
 ********************************************************************/  
 
-BOOL spoolss_io_q_enumprintprocessors(char *desc, SPOOL_Q_ENUMPRINTPROCESSORS *q_u, prs_struct *ps, int depth)
+BOOL spoolss_io_q_enumprintprocessors(const char *desc, SPOOL_Q_ENUMPRINTPROCESSORS *q_u, prs_struct *ps, int depth)
 {
 	prs_debug(ps, depth, desc, "spoolss_io_q_enumprintprocessors");
 	depth++;
@@ -5814,7 +5876,7 @@
 /*******************************************************************
 ********************************************************************/  
 
-BOOL spoolss_io_q_addprintprocessor(char *desc, SPOOL_Q_ADDPRINTPROCESSOR *q_u, prs_struct *ps, int depth)
+BOOL spoolss_io_q_addprintprocessor(const char *desc, SPOOL_Q_ADDPRINTPROCESSOR *q_u, prs_struct *ps, int depth)
 {
 	prs_debug(ps, depth, desc, "spoolss_io_q_addprintprocessor");
 	depth++;
@@ -5848,7 +5910,7 @@
 /*******************************************************************
 ********************************************************************/  
 
-BOOL spoolss_io_r_addprintprocessor(char *desc, SPOOL_R_ADDPRINTPROCESSOR *r_u, prs_struct *ps, int depth)
+BOOL spoolss_io_r_addprintprocessor(const char *desc, SPOOL_R_ADDPRINTPROCESSOR *r_u, prs_struct *ps, int depth)
 {		
 	prs_debug(ps, depth, desc, "spoolss_io_r_addprintproicessor");
 	depth++;
@@ -5865,7 +5927,7 @@
 /*******************************************************************
 ********************************************************************/  
 
-BOOL spoolss_io_r_enumprintprocdatatypes(char *desc, SPOOL_R_ENUMPRINTPROCDATATYPES *r_u, prs_struct *ps, int depth)
+BOOL spoolss_io_r_enumprintprocdatatypes(const char *desc, SPOOL_R_ENUMPRINTPROCDATATYPES *r_u, prs_struct *ps, int depth)
 {		
 	prs_debug(ps, depth, desc, "spoolss_io_r_enumprintprocdatatypes");
 	depth++;
@@ -5894,7 +5956,7 @@
 /*******************************************************************
 ********************************************************************/  
 
-BOOL spoolss_io_q_enumprintprocdatatypes(char *desc, SPOOL_Q_ENUMPRINTPROCDATATYPES *q_u, prs_struct *ps, int depth)
+BOOL spoolss_io_q_enumprintprocdatatypes(const char *desc, SPOOL_Q_ENUMPRINTPROCDATATYPES *q_u, prs_struct *ps, int depth)
 {
 	prs_debug(ps, depth, desc, "spoolss_io_q_enumprintprocdatatypes");
 	depth++;
@@ -5937,7 +5999,7 @@
  Parse a SPOOL_Q_ENUMPRINTMONITORS structure.
 ********************************************************************/  
 
-BOOL spoolss_io_q_enumprintmonitors(char *desc, SPOOL_Q_ENUMPRINTMONITORS *q_u, prs_struct *ps, int depth)
+BOOL spoolss_io_q_enumprintmonitors(const char *desc, SPOOL_Q_ENUMPRINTMONITORS *q_u, prs_struct *ps, int depth)
 {
 	prs_debug(ps, depth, desc, "spoolss_io_q_enumprintmonitors");
 	depth++;
@@ -5971,7 +6033,7 @@
 /*******************************************************************
 ********************************************************************/  
 
-BOOL spoolss_io_r_enumprintmonitors(char *desc, SPOOL_R_ENUMPRINTMONITORS *r_u, prs_struct *ps, int depth)
+BOOL spoolss_io_r_enumprintmonitors(const char *desc, SPOOL_R_ENUMPRINTMONITORS *r_u, prs_struct *ps, int depth)
 {		
 	prs_debug(ps, depth, desc, "spoolss_io_r_enumprintmonitors");
 	depth++;
@@ -6000,7 +6062,7 @@
 /*******************************************************************
 ********************************************************************/  
 
-BOOL spoolss_io_r_enumprinterdata(char *desc, SPOOL_R_ENUMPRINTERDATA *r_u, prs_struct *ps, int depth)
+BOOL spoolss_io_r_enumprinterdata(const char *desc, SPOOL_R_ENUMPRINTERDATA *r_u, prs_struct *ps, int depth)
 {	
 	prs_debug(ps, depth, desc, "spoolss_io_r_enumprinterdata");
 	depth++;
@@ -6057,7 +6119,7 @@
 /*******************************************************************
 ********************************************************************/  
 
-BOOL spoolss_io_q_enumprinterdata(char *desc, SPOOL_Q_ENUMPRINTERDATA *q_u, prs_struct *ps, int depth)
+BOOL spoolss_io_q_enumprinterdata(const char *desc, SPOOL_Q_ENUMPRINTERDATA *q_u, prs_struct *ps, int depth)
 {
 	prs_debug(ps, depth, desc, "spoolss_io_q_enumprinterdata");
 	depth++;
@@ -6095,7 +6157,7 @@
 ********************************************************************/  
 
 BOOL make_spoolss_q_enumprinterdataex(SPOOL_Q_ENUMPRINTERDATAEX *q_u,
-				      const POLICY_HND *hnd, char *key,
+				      const POLICY_HND *hnd, const char *key,
 				      uint32 size)
 {
 	memcpy(&q_u->handle, hnd, sizeof(q_u->handle));
@@ -6140,7 +6202,7 @@
 /*******************************************************************
 ********************************************************************/  
 
-BOOL spoolss_io_q_setprinterdata(char *desc, SPOOL_Q_SETPRINTERDATA *q_u, prs_struct *ps, int depth)
+BOOL spoolss_io_q_setprinterdata(const char *desc, SPOOL_Q_SETPRINTERDATA *q_u, prs_struct *ps, int depth)
 {
 	prs_debug(ps, depth, desc, "spoolss_io_q_setprinterdata");
 	depth++;
@@ -6189,7 +6251,7 @@
 /*******************************************************************
 ********************************************************************/  
 
-BOOL spoolss_io_r_setprinterdata(char *desc, SPOOL_R_SETPRINTERDATA *r_u, prs_struct *ps, int depth)
+BOOL spoolss_io_r_setprinterdata(const char *desc, SPOOL_R_SETPRINTERDATA *r_u, prs_struct *ps, int depth)
 {
 	prs_debug(ps, depth, desc, "spoolss_io_r_setprinterdata");
 	depth++;
@@ -6204,7 +6266,7 @@
 
 /*******************************************************************
 ********************************************************************/  
-BOOL spoolss_io_q_resetprinter(char *desc, SPOOL_Q_RESETPRINTER *q_u, prs_struct *ps, int depth)
+BOOL spoolss_io_q_resetprinter(const char *desc, SPOOL_Q_RESETPRINTER *q_u, prs_struct *ps, int depth)
 {
 	prs_debug(ps, depth, desc, "spoolss_io_q_resetprinter");
 	depth++;
@@ -6231,7 +6293,7 @@
 
 /*******************************************************************
 ********************************************************************/  
-BOOL spoolss_io_r_resetprinter(char *desc, SPOOL_R_RESETPRINTER *r_u, prs_struct *ps, int depth)
+BOOL spoolss_io_r_resetprinter(const char *desc, SPOOL_R_RESETPRINTER *r_u, prs_struct *ps, int depth)
 {
 	prs_debug(ps, depth, desc, "spoolss_io_r_resetprinter");
 	depth++;
@@ -6247,7 +6309,7 @@
 /*******************************************************************
 ********************************************************************/  
 
-static BOOL spoolss_io_addform(char *desc, FORM *f, uint32 ptr, prs_struct *ps, int depth)
+static BOOL spoolss_io_addform(const char *desc, FORM *f, uint32 ptr, prs_struct *ps, int depth)
 {
 	prs_debug(ps, depth, desc, "spoolss_io_addform");
 	depth++;
@@ -6283,7 +6345,7 @@
 /*******************************************************************
 ********************************************************************/  
 
-BOOL spoolss_io_q_deleteform(char *desc, SPOOL_Q_DELETEFORM *q_u, prs_struct *ps, int depth)
+BOOL spoolss_io_q_deleteform(const char *desc, SPOOL_Q_DELETEFORM *q_u, prs_struct *ps, int depth)
 {
 	prs_debug(ps, depth, desc, "spoolss_io_q_deleteform");
 	depth++;
@@ -6301,7 +6363,7 @@
 /*******************************************************************
 ********************************************************************/  
 
-BOOL spoolss_io_r_deleteform(char *desc, SPOOL_R_DELETEFORM *r_u, prs_struct *ps, int depth)
+BOOL spoolss_io_r_deleteform(const char *desc, SPOOL_R_DELETEFORM *r_u, prs_struct *ps, int depth)
 {
 	prs_debug(ps, depth, desc, "spoolss_io_r_deleteform");
 	depth++;
@@ -6317,7 +6379,7 @@
 /*******************************************************************
 ********************************************************************/  
 
-BOOL spoolss_io_q_addform(char *desc, SPOOL_Q_ADDFORM *q_u, prs_struct *ps, int depth)
+BOOL spoolss_io_q_addform(const char *desc, SPOOL_Q_ADDFORM *q_u, prs_struct *ps, int depth)
 {
 	uint32 useless_ptr=1;
 	prs_debug(ps, depth, desc, "spoolss_io_q_addform");
@@ -6346,7 +6408,7 @@
 /*******************************************************************
 ********************************************************************/  
 
-BOOL spoolss_io_r_addform(char *desc, SPOOL_R_ADDFORM *r_u, prs_struct *ps, int depth)
+BOOL spoolss_io_r_addform(const char *desc, SPOOL_R_ADDFORM *r_u, prs_struct *ps, int depth)
 {
 	prs_debug(ps, depth, desc, "spoolss_io_r_addform");
 	depth++;
@@ -6362,7 +6424,7 @@
 /*******************************************************************
 ********************************************************************/  
 
-BOOL spoolss_io_q_setform(char *desc, SPOOL_Q_SETFORM *q_u, prs_struct *ps, int depth)
+BOOL spoolss_io_q_setform(const char *desc, SPOOL_Q_SETFORM *q_u, prs_struct *ps, int depth)
 {
 	uint32 useless_ptr=1;
 	prs_debug(ps, depth, desc, "spoolss_io_q_setform");
@@ -6397,7 +6459,7 @@
 /*******************************************************************
 ********************************************************************/  
 
-BOOL spoolss_io_r_setform(char *desc, SPOOL_R_SETFORM *r_u, prs_struct *ps, int depth)
+BOOL spoolss_io_r_setform(const char *desc, SPOOL_R_SETFORM *r_u, prs_struct *ps, int depth)
 {
 	prs_debug(ps, depth, desc, "spoolss_io_r_setform");
 	depth++;
@@ -6414,7 +6476,7 @@
  Parse a SPOOL_R_GETJOB structure.
 ********************************************************************/  
 
-BOOL spoolss_io_r_getjob(char *desc, SPOOL_R_GETJOB *r_u, prs_struct *ps, int depth)
+BOOL spoolss_io_r_getjob(const char *desc, SPOOL_R_GETJOB *r_u, prs_struct *ps, int depth)
 {		
 	prs_debug(ps, depth, desc, "spoolss_io_r_getjob");
 	depth++;
@@ -6441,7 +6503,7 @@
  Parse a SPOOL_Q_GETJOB structure.
 ********************************************************************/  
 
-BOOL spoolss_io_q_getjob(char *desc, SPOOL_Q_GETJOB *q_u, prs_struct *ps, int depth)
+BOOL spoolss_io_q_getjob(const char *desc, SPOOL_Q_GETJOB *q_u, prs_struct *ps, int depth)
 {
 	prs_debug(ps, depth, desc, "");
 	depth++;
@@ -6505,6 +6567,11 @@
 	SAFE_FREE(printer);
 }
 
+void free_printer_info_7(PRINTER_INFO_7 *printer)
+{
+	SAFE_FREE(printer);
+}
+
 void free_job_info_2(JOB_INFO_2 *job)
 {
     if (job!=NULL)
@@ -6536,7 +6603,7 @@
  Parse a SPOOL_Q_REPLYOPENPRINTER structure.
 ********************************************************************/  
 
-BOOL spoolss_io_q_replyopenprinter(char *desc, SPOOL_Q_REPLYOPENPRINTER *q_u, prs_struct *ps, int depth)
+BOOL spoolss_io_q_replyopenprinter(const char *desc, SPOOL_Q_REPLYOPENPRINTER *q_u, prs_struct *ps, int depth)
 {
 	prs_debug(ps, depth, desc, "spoolss_io_q_replyopenprinter");
 	depth++;
@@ -6567,7 +6634,7 @@
  Parse a SPOOL_R_REPLYOPENPRINTER structure.
 ********************************************************************/  
 
-BOOL spoolss_io_r_replyopenprinter(char *desc, SPOOL_R_REPLYOPENPRINTER *r_u, prs_struct *ps, int depth)
+BOOL spoolss_io_r_replyopenprinter(const char *desc, SPOOL_R_REPLYOPENPRINTER *r_u, prs_struct *ps, int depth)
 {		
 	prs_debug(ps, depth, desc, "spoolss_io_r_replyopenprinter");
 	depth++;
@@ -6607,7 +6674,7 @@
 /*******************************************************************
  Parse a SPOOL_Q_ROUTERREPLYPRINTER structure.
 ********************************************************************/
-BOOL spoolss_io_q_routerreplyprinter (char *desc, SPOOL_Q_ROUTERREPLYPRINTER *q_u, prs_struct *ps, int depth)
+BOOL spoolss_io_q_routerreplyprinter (const char *desc, SPOOL_Q_ROUTERREPLYPRINTER *q_u, prs_struct *ps, int depth)
 {
 
 	prs_debug(ps, depth, desc, "spoolss_io_q_routerreplyprinter");
@@ -6637,7 +6704,7 @@
 /*******************************************************************
  Parse a SPOOL_R_ROUTERREPLYPRINTER structure.
 ********************************************************************/
-BOOL spoolss_io_r_routerreplyprinter (char *desc, SPOOL_R_ROUTERREPLYPRINTER *r_u, prs_struct *ps, int depth)
+BOOL spoolss_io_r_routerreplyprinter (const char *desc, SPOOL_R_ROUTERREPLYPRINTER *r_u, prs_struct *ps, int depth)
 {
 	prs_debug(ps, depth, desc, "spoolss_io_r_routerreplyprinter");
 	depth++;
@@ -6669,7 +6736,7 @@
  Parse a SPOOL_Q_REPLYCLOSEPRINTER structure.
 ********************************************************************/  
 
-BOOL spoolss_io_q_replycloseprinter(char *desc, SPOOL_Q_REPLYCLOSEPRINTER *q_u, prs_struct *ps, int depth)
+BOOL spoolss_io_q_replycloseprinter(const char *desc, SPOOL_Q_REPLYCLOSEPRINTER *q_u, prs_struct *ps, int depth)
 {
 	prs_debug(ps, depth, desc, "spoolss_io_q_replycloseprinter");
 	depth++;
@@ -6687,7 +6754,7 @@
  Parse a SPOOL_R_REPLYCLOSEPRINTER structure.
 ********************************************************************/  
 
-BOOL spoolss_io_r_replycloseprinter(char *desc, SPOOL_R_REPLYCLOSEPRINTER *r_u, prs_struct *ps, int depth)
+BOOL spoolss_io_r_replycloseprinter(const char *desc, SPOOL_R_REPLYCLOSEPRINTER *r_u, prs_struct *ps, int depth)
 {		
 	prs_debug(ps, depth, desc, "spoolss_io_r_replycloseprinter");
 	depth++;
@@ -6814,7 +6881,7 @@
  Parse a SPOOL_Q_REPLY_RRPCN structure.
 ********************************************************************/  
 
-BOOL spoolss_io_q_reply_rrpcn(char *desc, SPOOL_Q_REPLY_RRPCN *q_u, prs_struct *ps, int depth)
+BOOL spoolss_io_q_reply_rrpcn(const char *desc, SPOOL_Q_REPLY_RRPCN *q_u, prs_struct *ps, int depth)
 {
 	prs_debug(ps, depth, desc, "spoolss_io_q_reply_rrpcn");
 	depth++;
@@ -6851,7 +6918,7 @@
  Parse a SPOOL_R_REPLY_RRPCN structure.
 ********************************************************************/  
 
-BOOL spoolss_io_r_reply_rrpcn(char *desc, SPOOL_R_REPLY_RRPCN *r_u, prs_struct *ps, int depth)
+BOOL spoolss_io_r_reply_rrpcn(const char *desc, SPOOL_R_REPLY_RRPCN *r_u, prs_struct *ps, int depth)
 {		
 	prs_debug(ps, depth, desc, "spoolss_io_r_reply_rrpcn");
 	depth++;
@@ -6873,7 +6940,7 @@
  * called from spoolss_q_getprinterdataex (srv_spoolss.c)
  ********************************************************************/
 
-BOOL spoolss_io_q_getprinterdataex(char *desc, SPOOL_Q_GETPRINTERDATAEX *q_u, prs_struct *ps, int depth)
+BOOL spoolss_io_q_getprinterdataex(const char *desc, SPOOL_Q_GETPRINTERDATAEX *q_u, prs_struct *ps, int depth)
 {
 	if (q_u == NULL)
 		return False;
@@ -6906,7 +6973,7 @@
  * called from spoolss_r_getprinterdataex (srv_spoolss.c)
  ********************************************************************/
 
-BOOL spoolss_io_r_getprinterdataex(char *desc, SPOOL_R_GETPRINTERDATAEX *r_u, prs_struct *ps, int depth)
+BOOL spoolss_io_r_getprinterdataex(const char *desc, SPOOL_R_GETPRINTERDATAEX *r_u, prs_struct *ps, int depth)
 {
 	if (r_u == NULL)
 		return False;
@@ -6945,7 +7012,7 @@
  * read a structure.
  ********************************************************************/  
 
-BOOL spoolss_io_q_setprinterdataex(char *desc, SPOOL_Q_SETPRINTERDATAEX *q_u, prs_struct *ps, int depth)
+BOOL spoolss_io_q_setprinterdataex(const char *desc, SPOOL_Q_SETPRINTERDATAEX *q_u, prs_struct *ps, int depth)
 {
 	prs_debug(ps, depth, desc, "spoolss_io_q_setprinterdataex");
 	depth++;
@@ -7001,7 +7068,7 @@
  * write a structure.
  ********************************************************************/  
 
-BOOL spoolss_io_r_setprinterdataex(char *desc, SPOOL_R_SETPRINTERDATAEX *r_u, prs_struct *ps, int depth)
+BOOL spoolss_io_r_setprinterdataex(const char *desc, SPOOL_R_SETPRINTERDATAEX *r_u, prs_struct *ps, int depth)
 {
 	prs_debug(ps, depth, desc, "spoolss_io_r_setprinterdataex");
 	depth++;
@@ -7018,7 +7085,8 @@
  * read a structure.
  ********************************************************************/  
 BOOL make_spoolss_q_enumprinterkey(SPOOL_Q_ENUMPRINTERKEY *q_u, 
-				   POLICY_HND *hnd, char *key, uint32 size)
+				   POLICY_HND *hnd, const char *key, 
+				   uint32 size)
 {
 	DEBUG(5,("make_spoolss_q_enumprinterkey\n"));
 
@@ -7033,7 +7101,7 @@
  * read a structure.
  ********************************************************************/  
 
-BOOL spoolss_io_q_enumprinterkey(char *desc, SPOOL_Q_ENUMPRINTERKEY *q_u, prs_struct *ps, int depth)
+BOOL spoolss_io_q_enumprinterkey(const char *desc, SPOOL_Q_ENUMPRINTERKEY *q_u, prs_struct *ps, int depth)
 {
 	prs_debug(ps, depth, desc, "spoolss_io_q_enumprinterkey");
 	depth++;
@@ -7059,7 +7127,7 @@
  * write a structure.
  ********************************************************************/  
 
-BOOL spoolss_io_r_enumprinterkey(char *desc, SPOOL_R_ENUMPRINTERKEY *r_u, prs_struct *ps, int depth)
+BOOL spoolss_io_r_enumprinterkey(const char *desc, SPOOL_R_ENUMPRINTERKEY *r_u, prs_struct *ps, int depth)
 {
 	prs_debug(ps, depth, desc, "spoolss_io_r_enumprinterkey");
 	depth++;
@@ -7101,7 +7169,7 @@
  * read a structure.
  ********************************************************************/  
 
-BOOL spoolss_io_q_deleteprinterkey(char *desc, SPOOL_Q_DELETEPRINTERKEY *q_u, prs_struct *ps, int depth)
+BOOL spoolss_io_q_deleteprinterkey(const char *desc, SPOOL_Q_DELETEPRINTERKEY *q_u, prs_struct *ps, int depth)
 {
 	prs_debug(ps, depth, desc, "spoolss_io_q_deleteprinterkey");
 	depth++;
@@ -7121,7 +7189,7 @@
  * write a structure.
  ********************************************************************/  
 
-BOOL spoolss_io_r_deleteprinterkey(char *desc, SPOOL_R_DELETEPRINTERKEY *r_u, prs_struct *ps, int depth)
+BOOL spoolss_io_r_deleteprinterkey(const char *desc, SPOOL_R_DELETEPRINTERKEY *r_u, prs_struct *ps, int depth)
 {
 	prs_debug(ps, depth, desc, "spoolss_io_r_deleteprinterkey");
 	depth++;
@@ -7140,7 +7208,7 @@
  * read a structure.
  ********************************************************************/  
 
-BOOL spoolss_io_q_enumprinterdataex(char *desc, SPOOL_Q_ENUMPRINTERDATAEX *q_u, prs_struct *ps, int depth)
+BOOL spoolss_io_q_enumprinterdataex(const char *desc, SPOOL_Q_ENUMPRINTERDATAEX *q_u, prs_struct *ps, int depth)
 {
 	prs_debug(ps, depth, desc, "spoolss_io_q_enumprinterdataex");
 	depth++;
@@ -7165,7 +7233,7 @@
 /*******************************************************************
 ********************************************************************/  
 
-static BOOL spoolss_io_printer_enum_values_ctr(char *desc, prs_struct *ps, 
+static BOOL spoolss_io_printer_enum_values_ctr(const char *desc, prs_struct *ps, 
 				PRINTER_ENUM_VALUES_CTR *ctr, int depth)
 {
 	int 	i;
@@ -7248,7 +7316,7 @@
  * write a structure.
  ********************************************************************/  
 
-BOOL spoolss_io_r_enumprinterdataex(char *desc, SPOOL_R_ENUMPRINTERDATAEX *r_u, prs_struct *ps, int depth)
+BOOL spoolss_io_r_enumprinterdataex(const char *desc, SPOOL_R_ENUMPRINTERDATAEX *r_u, prs_struct *ps, int depth)
 {
 	uint32 data_offset, end_offset;
 	prs_debug(ps, depth, desc, "spoolss_io_r_enumprinterdataex");
@@ -7325,7 +7393,7 @@
 	return True;
 }
 
-BOOL spoolss_io_q_getprintprocessordirectory(char *desc, SPOOL_Q_GETPRINTPROCESSORDIRECTORY *q_u, prs_struct *ps, int depth)
+BOOL spoolss_io_q_getprintprocessordirectory(const char *desc, SPOOL_Q_GETPRINTPROCESSORDIRECTORY *q_u, prs_struct *ps, int depth)
 {
 	uint32 ptr;
 
@@ -7377,7 +7445,7 @@
  * write a structure.
  ********************************************************************/  
 
-BOOL spoolss_io_r_getprintprocessordirectory(char *desc, SPOOL_R_GETPRINTPROCESSORDIRECTORY *r_u, prs_struct *ps, int depth)
+BOOL spoolss_io_r_getprintprocessordirectory(const char *desc, SPOOL_R_GETPRINTPROCESSORDIRECTORY *r_u, prs_struct *ps, int depth)
 {
 	prs_debug(ps, depth, desc, "spoolss_io_r_getprintprocessordirectory");
 	depth++;
@@ -7400,7 +7468,7 @@
 	return True;
 }
 
-BOOL smb_io_printprocessordirectory_1(char *desc, NEW_BUFFER *buffer, PRINTPROCESSOR_DIRECTORY_1 *info, int depth)
+BOOL smb_io_printprocessordirectory_1(const char *desc, NEW_BUFFER *buffer, PRINTPROCESSOR_DIRECTORY_1 *info, int depth)
 {
 	prs_struct *ps=&buffer->prs;
 
diff -uNr samba-3.0alpha21.orig/source/rpc_parse/parse_srv.c samba-3.0alpha21/source/rpc_parse/parse_srv.c
--- samba-3.0alpha21.orig/source/rpc_parse/parse_srv.c	2003-02-16 19:06:33.000000000 -0600
+++ samba-3.0alpha21/source/rpc_parse/parse_srv.c	2003-02-16 19:05:46.000000000 -0600
@@ -32,7 +32,7 @@
  Inits a SH_INFO_0_STR structure
 ********************************************************************/
 
-void init_srv_share_info0_str(SH_INFO_0_STR *sh0, char *net_name)
+void init_srv_share_info0_str(SH_INFO_0_STR *sh0, const char *net_name)
 {
 	DEBUG(5,("init_srv_share_info0_str\n"));
 
@@ -44,7 +44,7 @@
  Reads or writes a structure.
 ********************************************************************/
 
-static BOOL srv_io_share_info0_str(char *desc, SH_INFO_0_STR *sh0, prs_struct *ps, int depth)
+static BOOL srv_io_share_info0_str(const char *desc, SH_INFO_0_STR *sh0, prs_struct *ps, int depth)
 {
 	if (sh0 == NULL)
 		return False;
@@ -65,7 +65,7 @@
  makes a SH_INFO_0 structure
 ********************************************************************/
 
-void init_srv_share_info0(SH_INFO_0 *sh0, char *net_name)
+void init_srv_share_info0(SH_INFO_0 *sh0, const char *net_name)
 {
 	DEBUG(5,("init_srv_share_info0: %s\n", net_name));
 
@@ -76,7 +76,7 @@
  Reads or writes a structure.
 ********************************************************************/
 
-static BOOL srv_io_share_info0(char *desc, SH_INFO_0 *sh0, prs_struct *ps, int depth)
+static BOOL srv_io_share_info0(const char *desc, SH_INFO_0 *sh0, prs_struct *ps, int depth)
 {
 	if (sh0 == NULL)
 		return False;
@@ -97,7 +97,7 @@
  Inits a SH_INFO_1_STR structure
 ********************************************************************/
 
-void init_srv_share_info1_str(SH_INFO_1_STR *sh1, char *net_name, char *remark)
+void init_srv_share_info1_str(SH_INFO_1_STR *sh1, const char *net_name, const char *remark)
 {
 	DEBUG(5,("init_srv_share_info1_str\n"));
 
@@ -111,7 +111,7 @@
  Reads or writes a structure.
 ********************************************************************/
 
-static BOOL srv_io_share_info1_str(char *desc, SH_INFO_1_STR *sh1, prs_struct *ps, int depth)
+static BOOL srv_io_share_info1_str(const char *desc, SH_INFO_1_STR *sh1, prs_struct *ps, int depth)
 {
 	if (sh1 == NULL)
 		return False;
@@ -140,7 +140,7 @@
  makes a SH_INFO_1 structure
 ********************************************************************/
 
-void init_srv_share_info1(SH_INFO_1 *sh1, char *net_name, uint32 type, char *remark)
+void init_srv_share_info1(SH_INFO_1 *sh1, const char *net_name, uint32 type, const char *remark)
 {
 	DEBUG(5,("init_srv_share_info1: %s %8x %s\n", net_name, type, remark));
 	
@@ -153,7 +153,7 @@
  Reads or writes a structure.
 ********************************************************************/
 
-static BOOL srv_io_share_info1(char *desc, SH_INFO_1 *sh1, prs_struct *ps, int depth)
+static BOOL srv_io_share_info1(const char *desc, SH_INFO_1 *sh1, prs_struct *ps, int depth)
 {
 	if (sh1 == NULL)
 		return False;
@@ -179,8 +179,8 @@
 ********************************************************************/
 
 void init_srv_share_info2_str(SH_INFO_2_STR *sh2,
-				char *net_name, char *remark,
-				char *path, char *passwd)
+				const char *net_name, const char *remark,
+				const char *path, const char *passwd)
 {
 	DEBUG(5,("init_srv_share_info2_str\n"));
 
@@ -198,7 +198,7 @@
  Reads or writes a structure.
 ********************************************************************/
 
-static BOOL srv_io_share_info2_str(char *desc, SH_INFO_2 *sh, SH_INFO_2_STR *sh2, prs_struct *ps, int depth)
+static BOOL srv_io_share_info2_str(const char *desc, SH_INFO_2 *sh, SH_INFO_2_STR *sh2, prs_struct *ps, int depth)
 {
 	if (sh2 == NULL)
 		return False;
@@ -236,9 +236,9 @@
 ********************************************************************/
 
 void init_srv_share_info2(SH_INFO_2 *sh2,
-				char *net_name, uint32 type, char *remark,
+				const char *net_name, uint32 type, const char *remark,
 				uint32 perms, uint32 max_uses, uint32 num_uses,
-				char *path, char *passwd)
+				const char *path, const char *passwd)
 {
 	DEBUG(5,("init_srv_share_info2: %s %8x %s\n", net_name, type, remark));
 
@@ -256,7 +256,7 @@
  Reads or writes a structure.
 ********************************************************************/
 
-static BOOL srv_io_share_info2(char *desc, SH_INFO_2 *sh2, prs_struct *ps, int depth)
+static BOOL srv_io_share_info2(const char *desc, SH_INFO_2 *sh2, prs_struct *ps, int depth)
 {
 	if (sh2 == NULL)
 		return False;
@@ -292,7 +292,7 @@
 ********************************************************************/
 
 void init_srv_share_info501_str(SH_INFO_501_STR *sh501,
-				char *net_name, char *remark)
+				const char *net_name, const char *remark)
 {
 	DEBUG(5,("init_srv_share_info501_str\n"));
 
@@ -306,7 +306,7 @@
  Inits a SH_INFO_2 structure
 *******************************************************************/
 
-void init_srv_share_info501(SH_INFO_501 *sh501, char *net_name, uint32 type, char *remark, uint32 csc_policy)
+void init_srv_share_info501(SH_INFO_501 *sh501, const char *net_name, uint32 type, const char *remark, uint32 csc_policy)
 {
 	DEBUG(5,("init_srv_share_info501: %s %8x %s %08x\n", net_name, type,
 		remark, csc_policy));
@@ -323,7 +323,7 @@
  Reads of writes a structure.
 *******************************************************************/
 
-static BOOL srv_io_share_info501(char *desc, SH_INFO_501 *sh501, prs_struct *ps, int depth)
+static BOOL srv_io_share_info501(const char *desc, SH_INFO_501 *sh501, prs_struct *ps, int depth)
 {
 	if (sh501 == NULL)
 		return False;
@@ -350,7 +350,7 @@
  Reads or writes a structure.
 ********************************************************************/
 
-static BOOL srv_io_share_info501_str(char *desc, SH_INFO_501_STR *sh501, prs_struct *ps, int depth)
+static BOOL srv_io_share_info501_str(const char *desc, SH_INFO_501_STR *sh501, prs_struct *ps, int depth)
 {
 	if (sh501 == NULL)
 		return False;
@@ -376,9 +376,9 @@
 ********************************************************************/
 
 void init_srv_share_info502(SH_INFO_502 *sh502,
-				const char *net_name, uint32 type, char *remark,
+				const char *net_name, uint32 type, const char *remark,
 				uint32 perms, uint32 max_uses, uint32 num_uses,
-				char *path, char *passwd, SEC_DESC *psd, size_t sd_size)
+				const char *path, const char *passwd, SEC_DESC *psd, size_t sd_size)
 {
 	DEBUG(5,("init_srv_share_info502: %s %8x %s\n", net_name, type, remark));
 
@@ -401,7 +401,7 @@
  Reads or writes a structure.
 ********************************************************************/
 
-static BOOL srv_io_share_info502(char *desc, SH_INFO_502 *sh502, prs_struct *ps, int depth)
+static BOOL srv_io_share_info502(const char *desc, SH_INFO_502 *sh502, prs_struct *ps, int depth)
 {
 	if (sh502 == NULL)
 		return False;
@@ -441,8 +441,8 @@
 ********************************************************************/
 
 void init_srv_share_info502_str(SH_INFO_502_STR *sh502str,
-				char *net_name, char *remark,
-				char *path, char *passwd, SEC_DESC *psd, size_t sd_size)
+				const char *net_name, const char *remark,
+				const char *path, const char *passwd, SEC_DESC *psd, size_t sd_size)
 {
 	DEBUG(5,("init_srv_share_info502_str\n"));
 
@@ -463,7 +463,7 @@
  Reads or writes a structure.
 ********************************************************************/
 
-static BOOL srv_io_share_info502_str(char *desc, SH_INFO_502_STR *sh502, prs_struct *ps, int depth)
+static BOOL srv_io_share_info502_str(const char *desc, SH_INFO_502_STR *sh502, prs_struct *ps, int depth)
 {
 	if (sh502 == NULL)
 		return False;
@@ -547,7 +547,7 @@
  Inits a SH_INFO_1004_STR structure
 ********************************************************************/
 
-void init_srv_share_info1004_str(SH_INFO_1004_STR *sh1004, char *remark)
+void init_srv_share_info1004_str(SH_INFO_1004_STR *sh1004, const char *remark)
 {
 	DEBUG(5,("init_srv_share_info1004_str\n"));
 
@@ -559,7 +559,7 @@
  Reads or writes a structure.
 ********************************************************************/
 
-static BOOL srv_io_share_info1004_str(char *desc, SH_INFO_1004_STR *sh1004, prs_struct *ps, int depth)
+static BOOL srv_io_share_info1004_str(const char *desc, SH_INFO_1004_STR *sh1004, prs_struct *ps, int depth)
 {
 	if (sh1004 == NULL)
 		return False;
@@ -580,7 +580,7 @@
  makes a SH_INFO_1004 structure
 ********************************************************************/
 
-void init_srv_share_info1004(SH_INFO_1004 *sh1004, char *remark)
+void init_srv_share_info1004(SH_INFO_1004 *sh1004, const char *remark)
 {
 	DEBUG(5,("init_srv_share_info1004: %s\n", remark));
 
@@ -591,7 +591,7 @@
  Reads or writes a structure.
 ********************************************************************/
 
-static BOOL srv_io_share_info1004(char *desc, SH_INFO_1004 *sh1004, prs_struct *ps, int depth)
+static BOOL srv_io_share_info1004(const char *desc, SH_INFO_1004 *sh1004, prs_struct *ps, int depth)
 {
 	if (sh1004 == NULL)
 		return False;
@@ -612,7 +612,7 @@
  Reads or writes a structure.
 ********************************************************************/
 
-static BOOL srv_io_share_info1005(char* desc, SRV_SHARE_INFO_1005* sh1005, prs_struct* ps, int depth)
+static BOOL srv_io_share_info1005(const char* desc, SRV_SHARE_INFO_1005* sh1005, prs_struct* ps, int depth)
 {
 	if(sh1005 == NULL)
 		return False;
@@ -633,7 +633,7 @@
  Reads or writes a structure.
 ********************************************************************/
 
-static BOOL srv_io_share_info1006(char* desc, SRV_SHARE_INFO_1006* sh1006, prs_struct* ps, int depth)
+static BOOL srv_io_share_info1006(const char* desc, SRV_SHARE_INFO_1006* sh1006, prs_struct* ps, int depth)
 {
 	if(sh1006 == NULL)
 		return False;
@@ -666,7 +666,7 @@
  Reads or writes a structure.
 ********************************************************************/
 
-static BOOL srv_io_share_info1007_str(char *desc, SH_INFO_1007_STR *sh1007, prs_struct *ps, int depth)
+static BOOL srv_io_share_info1007_str(const char *desc, SH_INFO_1007_STR *sh1007, prs_struct *ps, int depth)
 {
 	if (sh1007 == NULL)
 		return False;
@@ -699,7 +699,7 @@
  Reads or writes a structure.
 ********************************************************************/
 
-static BOOL srv_io_share_info1007(char *desc, SH_INFO_1007 *sh1007, prs_struct *ps, int depth)
+static BOOL srv_io_share_info1007(const char *desc, SH_INFO_1007 *sh1007, prs_struct *ps, int depth)
 {
 	if (sh1007 == NULL)
 		return False;
@@ -722,7 +722,7 @@
  Reads or writes a structure.
 ********************************************************************/
 
-static BOOL srv_io_share_info1501(char* desc, SRV_SHARE_INFO_1501* sh1501,
+static BOOL srv_io_share_info1501(const char* desc, SRV_SHARE_INFO_1501* sh1501,
 				  prs_struct* ps, int depth)
 {
 	if(sh1501 == NULL)
@@ -744,7 +744,7 @@
  Reads or writes a structure.
 ********************************************************************/
 
-static BOOL srv_io_srv_share_ctr(char *desc, SRV_SHARE_INFO_CTR *ctr, prs_struct *ps, int depth)
+static BOOL srv_io_srv_share_ctr(const char *desc, SRV_SHARE_INFO_CTR *ctr, prs_struct *ps, int depth)
 {
 	if (ctr == NULL)
 		return False;
@@ -1045,7 +1045,7 @@
 ********************************************************************/
 
 void init_srv_q_net_share_enum(SRV_Q_NET_SHARE_ENUM *q_n, 
-				char *srv_name, uint32 info_level,
+				const char *srv_name, uint32 info_level,
 				uint32 preferred_len, ENUM_HND *hnd)
 {
 
@@ -1067,7 +1067,7 @@
  Reads or writes a structure.
 ********************************************************************/
 
-BOOL srv_io_q_net_share_enum(char *desc, SRV_Q_NET_SHARE_ENUM *q_n, prs_struct *ps, int depth)
+BOOL srv_io_q_net_share_enum(const char *desc, SRV_Q_NET_SHARE_ENUM *q_n, prs_struct *ps, int depth)
 {
 	if (q_n == NULL)
 		return False;
@@ -1102,7 +1102,7 @@
  Reads or writes a structure.
 ********************************************************************/
 
-BOOL srv_io_r_net_share_enum(char *desc, SRV_R_NET_SHARE_ENUM *r_n, prs_struct *ps, int depth)
+BOOL srv_io_r_net_share_enum(const char *desc, SRV_R_NET_SHARE_ENUM *r_n, prs_struct *ps, int depth)
 {
 	if (r_n == NULL)
 		return False;
@@ -1151,7 +1151,7 @@
  Reads or writes a structure.
 ********************************************************************/
 
-BOOL srv_io_q_net_share_get_info(char *desc, SRV_Q_NET_SHARE_GET_INFO *q_n, prs_struct *ps, int depth)
+BOOL srv_io_q_net_share_get_info(const char *desc, SRV_Q_NET_SHARE_GET_INFO *q_n, prs_struct *ps, int depth)
 {
 	if (q_n == NULL)
 		return False;
@@ -1183,7 +1183,7 @@
  Reads or writes a structure.
 ********************************************************************/
 
-static BOOL srv_io_srv_share_info(char *desc, prs_struct *ps, int depth, SRV_SHARE_INFO *r_n)
+static BOOL srv_io_srv_share_info(const char *desc, prs_struct *ps, int depth, SRV_SHARE_INFO *r_n)
 {
 	if (r_n == NULL)
 		return False;
@@ -1294,7 +1294,7 @@
  Reads or writes a structure.
 ********************************************************************/
 
-BOOL srv_io_r_net_share_get_info(char *desc, SRV_R_NET_SHARE_GET_INFO *r_n, prs_struct *ps, int depth)
+BOOL srv_io_r_net_share_get_info(const char *desc, SRV_R_NET_SHARE_GET_INFO *r_n, prs_struct *ps, int depth)
 {
 	if (r_n == NULL)
 		return False;
@@ -1349,7 +1349,7 @@
  Reads or writes a structure.
 ********************************************************************/
 
-BOOL srv_io_q_net_share_set_info(char *desc, SRV_Q_NET_SHARE_SET_INFO *q_n, prs_struct *ps, int depth)
+BOOL srv_io_q_net_share_set_info(const char *desc, SRV_Q_NET_SHARE_SET_INFO *q_n, prs_struct *ps, int depth)
 {
 	if (q_n == NULL)
 		return False;
@@ -1396,7 +1396,7 @@
  Reads or writes a structure.
 ********************************************************************/
 
-BOOL srv_io_r_net_share_set_info(char *desc, SRV_R_NET_SHARE_SET_INFO *r_n, prs_struct *ps, int depth)
+BOOL srv_io_r_net_share_set_info(const char *desc, SRV_R_NET_SHARE_SET_INFO *r_n, prs_struct *ps, int depth)
 {
 	if (r_n == NULL)
 		return False;
@@ -1427,7 +1427,7 @@
  Reads or writes a structure.
 ********************************************************************/
 
-BOOL srv_io_q_net_share_add(char *desc, SRV_Q_NET_SHARE_ADD *q_n, prs_struct *ps, int depth)
+BOOL srv_io_q_net_share_add(const char *desc, SRV_Q_NET_SHARE_ADD *q_n, prs_struct *ps, int depth)
 {
 	if (q_n == NULL)
 		return False;
@@ -1467,10 +1467,10 @@
 	return True;
 }
 
-void init_srv_q_net_share_add(SRV_Q_NET_SHARE_ADD *q, char *srvname,
-			      char *netname, uint32 type, char *remark, 
+void init_srv_q_net_share_add(SRV_Q_NET_SHARE_ADD *q, const char *srvname,
+			      const char *netname, uint32 type, const char *remark, 
 			      uint32 perms, uint32 max_uses, uint32 num_uses,
-			      char *path, char *passwd)
+			      const char *path, const char *passwd)
 {
 	q->ptr_srv_name = 1;
 	init_unistr2(&q->uni_srv_name, srvname, strlen(srvname) +1);
@@ -1490,7 +1490,7 @@
  Reads or writes a structure.
 ********************************************************************/
 
-BOOL srv_io_r_net_share_add(char *desc, SRV_R_NET_SHARE_ADD *r_n, prs_struct *ps, int depth)
+BOOL srv_io_r_net_share_add(const char *desc, SRV_R_NET_SHARE_ADD *r_n, prs_struct *ps, int depth)
 {
 	if (r_n == NULL)
 		return False;
@@ -1532,7 +1532,7 @@
  Reads or writes a structure.
 ********************************************************************/
 
-BOOL srv_io_q_net_share_del(char *desc, SRV_Q_NET_SHARE_DEL *q_n, prs_struct *ps, int depth)
+BOOL srv_io_q_net_share_del(const char *desc, SRV_Q_NET_SHARE_DEL *q_n, prs_struct *ps, int depth)
 {
 	if (q_n == NULL)
 		return False;
@@ -1563,7 +1563,7 @@
  Reads or writes a structure.
 ********************************************************************/
 
-BOOL srv_io_r_net_share_del(char *desc, SRV_R_NET_SHARE_DEL *q_n, prs_struct *ps, int depth)
+BOOL srv_io_r_net_share_del(const char *desc, SRV_R_NET_SHARE_DEL *q_n, prs_struct *ps, int depth)
 {
 	if (q_n == NULL)
 		return False;
@@ -1584,7 +1584,7 @@
  Inits a SESS_INFO_0_STR structure
 ********************************************************************/
 
-void init_srv_sess_info0_str(SESS_INFO_0_STR *ss0, char *name)
+void init_srv_sess_info0_str(SESS_INFO_0_STR *ss0, const char *name)
 {
 	DEBUG(5,("init_srv_sess_info0_str\n"));
 
@@ -1595,7 +1595,7 @@
  Reads or writes a structure.
 ********************************************************************/
 
-static BOOL srv_io_sess_info0_str(char *desc,  SESS_INFO_0_STR *ss0, prs_struct *ps, int depth)
+static BOOL srv_io_sess_info0_str(const char *desc,  SESS_INFO_0_STR *ss0, prs_struct *ps, int depth)
 {
 	if (ss0 == NULL)
 		return False;
@@ -1616,7 +1616,7 @@
  Inits a SESS_INFO_0 structure
 ********************************************************************/
 
-void init_srv_sess_info0(SESS_INFO_0 *ss0, char *name)
+void init_srv_sess_info0(SESS_INFO_0 *ss0, const char *name)
 {
 	DEBUG(5,("init_srv_sess_info0: %s\n", name));
 
@@ -1627,7 +1627,7 @@
  Reads or writes a structure.
 ********************************************************************/
 
-static BOOL srv_io_sess_info0(char *desc, SESS_INFO_0 *ss0, prs_struct *ps, int depth)
+static BOOL srv_io_sess_info0(const char *desc, SESS_INFO_0 *ss0, prs_struct *ps, int depth)
 {
 	if (ss0 == NULL)
 		return False;
@@ -1648,7 +1648,7 @@
  Reads or writes a structure.
 ********************************************************************/
 
-static BOOL srv_io_srv_sess_info_0(char *desc, SRV_SESS_INFO_0 *ss0, prs_struct *ps, int depth)
+static BOOL srv_io_srv_sess_info_0(const char *desc, SRV_SESS_INFO_0 *ss0, prs_struct *ps, int depth)
 {
 	if (ss0 == NULL)
 		return False;
@@ -1698,7 +1698,7 @@
  Inits a SESS_INFO_1_STR structure
 ********************************************************************/
 
-void init_srv_sess_info1_str(SESS_INFO_1_STR *ss1, char *name, char *user)
+void init_srv_sess_info1_str(SESS_INFO_1_STR *ss1, const char *name, const char *user)
 {
 	DEBUG(5,("init_srv_sess_info1_str\n"));
 
@@ -1710,7 +1710,7 @@
  Reads or writes a structure.
 ********************************************************************/
 
-static BOOL srv_io_sess_info1_str(char *desc, SESS_INFO_1_STR *ss1, prs_struct *ps, int depth)
+static BOOL srv_io_sess_info1_str(const char *desc, SESS_INFO_1_STR *ss1, prs_struct *ps, int depth)
 {
 	if (ss1 == NULL)
 		return False;
@@ -1734,7 +1734,7 @@
 ********************************************************************/
 
 void init_srv_sess_info1(SESS_INFO_1 *ss1, 
-				char *name, char *user,
+				const char *name, const char *user,
 				uint32 num_opens, uint32 open_time, uint32 idle_time,
 				uint32 user_flags)
 {
@@ -1753,7 +1753,7 @@
 reads or writes a structure.
 ********************************************************************/
 
-static BOOL srv_io_sess_info1(char *desc, SESS_INFO_1 *ss1, prs_struct *ps, int depth)
+static BOOL srv_io_sess_info1(const char *desc, SESS_INFO_1 *ss1, prs_struct *ps, int depth)
 {
 	if (ss1 == NULL)
 		return False;
@@ -1785,7 +1785,7 @@
  Reads or writes a structure.
 ********************************************************************/
 
-static BOOL srv_io_srv_sess_info_1(char *desc, SRV_SESS_INFO_1 *ss1, prs_struct *ps, int depth)
+static BOOL srv_io_srv_sess_info_1(const char *desc, SRV_SESS_INFO_1 *ss1, prs_struct *ps, int depth)
 {
 	if (ss1 == NULL)
 		return False;
@@ -1835,7 +1835,7 @@
  Reads or writes a structure.
 ********************************************************************/
 
-static BOOL srv_io_srv_sess_ctr(char *desc, SRV_SESS_INFO_CTR **pp_ctr, prs_struct *ps, int depth)
+static BOOL srv_io_srv_sess_ctr(const char *desc, SRV_SESS_INFO_CTR **pp_ctr, prs_struct *ps, int depth)
 {
 	SRV_SESS_INFO_CTR *ctr = *pp_ctr;
 
@@ -1884,8 +1884,8 @@
 ********************************************************************/
 
 void init_srv_q_net_sess_enum(SRV_Q_NET_SESS_ENUM *q_n, 
-			      char *srv_name, char *qual_name,
-			      char *user_name, uint32 sess_level, 
+			      const char *srv_name, const char *qual_name,
+			      const char *user_name, uint32 sess_level, 
 			      SRV_SESS_INFO_CTR *ctr, uint32 preferred_len,
 			      ENUM_HND *hnd)
 {
@@ -1907,7 +1907,7 @@
  Reads or writes a structure.
 ********************************************************************/
 
-BOOL srv_io_q_net_sess_enum(char *desc, SRV_Q_NET_SESS_ENUM *q_n, prs_struct *ps, int depth)
+BOOL srv_io_q_net_sess_enum(const char *desc, SRV_Q_NET_SESS_ENUM *q_n, prs_struct *ps, int depth)
 {
 	if (q_n == NULL)
 		return False;
@@ -1962,7 +1962,7 @@
  Reads or writes a structure.
 ********************************************************************/
 
-BOOL srv_io_r_net_sess_enum(char *desc, SRV_R_NET_SESS_ENUM *r_n, prs_struct *ps, int depth)
+BOOL srv_io_r_net_sess_enum(const char *desc, SRV_R_NET_SESS_ENUM *r_n, prs_struct *ps, int depth)
 {
 	if (r_n == NULL)
 		return False;
@@ -2006,7 +2006,7 @@
  Reads or writes a structure.
 ********************************************************************/
 
-static BOOL srv_io_conn_info0(char *desc, CONN_INFO_0 *ss0, prs_struct *ps, int depth)
+static BOOL srv_io_conn_info0(const char *desc, CONN_INFO_0 *ss0, prs_struct *ps, int depth)
 {
 	if (ss0 == NULL)
 		return False;
@@ -2027,7 +2027,7 @@
  Reads or writes a structure.
 ********************************************************************/
 
-static BOOL srv_io_srv_conn_info_0(char *desc, SRV_CONN_INFO_0 *ss0, prs_struct *ps, int depth)
+static BOOL srv_io_srv_conn_info_0(const char *desc, SRV_CONN_INFO_0 *ss0, prs_struct *ps, int depth)
 {
 	if (ss0 == NULL)
 		return False;
@@ -2070,7 +2070,7 @@
  Inits a CONN_INFO_1_STR structure
 ********************************************************************/
 
-void init_srv_conn_info1_str(CONN_INFO_1_STR *ss1, char *usr_name, char *net_name)
+void init_srv_conn_info1_str(CONN_INFO_1_STR *ss1, const char *usr_name, const char *net_name)
 {
 	DEBUG(5,("init_srv_conn_info1_str\n"));
 
@@ -2082,7 +2082,7 @@
  Reads or writes a structure.
 ********************************************************************/
 
-static BOOL srv_io_conn_info1_str(char *desc, CONN_INFO_1_STR *ss1, prs_struct *ps, int depth)
+static BOOL srv_io_conn_info1_str(const char *desc, CONN_INFO_1_STR *ss1, prs_struct *ps, int depth)
 {
 	if (ss1 == NULL)
 		return False;
@@ -2108,7 +2108,7 @@
 void init_srv_conn_info1(CONN_INFO_1 *ss1, 
 				uint32 id, uint32 type,
 				uint32 num_opens, uint32 num_users, uint32 open_time,
-				char *usr_name, char *net_name)
+				const char *usr_name, const char *net_name)
 {
 	DEBUG(5,("init_srv_conn_info1: %s %s\n", usr_name, net_name));
 
@@ -2126,7 +2126,7 @@
  Reads or writes a structure.
 ********************************************************************/
 
-static BOOL srv_io_conn_info1(char *desc, CONN_INFO_1 *ss1, prs_struct *ps, int depth)
+static BOOL srv_io_conn_info1(const char *desc, CONN_INFO_1 *ss1, prs_struct *ps, int depth)
 {
 	if (ss1 == NULL)
 		return False;
@@ -2160,7 +2160,7 @@
  Reads or writes a structure.
 ********************************************************************/
 
-static BOOL srv_io_srv_conn_info_1(char *desc, SRV_CONN_INFO_1 *ss1, prs_struct *ps, int depth)
+static BOOL srv_io_srv_conn_info_1(const char *desc, SRV_CONN_INFO_1 *ss1, prs_struct *ps, int depth)
 {
 	if (ss1 == NULL)
 		return False;
@@ -2208,7 +2208,7 @@
  Reads or writes a structure.
 ********************************************************************/
 
-static BOOL srv_io_srv_conn_ctr(char *desc, SRV_CONN_INFO_CTR **pp_ctr, prs_struct *ps, int depth)
+static BOOL srv_io_srv_conn_ctr(const char *desc, SRV_CONN_INFO_CTR **pp_ctr, prs_struct *ps, int depth)
 {
 	SRV_CONN_INFO_CTR *ctr = *pp_ctr;
 
@@ -2257,7 +2257,7 @@
 ********************************************************************/
 
 void init_srv_q_net_conn_enum(SRV_Q_NET_CONN_ENUM *q_n, 
-				char *srv_name, char *qual_name,
+				const char *srv_name, const char *qual_name,
 				uint32 conn_level, SRV_CONN_INFO_CTR *ctr,
 				uint32 preferred_len,
 				ENUM_HND *hnd)
@@ -2279,7 +2279,7 @@
  Reads or writes a structure.
 ********************************************************************/
 
-BOOL srv_io_q_net_conn_enum(char *desc, SRV_Q_NET_CONN_ENUM *q_n, prs_struct *ps, int depth)
+BOOL srv_io_q_net_conn_enum(const char *desc, SRV_Q_NET_CONN_ENUM *q_n, prs_struct *ps, int depth)
 {
 	if (q_n == NULL)
 		return False;
@@ -2327,7 +2327,7 @@
  Reads or writes a structure.
 ********************************************************************/
 
-BOOL srv_io_r_net_conn_enum(char *desc,  SRV_R_NET_CONN_ENUM *r_n, prs_struct *ps, int depth)
+BOOL srv_io_r_net_conn_enum(const char *desc,  SRV_R_NET_CONN_ENUM *r_n, prs_struct *ps, int depth)
 {
 	if (r_n == NULL)
 		return False;
@@ -2360,7 +2360,7 @@
  Inits a FILE_INFO_3_STR structure
 ********************************************************************/
 
-void init_srv_file_info3_str(FILE_INFO_3_STR *fi3, char *user_name, char *path_name)
+void init_srv_file_info3_str(FILE_INFO_3_STR *fi3, const char *user_name, const char *path_name)
 {
 	DEBUG(5,("init_srv_file_info3_str\n"));
 
@@ -2372,7 +2372,7 @@
  Reads or writes a structure.
 ********************************************************************/
 
-static BOOL srv_io_file_info3_str(char *desc, FILE_INFO_3_STR *sh1, prs_struct *ps, int depth)
+static BOOL srv_io_file_info3_str(const char *desc, FILE_INFO_3_STR *sh1, prs_struct *ps, int depth)
 {
 	if (sh1 == NULL)
 		return False;
@@ -2397,7 +2397,7 @@
 
 void init_srv_file_info3(FILE_INFO_3 *fl3,
 			 uint32 id, uint32 perms, uint32 num_locks,
-			 char *path_name, char *user_name)
+			 const char *path_name, const char *user_name)
 {
 	DEBUG(5,("init_srv_file_info3: %s %s\n", path_name, user_name));
 
@@ -2413,7 +2413,7 @@
  Reads or writes a structure.
 ********************************************************************/
 
-static BOOL srv_io_file_info3(char *desc, FILE_INFO_3 *fl3, prs_struct *ps, int depth)
+static BOOL srv_io_file_info3(const char *desc, FILE_INFO_3 *fl3, prs_struct *ps, int depth)
 {
 	if (fl3 == NULL)
 		return False;
@@ -2442,7 +2442,7 @@
  Reads or writes a structure.
 ********************************************************************/
 
-static BOOL srv_io_srv_file_ctr(char *desc, SRV_FILE_INFO_CTR *ctr, prs_struct *ps, int depth)
+static BOOL srv_io_srv_file_ctr(const char *desc, SRV_FILE_INFO_CTR *ctr, prs_struct *ps, int depth)
 {
 	if (ctr == NULL)
 		return False;
@@ -2536,7 +2536,7 @@
  Reads or writes a structure.
 ********************************************************************/
 
-BOOL srv_io_q_net_file_enum(char *desc, SRV_Q_NET_FILE_ENUM *q_n, prs_struct *ps, int depth)
+BOOL srv_io_q_net_file_enum(const char *desc, SRV_Q_NET_FILE_ENUM *q_n, prs_struct *ps, int depth)
 {
 	if (q_n == NULL)
 		return False;
@@ -2591,7 +2591,7 @@
  Reads or writes a structure.
 ********************************************************************/
 
-BOOL srv_io_r_net_file_enum(char *desc, SRV_R_NET_FILE_ENUM *r_n, prs_struct *ps, int depth)
+BOOL srv_io_r_net_file_enum(const char *desc, SRV_R_NET_FILE_ENUM *r_n, prs_struct *ps, int depth)
 {
 	if (r_n == NULL)
 		return False;
@@ -2623,7 +2623,7 @@
 /*******************************************************************
  Initialize a net file close request
 ********************************************************************/
-void init_srv_q_net_file_close(SRV_Q_NET_FILE_CLOSE *q_n, char *server,
+void init_srv_q_net_file_close(SRV_Q_NET_FILE_CLOSE *q_n, const char *server,
 			       uint32 file_id)
 {
 	q_n->ptr_srv_name = 1;
@@ -2634,7 +2634,7 @@
 /*******************************************************************
  Reads or writes a structure.
 ********************************************************************/
-BOOL srv_io_q_net_file_close(char *desc, SRV_Q_NET_FILE_CLOSE *q_n,
+BOOL srv_io_q_net_file_close(const char *desc, SRV_Q_NET_FILE_CLOSE *q_n,
 			     prs_struct *ps, int depth)
 {
 	if (q_n == NULL)
@@ -2664,7 +2664,7 @@
  Reads or writes a structure.
 ********************************************************************/
 
-BOOL srv_io_r_net_file_close(char *desc, SRV_R_NET_FILE_CLOSE *q_n, 
+BOOL srv_io_r_net_file_close(const char *desc, SRV_R_NET_FILE_CLOSE *q_n, 
 			     prs_struct *ps, int depth)
 {
 	if (q_n == NULL)
@@ -2698,7 +2698,7 @@
  Reads or writes a SRV_INFO_101 structure.
  ********************************************************************/
 
-static BOOL srv_io_info_100(char *desc, SRV_INFO_100 *sv100, prs_struct *ps, int depth)
+static BOOL srv_io_info_100(const char *desc, SRV_INFO_100 *sv100, prs_struct *ps, int depth)
 {
 	if (sv100 == NULL)
 		return False;
@@ -2743,7 +2743,7 @@
  Reads or writes a SRV_INFO_101 structure.
  ********************************************************************/
 
-static BOOL srv_io_info_101(char *desc, SRV_INFO_101 *sv101, prs_struct *ps, int depth)
+static BOOL srv_io_info_101(const char *desc, SRV_INFO_101 *sv101, prs_struct *ps, int depth)
 {
 	if (sv101 == NULL)
 		return False;
@@ -2813,7 +2813,7 @@
  Reads or writes a SRV_INFO_102 structure.
  ********************************************************************/
 
-static BOOL srv_io_info_102(char *desc, SRV_INFO_102 *sv102, prs_struct *ps, int depth)
+static BOOL srv_io_info_102(const char *desc, SRV_INFO_102 *sv102, prs_struct *ps, int depth)
 {
 	if (sv102 == NULL)
 		return False;
@@ -2872,7 +2872,7 @@
  Reads or writes a SRV_INFO_102 structure.
  ********************************************************************/
 
-static BOOL srv_io_info_ctr(char *desc, SRV_INFO_CTR *ctr, prs_struct *ps, int depth)
+static BOOL srv_io_info_ctr(const char *desc, SRV_INFO_CTR *ctr, prs_struct *ps, int depth)
 {
 	if (ctr == NULL)
 		return False;
@@ -2919,7 +2919,7 @@
  ********************************************************************/
 
 void init_srv_q_net_srv_get_info(SRV_Q_NET_SRV_GET_INFO *srv,
-				char *server_name, uint32 switch_value)
+				const char *server_name, uint32 switch_value)
 {
 	DEBUG(5,("init_srv_q_net_srv_get_info\n"));
 
@@ -2932,7 +2932,7 @@
  Reads or writes a structure.
 ********************************************************************/
 
-BOOL srv_io_q_net_srv_get_info(char *desc, SRV_Q_NET_SRV_GET_INFO *q_n, prs_struct *ps, int depth)
+BOOL srv_io_q_net_srv_get_info(const char *desc, SRV_Q_NET_SRV_GET_INFO *q_n, prs_struct *ps, int depth)
 {
 	if (q_n == NULL)
 		return False;
@@ -2996,7 +2996,7 @@
  Reads or writes a structure.
 ********************************************************************/
 
-BOOL srv_io_q_net_srv_set_info(char *desc, SRV_Q_NET_SRV_SET_INFO *q_n, 
+BOOL srv_io_q_net_srv_set_info(const char *desc, SRV_Q_NET_SRV_SET_INFO *q_n, 
 			       prs_struct *ps, int depth)
 {
 	prs_debug(ps, depth, desc, "srv_io_q_net_srv_set_info");
@@ -3034,7 +3034,7 @@
  Reads or writes a structure.
  ********************************************************************/
 
-BOOL srv_io_r_net_srv_get_info(char *desc, SRV_R_NET_SRV_GET_INFO *r_n, prs_struct *ps, int depth)
+BOOL srv_io_r_net_srv_get_info(const char *desc, SRV_R_NET_SRV_GET_INFO *r_n, prs_struct *ps, int depth)
 {
 	if (r_n == NULL)
 		return False;
@@ -3058,7 +3058,7 @@
  Reads or writes a structure.
  ********************************************************************/
 
-BOOL srv_io_r_net_srv_set_info(char *desc, SRV_R_NET_SRV_SET_INFO *r_n, 
+BOOL srv_io_r_net_srv_set_info(const char *desc, SRV_R_NET_SRV_SET_INFO *r_n, 
 			       prs_struct *ps, int depth)
 {
 	prs_debug(ps, depth, desc, "srv_io_r_net_srv_set_info");
@@ -3080,7 +3080,7 @@
  Reads or writes a structure.
  ********************************************************************/
 
-BOOL srv_io_q_net_remote_tod(char *desc, SRV_Q_NET_REMOTE_TOD *q_n, prs_struct *ps, int depth)
+BOOL srv_io_q_net_remote_tod(const char *desc, SRV_Q_NET_REMOTE_TOD *q_n, prs_struct *ps, int depth)
 {
 	if (q_n == NULL)
 		return False;
@@ -3103,7 +3103,7 @@
  Reads or writes a TIME_OF_DAY_INFO structure.
  ********************************************************************/
 
-static BOOL srv_io_time_of_day_info(char *desc, TIME_OF_DAY_INFO *tod, prs_struct *ps, int depth)
+static BOOL srv_io_time_of_day_info(const char *desc, TIME_OF_DAY_INFO *tod, prs_struct *ps, int depth)
 {
 	if (tod == NULL)
 		return False;
@@ -3172,7 +3172,7 @@
  Reads or writes a structure.
  ********************************************************************/
 
-BOOL srv_io_r_net_remote_tod(char *desc, SRV_R_NET_REMOTE_TOD *r_n, prs_struct *ps, int depth)
+BOOL srv_io_r_net_remote_tod(const char *desc, SRV_R_NET_REMOTE_TOD *r_n, prs_struct *ps, int depth)
 {
 	if (r_n == NULL)
 		return False;
@@ -3224,7 +3224,7 @@
  Reads or writes a structure.
  ********************************************************************/
 
-BOOL srv_io_q_net_disk_enum(char *desc, SRV_Q_NET_DISK_ENUM *q_n, prs_struct *ps, int depth)
+BOOL srv_io_q_net_disk_enum(const char *desc, SRV_Q_NET_DISK_ENUM *q_n, prs_struct *ps, int depth)
 {
 	if (q_n == NULL)
 		return False;
@@ -3268,7 +3268,7 @@
  Reads or writes a structure.
  ********************************************************************/
 
-BOOL srv_io_r_net_disk_enum(char *desc, SRV_R_NET_DISK_ENUM *r_n, prs_struct *ps, int depth)
+BOOL srv_io_r_net_disk_enum(const char *desc, SRV_R_NET_DISK_ENUM *r_n, prs_struct *ps, int depth)
 {
 
 	int i;
@@ -3357,7 +3357,7 @@
  Reads or writes a structure.
  ********************************************************************/
 
-BOOL srv_io_q_net_name_validate(char *desc, SRV_Q_NET_NAME_VALIDATE *q_n, prs_struct *ps, int depth)
+BOOL srv_io_q_net_name_validate(const char *desc, SRV_Q_NET_NAME_VALIDATE *q_n, prs_struct *ps, int depth)
 {
 	if (q_n == NULL)
 		return False;
@@ -3396,7 +3396,7 @@
  Reads or writes a structure.
  ********************************************************************/
 
-BOOL srv_io_r_net_name_validate(char *desc, SRV_R_NET_NAME_VALIDATE *r_n, prs_struct *ps, int depth)
+BOOL srv_io_r_net_name_validate(const char *desc, SRV_R_NET_NAME_VALIDATE *r_n, prs_struct *ps, int depth)
 {
 	if (r_n == NULL)
 		return False;
@@ -3417,7 +3417,7 @@
  Reads or writes a structure.
 ********************************************************************/
 
-BOOL srv_io_q_net_file_query_secdesc(char *desc, SRV_Q_NET_FILE_QUERY_SECDESC *q_n, prs_struct *ps, int depth)
+BOOL srv_io_q_net_file_query_secdesc(const char *desc, SRV_Q_NET_FILE_QUERY_SECDESC *q_n, prs_struct *ps, int depth)
 {
 	if (q_n == NULL)
 		return False;
@@ -3465,7 +3465,7 @@
  Reads or writes a structure.
 ********************************************************************/
 
-BOOL srv_io_r_net_file_query_secdesc(char *desc, SRV_R_NET_FILE_QUERY_SECDESC *r_n, prs_struct *ps, int depth)
+BOOL srv_io_r_net_file_query_secdesc(const char *desc, SRV_R_NET_FILE_QUERY_SECDESC *r_n, prs_struct *ps, int depth)
 {
 	if (r_n == NULL)
 		return False;
@@ -3504,7 +3504,7 @@
  Reads or writes a structure.
 ********************************************************************/
 
-BOOL srv_io_q_net_file_set_secdesc(char *desc, SRV_Q_NET_FILE_SET_SECDESC *q_n, prs_struct *ps, int depth)
+BOOL srv_io_q_net_file_set_secdesc(const char *desc, SRV_Q_NET_FILE_SET_SECDESC *q_n, prs_struct *ps, int depth)
 {
 	if (q_n == NULL)
 		return False;
@@ -3561,7 +3561,7 @@
  Reads or writes a structure.
 ********************************************************************/
 
-BOOL srv_io_r_net_file_set_secdesc(char *desc, SRV_R_NET_FILE_SET_SECDESC *r_n, prs_struct *ps, int depth)
+BOOL srv_io_r_net_file_set_secdesc(const char *desc, SRV_R_NET_FILE_SET_SECDESC *r_n, prs_struct *ps, int depth)
 {
 	if (r_n == NULL)
 		return False;
@@ -3582,7 +3582,7 @@
  Inits a structure
 ********************************************************************/
 
-void init_srv_q_net_remote_tod(SRV_Q_NET_REMOTE_TOD *q_u, char *server)
+void init_srv_q_net_remote_tod(SRV_Q_NET_REMOTE_TOD *q_u, const char *server)
 {
 	q_u->ptr_srv_name = 1;
 	init_unistr2(&q_u->uni_srv_name, server, strlen(server) + 1);
diff -uNr samba-3.0alpha21.orig/source/rpc_parse/parse_wks.c samba-3.0alpha21/source/rpc_parse/parse_wks.c
--- samba-3.0alpha21.orig/source/rpc_parse/parse_wks.c	2003-02-16 19:06:33.000000000 -0600
+++ samba-3.0alpha21/source/rpc_parse/parse_wks.c	2003-02-16 19:05:46.000000000 -0600
@@ -42,7 +42,7 @@
  Reads or writes a WKS_Q_QUERY_INFO structure.
 ********************************************************************/
 
-BOOL wks_io_q_query_info(char *desc, WKS_Q_QUERY_INFO *q_u, prs_struct *ps, int depth)
+BOOL wks_io_q_query_info(const char *desc, WKS_Q_QUERY_INFO *q_u, prs_struct *ps, int depth)
 {
 	if (q_u == NULL)
 		return False;
@@ -90,7 +90,7 @@
  Reads or writes a WKS_INFO_100 structure.
 ********************************************************************/
 
-static BOOL wks_io_wks_info_100(char *desc, WKS_INFO_100 *inf, prs_struct *ps, int depth)
+static BOOL wks_io_wks_info_100(const char *desc, WKS_INFO_100 *inf, prs_struct *ps, int depth)
 {
 	if (inf == NULL)
 		return False;
@@ -150,7 +150,7 @@
  Reads or writes a structure.
 ********************************************************************/
 
-BOOL wks_io_r_query_info(char *desc, WKS_R_QUERY_INFO *r_u, prs_struct *ps, int depth)
+BOOL wks_io_r_query_info(const char *desc, WKS_R_QUERY_INFO *r_u, prs_struct *ps, int depth)
 {
 	if (r_u == NULL)
 		return False;
diff -uNr samba-3.0alpha21.orig/source/rpc_server/srv_dfs.c samba-3.0alpha21/source/rpc_server/srv_dfs.c
--- samba-3.0alpha21.orig/source/rpc_server/srv_dfs.c	2003-02-16 19:06:33.000000000 -0600
+++ samba-3.0alpha21/source/rpc_server/srv_dfs.c	2003-02-16 19:05:46.000000000 -0600
@@ -3,8 +3,9 @@
  *  RPC Pipe client / server routines for Dfs
  *  Copyright (C) Andrew Tridgell              1992-1997,
  *  Copyright (C) Luke Kenneth Casson Leighton 1996-1997,
- *  Copyright (C) Shirish Kalele               2000.
- *  Copyright (C) Jeremy Allison				2001.
+ *  Copyright (C) Shirish Kalele                    2000,
+ *  Copyright (C) Jeremy Allison                    2001,
+ *  Copyright (C) Anthony Liguori                   2003.
  *  
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License as published by
@@ -157,21 +158,20 @@
 \pipe\netdfs commands
 ********************************************************************/
 
-struct api_struct api_netdfs_cmds[] =
-{
-	{"DFS_EXIST",        DFS_EXIST,               api_dfs_exist    },
-	{"DFS_ADD",          DFS_ADD,                 api_dfs_add      },
-	{"DFS_REMOVE",       DFS_REMOVE,              api_dfs_remove   },
-	{"DFS_GET_INFO",     DFS_GET_INFO,            api_dfs_get_info },
-	{"DFS_ENUM",         DFS_ENUM,                api_dfs_enum     },
-	{NULL,               0,                       NULL             }
-};
-
-/*******************************************************************
-receives a netdfs pipe and responds.
-********************************************************************/
-
-BOOL api_netdfs_rpc(pipes_struct *p)
-{
-	return api_rpcTNP(p, "api_netdfs_rpc", api_netdfs_cmds);
+#ifdef RPC_DFS_DYNAMIC
+int rpc_pipe_init(void)
+#else
+int rpc_dfs_init(void)
+#endif
+{
+  struct api_struct api_netdfs_cmds[] =
+    {
+      {"DFS_EXIST",        DFS_EXIST,               api_dfs_exist    },
+      {"DFS_ADD",          DFS_ADD,                 api_dfs_add      },
+      {"DFS_REMOVE",       DFS_REMOVE,              api_dfs_remove   },
+      {"DFS_GET_INFO",     DFS_GET_INFO,            api_dfs_get_info },
+      {"DFS_ENUM",         DFS_ENUM,                api_dfs_enum     }
+    };
+  return rpc_pipe_register_commands("netdfs", "netdfs", api_netdfs_cmds,
+				    sizeof(api_netdfs_cmds) / sizeof(struct api_struct));
 }
diff -uNr samba-3.0alpha21.orig/source/rpc_server/srv_lsa.c samba-3.0alpha21/source/rpc_server/srv_lsa.c
--- samba-3.0alpha21.orig/source/rpc_server/srv_lsa.c	2003-02-16 19:06:33.000000000 -0600
+++ samba-3.0alpha21/source/rpc_server/srv_lsa.c	2003-02-16 19:05:46.000000000 -0600
@@ -5,7 +5,8 @@
  *  Copyright (C) Luke Kenneth Casson Leighton 1996-1997,
  *  Copyright (C) Paul Ashton                       1997,
  *  Copyright (C) Jeremy Allison                    2001,
- *  Copyright (C) Jim McDonough                     2002.
+ *  Copyright (C) Jim McDonough                     2002,
+ *  Copyright (C) Anthony Liguori                   2003.
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License as published by
@@ -644,8 +645,13 @@
 /***************************************************************************
  \PIPE\ntlsa commands
  ***************************************************************************/
-
-static struct api_struct api_lsa_cmds[] =
+#ifdef RPC_LSA_DYNAMIC
+int rpc_pipe_init(void)
+#else
+int rpc_lsa_init(void)
+#endif
+{
+static const struct api_struct api_lsa_cmds[] =
 {
 	{ "LSA_OPENPOLICY2"     , LSA_OPENPOLICY2     , api_lsa_open_policy2     },
 	{ "LSA_OPENPOLICY"      , LSA_OPENPOLICY      , api_lsa_open_policy      },
@@ -666,14 +672,9 @@
 	{ "LSA_ADDPRIVS"        , LSA_ADDPRIVS        , api_lsa_addprivs         },
 	{ "LSA_REMOVEPRIVS"     , LSA_REMOVEPRIVS     , api_lsa_removeprivs      },
 	{ "LSA_QUERYSECOBJ"     , LSA_QUERYSECOBJ     , api_lsa_query_secobj     },
-	{ "LSA_QUERYINFO2"      , LSA_QUERYINFO2      , api_lsa_query_info2      },
-	{ NULL                  , 0                   , NULL                     }
+	{ "LSA_QUERYINFO2"      , LSA_QUERYINFO2      , api_lsa_query_info2      }
 };
 
-/***************************************************************************
- api_ntLsarpcTNP
- ***************************************************************************/
-BOOL api_ntlsa_rpc(pipes_struct *p)
-{
-	return api_rpcTNP(p, "api_ntlsa_rpc", api_lsa_cmds);
+  return rpc_pipe_register_commands("lsarpc", "lsass", api_lsa_cmds, 
+				    sizeof(api_lsa_cmds) / sizeof(struct api_struct));
 }
diff -uNr samba-3.0alpha21.orig/source/rpc_server/srv_lsa_hnd.c samba-3.0alpha21/source/rpc_server/srv_lsa_hnd.c
--- samba-3.0alpha21.orig/source/rpc_server/srv_lsa_hnd.c	2003-02-16 19:06:33.000000000 -0600
+++ samba-3.0alpha21/source/rpc_server/srv_lsa_hnd.c	2003-02-16 19:05:46.000000000 -0600
@@ -137,14 +137,6 @@
 	DLIST_ADD(p->pipe_handles->Policy, pol);
 	p->pipe_handles->count++;
 
-	/*
-	 * Ensure we don't idle this connection if a handle is open.
-	 * Increment the number of files open on the first handle create.
-	 */
-
-	if (p->pipe_handles->count == 1)
-		p->conn->num_files_open++;
-
 	*hnd = pol->pol_hnd;
 	
 	DEBUG(4,("Opened policy hnd[%d] ", (int)p->pipe_handles->count));
@@ -212,15 +204,6 @@
 
 	p->pipe_handles->count--;
 
-	/*
-	 * Ensure we can idle this connection if this is the last handle.
-	 * Decrement the number of files open on the last handle delete.
-	 */
-
-	if (p->pipe_handles->count == 0)
-		p->conn->num_files_open--;
-
-
 	DLIST_REMOVE(p->pipe_handles->Policy, pol);
 
 	ZERO_STRUCTP(pol);
diff -uNr samba-3.0alpha21.orig/source/rpc_server/srv_netlog.c samba-3.0alpha21/source/rpc_server/srv_netlog.c
--- samba-3.0alpha21.orig/source/rpc_server/srv_netlog.c	2003-02-16 19:06:33.000000000 -0600
+++ samba-3.0alpha21/source/rpc_server/srv_netlog.c	2003-02-16 19:05:46.000000000 -0600
@@ -3,8 +3,9 @@
  *  RPC Pipe client / server routines
  *  Copyright (C) Andrew Tridgell              1992-1997,
  *  Copyright (C) Luke Kenneth Casson Leighton 1996-1997,
- *  Copyright (C) Paul Ashton                       1997.
- *  Copyright (C) Jeremy Allison               1998-2001.
+ *  Copyright (C) Paul Ashton                       1997,
+ *  Copyright (C) Jeremy Allison               1998-2001,
+ *  Copyright (C) Anthony Liguori                   2003.
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License as published by
@@ -319,25 +320,26 @@
 /*******************************************************************
  array of \PIPE\NETLOGON operations
  ********************************************************************/
-static struct api_struct api_net_cmds [] =
-{
-	{ "NET_REQCHAL"       , NET_REQCHAL       , api_net_req_chal       }, 
-	{ "NET_AUTH"          , NET_AUTH          , api_net_auth           }, 
-	{ "NET_AUTH2"         , NET_AUTH2         , api_net_auth_2         }, 
-	{ "NET_SRVPWSET"      , NET_SRVPWSET      , api_net_srv_pwset      }, 
-	{ "NET_SAMLOGON"      , NET_SAMLOGON      , api_net_sam_logon      }, 
-	{ "NET_SAMLOGOFF"     , NET_SAMLOGOFF     , api_net_sam_logoff     }, 
-	{ "NET_LOGON_CTRL2"   , NET_LOGON_CTRL2   , api_net_logon_ctrl2    }, 
-	{ "NET_TRUST_DOM_LIST", NET_TRUST_DOM_LIST, api_net_trust_dom_list },
-	{ "NET_LOGON_CTRL"    , NET_LOGON_CTRL    , api_net_logon_ctrl     },
-	{  NULL               , 0                 , NULL                   }
-};
 
-/*******************************************************************
- receives a netlogon pipe and responds.
- ********************************************************************/
+#ifdef RPC_NETLOG_DYNAMIC
+int rpc_pipe_init(void)
+#else
+int rpc_net_init(void)
+#endif
+{
+  static struct api_struct api_net_cmds [] =
+    {
+      { "NET_REQCHAL"       , NET_REQCHAL       , api_net_req_chal       }, 
+      { "NET_AUTH"          , NET_AUTH          , api_net_auth           }, 
+      { "NET_AUTH2"         , NET_AUTH2         , api_net_auth_2         }, 
+      { "NET_SRVPWSET"      , NET_SRVPWSET      , api_net_srv_pwset      }, 
+      { "NET_SAMLOGON"      , NET_SAMLOGON      , api_net_sam_logon      }, 
+      { "NET_SAMLOGOFF"     , NET_SAMLOGOFF     , api_net_sam_logoff     }, 
+      { "NET_LOGON_CTRL2"   , NET_LOGON_CTRL2   , api_net_logon_ctrl2    }, 
+      { "NET_TRUST_DOM_LIST", NET_TRUST_DOM_LIST, api_net_trust_dom_list },
+      { "NET_LOGON_CTRL"    , NET_LOGON_CTRL    , api_net_logon_ctrl     }
+    };
 
-BOOL api_netlog_rpc(pipes_struct *p)
-{
-	return api_rpcTNP(p, "api_netlog_rpc", api_net_cmds);
+  return rpc_pipe_register_commands("NETLOGON", "lsass", api_net_cmds,
+				    sizeof(api_net_cmds) / sizeof(struct api_struct));
 }
diff -uNr samba-3.0alpha21.orig/source/rpc_server/srv_netlog_nt.c samba-3.0alpha21/source/rpc_server/srv_netlog_nt.c
--- samba-3.0alpha21.orig/source/rpc_server/srv_netlog_nt.c	2003-02-16 19:06:33.000000000 -0600
+++ samba-3.0alpha21/source/rpc_server/srv_netlog_nt.c	2003-02-16 19:05:46.000000000 -0600
@@ -105,7 +105,7 @@
         uint32 pdc_connection_status = 0x0;
         uint32 logon_attempts = 0x0;
         uint32 tc_status = ERROR_NO_LOGON_SERVERS;
-        char *trusted_domain = "test_domain";
+        const char *trusted_domain = "test_domain";
 
         DEBUG(0, ("*** net long ctrl2 %d, %d, %d\n",
                   q_u->function_code, q_u->query_level, q_u->switch_value));
@@ -132,7 +132,7 @@
 
 NTSTATUS _net_trust_dom_list(pipes_struct *p, NET_Q_TRUST_DOM_LIST *q_u, NET_R_TRUST_DOM_LIST *r_u)
 {
-	char *trusted_domain = "test_domain";
+	const char *trusted_domain = "test_domain";
 	uint32 num_trust_domains = 1;
 
 	DEBUG(6,("_net_trust_dom_list: %d\n", __LINE__));
@@ -565,7 +565,7 @@
 	DEBUG(3,("User:[%s@%s] Requested Domain:[%s]\n", nt_username, 
                  nt_workstation, nt_domain));
    	
-	pstrcpy(current_user_info.smb_name, nt_username);
+	fstrcpy(current_user_info.smb_name, nt_username);
 	sub_set_smb_name(nt_username);
      
 	/*
@@ -666,6 +666,8 @@
 		pstring my_name;
 		fstring user_sid_string;
 		fstring group_sid_string;
+		uchar user_sess_key[16];
+		uchar netlogon_sess_key[16];
 		
 		sampw = server_info->sam_account;
 
@@ -688,16 +690,20 @@
 		
 		pstrcpy(my_name, global_myname());
 
-		/*
-		 * This is the point at which we get the group
-		 * database - we should be getting the gid_t list
-		 * from /etc/group and then turning the uids into
-		 * rids and then into machine sids for this user.
-		 * JRA.
-		 */
+		if (!NT_STATUS_IS_OK(status 
+				     = nt_token_to_group_list(p->mem_ctx, 
+							      &domain_sid, 
+							      server_info->ptok, 
+							      &num_gids, 
+							      &gids))) {
+			return status;
+		}
 
-  		gids = NULL;
-		get_domain_user_groups(p->mem_ctx, &num_gids, &gids, server_info->sam_account);
+		ZERO_STRUCT(netlogon_sess_key);
+		memcpy(netlogon_sess_key, p->dc.sess_key, 8);
+		memcpy(user_sess_key, server_info->session_key, sizeof(user_sess_key));
+		SamOEMhash(user_sess_key, netlogon_sess_key, 16);
+		ZERO_STRUCT(netlogon_sess_key);
 
 		init_net_user_info3(p->mem_ctx, usr_info, 
 				    user_rid,
@@ -721,13 +727,14 @@
 				    num_gids,    /* uint32 num_groups */
 				    gids    , /* DOM_GID *gids */
 				    0x20    , /* uint32 user_flgs (?) */
-				    NULL, /* uchar sess_key[16] */
+				    user_sess_key,
 				    my_name     , /* char *logon_srv */
 				    pdb_get_domain(sampw),
 				    &domain_sid,     /* DOM_SID *dom_sid */  
 				    /* Should be users domain sid, not servers - for trusted domains */
 				  
 				    NULL); /* char *other_sids */
+		ZERO_STRUCT(user_sess_key);
 	}
 	free_server_info(&server_info);
 	return status;
diff -uNr samba-3.0alpha21.orig/source/rpc_server/srv_pipe.c samba-3.0alpha21/source/rpc_server/srv_pipe.c
--- samba-3.0alpha21.orig/source/rpc_server/srv_pipe.c	2003-02-16 19:06:33.000000000 -0600
+++ samba-3.0alpha21/source/rpc_server/srv_pipe.c	2003-02-16 19:05:46.000000000 -0600
@@ -3,8 +3,9 @@
  *  RPC Pipe client / server routines
  *  Copyright (C) Andrew Tridgell              1992-1998
  *  Copyright (C) Luke Kenneth Casson Leighton 1996-1998,
- *  Copyright (C) Paul Ashton                  1997-1998.
- *  Copyright (C) Jeremy Allison                    1999.
+ *  Copyright (C) Paul Ashton                  1997-1998,
+ *  Copyright (C) Jeremy Allison                    1999,
+ *  Copyright (C) Anthony Liguori                   2003.
  *  
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License as published by
@@ -83,8 +84,6 @@
 	uint32 data_space_available;
 	uint32 data_len_left;
 	prs_struct outgoing_pdu;
-	char *data;
-	char *data_from;
 	uint32 data_pos;
 
 	/*
@@ -186,26 +185,26 @@
 	data_pos = prs_offset(&outgoing_pdu);
 
 	/* Copy the data into the PDU. */
-	data_from = prs_data_p(&p->out_data.rdata) + p->out_data.data_sent_length;
 
-	if(!prs_append_data(&outgoing_pdu, data_from, data_len)) {
+	if(!prs_append_some_prs_data(&outgoing_pdu, &p->out_data.rdata, p->out_data.data_sent_length, data_len)) {
 		DEBUG(0,("create_next_pdu: failed to copy %u bytes of data.\n", (unsigned int)data_len));
 		prs_mem_free(&outgoing_pdu);
 		return False;
 	}
 
-	/*
-	 * Set data to point to where we copied the data into.
-	 */
-
-	data = prs_data_p(&outgoing_pdu) + data_pos;
-
 	if (p->hdr.auth_len > 0) {
 		uint32 crc32 = 0;
+		char *data;
 
 		DEBUG(5,("create_next_pdu: sign: %s seal: %s data %d auth %d\n",
 			 BOOLSTR(auth_verify), BOOLSTR(auth_seal), data_len, p->hdr.auth_len));
 
+		/*
+		 * Set data to point to where we copied the data into.
+		 */
+
+		data = prs_data_p(&outgoing_pdu) + data_pos;
+
 		if (auth_seal) {
 			crc32 = crc32_calc_buffer(data, data_len);
 			NTLMSSPcalc_p(p, (uchar*)data, data_len);
@@ -457,24 +456,53 @@
 
 struct api_cmd
 {
-  char * pipe_clnt_name;
-  char * pipe_srv_name;
-  BOOL (*fn) (pipes_struct *);
+  const char *name;
+  int (*init)(void);
 };
 
 static struct api_cmd api_fd_commands[] =
 {
-    { "lsarpc",   "lsass",   api_ntlsa_rpc },
-    { "samr",     "lsass",   api_samr_rpc },
-    { "srvsvc",   "ntsvcs",  api_srvsvc_rpc },
-    { "wkssvc",   "ntsvcs",  api_wkssvc_rpc },
-    { "NETLOGON", "lsass",   api_netlog_rpc },
-    { "winreg",   "winreg",  api_reg_rpc },
-    { "spoolss",  "spoolss", api_spoolss_rpc },
-    { "netdfs",   "netdfs" , api_netdfs_rpc },
-    { NULL,       NULL,      NULL }
+#ifndef RPC_LSA_DYNAMIC
+    { "lsarpc",   rpc_lsa_init },
+#endif
+#ifndef RPC_SAMR_DYNAMIC
+    { "samr",     rpc_samr_init },
+#endif
+#ifndef RPC_SVC_DYNAMIC
+    { "srvsvc",   rpc_srv_init },
+#endif
+#ifndef RPC_WKS_DYNAMIC
+    { "wkssvc",   rpc_wks_init },
+#endif
+#ifndef RPC_NETLOG_DYNAMIC
+    { "NETLOGON", rpc_net_init },
+#endif
+#ifndef RPC_REG_DYNAMIC
+    { "winreg",   rpc_reg_init },
+#endif
+#ifndef RPC_SPOOLSS_DYNAMIC
+    { "spoolss",  rpc_spoolss_init },
+#endif
+#ifndef RPC_DFS_DYNAMIC
+    { "netdfs",   rpc_dfs_init },
+#endif
+    { NULL, NULL }
 };
 
+struct rpc_table
+{
+  struct
+  {
+    const char *clnt;
+    const char *srv;
+  } pipe;
+  struct api_struct *cmds;
+  int n_cmds;
+};
+
+static struct rpc_table *rpc_lookup;
+static int rpc_lookup_size;
+
 /*******************************************************************
  This is the client reply to our challenge for an authenticated 
  bind request. The challenge we sent is in p->challenge.
@@ -681,6 +709,7 @@
 	fstrcpy(pname,"\\PIPE\\");
 	fstrcat(pname,pipe_name);
 
+	DEBUG(3,("check_bind_req for %s\n", pname));
 
 #ifndef SUPPORT_NEW_LSARPC_UUID
 
@@ -728,6 +757,82 @@
 }
 
 /*******************************************************************
+ Register commands to an RPC pipe
+*******************************************************************/
+int rpc_pipe_register_commands(const char *clnt, const char *srv, const struct api_struct *cmds, int size)
+{
+        struct rpc_table *rpc_entry;
+
+
+        /* We use a temporary variable because this call can fail and 
+           rpc_lookup will still be valid afterwards.  It could then succeed if
+           called again later */
+        rpc_entry = realloc(rpc_lookup, 
+                            ++rpc_lookup_size*sizeof(struct rpc_table));
+        if (NULL == rpc_entry) {
+                rpc_lookup_size--;
+                DEBUG(0, ("rpc_pipe_register_commands: memory allocation failed\n"));
+                return 0;
+        } else {
+                rpc_lookup = rpc_entry;
+        }
+        
+        rpc_entry = rpc_lookup + (rpc_lookup_size - 1);
+        ZERO_STRUCTP(rpc_entry);
+        rpc_entry->pipe.clnt = strdup(clnt);
+        rpc_entry->pipe.srv = strdup(srv);
+        rpc_entry->cmds = realloc(rpc_entry->cmds, 
+                                  (rpc_entry->n_cmds + size) *
+                                  sizeof(struct api_struct));
+        memcpy(rpc_entry->cmds + rpc_entry->n_cmds, cmds,
+               size * sizeof(struct api_struct));
+        rpc_entry->n_cmds += size;
+        
+        return size;
+}
+
+/*******************************************************************
+ Register commands to an RPC pipe
+*******************************************************************/
+int rpc_load_module(const char *module)
+{
+#ifdef HAVE_DLOPEN
+        void *handle;
+        int (*module_init)(void);
+        pstring full_path;
+        char *error;
+        
+        pstrcpy(full_path, lib_path("rpc"));
+        pstrcat(full_path, "/librpc_");
+        pstrcat(full_path, module);
+        pstrcat(full_path, ".");
+        pstrcat(full_path, shlib_ext());
+
+        handle = sys_dlopen(full_path, RTLD_LAZY);
+        if (!handle) {
+                DEBUG(0, ("Could not load requested pipe %s as %s\n", 
+                    module, full_path));
+                DEBUG(0, (" Error: %s\n", dlerror()));
+                return 0;
+        }
+        
+        DEBUG(3, ("Module '%s' loaded\n", full_path));
+        
+        module_init = sys_dlsym(handle, "rpc_pipe_init");
+        if ((error = sys_dlerror()) != NULL) {
+                DEBUG(0, ("Error trying to resolve symbol 'rpc_pipe_init' in %s: %s\n",
+                          full_path, error));
+                return 0;
+        }
+        
+        return module_init();
+#else
+        DEBUG(0,("Attempting to load a dynamic RPC pipe when dlopen isn't available\n"));
+        return 0;
+#endif
+}
+
+/*******************************************************************
  Respond to a pipe bind request.
 *******************************************************************/
 
@@ -754,23 +859,40 @@
 	 * that this is a pipe name we support.
 	 */
 
-	for (i = 0; api_fd_commands[i].pipe_clnt_name; i++) {
-		if (strequal(api_fd_commands[i].pipe_clnt_name, p->name) &&
-		    api_fd_commands[i].fn != NULL) {
-			DEBUG(3,("api_pipe_bind_req: \\PIPE\\%s -> \\PIPE\\%s\n",
-			           api_fd_commands[i].pipe_clnt_name,
-			           api_fd_commands[i].pipe_srv_name));
-			fstrcpy(p->pipe_srv_name, api_fd_commands[i].pipe_srv_name);
-			break;
-		}
-	}
 
-	if (api_fd_commands[i].fn == NULL) {
-		DEBUG(3,("api_pipe_bind_req: Unknown pipe name %s in bind request.\n",
-			p->name ));
-		if(!setup_bind_nak(p))
-			return False;
-		return True;
+	for (i = 0; i < rpc_lookup_size; i++) {
+	        if (strequal(rpc_lookup[i].pipe.clnt, p->name)) {
+                  DEBUG(3, ("api_pipe_bind_req: \\PIPE\\%s -> \\PIPE\\%s\n",
+                            rpc_lookup[i].pipe.clnt, rpc_lookup[i].pipe.srv));
+                  fstrcpy(p->pipe_srv_name, rpc_lookup[i].pipe.srv);
+                  break;
+                }
+	}
+
+	if (i == rpc_lookup_size) {
+                for (i = 0; api_fd_commands[i].name; i++) {
+                       if (strequal(api_fd_commands[i].name, p->name)) {
+                               api_fd_commands[i].init();
+                               break;
+                       }
+                }
+
+                if (!api_fd_commands[i].name && !rpc_load_module(p->name)) {
+                       DEBUG(3,("api_pipe_bind_req: Unknown pipe name %s in bind request.\n",
+                                p->name ));
+                       if(!setup_bind_nak(p))
+                               return False;
+                       return True;
+                }
+
+                for (i = 0; i < rpc_lookup_size; i++) {
+                       if (strequal(rpc_lookup[i].pipe.clnt, p->name)) {
+                               DEBUG(3, ("api_pipe_bind_req: \\PIPE\\%s -> \\PIPE\\%s\n",
+                                         rpc_lookup[i].pipe.clnt, rpc_lookup[i].pipe.srv));
+                               fstrcpy(p->pipe_srv_name, rpc_lookup[i].pipe.srv);
+                               break;
+                       }
+                }
 	}
 
 	/* decode the bind request */
@@ -1153,14 +1275,46 @@
 		}
 	}
 
-	for (i = 0; api_fd_commands[i].pipe_clnt_name; i++) {
-		if (strequal(api_fd_commands[i].pipe_clnt_name, p->name) &&
-		    api_fd_commands[i].fn != NULL) {
-			DEBUG(3,("Doing \\PIPE\\%s\n", api_fd_commands[i].pipe_clnt_name));
-			set_current_rpc_talloc(p->mem_ctx);
-			ret = api_fd_commands[i].fn(p);
-			set_current_rpc_talloc(NULL);
-		}
+	DEBUG(5, ("Requested \\PIPE\\%s\n", p->name));
+
+	for (i = 0; i < rpc_lookup_size; i++) {
+	        if (strequal(rpc_lookup[i].pipe.clnt, p->name)) {
+                        DEBUG(3,("Doing \\PIPE\\%s\n", 
+                                 rpc_lookup[i].pipe.clnt));
+                        set_current_rpc_talloc(p->mem_ctx);
+                        ret = api_rpcTNP(p, rpc_lookup[i].pipe.clnt,
+                                         rpc_lookup[i].cmds,
+                                         rpc_lookup[i].n_cmds);
+                        set_current_rpc_talloc(NULL);
+                        break;
+                }
+	}
+
+
+	if (i == rpc_lookup_size) {
+	        for (i = 0; api_fd_commands[i].name; i++) {
+                        if (strequal(api_fd_commands[i].name, p->name)) {
+                                api_fd_commands[i].init();
+                                break;
+                        }
+                }
+
+                if (!api_fd_commands[i].name) {
+                       rpc_load_module(p->name);
+                }
+
+                for (i = 0; i < rpc_lookup_size; i++) {
+                        if (strequal(rpc_lookup[i].pipe.clnt, p->name)) {
+                                DEBUG(3,("Doing \\PIPE\\%s\n",
+                                         rpc_lookup[i].pipe.clnt));
+                                set_current_rpc_talloc(p->mem_ctx);
+                                ret = api_rpcTNP(p, rpc_lookup[i].pipe.clnt,
+                                                 rpc_lookup[i].cmds,
+                                                 rpc_lookup[i].n_cmds);
+                                set_current_rpc_talloc(NULL);
+                                break;
+                        }
+                }
 	}
 
 	if(p->ntlmssp_auth_validated)
@@ -1173,8 +1327,8 @@
  Calls the underlying RPC function for a named pipe.
  ********************************************************************/
 
-BOOL api_rpcTNP(pipes_struct *p, char *rpc_name, 
-		const struct api_struct *api_rpc_cmds)
+BOOL api_rpcTNP(pipes_struct *p, const char *rpc_name, 
+		const struct api_struct *api_rpc_cmds, int n_cmds)
 {
 	int fn_num;
 	fstring name;
@@ -1186,14 +1340,14 @@
 	slprintf(name, sizeof(name)-1, "in_%s", rpc_name);
 	prs_dump(name, p->hdr_req.opnum, &p->in_data.data);
 
-	for (fn_num = 0; api_rpc_cmds[fn_num].name; fn_num++) {
+	for (fn_num = 0; fn_num < n_cmds; fn_num++) {
 		if (api_rpc_cmds[fn_num].opnum == p->hdr_req.opnum && api_rpc_cmds[fn_num].fn != NULL) {
 			DEBUG(3,("api_rpcTNP: rpc command: %s\n", api_rpc_cmds[fn_num].name));
 			break;
 		}
 	}
 
-	if (api_rpc_cmds[fn_num].name == NULL) {
+	if (fn_num == n_cmds) {
 		/*
 		 * For an unknown RPC just return a fault PDU but
 		 * return True to allow RPC's on the pipe to continue
@@ -1206,6 +1360,8 @@
 
 	offset1 = prs_offset(&p->out_data.rdata);
 
+        DEBUG(6, ("api_rpc_cmds[%d].fn == %p\n", 
+                fn_num, api_rpc_cmds[fn_num].fn));
 	/* do the actual command */
 	if(!api_rpc_cmds[fn_num].fn(p)) {
 		DEBUG(0,("api_rpcTNP: %s: %s failed.\n", rpc_name, api_rpc_cmds[fn_num].name));
@@ -1231,17 +1387,15 @@
 	/* Check for buffer underflow in rpc parsing */
 
 	if ((DEBUGLEVEL >= 10) && 
-	    (p->in_data.data.data_offset != p->in_data.data.buffer_size)) {
-		int data_len = p->in_data.data.buffer_size - 
-			p->in_data.data.data_offset;
+	    (prs_offset(&p->in_data.data) != prs_data_size(&p->in_data.data))) {
+		size_t data_len = prs_data_size(&p->in_data.data) - prs_offset(&p->in_data.data);
 		char *data;
 
 		data = malloc(data_len);
 
 		DEBUG(10, ("api_rpcTNP: rpc input buffer underflow (parse error?)\n"));
 		if (data) {
-			prs_uint8s(False, "", &p->in_data.data, 0, (unsigned char *)data,
-				   data_len);
+			prs_uint8s(False, "", &p->in_data.data, 0, (unsigned char *)data, (uint32)data_len);
 			SAFE_FREE(data);
 		}
 
diff -uNr samba-3.0alpha21.orig/source/rpc_server/srv_pipe_hnd.c samba-3.0alpha21/source/rpc_server/srv_pipe_hnd.c
--- samba-3.0alpha21.orig/source/rpc_server/srv_pipe_hnd.c	2003-02-16 19:06:33.000000000 -0600
+++ samba-3.0alpha21/source/rpc_server/srv_pipe_hnd.c	2003-02-16 19:05:46.000000000 -0600
@@ -293,7 +293,7 @@
 
 	ZERO_STRUCTP(p);
 
-	if ((p->mem_ctx = talloc_init()) == NULL) {
+	if ((p->mem_ctx = talloc_init("pipe %s %p", pipe_name, p)) == NULL) {
 		DEBUG(0,("open_rpc_pipe_p: talloc_init failed.\n"));
 		SAFE_FREE(p);
 		return NULL;
@@ -544,7 +544,7 @@
 		DEBUG(3,("free_pipe_context: destroying talloc pool of size %u\n", talloc_pool_size(p->mem_ctx) ));
 		talloc_destroy_pool(p->mem_ctx);
 	} else {
-		p->mem_ctx = talloc_init();
+		p->mem_ctx = talloc_init("pipe %s %p", p->name, p);
 		if (p->mem_ctx == NULL)
 			p->fault_state = True;
 	}
@@ -618,16 +618,11 @@
 	 * Append the data portion into the buffer and return.
 	 */
 
-	{
-		char *data_from = prs_data_p(rpc_in_p) + prs_offset(rpc_in_p);
-
-		if(!prs_append_data(&p->in_data.data, data_from, data_len)) {
-			DEBUG(0,("process_request_pdu: Unable to append data size %u to parse buffer of size %u.\n",
-					(unsigned int)data_len, (unsigned int)prs_data_size(&p->in_data.data) ));
-			set_incoming_fault(p);
-			return False;
-		}
-
+	if(!prs_append_some_prs_data(&p->in_data.data, rpc_in_p, prs_offset(rpc_in_p), data_len)) {
+		DEBUG(0,("process_request_pdu: Unable to append data size %u to parse buffer of size %u.\n",
+				(unsigned int)data_len, (unsigned int)prs_data_size(&p->in_data.data) ));
+		set_incoming_fault(p);
+		return False;
 	}
 
 	if(p->hdr.flags & RPC_FLG_LAST) {
diff -uNr samba-3.0alpha21.orig/source/rpc_server/srv_reg.c samba-3.0alpha21/source/rpc_server/srv_reg.c
--- samba-3.0alpha21.orig/source/rpc_server/srv_reg.c	2003-02-16 19:06:33.000000000 -0600
+++ samba-3.0alpha21/source/rpc_server/srv_reg.c	2003-02-16 19:05:46.000000000 -0600
@@ -3,10 +3,11 @@
  *  RPC Pipe client / server routines
  *  Copyright (C) Andrew Tridgell              1992-1997,
  *  Copyright (C) Luke Kenneth Casson Leighton 1996-1997,
- *  Copyright (C) Paul Ashton                       1997.
- *  Copyright (C) Marc Jacobsen	   		    2000.
- *  Copyright (C) Jeremy Allison		    2001.
- *  Copyright (C) Gerald Carter 		    2002.
+ *  Copyright (C) Paul Ashton                       1997,
+ *  Copyright (C) Marc Jacobsen	   		    2000,
+ *  Copyright (C) Jeremy Allison		    2001,
+ *  Copyright (C) Gerald Carter 		    2002,
+ *  Copyright (C) Anthony Liguori                   2003.
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License as published by
@@ -371,29 +372,29 @@
 /*******************************************************************
  array of \PIPE\reg operations
  ********************************************************************/
-static struct api_struct api_reg_cmds[] =
-{
-	{ "REG_CLOSE"              , REG_CLOSE              , api_reg_close            },
-	{ "REG_OPEN_ENTRY"         , REG_OPEN_ENTRY         , api_reg_open_entry       },
-	{ "REG_OPEN_HKCR"          , REG_OPEN_HKCR          , api_reg_open_hkcr        },
-	{ "REG_OPEN_HKLM"          , REG_OPEN_HKLM          , api_reg_open_hklm        },
-	{ "REG_OPEN_HKU"     	   , REG_OPEN_HKU           , api_reg_open_hku         },
-	{ "REG_ENUM_KEY"           , REG_ENUM_KEY           , api_reg_enum_key         },
-	{ "REG_ENUM_VALUE"         , REG_ENUM_VALUE         , api_reg_enum_value       },
-	{ "REG_QUERY_KEY"          , REG_QUERY_KEY          , api_reg_query_key        },
-	{ "REG_INFO"               , REG_INFO               , api_reg_info             },
-	{ "REG_SHUTDOWN"           , REG_SHUTDOWN           , api_reg_shutdown         },
-	{ "REG_ABORT_SHUTDOWN"     , REG_ABORT_SHUTDOWN     , api_reg_abort_shutdown   },
-	{ "REG_UNKNOWN_1A"         , REG_UNKNOWN_1A         , api_reg_unknown_1a       },
-	{ "REG_SAVE_KEY"           , REG_SAVE_KEY           , api_reg_save_key         },
-	{ NULL                     , 0                      , NULL                     }
-};
 
-/*******************************************************************
- receives a reg pipe and responds.
- ********************************************************************/
-
-BOOL api_reg_rpc(pipes_struct *p)
-{
-	return api_rpcTNP(p, "api_reg_rpc", api_reg_cmds);
+#ifdef RPC_REG_DYNAMIC
+int rpc_pipe_init(void)
+#else
+int rpc_reg_init(void)
+#endif
+{
+  static struct api_struct api_reg_cmds[] =
+    {
+      { "REG_CLOSE"              , REG_CLOSE              , api_reg_close            },
+      { "REG_OPEN_ENTRY"         , REG_OPEN_ENTRY         , api_reg_open_entry       },
+      { "REG_OPEN_HKCR"          , REG_OPEN_HKCR          , api_reg_open_hkcr        },
+      { "REG_OPEN_HKLM"          , REG_OPEN_HKLM          , api_reg_open_hklm        },
+      { "REG_OPEN_HKU"           , REG_OPEN_HKU           , api_reg_open_hku         },
+      { "REG_ENUM_KEY"           , REG_ENUM_KEY           , api_reg_enum_key         },
+      { "REG_ENUM_VALUE"         , REG_ENUM_VALUE         , api_reg_enum_value       },
+      { "REG_QUERY_KEY"          , REG_QUERY_KEY          , api_reg_query_key        },
+      { "REG_INFO"               , REG_INFO               , api_reg_info             },
+      { "REG_SHUTDOWN"           , REG_SHUTDOWN           , api_reg_shutdown         },
+      { "REG_ABORT_SHUTDOWN"     , REG_ABORT_SHUTDOWN     , api_reg_abort_shutdown   },
+      { "REG_UNKNOWN_1A"         , REG_UNKNOWN_1A         , api_reg_unknown_1a       },
+      { "REG_SAVE_KEY"           , REG_SAVE_KEY           , api_reg_save_key         }
+    };
+  return rpc_pipe_register_commands("winreg", "winreg", api_reg_cmds,
+				    sizeof(api_reg_cmds) / sizeof(struct api_struct));
 }
diff -uNr samba-3.0alpha21.orig/source/rpc_server/srv_reg_nt.c samba-3.0alpha21/source/rpc_server/srv_reg_nt.c
--- samba-3.0alpha21.orig/source/rpc_server/srv_reg_nt.c	2003-02-16 19:06:33.000000000 -0600
+++ samba-3.0alpha21/source/rpc_server/srv_reg_nt.c	2003-02-16 19:05:46.000000000 -0600
@@ -80,15 +80,23 @@
  *******************************************************************/
  
 static NTSTATUS open_registry_key(pipes_struct *p, POLICY_HND *hnd, REGISTRY_KEY *parent,
-				char *subkeyname, uint32 access_granted  )
+				const char *subkeyname, uint32 access_granted  )
 {
 	REGISTRY_KEY 	*regkey = NULL;
 	NTSTATUS     	result = NT_STATUS_OK;
 	REGSUBKEY_CTR	subkeys;
+	pstring		subkeyname2;
+	int		subkey_len;
 	
 	DEBUG(7,("open_registry_key: name = [%s][%s]\n", 
 		parent ? parent->name : "NULL", subkeyname));
 
+	/* strip any trailing '\'s */
+	pstrcpy( subkeyname2, subkeyname );
+	subkey_len = strlen ( subkeyname2 );
+	if ( subkey_len && subkeyname2[subkey_len-1] == '\\' )
+		subkeyname2[subkey_len-1] = '\0';
+
 	if ((regkey=(REGISTRY_KEY*)malloc(sizeof(REGISTRY_KEY))) == NULL)
 		return NT_STATUS_NO_MEMORY;
 		
@@ -101,7 +109,7 @@
 	 * not do this stupidity.   --jerry
 	 */
 	
-	if (!subkeyname || !*subkeyname ) {
+	if ( !subkey_len ) {
 		pstrcpy( regkey->name, parent->name );	
 	}
 	else {
@@ -110,7 +118,7 @@
 			pstrcat( regkey->name, parent->name );
 			pstrcat( regkey->name, "\\" );
 		}
-		pstrcat( regkey->name, subkeyname );
+		pstrcat( regkey->name, subkeyname2 );
 	}
 	
 	/* Look up the table of registry I/O operations */
@@ -131,7 +139,6 @@
 	if ( fetch_reg_keys( regkey, &subkeys ) == -1 )  {
 	
 		/* don't really know what to return here */
-		
 		result = NT_STATUS_NO_SUCH_FILE;
 	}
 	else {
@@ -323,8 +330,6 @@
 
 	rpcstr_pull(name,q_u->uni_name.buffer,sizeof(name),q_u->uni_name.uni_str_len*2,0);
 	
-	DEBUG(5,("reg_open_entry: Enter\n"));
-		   
 	result = open_registry_key( p, &pol, key, name, 0x0 );
 	
 	init_reg_r_open_entry( r_u, &pol, result );
@@ -342,12 +347,11 @@
 {
 	NTSTATUS 		status = NT_STATUS_NO_SUCH_FILE;
 	fstring 		name;
-	char                    *value_ascii = "";
+	const char              *value_ascii = "";
 	fstring                 value;
 	int                     value_length;
 	REGISTRY_KEY 		*regkey = find_regkey_index_by_hnd( p, &q_u->pol );
 	REGISTRY_VALUE		*val = NULL;
-	REGISTRY_VALUE		emptyval;
 	REGVAL_CTR		regvals;
 	int			i;
 
@@ -369,8 +373,11 @@
 	/* couple of hard coded registry values */
 	
 	if ( strequal(name, "RefusePasswordChange") ) {
-		ZERO_STRUCTP( &emptyval );
-		val = &emptyval;
+		if ( (val = (REGISTRY_VALUE*)malloc(sizeof(REGISTRY_VALUE))) == NULL ) {
+			DEBUG(0,("_reg_info: malloc() failed!\n"));
+			return NT_STATUS_NO_MEMORY;
+		}
+		ZERO_STRUCTP( val );
 	
 		goto out;
 	}
@@ -591,9 +598,9 @@
 	/* timeout */
 	snprintf(timeout, sizeof(timeout), "%d", q_u->timeout);
 	/* reboot */
-	snprintf(r, sizeof(r), (q_u->flags & REG_REBOOT_ON_SHUTDOWN)?SHUTDOWN_R_STRING:"");
+	snprintf(r, sizeof(r), (q_u->reboot) ? SHUTDOWN_R_STRING : "");
 	/* force */
-	snprintf(f, sizeof(f), (q_u->flags & REG_FORCE_SHUTDOWN)?SHUTDOWN_F_STRING:"");
+	snprintf(f, sizeof(f), (q_u->force) ? SHUTDOWN_F_STRING : "");
 
 	pstrcpy(shutdown_script, lp_shutdown_script());
 
diff -uNr samba-3.0alpha21.orig/source/rpc_server/srv_samr.c samba-3.0alpha21/source/rpc_server/srv_samr.c
--- samba-3.0alpha21.orig/source/rpc_server/srv_samr.c	2003-02-16 19:06:33.000000000 -0600
+++ samba-3.0alpha21/source/rpc_server/srv_samr.c	2003-02-16 19:05:46.000000000 -0600
@@ -6,7 +6,7 @@
  *  Copyright (C) Paul Ashton                       1997,
  *  Copyright (C) Marc Jacobsen			    1999,
  *  Copyright (C) Jean Franois Micouleau      1998-2001,
- *  Copyright (C) Anthony Liguori                   2002,
+ *  Copyright (C) Anthony Liguori              2002-2003,
  *  Copyright (C) Jim McDonough                     2002.
  *	
  * 	Split into interface and implementation modules by, 
@@ -155,7 +155,6 @@
 		return False;
 	}
 	
-	
 	return True;
 }
 
@@ -1444,68 +1443,68 @@
  array of \PIPE\samr operations
  ********************************************************************/
 
-static struct api_struct api_samr_cmds [] =
-{
-	{"SAMR_CLOSE_HND"         , SAMR_CLOSE_HND        , api_samr_close_hnd        },
-	{"SAMR_CONNECT"           , SAMR_CONNECT          , api_samr_connect          },
-	{"SAMR_CONNECT_ANON"      , SAMR_CONNECT_ANON     , api_samr_connect_anon     },
-	{"SAMR_ENUM_DOMAINS"      , SAMR_ENUM_DOMAINS     , api_samr_enum_domains     },
-	{"SAMR_ENUM_DOM_USERS"    , SAMR_ENUM_DOM_USERS   , api_samr_enum_dom_users   },
-
-	{"SAMR_ENUM_DOM_GROUPS"   , SAMR_ENUM_DOM_GROUPS  , api_samr_enum_dom_groups  },
-	{"SAMR_ENUM_DOM_ALIASES"  , SAMR_ENUM_DOM_ALIASES , api_samr_enum_dom_aliases },
-	{"SAMR_QUERY_USERALIASES" , SAMR_QUERY_USERALIASES, api_samr_query_useraliases},
-	{"SAMR_QUERY_ALIASMEM"    , SAMR_QUERY_ALIASMEM   , api_samr_query_aliasmem   },
-	{"SAMR_QUERY_GROUPMEM"    , SAMR_QUERY_GROUPMEM   , api_samr_query_groupmem   },
-	{"SAMR_ADD_ALIASMEM"      , SAMR_ADD_ALIASMEM     , api_samr_add_aliasmem     },
-	{"SAMR_DEL_ALIASMEM"      , SAMR_DEL_ALIASMEM     , api_samr_del_aliasmem     },
-	{"SAMR_ADD_GROUPMEM"      , SAMR_ADD_GROUPMEM     , api_samr_add_groupmem     },
-	{"SAMR_DEL_GROUPMEM"      , SAMR_DEL_GROUPMEM     , api_samr_del_groupmem     },
-
-	{"SAMR_DELETE_DOM_USER"   , SAMR_DELETE_DOM_USER  , api_samr_delete_dom_user  },
-	{"SAMR_DELETE_DOM_GROUP"  , SAMR_DELETE_DOM_GROUP , api_samr_delete_dom_group },
-	{"SAMR_DELETE_DOM_ALIAS"  , SAMR_DELETE_DOM_ALIAS , api_samr_delete_dom_alias },
-	{"SAMR_CREATE_DOM_GROUP"  , SAMR_CREATE_DOM_GROUP , api_samr_create_dom_group },
-	{"SAMR_CREATE_DOM_ALIAS"  , SAMR_CREATE_DOM_ALIAS , api_samr_create_dom_alias },
-	{"SAMR_LOOKUP_NAMES"      , SAMR_LOOKUP_NAMES     , api_samr_lookup_names     },
-	{"SAMR_OPEN_USER"         , SAMR_OPEN_USER        , api_samr_open_user        },
-	{"SAMR_QUERY_USERINFO"    , SAMR_QUERY_USERINFO   , api_samr_query_userinfo   },
-	{"SAMR_SET_USERINFO"      , SAMR_SET_USERINFO     , api_samr_set_userinfo     },
-	{"SAMR_SET_USERINFO2"     , SAMR_SET_USERINFO2    , api_samr_set_userinfo2    },
-
-	{"SAMR_QUERY_DOMAIN_INFO" , SAMR_QUERY_DOMAIN_INFO, api_samr_query_dom_info   },
-	{"SAMR_QUERY_USERGROUPS"  , SAMR_QUERY_USERGROUPS , api_samr_query_usergroups },
-	{"SAMR_QUERY_DISPINFO"    , SAMR_QUERY_DISPINFO   , api_samr_query_dispinfo   },
-	{"SAMR_QUERY_DISPINFO3"   , SAMR_QUERY_DISPINFO3  , api_samr_query_dispinfo   },
-	{"SAMR_QUERY_DISPINFO4"   , SAMR_QUERY_DISPINFO4  , api_samr_query_dispinfo   },
-
-	{"SAMR_QUERY_ALIASINFO"   , SAMR_QUERY_ALIASINFO  , api_samr_query_aliasinfo  },
-	{"SAMR_QUERY_GROUPINFO"   , SAMR_QUERY_GROUPINFO  , api_samr_query_groupinfo  },
-	{"SAMR_SET_GROUPINFO"     , SAMR_SET_GROUPINFO    , api_samr_set_groupinfo    },
-	{"SAMR_SET_ALIASINFO"     , SAMR_SET_ALIASINFO    , api_samr_set_aliasinfo    },
-	{"SAMR_CREATE_USER"       , SAMR_CREATE_USER      , api_samr_create_user      },
-	{"SAMR_LOOKUP_RIDS"       , SAMR_LOOKUP_RIDS      , api_samr_lookup_rids      },
-	{"SAMR_GET_DOM_PWINFO"    , SAMR_GET_DOM_PWINFO   , api_samr_get_dom_pwinfo   },
-	{"SAMR_CHGPASSWD_USER"    , SAMR_CHGPASSWD_USER   , api_samr_chgpasswd_user   },
-	{"SAMR_OPEN_ALIAS"        , SAMR_OPEN_ALIAS       , api_samr_open_alias       },
-	{"SAMR_OPEN_GROUP"        , SAMR_OPEN_GROUP       , api_samr_open_group       },
-	{"SAMR_OPEN_DOMAIN"       , SAMR_OPEN_DOMAIN      , api_samr_open_domain      },
-	{"SAMR_UNKNOWN_2D"        , SAMR_UNKNOWN_2D       , api_samr_unknown_2d       },
-	{"SAMR_LOOKUP_DOMAIN"     , SAMR_LOOKUP_DOMAIN    , api_samr_lookup_domain    },
-
-	{"SAMR_QUERY_SEC_OBJECT"  , SAMR_QUERY_SEC_OBJECT , api_samr_query_sec_obj    },
-	{"SAMR_SET_SEC_OBJECT"    , SAMR_SET_SEC_OBJECT   , api_samr_set_sec_obj      },
-	{"SAMR_GET_USRDOM_PWINFO" , SAMR_GET_USRDOM_PWINFO, api_samr_get_usrdom_pwinfo},
-	{"SAMR_UNKNOWN_2E"        , SAMR_UNKNOWN_2E       , api_samr_unknown_2e       },
-	{"SAMR_SET_DOMAIN_INFO"   , SAMR_SET_DOMAIN_INFO  , api_samr_set_dom_info     },
-	{"SAMR_CONNECT4"          , SAMR_CONNECT4         , api_samr_connect4         },
-	{NULL                     , 0                     , NULL                      }
-};
-
-/*******************************************************************
- receives a samr pipe and responds.
- ********************************************************************/
-BOOL api_samr_rpc(pipes_struct *p)
-{
-	return api_rpcTNP(p, "api_samr_rpc", api_samr_cmds);
+#ifdef RPC_SAMR_DYNAMIC
+int rpc_pipe_init(void)
+#else
+int rpc_samr_init(void)
+#endif
+{
+  static struct api_struct api_samr_cmds [] =
+    {
+      {"SAMR_CLOSE_HND"         , SAMR_CLOSE_HND        , api_samr_close_hnd        },
+      {"SAMR_CONNECT"           , SAMR_CONNECT          , api_samr_connect          },
+      {"SAMR_CONNECT_ANON"      , SAMR_CONNECT_ANON     , api_samr_connect_anon     },
+      {"SAMR_ENUM_DOMAINS"      , SAMR_ENUM_DOMAINS     , api_samr_enum_domains     },
+      {"SAMR_ENUM_DOM_USERS"    , SAMR_ENUM_DOM_USERS   , api_samr_enum_dom_users   },
+      
+      {"SAMR_ENUM_DOM_GROUPS"   , SAMR_ENUM_DOM_GROUPS  , api_samr_enum_dom_groups  },
+      {"SAMR_ENUM_DOM_ALIASES"  , SAMR_ENUM_DOM_ALIASES , api_samr_enum_dom_aliases },
+      {"SAMR_QUERY_USERALIASES" , SAMR_QUERY_USERALIASES, api_samr_query_useraliases},
+      {"SAMR_QUERY_ALIASMEM"    , SAMR_QUERY_ALIASMEM   , api_samr_query_aliasmem   },
+      {"SAMR_QUERY_GROUPMEM"    , SAMR_QUERY_GROUPMEM   , api_samr_query_groupmem   },
+      {"SAMR_ADD_ALIASMEM"      , SAMR_ADD_ALIASMEM     , api_samr_add_aliasmem     },
+      {"SAMR_DEL_ALIASMEM"      , SAMR_DEL_ALIASMEM     , api_samr_del_aliasmem     },
+      {"SAMR_ADD_GROUPMEM"      , SAMR_ADD_GROUPMEM     , api_samr_add_groupmem     },
+      {"SAMR_DEL_GROUPMEM"      , SAMR_DEL_GROUPMEM     , api_samr_del_groupmem     },
+      
+      {"SAMR_DELETE_DOM_USER"   , SAMR_DELETE_DOM_USER  , api_samr_delete_dom_user  },
+      {"SAMR_DELETE_DOM_GROUP"  , SAMR_DELETE_DOM_GROUP , api_samr_delete_dom_group },
+      {"SAMR_DELETE_DOM_ALIAS"  , SAMR_DELETE_DOM_ALIAS , api_samr_delete_dom_alias },
+      {"SAMR_CREATE_DOM_GROUP"  , SAMR_CREATE_DOM_GROUP , api_samr_create_dom_group },
+      {"SAMR_CREATE_DOM_ALIAS"  , SAMR_CREATE_DOM_ALIAS , api_samr_create_dom_alias },
+      {"SAMR_LOOKUP_NAMES"      , SAMR_LOOKUP_NAMES     , api_samr_lookup_names     },
+      {"SAMR_OPEN_USER"         , SAMR_OPEN_USER        , api_samr_open_user        },
+      {"SAMR_QUERY_USERINFO"    , SAMR_QUERY_USERINFO   , api_samr_query_userinfo   },
+      {"SAMR_SET_USERINFO"      , SAMR_SET_USERINFO     , api_samr_set_userinfo     },
+      {"SAMR_SET_USERINFO2"     , SAMR_SET_USERINFO2    , api_samr_set_userinfo2    },
+      
+      {"SAMR_QUERY_DOMAIN_INFO" , SAMR_QUERY_DOMAIN_INFO, api_samr_query_dom_info   },
+      {"SAMR_QUERY_USERGROUPS"  , SAMR_QUERY_USERGROUPS , api_samr_query_usergroups },
+      {"SAMR_QUERY_DISPINFO"    , SAMR_QUERY_DISPINFO   , api_samr_query_dispinfo   },
+      {"SAMR_QUERY_DISPINFO3"   , SAMR_QUERY_DISPINFO3  , api_samr_query_dispinfo   },
+      {"SAMR_QUERY_DISPINFO4"   , SAMR_QUERY_DISPINFO4  , api_samr_query_dispinfo   },
+      
+      {"SAMR_QUERY_ALIASINFO"   , SAMR_QUERY_ALIASINFO  , api_samr_query_aliasinfo  },
+      {"SAMR_QUERY_GROUPINFO"   , SAMR_QUERY_GROUPINFO  , api_samr_query_groupinfo  },
+      {"SAMR_SET_GROUPINFO"     , SAMR_SET_GROUPINFO    , api_samr_set_groupinfo    },
+      {"SAMR_SET_ALIASINFO"     , SAMR_SET_ALIASINFO    , api_samr_set_aliasinfo    },
+      {"SAMR_CREATE_USER"       , SAMR_CREATE_USER      , api_samr_create_user      },
+      {"SAMR_LOOKUP_RIDS"       , SAMR_LOOKUP_RIDS      , api_samr_lookup_rids      },
+      {"SAMR_GET_DOM_PWINFO"    , SAMR_GET_DOM_PWINFO   , api_samr_get_dom_pwinfo   },
+      {"SAMR_CHGPASSWD_USER"    , SAMR_CHGPASSWD_USER   , api_samr_chgpasswd_user   },
+      {"SAMR_OPEN_ALIAS"        , SAMR_OPEN_ALIAS       , api_samr_open_alias       },
+      {"SAMR_OPEN_GROUP"        , SAMR_OPEN_GROUP       , api_samr_open_group       },
+      {"SAMR_OPEN_DOMAIN"       , SAMR_OPEN_DOMAIN      , api_samr_open_domain      },
+      {"SAMR_UNKNOWN_2D"        , SAMR_UNKNOWN_2D       , api_samr_unknown_2d       },
+      {"SAMR_LOOKUP_DOMAIN"     , SAMR_LOOKUP_DOMAIN    , api_samr_lookup_domain    },
+      
+      {"SAMR_QUERY_SEC_OBJECT"  , SAMR_QUERY_SEC_OBJECT , api_samr_query_sec_obj    },
+      {"SAMR_SET_SEC_OBJECT"    , SAMR_SET_SEC_OBJECT   , api_samr_set_sec_obj      },
+      {"SAMR_GET_USRDOM_PWINFO" , SAMR_GET_USRDOM_PWINFO, api_samr_get_usrdom_pwinfo},
+      {"SAMR_UNKNOWN_2E"        , SAMR_UNKNOWN_2E       , api_samr_unknown_2e       },
+      {"SAMR_SET_DOMAIN_INFO"   , SAMR_SET_DOMAIN_INFO  , api_samr_set_dom_info     },
+      {"SAMR_CONNECT4"          , SAMR_CONNECT4         , api_samr_connect4         }
+    };
+  return rpc_pipe_register_commands("samr", "lsass", api_samr_cmds,
+				    sizeof(api_samr_cmds) / sizeof(struct api_struct));
 }
diff -uNr samba-3.0alpha21.orig/source/rpc_server/srv_samr_nt.c samba-3.0alpha21/source/rpc_server/srv_samr_nt.c
--- samba-3.0alpha21.orig/source/rpc_server/srv_samr_nt.c	2003-02-16 19:06:33.000000000 -0600
+++ samba-3.0alpha21/source/rpc_server/srv_samr_nt.c	2003-02-16 19:05:46.000000000 -0600
@@ -134,7 +134,7 @@
 		fstrcpy(sid_str,"(NULL)");
 	}
 
-	mem_ctx = talloc_init_named("samr_info for domain sid %s", sid_str);
+	mem_ctx = talloc_init("samr_info for domain sid %s", sid_str);
 
 	if ((info = (struct samr_info *)talloc(mem_ctx, sizeof(struct samr_info))) == NULL)
 		return NULL;
@@ -1180,6 +1180,18 @@
 	/* Get what we need from the password database */
 	switch (q_u->switch_level) {
 		case 0x1:
+			/* When playing with usrmgr, this is necessary
+                           if you want immediate refresh after editing
+                           a user. I would like to do this after the
+                           setuserinfo2, but we do not have access to
+                           the domain handle in that call, only to the
+                           user handle. Where else does this hurt?
+			   -- Volker
+			*/
+#if 0
+			/* We cannot do this here - it kills performace. JRA. */
+			free_samr_users(info);
+#endif
 		case 0x2:
 		case 0x4:
 			become_root();		
@@ -1524,9 +1536,8 @@
 	 * is case insensitive.
 	 */
 
-    if (!pass_oem_change(user_name, q_u->lm_newpass.pass, q_u->lm_oldhash.hash,
-                         q_u->nt_newpass.pass, q_u->nt_oldhash.hash))
-        r_u->status = NT_STATUS_WRONG_PASSWORD;
+    r_u->status = pass_oem_change(user_name, q_u->lm_newpass.pass, q_u->lm_oldhash.hash,
+				  q_u->nt_newpass.pass, q_u->nt_oldhash.hash);
 
     init_samr_r_chgpasswd_user(r_u, r_u->status);
 
diff -uNr samba-3.0alpha21.orig/source/rpc_server/srv_samr_util.c samba-3.0alpha21/source/rpc_server/srv_samr_util.c
--- samba-3.0alpha21.orig/source/rpc_server/srv_samr_util.c	2003-02-16 19:06:33.000000000 -0600
+++ samba-3.0alpha21/source/rpc_server/srv_samr_util.c	2003-02-16 19:05:46.000000000 -0600
@@ -91,7 +91,7 @@
 	/* Backend should check this for sainity */
 	if (from->hdr_user_name.buffer) {
 		old_string = pdb_get_username(to);
-		new_string = pdb_unistr2_convert(&from->uni_user_name);
+		new_string = unistr2_static(&from->uni_user_name);
 		DEBUG(10,("INFO_21 UNI_USER_NAME: %s -> %s\n", old_string, new_string));
 		if (STRING_CHANGED)
 		    pdb_set_username(to      , new_string, PDB_CHANGED);
@@ -99,7 +99,7 @@
 
 	if (from->hdr_full_name.buffer) {
 		old_string = pdb_get_fullname(to);
-		new_string = pdb_unistr2_convert(&from->uni_full_name);
+		new_string = unistr2_static(&from->uni_full_name);
 		DEBUG(10,("INFO_21 UNI_FULL_NAME: %s -> %s\n",old_string, new_string));
 		if (STRING_CHANGED)
 			pdb_set_fullname(to      , new_string, PDB_CHANGED);
@@ -107,7 +107,7 @@
 	
 	if (from->hdr_home_dir.buffer) {
 		old_string = pdb_get_homedir(to);
-		new_string = pdb_unistr2_convert(&from->uni_home_dir);
+		new_string = unistr2_static(&from->uni_home_dir);
 		DEBUG(10,("INFO_21 UNI_HOME_DIR: %s -> %s\n",old_string,new_string));
 		if (STRING_CHANGED)
 			pdb_set_homedir(to       , new_string, PDB_CHANGED);
@@ -115,7 +115,7 @@
 
 	if (from->hdr_dir_drive.buffer) {
 		old_string = pdb_get_dir_drive(to);
-		new_string = pdb_unistr2_convert(&from->uni_dir_drive);
+		new_string = unistr2_static(&from->uni_dir_drive);
 		DEBUG(10,("INFO_21 UNI_DIR_DRIVE: %s -> %s\n",old_string,new_string));
 		if (STRING_CHANGED)
 			pdb_set_dir_drive(to     , new_string, PDB_CHANGED);
@@ -123,7 +123,7 @@
 
 	if (from->hdr_logon_script.buffer) {
 		old_string = pdb_get_logon_script(to);
-		new_string = pdb_unistr2_convert(&from->uni_logon_script);
+		new_string = unistr2_static(&from->uni_logon_script);
 		DEBUG(10,("INFO_21 UNI_LOGON_SCRIPT: %s -> %s\n",old_string,new_string));
 		if (STRING_CHANGED)
 			pdb_set_logon_script(to  , new_string, PDB_CHANGED);
@@ -131,7 +131,7 @@
 
 	if (from->hdr_profile_path.buffer) {
 		old_string = pdb_get_profile_path(to);
-		new_string = pdb_unistr2_convert(&from->uni_profile_path);
+		new_string = unistr2_static(&from->uni_profile_path);
 		DEBUG(10,("INFO_21 UNI_PROFILE_PATH: %s -> %s\n",old_string, new_string));
 		if (STRING_CHANGED)
 			pdb_set_profile_path(to  , new_string, PDB_CHANGED);
@@ -139,7 +139,7 @@
 	
 	if (from->hdr_acct_desc.buffer) {
 		old_string = pdb_get_acct_desc(to);
-		new_string = pdb_unistr2_convert(&from->uni_acct_desc);
+		new_string = unistr2_static(&from->uni_acct_desc);
 		DEBUG(10,("INFO_21 UNI_ACCT_DESC: %s -> %s\n",old_string,new_string));
 		if (STRING_CHANGED)
 			pdb_set_acct_desc(to     , new_string, PDB_CHANGED);
@@ -147,7 +147,7 @@
 	
 	if (from->hdr_workstations.buffer) {
 		old_string = pdb_get_workstations(to);
-		new_string = pdb_unistr2_convert(&from->uni_workstations);
+		new_string = unistr2_static(&from->uni_workstations);
 		DEBUG(10,("INFO_21 UNI_WORKSTATIONS: %s -> %s\n",old_string, new_string));
 		if (STRING_CHANGED)
 			pdb_set_workstations(to  , new_string, PDB_CHANGED);
@@ -155,7 +155,7 @@
 
 	if (from->hdr_unknown_str.buffer) {
 		old_string = pdb_get_unknown_str(to);
-		new_string = pdb_unistr2_convert(&from->uni_unknown_str);
+		new_string = unistr2_static(&from->uni_unknown_str);
 		DEBUG(10,("INFO_21 UNI_UNKNOWN_STR: %s -> %s\n",old_string, new_string));
 		if (STRING_CHANGED)
 			pdb_set_unknown_str(to   , new_string, PDB_CHANGED);
@@ -163,7 +163,7 @@
 	
 	if (from->hdr_munged_dial.buffer) {
 		old_string = pdb_get_munged_dial(to);
-		new_string = pdb_unistr2_convert(&from->uni_munged_dial);
+		new_string = unistr2_static(&from->uni_munged_dial);
 		DEBUG(10,("INFO_21 UNI_MUNGED_DIAL: %s -> %s\n",old_string, new_string));
 		if (STRING_CHANGED)
 			pdb_set_munged_dial(to   , new_string, PDB_CHANGED);
@@ -293,7 +293,7 @@
 	/* Backend should check this for sainity */
 	if (from->hdr_user_name.buffer) {
 		old_string = pdb_get_username(to);
-		new_string = pdb_unistr2_convert(&from->uni_user_name);
+		new_string = unistr2_static(&from->uni_user_name);
 		DEBUG(10,("INFO_23 UNI_USER_NAME: %s -> %s\n", old_string, new_string));
 		if (STRING_CHANGED)
 		    pdb_set_username(to      , new_string, PDB_CHANGED);
@@ -301,7 +301,7 @@
 
 	if (from->hdr_full_name.buffer) {
 		old_string = pdb_get_fullname(to);
-		new_string = pdb_unistr2_convert(&from->uni_full_name);
+		new_string = unistr2_static(&from->uni_full_name);
 		DEBUG(10,("INFO_23 UNI_FULL_NAME: %s -> %s\n",old_string, new_string));
 		if (STRING_CHANGED)
 			pdb_set_fullname(to      , new_string, PDB_CHANGED);
@@ -309,7 +309,7 @@
 	
 	if (from->hdr_home_dir.buffer) {
 		old_string = pdb_get_homedir(to);
-		new_string = pdb_unistr2_convert(&from->uni_home_dir);
+		new_string = unistr2_static(&from->uni_home_dir);
 		DEBUG(10,("INFO_23 UNI_HOME_DIR: %s -> %s\n",old_string,new_string));
 		if (STRING_CHANGED)
 			pdb_set_homedir(to       , new_string, PDB_CHANGED);
@@ -317,7 +317,7 @@
 
 	if (from->hdr_dir_drive.buffer) {
 		old_string = pdb_get_dir_drive(to);
-		new_string = pdb_unistr2_convert(&from->uni_dir_drive);
+		new_string = unistr2_static(&from->uni_dir_drive);
 		DEBUG(10,("INFO_23 UNI_DIR_DRIVE: %s -> %s\n",old_string,new_string));
 		if (STRING_CHANGED)
 			pdb_set_dir_drive(to     , new_string, PDB_CHANGED);
@@ -325,7 +325,7 @@
 
 	if (from->hdr_logon_script.buffer) {
 		old_string = pdb_get_logon_script(to);
-		new_string = pdb_unistr2_convert(&from->uni_logon_script);
+		new_string = unistr2_static(&from->uni_logon_script);
 		DEBUG(10,("INFO_23 UNI_LOGON_SCRIPT: %s -> %s\n",old_string,new_string));
 		if (STRING_CHANGED)
 			pdb_set_logon_script(to  , new_string, PDB_CHANGED);
@@ -333,7 +333,7 @@
 
 	if (from->hdr_profile_path.buffer) {
 		old_string = pdb_get_profile_path(to);
-		new_string = pdb_unistr2_convert(&from->uni_profile_path);
+		new_string = unistr2_static(&from->uni_profile_path);
 		DEBUG(10,("INFO_23 UNI_PROFILE_PATH: %s -> %s\n",old_string, new_string));
 		if (STRING_CHANGED)
 			pdb_set_profile_path(to  , new_string, PDB_CHANGED);
@@ -341,7 +341,7 @@
 	
 	if (from->hdr_acct_desc.buffer) {
 		old_string = pdb_get_acct_desc(to);
-		new_string = pdb_unistr2_convert(&from->uni_acct_desc);
+		new_string = unistr2_static(&from->uni_acct_desc);
 		DEBUG(10,("INFO_23 UNI_ACCT_DESC: %s -> %s\n",old_string,new_string));
 		if (STRING_CHANGED)
 			pdb_set_acct_desc(to     , new_string, PDB_CHANGED);
@@ -349,7 +349,7 @@
 	
 	if (from->hdr_workstations.buffer) {
 		old_string = pdb_get_workstations(to);
-		new_string = pdb_unistr2_convert(&from->uni_workstations);
+		new_string = unistr2_static(&from->uni_workstations);
 		DEBUG(10,("INFO_23 UNI_WORKSTATIONS: %s -> %s\n",old_string, new_string));
 		if (STRING_CHANGED)
 			pdb_set_workstations(to  , new_string, PDB_CHANGED);
@@ -357,7 +357,7 @@
 
 	if (from->hdr_unknown_str.buffer) {
 		old_string = pdb_get_unknown_str(to);
-		new_string = pdb_unistr2_convert(&from->uni_unknown_str);
+		new_string = unistr2_static(&from->uni_unknown_str);
 		DEBUG(10,("INFO_23 UNI_UNKNOWN_STR: %s -> %s\n",old_string, new_string));
 		if (STRING_CHANGED)
 			pdb_set_unknown_str(to   , new_string, PDB_CHANGED);
@@ -365,7 +365,7 @@
 	
 	if (from->hdr_munged_dial.buffer) {
 		old_string = pdb_get_munged_dial(to);
-		new_string = pdb_unistr2_convert(&from->uni_munged_dial);
+		new_string = unistr2_static(&from->uni_munged_dial);
 		DEBUG(10,("INFO_23 UNI_MUNGED_DIAL: %s -> %s\n",old_string, new_string));
 		if (STRING_CHANGED)
 			pdb_set_munged_dial(to   , new_string, PDB_CHANGED);
diff -uNr samba-3.0alpha21.orig/source/rpc_server/srv_spoolss.c samba-3.0alpha21/source/rpc_server/srv_spoolss.c
--- samba-3.0alpha21.orig/source/rpc_server/srv_spoolss.c	2003-02-16 19:06:33.000000000 -0600
+++ samba-3.0alpha21/source/rpc_server/srv_spoolss.c	2003-02-16 19:05:46.000000000 -0600
@@ -3,9 +3,10 @@
  *  RPC Pipe client / server routines
  *  Copyright (C) Andrew Tridgell              1992-2000,
  *  Copyright (C) Luke Kenneth Casson Leighton 1996-2000,
- *  Copyright (C) Jean Franois Micouleau      1998-2000.
- *  Copyright (C) Jeremy Allison                    2001.
- *  Copyright (C) Gerald Carter                2001-2002.
+ *  Copyright (C) Jean Franois Micouleau      1998-2000,
+ *  Copyright (C) Jeremy Allison                    2001,
+ *  Copyright (C) Gerald Carter                2001-2002,
+ *  Copyright (C) Anthony Liguori                   2003.
  *  
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License as published by
@@ -1579,8 +1580,14 @@
 \pipe\spoolss commands
 ********************************************************************/
 
-struct api_struct api_spoolss_cmds[] = 
+#ifdef RPC_SPOOLSS_DYNAMIC
+int rpc_pipe_init(void)
+#else
+int rpc_spoolss_init(void)
+#endif
 {
+  struct api_struct api_spoolss_cmds[] = 
+    {
  {"SPOOLSS_OPENPRINTER",               SPOOLSS_OPENPRINTER,               api_spoolss_open_printer              },
  {"SPOOLSS_OPENPRINTEREX",             SPOOLSS_OPENPRINTEREX,             api_spoolss_open_printer_ex           },
  {"SPOOLSS_GETPRINTERDATA",            SPOOLSS_GETPRINTERDATA,            api_spoolss_getprinterdata            },
@@ -1634,15 +1641,9 @@
  {"SPOOLSS_DELETEPRINTERDRIVEREX",     SPOOLSS_DELETEPRINTERDRIVEREX,     api_spoolss_deleteprinterdriverex     },
 #if 0
  {"SPOOLSS_REPLYOPENPRINTER",          SPOOLSS_REPLYOPENPRINTER,          api_spoolss_replyopenprinter          },
- {"SPOOLSS_REPLYCLOSEPRINTER",         SPOOLSS_REPLYCLOSEPRINTER,         api_spoolss_replycloseprinter         },
+ {"SPOOLSS_REPLYCLOSEPRINTER",         SPOOLSS_REPLYCLOSEPRINTER,         api_spoolss_replycloseprinter         }
 #endif
- { NULL,                               0,                                 NULL                                  }
-};
-
-/*******************************************************************
-receives a spoolss pipe and responds.
-********************************************************************/
-BOOL api_spoolss_rpc(pipes_struct *p)
-{
-	return api_rpcTNP(p, "api_spoolss_rpc", api_spoolss_cmds);
+    };
+  return rpc_pipe_register_commands("spoolss", "spoolss", api_spoolss_cmds,
+				    sizeof(api_spoolss_cmds) / sizeof(struct api_struct));
 }
diff -uNr samba-3.0alpha21.orig/source/rpc_server/srv_spoolss_nt.c samba-3.0alpha21/source/rpc_server/srv_spoolss_nt.c
--- samba-3.0alpha21.orig/source/rpc_server/srv_spoolss_nt.c	2003-02-16 19:06:33.000000000 -0600
+++ samba-3.0alpha21/source/rpc_server/srv_spoolss_nt.c	2003-02-16 19:05:47.000000000 -0600
@@ -30,7 +30,6 @@
 
 #undef DBGC_CLASS
 #define DBGC_CLASS DBGC_RPC_SRV
-/* #define EMULATE_WIN2K_HACK	1 */
 
 #ifndef MAX_OPEN_PRINTER_EXS
 #define MAX_OPEN_PRINTER_EXS 50
@@ -43,7 +42,7 @@
 
 /* Table to map the driver version */
 /* to OS */
-char * drv_ver_to_os[] = {
+static const char * drv_ver_to_os[] = {
 	"WIN9X",   /* driver version/cversion 0 */
 	"",        /* unused ? */
 	"WINNT",   /* driver version/cversion 2 */
@@ -51,8 +50,8 @@
 };
 
 struct table_node {
-	char    *long_archi;
-	char    *short_archi;
+	const char    *long_archi;
+	const char    *short_archi;
 	int     version;
 };
 
@@ -80,8 +79,10 @@
 		uint32 printerlocal;
 		SPOOL_NOTIFY_OPTION *option;
 		POLICY_HND client_hnd;
-		uint32 client_connected;
+		BOOL client_connected;
 		uint32 change;
+		/* are we in a FindNextPrinterChangeNotify() call? */
+		BOOL fnpcn;
 	} notify;
 	struct {
 		fstring machine;
@@ -91,6 +92,7 @@
 	/* devmode sent in the OpenPrinter() call */
 	NT_DEVICEMODE	*nt_devmode;
 	
+	
 } Printer_entry;
 
 static Printer_entry *printers_list;
@@ -260,7 +262,7 @@
  Functions to duplicate a SPOOL_NOTIFY_OPTION struct stored in Printer_entry.
 ****************************************************************************/
 
-SPOOL_NOTIFY_OPTION *dup_spool_notify_option(SPOOL_NOTIFY_OPTION *sp)
+static SPOOL_NOTIFY_OPTION *dup_spool_notify_option(SPOOL_NOTIFY_OPTION *sp)
 {
 	SPOOL_NOTIFY_OPTION *new_sp = NULL;
 
@@ -704,16 +706,15 @@
 		return;
 
 	data->notify_data.data.length = prs_offset(&ps);
-	data->notify_data.data.string =
-		talloc(mem_ctx, prs_offset(&ps));
+	data->notify_data.data.string = talloc(mem_ctx, prs_offset(&ps));
 
-	memcpy(data->notify_data.data.string, prs_data_p(&ps), prs_offset(&ps));
+	prs_copy_all_data_out((char *)data->notify_data.data.string, &ps);
 
 	prs_mem_free(&ps);
 }
 
 struct notify2_message_table {
-	char *name;
+	const char *name;
 	void (*fn)(struct spoolss_notify_msg *msg,
 		   SPOOL_NOTIFY_INFO_DATA *data, TALLOC_CTX *mem_ctx);
 };
@@ -777,7 +778,7 @@
 	if ( !ctr )
 		return;
 
-	ctr->ctx = talloc_init();
+	ctr->ctx = talloc_init("notify_msg_ctr_init %p", ctr);
 		
 	return;
 }
@@ -933,7 +934,7 @@
 		SPOOL_NOTIFY_INFO_DATA *data;
 		uint32	data_len = 0;
 		uint32 	id;
-		int 	i;
+		int 	i, event_index;
 
 		/* Is there notification on this handle? */
 
@@ -956,67 +957,65 @@
 		data = talloc( mem_ctx, msg_group->num_msgs*sizeof(SPOOL_NOTIFY_INFO_DATA) );
 		ZERO_STRUCTP(data);
 		
+		event_index = 0;
+		
 		/* build the array of change notifications */
 		
 		for ( i=0; i<msg_group->num_msgs; i++ )
 		{
 			SPOOLSS_NOTIFY_MSG	*msg = &messages[i];
 			
-		/* Are we monitoring this event? */
+			/* Are we monitoring this event? */
 
-		if (!is_monitoring_event(p, msg->type, msg->field))
-			continue;
+			if (!is_monitoring_event(p, msg->type, msg->field))
+				continue;
 
 			
-		DEBUG(10,("process_notify2_message: Sending message type [%x] field [%x] for printer [%s]\n",
-			msg->type, msg->field, p->dev.handlename));
+			DEBUG(10,("process_notify2_message: Sending message type [%x] field [%x] for printer [%s]\n",
+				msg->type, msg->field, p->dev.handlename));
 
-		/* 
-		 * if the is a printer notification handle and not a job notification 
-		 * type, then set the id to 0.  Other wise just use what was specified
-		 * in the message.  
-		 *
-		 * When registering change notification on a print server handle 
-		 * we always need to send back the id (snum) matching the printer
-		 * for which the change took place.  For change notify registered
-		 * on a printer handle, this does not matter and the id should be 0.
-		 *
-		 * --jerry
-		 */
+			/* 
+			 * if the is a printer notification handle and not a job notification 
+			 * type, then set the id to 0.  Other wise just use what was specified
+			 * in the message.  
+			 *
+			 * When registering change notification on a print server handle 
+			 * we always need to send back the id (snum) matching the printer
+			 * for which the change took place.  For change notify registered
+			 * on a printer handle, this does not matter and the id should be 0.
+			 *
+			 * --jerry
+			 */
 
-		if ( ( p->printer_type == PRINTER_HANDLE_IS_PRINTER ) && ( msg->type == PRINTER_NOTIFY_TYPE ) )
-			id = 0;
-		else
-		id = msg->id;
+			if ( ( p->printer_type == PRINTER_HANDLE_IS_PRINTER ) && ( msg->type == PRINTER_NOTIFY_TYPE ) )
+				id = 0;
+			else
+				id = msg->id;
 
 
-		/* Convert unix jobid to smb jobid */
+			/* Convert unix jobid to smb jobid */
 
 			if (msg->flags & SPOOLSS_NOTIFY_MSG_UNIX_JOBID) 
 			{
-			id = sysjob_to_jobid(msg->id);
+				id = sysjob_to_jobid(msg->id);
 
-			if (id == -1) {
-				DEBUG(3, ("no such unix jobid %d\n", msg->id));
-				goto done;
+				if (id == -1) {
+					DEBUG(3, ("no such unix jobid %d\n", msg->id));
+					goto done;
+				}
 			}
-		}
 
 			construct_info_data( &data[data_len], msg->type, msg->field, id );
 
-		switch(msg->type) {
-		case PRINTER_NOTIFY_TYPE:
-				if ( !printer_notify_table[msg->field].fn )
-				goto done;
+			switch(msg->type) {
+			case PRINTER_NOTIFY_TYPE:
+				if ( printer_notify_table[msg->field].fn )
 					printer_notify_table[msg->field].fn(msg, &data[data_len], mem_ctx);
-				
-			break;
+				break;
 			
-		case JOB_NOTIFY_TYPE:
-				if ( !job_notify_table[msg->field].fn )
-				goto done;
+			case JOB_NOTIFY_TYPE:
+				if ( job_notify_table[msg->field].fn )
 					job_notify_table[msg->field].fn(msg, &data[data_len], mem_ctx);
-
 				break;
 
 			default:
@@ -1042,7 +1041,7 @@
 static BOOL notify2_unpack_msg( SPOOLSS_NOTIFY_MSG *msg, void *buf, size_t len )
 {
 
-	int offset = 0;
+	size_t offset = 0;
 
 	/* Unpack message */
 
@@ -1230,6 +1229,32 @@
 }
 
 /********************************************************************
+ Update the cahce for all printq's with a registered client 
+ connection
+ ********************************************************************/
+
+void update_monitored_printq_cache( void )
+{
+	Printer_entry *printer = printers_list;
+	int snum;
+	
+	/* loop through all printers and update the cache where 
+	   client_connected == True */
+	while ( printer ) 
+	{
+		if ( (printer->printer_type == PRINTER_HANDLE_IS_PRINTER) 
+			&& printer->notify.client_connected ) 
+		{
+			snum = print_queue_snum(printer->dev.handlename);
+			print_queue_status( snum, NULL, NULL );
+		}
+		
+		printer = printer->next;
+	}
+	
+	return;
+}
+/********************************************************************
  Send a message to ourself about new driver being installed
  so we can upgrade the information for each printer bound to this
  driver
@@ -1709,7 +1734,7 @@
 	return result;
 }
 
-BOOL convert_devicemode(char *printername, const DEVICEMODE *devmode,
+BOOL convert_devicemode(const char *printername, const DEVICEMODE *devmode,
 				NT_DEVICEMODE **pp_nt_devmode)
 {
 	NT_DEVICEMODE *nt_devmode = *pp_nt_devmode;
@@ -2086,7 +2111,7 @@
  ***************************************************************************/
 
 static WERROR get_printer_dataex( TALLOC_CTX *ctx, NT_PRINTER_INFO_LEVEL *printer, 
-                                  char *key, char *value, uint32 *type, uint8 **data, 
+                                  const char *key, const char *value, uint32 *type, uint8 **data, 
 				  uint32 *needed, uint32 in_size  )
 {
 	REGISTRY_VALUE 		*val;
@@ -2105,8 +2130,16 @@
 	
 	if ( in_size ) {
 		data_len = (size > in_size) ? in_size : size*sizeof(uint8);
-		if ( (*data  = (uint8 *)talloc_memdup(ctx, regval_data_p(val), data_len)) == NULL )
-			return WERR_NOMEM;
+		
+		/* special case for 0 length values */
+		if ( data_len ) {
+			if ( (*data  = (uint8 *)talloc_memdup(ctx, regval_data_p(val), data_len)) == NULL )
+				return WERR_NOMEM;
+		}
+		else {
+			if ( (*data  = (uint8 *)talloc_zero(ctx, in_size)) == NULL )
+				return WERR_NOMEM;
+		}
 	}
 	else
 		*data = NULL;
@@ -2122,7 +2155,7 @@
  Internal routine for removing printerdata
  ***************************************************************************/
 
-static WERROR delete_printer_dataex( NT_PRINTER_INFO_LEVEL *printer, char *key, char *value )
+static WERROR delete_printer_dataex( NT_PRINTER_INFO_LEVEL *printer, const char *key, const char *value )
 {
 	delete_printer_data( printer->info_2, key, value );
 	
@@ -2133,7 +2166,7 @@
  Internal routine for storing printerdata
  ***************************************************************************/
 
-static WERROR set_printer_dataex( NT_PRINTER_INFO_LEVEL *printer, char *key, char *value, 
+static WERROR set_printer_dataex( NT_PRINTER_INFO_LEVEL *printer, const char *key, const char *value, 
                                   uint32 type, uint8 *data, int real_len  )
 {
 	delete_printer_data( printer->info_2, key, value );
@@ -2153,7 +2186,7 @@
 	
 	DEBUG(8,("getprinterdata_printer_server:%s\n", value));
 		
-	if (!strcmp(value, "W3SvcInstalled")) {
+	if (!StrCaseCmp(value, "W3SvcInstalled")) {
 		*type = 0x4;
 		if((*data = (uint8 *)talloc_zero(ctx, 4*sizeof(uint8) )) == NULL)
 			return WERR_NOMEM;
@@ -2161,7 +2194,7 @@
 		return WERR_OK;
 	}
 
-	if (!strcmp(value, "BeepEnabled")) {
+	if (!StrCaseCmp(value, "BeepEnabled")) {
 		*type = 0x4;
 		if((*data = (uint8 *)talloc(ctx, 4*sizeof(uint8) )) == NULL)
 			return WERR_NOMEM;
@@ -2170,7 +2203,7 @@
 		return WERR_OK;
 	}
 
-	if (!strcmp(value, "EventLog")) {
+	if (!StrCaseCmp(value, "EventLog")) {
 		*type = 0x4;
 		if((*data = (uint8 *)talloc(ctx, 4*sizeof(uint8) )) == NULL)
 			return WERR_NOMEM;
@@ -2180,7 +2213,7 @@
 		return WERR_OK;
 	}
 
-	if (!strcmp(value, "NetPopup")) {
+	if (!StrCaseCmp(value, "NetPopup")) {
 		*type = 0x4;
 		if((*data = (uint8 *)talloc(ctx, 4*sizeof(uint8) )) == NULL)
 			return WERR_NOMEM;
@@ -2189,20 +2222,20 @@
 		return WERR_OK;
 	}
 
-	if (!strcmp(value, "MajorVersion")) {
+	if (!StrCaseCmp(value, "MajorVersion")) {
 		*type = 0x4;
 		if((*data = (uint8 *)talloc(ctx, 4*sizeof(uint8) )) == NULL)
 			return WERR_NOMEM;
-#ifndef EMULATE_WIN2K_HACK /* JERRY */
-		SIVAL(*data, 0, 2);
-#else
+#ifdef HAVE_ADS
 		SIVAL(*data, 0, 3);
+#else
+		SIVAL(*data, 0, 2);
 #endif
 		*needed = 0x4;
 		return WERR_OK;
 	}
 
-   	if (!strcmp(value, "DefaultSpoolDirectory")) {
+   	if (!StrCaseCmp(value, "DefaultSpoolDirectory")) {
 		fstring string;
 
 		fstrcpy(string, string_truncate(lp_serverstring(), MAX_SERVER_STRING_LENGTH));
@@ -2220,7 +2253,7 @@
 		return WERR_OK;
 	}
 
-	if (!strcmp(value, "Architecture")) {			
+	if (!StrCaseCmp(value, "Architecture")) {			
 		pstring string="Windows NT x86";
 		*type = 0x1;			
 		*needed = 2*(strlen(string)+1);	
@@ -2233,8 +2266,35 @@
 		}			
 		return WERR_OK;
 	}
-	
-	return WERR_INVALID_PARAM;
+
+	if (!StrCaseCmp(value, "DsPresent")) {
+		*type = 0x4;
+		if((*data = (uint8 *)talloc(ctx, 4*sizeof(uint8) )) == NULL)
+			return WERR_NOMEM;
+		SIVAL(*data, 0, 0x01);
+		*needed = 0x4;
+		return WERR_OK;
+	}
+
+	if (!StrCaseCmp(value, "DNSMachineName")) {			
+		pstring hostname;
+		
+		if (!get_myfullname(hostname))
+			return WERR_BADFILE;
+		*type = 0x1;			
+		*needed = 2*(strlen(hostname)+1);	
+		if((*data  = (uint8 *)talloc(ctx, ((*needed > in_size) ? *needed:in_size) *sizeof(uint8))) == NULL)
+			return WERR_NOMEM;
+		memset(*data, 0, (*needed > in_size) ? *needed:in_size);
+		for (i=0; i<strlen(hostname); i++) {
+			(*data)[2*i]=hostname[i];
+			(*data)[2*i+1]='\0';
+		}			
+		return WERR_OK;
+	}
+
+
+	return WERR_BADFILE;
 }
 
 /********************************************************************
@@ -2292,8 +2352,21 @@
 		status = get_a_printer(&printer, 2, lp_servicename(snum));
 		if ( !W_ERROR_IS_OK(status) )
 			goto done;
-			
-		status = get_printer_dataex( p->mem_ctx, printer, SPOOL_PRINTERDATA_KEY, value, type, data, needed, *out_size );
+
+		/* XP sends this and wants to change id value from the PRINTER_INFO_0 */
+
+		if ( strequal(value, "ChangeId") ) {
+			*type = REG_DWORD;
+			*needed = sizeof(uint32);
+			if ( (*data = (uint8*)talloc(p->mem_ctx, sizeof(uint32))) == NULL) {
+				status = WERR_NOMEM;
+				goto done;
+			}
+			**data = printer->info_2->changeid;
+			status = WERR_OK;
+		}
+		else
+			status = get_printer_dataex( p->mem_ctx, printer, SPOOL_PRINTERDATA_KEY, value, type, data, needed, *out_size );
 	}
 
 	if (*needed > *out_size)
@@ -2302,7 +2375,7 @@
 done:
 	if ( !W_ERROR_IS_OK(status) ) 
 	{
-		DEBUG(5, ("error: allocating %d\n", *out_size));
+		DEBUG(5, ("error %d: allocating %d\n", W_ERROR_V(status),*out_size));
 		
 		/* reply this param doesn't exist */
 		
@@ -3055,7 +3128,7 @@
 	 * Now we're returning job status codes we just return a "" here. JRA.
 	 */
 
-	char *p = "";
+	const char *p = "";
 	pstring temp;
 	uint32 len;
 
@@ -3208,7 +3281,7 @@
 {
 	uint16 type;
 	uint16 field;
-	char *name;
+	const char *name;
 	uint32 size;
 	void (*fn) (int snum, SPOOL_NOTIFY_INFO_DATA *data,
 		    print_queue_struct *queue,
@@ -3219,7 +3292,7 @@
    whether the notification data is a pointer to a variable sized
    buffer, a one value uint32 or a two value uint32. */
 
-struct s_notify_info_data_table notify_info_data_table[] =
+static const struct s_notify_info_data_table notify_info_data_table[] =
 {
 { PRINTER_NOTIFY_TYPE, PRINTER_NOTIFY_SERVER_NAME,         "PRINTER_NOTIFY_SERVER_NAME",         NOTIFY_STRING,   spoolss_notify_server_name },
 { PRINTER_NOTIFY_TYPE, PRINTER_NOTIFY_PRINTER_NAME,        "PRINTER_NOTIFY_PRINTER_NAME",        NOTIFY_STRING,   spoolss_notify_printer_name },
@@ -3680,6 +3753,8 @@
 	/* We need to keep track of the change value to send back in 
            RRPCN replies otherwise our updates are ignored. */
 
+	Printer->notify.fnpcn = True;
+
 	if (Printer->notify.client_connected) {
 		DEBUG(10,("_spoolss_rfnpcnex: Saving change value in request [%x]\n", q_u->change));
 		Printer->notify.change = q_u->change;
@@ -3697,7 +3772,9 @@
 			break;
 	}
 	
- done:
+	Printer->notify.fnpcn = False;
+	
+done:
 	return result;
 }
 
@@ -3776,12 +3853,12 @@
 
 	printer->global_counter = global_counter;
 	printer->total_pages = 0;
-#ifndef EMULATE_WIN2K_HACK	/* JERRY */
-	printer->major_version = 0x0004; 	/* NT 4 */
-	printer->build_version = 0x0565; 	/* build 1381 */
-#else
+#ifdef HAVE_ADS
 	printer->major_version = 0x0005; 	/* NT 5 */
 	printer->build_version = 0x0893; 	/* build 2195 */
+#else
+	printer->major_version = 0x0004; 	/* NT 4 */
+	printer->build_version = 0x0565; 	/* build 1381 */
 #endif
 	printer->unknown7 = 0x1;
 	printer->unknown8 = 0x0;
@@ -4109,6 +4186,29 @@
 }
 
 /********************************************************************
+ * construct_printer_info_7
+ * fill a printer_info_7 struct
+ ********************************************************************/
+
+static BOOL construct_printer_info_7(PRINTER_INFO_7 *printer, int snum)
+{
+	char *guid_str = NULL;
+	GUID guid;
+	
+	if (is_printer_published(snum, &guid)) {
+		asprintf(&guid_str, "{%s}", uuid_string_static(guid));
+		strupper(guid_str);
+		init_unistr(&printer->guid, guid_str);
+		printer->action = SPOOL_DS_PUBLISH;
+	} else {
+		init_unistr(&printer->guid, "");
+		printer->action = SPOOL_DS_UNPUBLISH;
+	}
+
+	return True;
+}
+
+/********************************************************************
  Spoolss_enumprinters.
 ********************************************************************/
 
@@ -4664,6 +4764,37 @@
 	return WERR_OK;	
 }
 
+static WERROR getprinter_level_7(int snum, NEW_BUFFER *buffer, uint32 offered, uint32 *needed)
+{
+	PRINTER_INFO_7 *printer=NULL;
+
+	if((printer=(PRINTER_INFO_7*)malloc(sizeof(PRINTER_INFO_7)))==NULL)
+		return WERR_NOMEM;
+
+	if (!construct_printer_info_7(printer, snum))
+		return WERR_NOMEM;
+	
+	/* check the required size. */	
+	*needed += spoolss_size_printer_info_7(printer);
+
+	if (!alloc_buffer_size(buffer, *needed)) {
+		free_printer_info_7(printer);
+		return WERR_INSUFFICIENT_BUFFER;
+	}
+
+	/* fill the buffer with the structures */
+	smb_io_printer_info_7("", buffer, printer, 0);	
+	
+	/* clear memory */
+	free_printer_info_7(printer);
+	
+	if (*needed > offered) {
+		return WERR_INSUFFICIENT_BUFFER;
+	}
+
+	return WERR_OK;	
+}
+
 /****************************************************************************
 ****************************************************************************/
 
@@ -4699,6 +4830,8 @@
 		return getprinter_level_4(snum, buffer, offered, needed);
 	case 5:		
 		return getprinter_level_5(snum, buffer, offered, needed);
+	case 7:
+		return getprinter_level_7(snum, buffer, offered, needed);
 	}
 	return WERR_UNKNOWN_LEVEL;
 }	
@@ -4802,11 +4935,11 @@
  * convert an array of ascii string to a UNICODE string
  ********************************************************************/
 
-static uint32 init_unistr_array(uint16 **uni_array, fstring *char_array, char *servername)
+static uint32 init_unistr_array(uint16 **uni_array, fstring *char_array, const char *servername)
 {
 	int i=0;
 	int j=0;
-	char *v;
+	const char *v;
 	pstring line;
 	uint16 *tuary;
 
@@ -4833,8 +4966,10 @@
 			pstrcpy( line, v );
 			
 		DEBUGADD(6,("%d:%s:%d\n", i, line, strlen(line)));
+
+		/* add one extra unit16 for the second terminating NULL */
 		
-		if ( (tuary=Realloc(*uni_array, (j+strlen(line)+2)*sizeof(uint16))) == NULL ) {
+		if ( (tuary=Realloc(*uni_array, (j+1+strlen(line)+2)*sizeof(uint16))) == NULL ) {
 			DEBUG(2,("init_unistr_array: Realloc error\n" ));
 			return 0;
 		} else
@@ -4848,6 +4983,9 @@
 	}
 	
 	if (*uni_array) {
+		/* special case for ""; we need to add both NULL's here */
+		if (!j)
+			(*uni_array)[j++]=0x0000;	
 		(*uni_array)[j]=0x0000;
 	}
 	
@@ -5077,6 +5215,7 @@
 	fill_printer_driver_info_6(info, driver, servername);
 
 	free_a_printer(&printer,2);
+	free_a_printer_driver(driver, 3);
 
 	return WERR_OK;
 }
@@ -5269,7 +5408,7 @@
 	*servermajorversion = 0;
 	*serverminorversion = 0;
 
-	pstrcpy(servername, get_called_name());
+	fstrcpy(servername, get_called_name());
 	unistr2_to_ascii(architecture, uni_arch, sizeof(architecture)-1);
 
 	if (!get_printer_snum(p, handle, &snum))
@@ -5631,7 +5770,7 @@
 	fstrcpy(info->sharename, lp_servicename(snum));
 	slprintf(info->printername, sizeof(info->printername)-1, "\\\\%s\\%s",
 		 get_called_name(), info->sharename);
-	info->attributes = PRINTER_ATTRIBUTE_SHARED | PRINTER_ATTRIBUTE_NETWORK;
+	info->attributes = PRINTER_ATTRIBUTE_SAMBA;
 	
 	return True;
 }
@@ -5839,6 +5978,34 @@
 
 /****************************************************************************
 ****************************************************************************/
+static WERROR publish_or_unpublish_printer(pipes_struct *p, POLICY_HND *handle,
+				   const SPOOL_PRINTER_INFO_LEVEL *info)
+{
+#ifdef HAVE_ADS
+	SPOOL_PRINTER_INFO_LEVEL_7 *info7 = info->info_7;
+	int snum;
+	Printer_entry *Printer = find_printer_index_by_hnd(p, handle);
+	WERROR result;
+
+	DEBUG(5,("publish_or_unpublish_printer, action = %d\n",info7->action));
+
+	result = WERR_OK;
+
+	if (!Printer)
+		return WERR_BADFID;
+
+	if (!get_printer_snum(p, handle, &snum))
+		return WERR_BADFID;
+	
+	nt_printer_publish(snum, info7->action);
+	
+	return WERR_OK;
+#else
+	return WERR_UNKNOWN_LEVEL;
+#endif
+}
+/****************************************************************************
+****************************************************************************/
 
 WERROR _spoolss_setprinter(pipes_struct *p, SPOOL_Q_SETPRINTER *q_u, SPOOL_R_SETPRINTER *r_u)
 {
@@ -5865,6 +6032,8 @@
 		case 3:
 			return update_printer_sec(handle, level, info, p,
 						  secdesc_ctr);
+		case 7:
+			return publish_or_unpublish_printer(p, handle, info);
 		default:
 			return WERR_UNKNOWN_LEVEL;
 	}
@@ -5959,7 +6128,6 @@
 			    DEVICEMODE *devmode)
 {
 	pstring temp_name;
-	pstring chaine;
 	struct tm *t;
 
 	t=gmtime(&queue->time);
@@ -5967,9 +6135,7 @@
 
 	job_info->jobid=queue->job;
 	
-	slprintf(chaine, sizeof(chaine)-1, "\\\\%s\\%s", get_called_name(), ntprinter->info_2->printername);
-
-	init_unistr(&job_info->printername, chaine);
+	init_unistr(&job_info->printername, ntprinter->info_2->printername);
 	
 	init_unistr(&job_info->machinename, temp_name);
 	init_unistr(&job_info->username, queue->fs_user);
@@ -6708,7 +6874,7 @@
 /****************************************************************************
 ****************************************************************************/
 
-static void fill_port_1(PORT_INFO_1 *port, char *name)
+static void fill_port_1(PORT_INFO_1 *port, const char *name)
 {
 	init_unistr(&port->port_name, name);
 }
@@ -6716,7 +6882,7 @@
 /****************************************************************************
 ****************************************************************************/
 
-static void fill_port_2(PORT_INFO_2 *port, char *name)
+static void fill_port_2(PORT_INFO_2 *port, const char *name)
 {
 	init_unistr(&port->port_name, name);
 	init_unistr(&port->monitor_name, "Local Monitor");
diff -uNr samba-3.0alpha21.orig/source/rpc_server/srv_srvsvc.c samba-3.0alpha21/source/rpc_server/srv_srvsvc.c
--- samba-3.0alpha21.orig/source/rpc_server/srv_srvsvc.c	2003-02-16 19:06:33.000000000 -0600
+++ samba-3.0alpha21/source/rpc_server/srv_srvsvc.c	2003-02-16 19:05:47.000000000 -0600
@@ -3,8 +3,9 @@
  *  RPC Pipe client / server routines
  *  Copyright (C) Andrew Tridgell              1992-1997,
  *  Copyright (C) Luke Kenneth Casson Leighton 1996-1997,
- *  Copyright (C) Paul Ashton                       1997.
- *  Copyright (C) Jeremy Allison					2001.
+ *  Copyright (C) Paul Ashton                       1997,
+ *  Copyright (C) Jeremy Allison                    2001,
+ *  Copyright (C) Anthony Liguori                   2003.
  *  
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License as published by
@@ -525,32 +526,32 @@
 \PIPE\srvsvc commands
 ********************************************************************/
 
-static const struct api_struct api_srv_cmds[] =
-{
-	{ "SRV_NET_CONN_ENUM"       ,  SRV_NET_CONN_ENUM       ,   api_srv_net_conn_enum    },
-	{ "SRV_NET_SESS_ENUM"       ,  SRV_NET_SESS_ENUM       ,   api_srv_net_sess_enum    },
-	{ "SRV_NET_SHARE_ENUM_ALL"  ,  SRV_NET_SHARE_ENUM_ALL  ,   api_srv_net_share_enum_all   },
-	{ "SRV_NET_SHARE_ENUM"      ,  SRV_NET_SHARE_ENUM      ,   api_srv_net_share_enum   },
-	{ "SRV_NET_SHARE_ADD"     ,    SRV_NET_SHARE_ADD     ,     api_srv_net_share_add },
-	{ "SRV_NET_SHARE_DEL"     ,    SRV_NET_SHARE_DEL     ,     api_srv_net_share_del },
-	{ "SRV_NET_SHARE_DEL_STICKY", SRV_NET_SHARE_DEL_STICKY,    api_srv_net_share_del_sticky  },
-	{ "SRV_NET_SHARE_GET_INFO",    SRV_NET_SHARE_GET_INFO,     api_srv_net_share_get_info },
-	{ "SRV_NET_SHARE_SET_INFO",    SRV_NET_SHARE_SET_INFO,     api_srv_net_share_set_info },
-	{ "SRV_NET_FILE_ENUM"       ,  SRV_NET_FILE_ENUM       ,   api_srv_net_file_enum    },
-	{ "SRV_NET_SRV_GET_INFO"  ,    SRV_NET_SRV_GET_INFO  ,     api_srv_net_srv_get_info },
-	{ "SRV_NET_SRV_SET_INFO"  ,    SRV_NET_SRV_SET_INFO  ,     api_srv_net_srv_set_info },
-	{ "SRV_NET_REMOTE_TOD"    ,    SRV_NET_REMOTE_TOD    ,     api_srv_net_remote_tod   },
-	{ "SRV_NET_DISK_ENUM"     ,    SRV_NET_DISK_ENUM     ,     api_srv_net_disk_enum    },
-	{ "SRV_NET_NAME_VALIDATE" ,    SRV_NET_NAME_VALIDATE ,     api_srv_net_name_validate},
-	{ "SRV_NET_FILE_QUERY_SECDESC",SRV_NET_FILE_QUERY_SECDESC, api_srv_net_file_query_secdesc},
-	{ "SRV_NET_FILE_SET_SECDESC" , SRV_NET_FILE_SET_SECDESC ,  api_srv_net_file_set_secdesc},
-	{ NULL                    ,    0                     ,     NULL                     }
-};
-
-/*******************************************************************
-receives a srvsvc pipe and responds.
-********************************************************************/
-BOOL api_srvsvc_rpc(pipes_struct *p)
-{
-	return api_rpcTNP(p, "api_srvsvc_rpc", api_srv_cmds);
+#ifdef RPC_SVC_DYNAMIC
+int rpc_pipe_init(void)
+#else
+int rpc_srv_init(void)
+#endif
+{
+  static const struct api_struct api_srv_cmds[] =
+    {
+      { "SRV_NET_CONN_ENUM"         , SRV_NET_CONN_ENUM         , api_srv_net_conn_enum          },
+      { "SRV_NET_SESS_ENUM"         , SRV_NET_SESS_ENUM         , api_srv_net_sess_enum          },
+      { "SRV_NET_SHARE_ENUM_ALL"    , SRV_NET_SHARE_ENUM_ALL    , api_srv_net_share_enum_all     },
+      { "SRV_NET_SHARE_ENUM"        , SRV_NET_SHARE_ENUM        , api_srv_net_share_enum         },
+      { "SRV_NET_SHARE_ADD"         , SRV_NET_SHARE_ADD         , api_srv_net_share_add          },
+      { "SRV_NET_SHARE_DEL"         , SRV_NET_SHARE_DEL         , api_srv_net_share_del          },
+      { "SRV_NET_SHARE_DEL_STICKY"  , SRV_NET_SHARE_DEL_STICKY  , api_srv_net_share_del_sticky   },
+      { "SRV_NET_SHARE_GET_INFO"    , SRV_NET_SHARE_GET_INFO    , api_srv_net_share_get_info     },
+      { "SRV_NET_SHARE_SET_INFO"    , SRV_NET_SHARE_SET_INFO    , api_srv_net_share_set_info     },
+      { "SRV_NET_FILE_ENUM"         , SRV_NET_FILE_ENUM         , api_srv_net_file_enum          },
+      { "SRV_NET_SRV_GET_INFO"      , SRV_NET_SRV_GET_INFO      , api_srv_net_srv_get_info       },
+      { "SRV_NET_SRV_SET_INFO"      , SRV_NET_SRV_SET_INFO      , api_srv_net_srv_set_info       },
+      { "SRV_NET_REMOTE_TOD"        , SRV_NET_REMOTE_TOD        , api_srv_net_remote_tod         },
+      { "SRV_NET_DISK_ENUM"         , SRV_NET_DISK_ENUM         , api_srv_net_disk_enum          },
+      { "SRV_NET_NAME_VALIDATE"     , SRV_NET_NAME_VALIDATE     , api_srv_net_name_validate      },
+      { "SRV_NET_FILE_QUERY_SECDESC", SRV_NET_FILE_QUERY_SECDESC, api_srv_net_file_query_secdesc },
+      { "SRV_NET_FILE_SET_SECDESC"  , SRV_NET_FILE_SET_SECDESC  , api_srv_net_file_set_secdesc   }
+    };
+  return rpc_pipe_register_commands("srvsvc", "ntsvcs", api_srv_cmds,
+				    sizeof(api_srv_cmds) / sizeof(struct api_struct));
 }
diff -uNr samba-3.0alpha21.orig/source/rpc_server/srv_srvsvc_nt.c samba-3.0alpha21/source/rpc_server/srv_srvsvc_nt.c
--- samba-3.0alpha21.orig/source/rpc_server/srv_srvsvc_nt.c	2003-02-16 19:06:33.000000000 -0600
+++ samba-3.0alpha21/source/rpc_server/srv_srvsvc_nt.c	2003-02-16 19:05:47.000000000 -0600
@@ -128,7 +128,7 @@
 BOOL share_info_db_init(void)
 {
 	static pid_t local_pid;
-	char *vstring = "INFO/version";
+	const char *vstring = "INFO/version";
 	int32 vers_id;
  
 	if (share_tdb && local_pid == sys_getpid())
@@ -237,7 +237,7 @@
 	fstring key;
 	BOOL ret = False;
 
-	mem_ctx = talloc_init();
+	mem_ctx = talloc_init("set_share_security");
 	if (mem_ctx == NULL)
 		return False;
 
@@ -327,7 +327,7 @@
 	NT_USER_TOKEN *token = NULL;
 	BOOL ret = True;
 
-	mem_ctx = talloc_init();
+	mem_ctx = talloc_init("share_access_check");
 	if (mem_ctx == NULL)
 		return False;
 
@@ -1008,7 +1008,7 @@
 static void init_srv_conn_1_info(CONN_INFO_1 *se1, CONN_INFO_1_STR *str1,
 				uint32 id, uint32 type,
 				uint32 num_opens, uint32 num_users, uint32 open_time,
-				char *usr_name, char *net_name)
+				const char *usr_name, const char *net_name)
 {
 	init_srv_conn_info1(se1 , id, type, num_opens, num_users, open_time, usr_name, net_name);
 	init_srv_conn_info1_str(str1, usr_name, net_name);
@@ -1481,7 +1481,7 @@
 
 	switch (q_u->info_level) {
 	case 1:
-		fstrcpy(pathname, lp_pathname(snum));
+		pstrcpy(pathname, lp_pathname(snum));
 		unistr2_to_ascii(comment, &q_u->info.share.info2.info_2_str.uni_remark, sizeof(comment));
 		type = q_u->info.share.info2.info_2.type;
 		psd = NULL;
@@ -1508,7 +1508,7 @@
 		map_generic_share_sd_bits(psd);
 		break;
 	case 1004:
-		fstrcpy(pathname, lp_pathname(snum));
+		pstrcpy(pathname, lp_pathname(snum));
 		unistr2_to_ascii(comment, &q_u->info.share.info1004.info_1004_str.uni_remark, sizeof(comment));
 		type = STYPE_DISKTREE;
 		break;
@@ -1518,7 +1518,7 @@
 		return WERR_ACCESS_DENIED;
 		break;
 	case 1501:
-		fstrcpy(pathname, lp_pathname(snum));
+		pstrcpy(pathname, lp_pathname(snum));
 		fstrcpy(comment, lp_comment(snum));
 		psd = q_u->info.share.info1501.sdb->sec;
 		map_generic_share_sd_bits(psd);
diff -uNr samba-3.0alpha21.orig/source/rpc_server/srv_util.c samba-3.0alpha21/source/rpc_server/srv_util.c
--- samba-3.0alpha21.orig/source/rpc_server/srv_util.c	2003-02-16 19:06:33.000000000 -0600
+++ samba-3.0alpha21/source/rpc_server/srv_util.c	2003-02-16 19:05:47.000000000 -0600
@@ -342,6 +342,7 @@
 	DEBUG(0,("get_domain_user_groups: primary gid of user [%s] is not a Domain group !\n", user_name));
 	DEBUGADD(0,("get_domain_user_groups: You should fix it, NT doesn't like that\n"));
 
+
  done:
 	*pgids=gids;
 	*numgroups=cur_gid;
@@ -351,6 +352,35 @@
 }
 
 /*******************************************************************
+ gets a domain user's groups from their already-calculated NT_USER_TOKEN
+ ********************************************************************/
+NTSTATUS nt_token_to_group_list(TALLOC_CTX *mem_ctx, const DOM_SID *domain_sid, 
+				const NT_USER_TOKEN *nt_token,
+				int *numgroups, DOM_GID **pgids) 
+{
+	DOM_GID *gids;
+	int i;
+
+	gids = (DOM_GID *)talloc(mem_ctx, sizeof(*gids) * nt_token->num_sids);
+
+	if (!gids) {
+		return NT_STATUS_NO_MEMORY;
+	}
+
+	*numgroups=0;
+
+	for (i=PRIMARY_GROUP_SID_INDEX; i < nt_token->num_sids; i++) {
+		if (sid_compare_domain(domain_sid, &nt_token->user_sids[i])==0) {
+			sid_peek_rid(&nt_token->user_sids[i], &(gids[*numgroups].g_rid));
+			gids[*numgroups].attr=7;
+			(*numgroups)++;
+		}
+	}
+	*pgids = gids; 
+	return NT_STATUS_OK;
+}
+
+/*******************************************************************
  Look up a local (domain) rid and return a name and type.
  ********************************************************************/
 NTSTATUS local_lookup_group_name(uint32 rid, char *group_name, uint32 *type)
@@ -455,7 +485,7 @@
  ********************************************************************/
 NTSTATUS local_lookup_group_rid(char *group_name, uint32 *rid)
 {
-	char *grp_name;
+	const char *grp_name;
 	int i = -1; /* start do loop at -1 */
 
 	do /* find, if it exists, a group rid for the group name*/
@@ -472,9 +502,9 @@
 /*******************************************************************
  Look up a local (BUILTIN) alias name and return a rid
  ********************************************************************/
-NTSTATUS local_lookup_alias_rid(char *alias_name, uint32 *rid)
+NTSTATUS local_lookup_alias_rid(const char *alias_name, uint32 *rid)
 {
-	char *als_name;
+	const char *als_name;
 	int i = -1; /* start do loop at -1 */
 
 	do /* find, if it exists, a alias rid for the alias name*/
diff -uNr samba-3.0alpha21.orig/source/rpc_server/srv_wkssvc.c samba-3.0alpha21/source/rpc_server/srv_wkssvc.c
--- samba-3.0alpha21.orig/source/rpc_server/srv_wkssvc.c	2003-02-16 19:06:33.000000000 -0600
+++ samba-3.0alpha21/source/rpc_server/srv_wkssvc.c	2003-02-16 19:05:47.000000000 -0600
@@ -3,7 +3,8 @@
  *  RPC Pipe client / server routines
  *  Copyright (C) Andrew Tridgell              1992-1997,
  *  Copyright (C) Luke Kenneth Casson Leighton 1996-1997,
- *  Copyright (C) Paul Ashton                       1997.
+ *  Copyright (C) Paul Ashton                       1997,
+ *  Copyright (C) Anthony Liguori                   2003.
  *  
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License as published by
@@ -58,16 +59,17 @@
 /*******************************************************************
  \PIPE\wkssvc commands
  ********************************************************************/
-static struct api_struct api_wks_cmds[] =
-{
-	{ "WKS_Q_QUERY_INFO", WKS_QUERY_INFO, api_wks_query_info },
-	{ NULL             , 0            , NULL }
-};
 
-/*******************************************************************
- receives a wkssvc pipe and responds.
- ********************************************************************/
-BOOL api_wkssvc_rpc(pipes_struct *p)
+#ifdef RPC_WKS_DYNAMIC
+int rpc_pipe_init(void)
+#else
+int rpc_wks_init(void)
+#endif
 {
-	return api_rpcTNP(p, "api_wkssvc_rpc", api_wks_cmds);
+  static struct api_struct api_wks_cmds[] =
+    {
+      { "WKS_Q_QUERY_INFO", WKS_QUERY_INFO, api_wks_query_info }
+    };
+  return rpc_pipe_register_commands("wkssvc", "ntsvcs", api_wks_cmds,
+				    sizeof(api_wks_cmds) / sizeof(struct api_struct));
 }
diff -uNr samba-3.0alpha21.orig/source/rpcclient/cmd_lsarpc.c samba-3.0alpha21/source/rpcclient/cmd_lsarpc.c
--- samba-3.0alpha21.orig/source/rpcclient/cmd_lsarpc.c	2003-02-16 19:06:33.000000000 -0600
+++ samba-3.0alpha21/source/rpcclient/cmd_lsarpc.c	2003-02-16 19:05:47.000000000 -0600
@@ -1,4 +1,4 @@
-/* 
+/*
    Unix SMB/CIFS implementation.
    RPC pipe client
 
@@ -23,6 +23,43 @@
 #include "includes.h"
 #include "rpcclient.h"
 
+
+/* useful function to allow entering a name instead of a SID and
+ * looking it up automatically */
+static NTSTATUS name_to_sid(struct cli_state *cli, 
+			    TALLOC_CTX *mem_ctx,
+			    DOM_SID *sid, const char *name)
+{
+	POLICY_HND pol;
+	uint32 *sid_types;
+	NTSTATUS result;
+	DOM_SID *sids;
+
+	/* maybe its a raw SID */
+	if (strncmp(name, "S-", 2) == 0 &&
+	    string_to_sid(sid, name)) {
+		return NT_STATUS_OK;
+	}
+
+	result = cli_lsa_open_policy(cli, mem_ctx, True, 
+				     SEC_RIGHTS_MAXIMUM_ALLOWED,
+				     &pol);
+	if (!NT_STATUS_IS_OK(result))
+		goto done;
+
+	result = cli_lsa_lookup_names(cli, mem_ctx, &pol, 1, &name, &sids, &sid_types);
+	if (!NT_STATUS_IS_OK(result))
+		goto done;
+
+	cli_lsa_close(cli, mem_ctx, &pol);
+
+	*sid = sids[0];
+
+done:
+	return result;
+}
+
+
 /* Look up domain related information on a remote host */
 
 static NTSTATUS cmd_lsa_query_info_policy(struct cli_state *cli, 
@@ -422,7 +459,9 @@
 		return NT_STATUS_OK;
 	}
 
-	string_to_sid(&sid, argv[1]);
+	result = name_to_sid(cli, mem_ctx, &sid, argv[1]);
+	if (!NT_STATUS_IS_OK(result))
+		goto done;	
 
 	result = cli_lsa_open_policy2(cli, mem_ctx, True, 
 				     SEC_RIGHTS_MAXIMUM_ALLOWED,
@@ -453,6 +492,130 @@
 	return result;
 }
 
+
+/* Enumerate the privileges of an SID via LsaEnumerateAccountRights */
+
+static NTSTATUS cmd_lsa_enum_acct_rights(struct cli_state *cli, 
+					 TALLOC_CTX *mem_ctx, int argc, 
+					 char **argv) 
+{
+	POLICY_HND dom_pol;
+	NTSTATUS result = NT_STATUS_UNSUCCESSFUL;
+
+	DOM_SID sid;
+	uint32 count;
+	char **rights;
+
+	int i;
+
+	if (argc != 2 ) {
+		printf("Usage: %s SID\n", argv[0]);
+		return NT_STATUS_OK;
+	}
+
+	result = name_to_sid(cli, mem_ctx, &sid, argv[1]);
+	if (!NT_STATUS_IS_OK(result))
+		goto done;	
+
+	result = cli_lsa_open_policy2(cli, mem_ctx, True, 
+				     SEC_RIGHTS_MAXIMUM_ALLOWED,
+				     &dom_pol);
+
+	if (!NT_STATUS_IS_OK(result))
+		goto done;
+
+	result = cli_lsa_enum_account_rights(cli, mem_ctx, &dom_pol, sid, &count, &rights);
+
+	if (!NT_STATUS_IS_OK(result))
+		goto done;
+
+	printf("found %d privileges for SID %s\n", count, sid_string_static(&sid));
+
+	for (i = 0; i < count; i++) {
+		printf("\t%s\n", rights[i]);
+	}
+
+ done:
+	return result;
+}
+
+
+/* add some privileges to a SID via LsaAddAccountRights */
+
+static NTSTATUS cmd_lsa_add_acct_rights(struct cli_state *cli, 
+					TALLOC_CTX *mem_ctx, int argc, 
+					const char **argv) 
+{
+	POLICY_HND dom_pol;
+	NTSTATUS result = NT_STATUS_UNSUCCESSFUL;
+
+	DOM_SID sid;
+
+	if (argc < 3 ) {
+		printf("Usage: %s SID [rights...]\n", argv[0]);
+		return NT_STATUS_OK;
+	}
+
+	result = name_to_sid(cli, mem_ctx, &sid, argv[1]);
+	if (!NT_STATUS_IS_OK(result))
+		goto done;	
+
+	result = cli_lsa_open_policy2(cli, mem_ctx, True, 
+				     SEC_RIGHTS_MAXIMUM_ALLOWED,
+				     &dom_pol);
+
+	if (!NT_STATUS_IS_OK(result))
+		goto done;
+
+	result = cli_lsa_add_account_rights(cli, mem_ctx, &dom_pol, sid, 
+					    argc-2, argv+2);
+
+	if (!NT_STATUS_IS_OK(result))
+		goto done;
+
+ done:
+	return result;
+}
+
+
+/* remove some privileges to a SID via LsaRemoveAccountRights */
+
+static NTSTATUS cmd_lsa_remove_acct_rights(struct cli_state *cli, 
+					TALLOC_CTX *mem_ctx, int argc, 
+					const char **argv) 
+{
+	POLICY_HND dom_pol;
+	NTSTATUS result = NT_STATUS_UNSUCCESSFUL;
+
+	DOM_SID sid;
+
+	if (argc < 3 ) {
+		printf("Usage: %s SID [rights...]\n", argv[0]);
+		return NT_STATUS_OK;
+	}
+
+	result = name_to_sid(cli, mem_ctx, &sid, argv[1]);
+	if (!NT_STATUS_IS_OK(result))
+		goto done;	
+
+	result = cli_lsa_open_policy2(cli, mem_ctx, True, 
+				     SEC_RIGHTS_MAXIMUM_ALLOWED,
+				     &dom_pol);
+
+	if (!NT_STATUS_IS_OK(result))
+		goto done;
+
+	result = cli_lsa_remove_account_rights(cli, mem_ctx, &dom_pol, sid, 
+					       False, argc-2, argv+2);
+
+	if (!NT_STATUS_IS_OK(result))
+		goto done;
+
+ done:
+	return result;
+}
+
+
 /* Get a privilege value given its name */
 
 static NTSTATUS cmd_lsa_lookupprivvalue(struct cli_state *cli, 
@@ -539,6 +702,9 @@
 	{ "getdispname",         cmd_lsa_get_dispname,       PI_LSARPC, "Get the privilege name",               "" },
 	{ "lsaenumsid",          cmd_lsa_enum_sids,          PI_LSARPC, "Enumerate the LSA SIDS",               "" },
 	{ "lsaenumprivsaccount", cmd_lsa_enum_privsaccounts, PI_LSARPC, "Enumerate the privileges of an SID",   "" },
+	{ "lsaenumacctrights",   cmd_lsa_enum_acct_rights,   PI_LSARPC, "Enumerate the rights of an SID",   "" },
+	{ "lsaaddacctrights",    cmd_lsa_add_acct_rights,    PI_LSARPC, "Add rights to an account",   "" },
+	{ "lsaremoveacctrights", cmd_lsa_remove_acct_rights, PI_LSARPC, "Remove rights from an account",   "" },
 	{ "lsalookupprivvalue",  cmd_lsa_lookupprivvalue,    PI_LSARPC, "Get a privilege value given its name", "" },
 	{ "lsaquerysecobj",      cmd_lsa_query_secobj,       PI_LSARPC, "Query LSA security object", "" },
 
diff -uNr samba-3.0alpha21.orig/source/rpcclient/cmd_reg.c samba-3.0alpha21/source/rpcclient/cmd_reg.c
--- samba-3.0alpha21.orig/source/rpcclient/cmd_reg.c	2003-02-16 19:06:33.000000000 -0600
+++ samba-3.0alpha21/source/rpcclient/cmd_reg.c	2003-02-16 19:05:47.000000000 -0600
@@ -900,7 +900,8 @@
 	NTSTATUS result = NT_STATUS_UNSUCCESSFUL;
 	fstring msg;
 	uint32 timeout = 20;
-	uint16 flgs = 0;
+	BOOL force = False;
+	BOOL reboot = False;
 	int opt;
 
 	*msg = 0;
@@ -908,37 +909,33 @@
 
 	while ((opt = getopt(argc, argv, "m:t:rf")) != EOF)
 	{
-		fprintf (stderr, "[%s]\n", argv[argc-1]);
+		/*fprintf (stderr, "[%s]\n", argv[argc-1]);*/
 	
 		switch (opt)
 		{
 			case 'm':
-			{
 				safe_strcpy(msg, optarg, sizeof(msg)-1);
-				fprintf (stderr, "[%s|%s]\n", optarg, msg);
+				/*fprintf (stderr, "[%s|%s]\n", optarg, msg);*/
 				break;
-			}
+
 			case 't':
-			{
 				timeout = atoi(optarg);
-				fprintf (stderr, "[%s|%d]\n", optarg, timeout);
-			break;
-			}
+				/*fprintf (stderr, "[%s|%d]\n", optarg, timeout);*/
+				break;
+
 			case 'r':
-			{
-				flgs |= 0x100;
-			break;
-			}
+				reboot = True;
+				break;
+
 			case 'f':
-			{
-				flgs |= 0x001;
+				force = True;
 				break;
-			}
+
 		}
 	}
 
 	/* create an entry */
-	result = cli_reg_shutdown(cli, mem_ctx, msg, timeout, flgs);
+	result = cli_reg_shutdown(cli, mem_ctx, msg, timeout, reboot, force);
 
 	if (NT_STATUS_IS_OK(result))
 		DEBUG(5,("cmd_reg_shutdown: query succeeded\n"));
@@ -974,10 +971,10 @@
 	{ "REG"  },
 
 	{ "shutdown",		cmd_reg_shutdown,		PI_WINREG, "Remote Shutdown",
-				"[-m message] [-t timeout] [-r] [-f] (-r == reboot, -f == force)" },
+				"syntax: shutdown [-m message] [-t timeout] [-r] [-h] [-f] (-r == reboot, -h == halt, -f == force)" },
 				
 	{ "abortshutdown",	cmd_reg_abort_shutdown,		PI_WINREG, "Abort Shutdown",
-				"" },				
+				"syntax: abortshutdown" },
 /*
 	{ "regenum",		cmd_reg_enum,			"Registry Enumeration",
 				"<keyname>" },
diff -uNr samba-3.0alpha21.orig/source/rpcclient/cmd_samr.c samba-3.0alpha21/source/rpcclient/cmd_samr.c
--- samba-3.0alpha21.orig/source/rpcclient/cmd_samr.c	2003-02-16 19:06:33.000000000 -0600
+++ samba-3.0alpha21/source/rpcclient/cmd_samr.c	2003-02-16 19:05:47.000000000 -0600
@@ -94,7 +94,7 @@
 	}
 }
 
-static char *display_time(NTTIME nttime)
+static const char *display_time(NTTIME nttime)
 {
 	static fstring string;
 
@@ -379,7 +379,7 @@
 	NTSTATUS result = NT_STATUS_UNSUCCESSFUL;
 	uint32 info_level = 1;
 	uint32 access_mask = MAXIMUM_ALLOWED_ACCESS;
-	GROUP_INFO_CTR group_ctr;
+	GROUP_INFO_CTR *group_ctr;
 	fstring			server;	
 	uint32 group_rid;
 	
@@ -419,15 +419,13 @@
 	if (!NT_STATUS_IS_OK(result))
 		goto done;
 
-	ZERO_STRUCT(group_ctr);
-
 	result = cli_samr_query_groupinfo(cli, mem_ctx, &group_pol, 
 					  info_level, &group_ctr);
 	if (!NT_STATUS_IS_OK(result)) {
 		goto done;
 	}
 
-	display_group_info_ctr(&group_ctr);
+	display_group_info_ctr(group_ctr);
 
 done:
 	return result;
@@ -865,7 +863,7 @@
 {
 	POLICY_HND connect_pol, domain_pol;
 	NTSTATUS result = NT_STATUS_UNSUCCESSFUL;
-	uint32 start_idx=0, max_entries=250, num_entries, i;
+	uint32 start_idx=0, max_entries=250, max_size = 0xffff, num_entries, i;
 	uint32 access_mask = MAXIMUM_ALLOWED_ACCESS;
 	uint32 info_level = 1;
 	SAM_DISPINFO_CTR ctr;
@@ -874,9 +872,11 @@
 	SAM_DISPINFO_3 info3;
 	SAM_DISPINFO_4 info4;
 	SAM_DISPINFO_5 info5;
+	int loop_count = 0;
+	BOOL got_params = False; /* Use get_query_dispinfo_params() or not? */
 
 	if (argc > 5) {
-		printf("Usage: %s [info level] [start index] [max entries] [access mask]\n", argv[0]);
+		printf("Usage: %s [info level] [start index] [max entries] [max size] [access mask]\n", argv[0]);
 		return NT_STATUS_OK;
 	}
 
@@ -886,11 +886,18 @@
 	if (argc >= 3)
                 sscanf(argv[2], "%i", &start_idx);
         
-	if (argc >= 4)
+	if (argc >= 4) {
                 sscanf(argv[3], "%i", &max_entries);
+		got_params = True;
+	}
+	
+	if (argc >= 5) {
+                sscanf(argv[4], "%i", &max_size);
+		got_params = True;
+	}
 	
-	if (argc >= 5)
-                sscanf(argv[4], "%x", &access_mask);
+	if (argc >= 6)
+                sscanf(argv[5], "%x", &access_mask);
 
 	/* Get sam policy handle */
 
@@ -940,9 +947,16 @@
 
 	while(1) {
 
+		if (!got_params)
+			get_query_dispinfo_params(
+				loop_count, &max_entries, &max_size);
+		
 		result = cli_samr_query_dispinfo(cli, mem_ctx, &domain_pol,
 						 &start_idx, info_level,
-						 &num_entries, max_entries, &ctr);
+						 &num_entries, max_entries, 
+						 max_size, &ctr);
+
+		loop_count++;
 
 		if (!NT_STATUS_IS_OK(result) && !NT_STATUS_EQUAL(result, STATUS_MORE_ENTRIES)) 
 			break;
@@ -1312,7 +1326,7 @@
 	SEC_DESC_BUF *sec_desc_buf=NULL;
 	BOOL domain = False;
 
-	ctx=talloc_init();
+	ctx=talloc_init("cmd_samr_query_sec_obj");
 	
 	if ((argc < 1) || (argc > 2)) {
 		printf("Usage: %s [rid|-d]\n", argv[0]);
diff -uNr samba-3.0alpha21.orig/source/rpcclient/cmd_spoolss.c samba-3.0alpha21/source/rpcclient/cmd_spoolss.c
--- samba-3.0alpha21.orig/source/rpcclient/cmd_spoolss.c	2003-02-16 19:06:33.000000000 -0600
+++ samba-3.0alpha21/source/rpcclient/cmd_spoolss.c	2003-02-16 19:05:47.000000000 -0600
@@ -26,12 +26,12 @@
 #include "rpcclient.h"
 
 struct table_node {
-	char 	*long_archi;
-	char 	*short_archi;
+	const char 	*long_archi;
+	const char 	*short_archi;
 	int	version;
 };
  
-struct table_node archi_table[]= {
+static const struct table_node archi_table[]= {
 
 	{"Windows 4.0",          "WIN40",	0 },
 	{"Windows NT x86",       "W32X86",	2 },
@@ -45,7 +45,7 @@
 function to do the mapping between the long architecture name and
 the short one.
 ****************************************************************************/
-BOOL get_short_archi(char *short_archi, char *long_archi)
+BOOL get_short_archi(char *short_archi, const char *long_archi)
 {
         int i=-1;
 
@@ -60,6 +60,8 @@
                 return False;
         }
 
+	/* this might be client code - but shouldn't this be an fstrcpy etc? */
+
         StrnCpy (short_archi, archi_table[i].short_archi, strlen(archi_table[i].short_archi));
 
         DEBUGADD(108,("index: [%d]\n", i));
@@ -90,7 +92,7 @@
                                             int argc, char **argv)
 {
 	WERROR 	        werror;
-	pstring		printername;
+	fstring		printername;
 	fstring		servername, user;
 	POLICY_HND	hnd;
 	
@@ -102,7 +104,7 @@
 	if (!cli)
 		return NT_STATUS_UNSUCCESSFUL;
 
-	slprintf (servername, sizeof(fstring)-1, "\\\\%s", cli->desthost);
+	slprintf (servername, sizeof(servername)-1, "\\\\%s", cli->desthost);
 	strupper (servername);
 	fstrcpy  (user, cli->user_name);
 	fstrcpy  (printername, argv[1]);
@@ -110,7 +112,7 @@
 	/* Open the printer handle */
 
 	werror = cli_spoolss_open_printer_ex(cli, mem_ctx, printername, 
-					     "", MAXIMUM_ALLOWED_ACCESS, 
+					     "", PRINTER_ALL_ACCESS, 
 					     servername, user, &hnd);
 
 	if (W_ERROR_IS_OK(werror)) {
@@ -138,11 +140,9 @@
 	if (!i0)
 		return;
 
-	if (i0->printername.buffer)
-		rpcstr_pull(name, i0->printername.buffer, sizeof(name), -1, STR_TERMINATE);
+	rpcstr_pull(name, i0->printername.buffer, sizeof(name), -1, STR_TERMINATE);
 
-	if (i0->servername.buffer)
-		rpcstr_pull(servername, i0->servername.buffer, sizeof(servername), -1,STR_TERMINATE);
+	rpcstr_pull(servername, i0->servername.buffer, sizeof(servername), -1,STR_TERMINATE);
   
 	printf("\tprintername:[%s]\n", name);
 	printf("\tservername:[%s]\n", servername);
@@ -196,17 +196,11 @@
 	fstring name = "";
 	fstring comm = "";
 
-	if (i1->description.buffer)
-		rpcstr_pull(desc, i1->description.buffer, sizeof(desc), -1,
-			    STR_TERMINATE);
-
-	if (i1->name.buffer)
-		rpcstr_pull(name, i1->name.buffer, sizeof(name), -1, 
-			    STR_TERMINATE);
+	rpcstr_pull(desc, i1->description.buffer, sizeof(desc), -1,
+		    STR_TERMINATE);
 
-	if (i1->comment.buffer)
-		rpcstr_pull(comm, i1->comment.buffer, sizeof(comm), -1, 
-			    STR_TERMINATE);
+	rpcstr_pull(name, i1->name.buffer, sizeof(name), -1, STR_TERMINATE);
+	rpcstr_pull(comm, i1->comment.buffer, sizeof(comm), -1, STR_TERMINATE);
 
 	printf("\tflags:[0x%x]\n", i1->flags);
 	printf("\tname:[%s]\n", name);
@@ -233,38 +227,27 @@
 	fstring datatype = "";
 	fstring parameters = "";
 	
-	if (i2->servername.buffer)
-		rpcstr_pull(servername, i2->servername.buffer,sizeof(servername), -1, STR_TERMINATE);
+	rpcstr_pull(servername, i2->servername.buffer,sizeof(servername), -1, STR_TERMINATE);
 
-	if (i2->printername.buffer)
-		rpcstr_pull(printername, i2->printername.buffer,sizeof(printername), -1, STR_TERMINATE);
+	rpcstr_pull(printername, i2->printername.buffer,sizeof(printername), -1, STR_TERMINATE);
 
-	if (i2->sharename.buffer)
-		rpcstr_pull(sharename, i2->sharename.buffer,sizeof(sharename), -1, STR_TERMINATE);
+	rpcstr_pull(sharename, i2->sharename.buffer,sizeof(sharename), -1, STR_TERMINATE);
 
-	if (i2->portname.buffer)
-		rpcstr_pull(portname, i2->portname.buffer,sizeof(portname), -1, STR_TERMINATE);
+	rpcstr_pull(portname, i2->portname.buffer,sizeof(portname), -1, STR_TERMINATE);
 
-	if (i2->drivername.buffer)
-		rpcstr_pull(drivername, i2->drivername.buffer,sizeof(drivername), -1, STR_TERMINATE);
+	rpcstr_pull(drivername, i2->drivername.buffer,sizeof(drivername), -1, STR_TERMINATE);
 
-	if (i2->comment.buffer)
-		rpcstr_pull(comment, i2->comment.buffer,sizeof(comment), -1, STR_TERMINATE);
+	rpcstr_pull(comment, i2->comment.buffer,sizeof(comment), -1, STR_TERMINATE);
 
-	if (i2->location.buffer)
-		rpcstr_pull(location, i2->location.buffer,sizeof(location), -1, STR_TERMINATE);
+	rpcstr_pull(location, i2->location.buffer,sizeof(location), -1, STR_TERMINATE);
 
-	if (i2->sepfile.buffer)
-		rpcstr_pull(sepfile, i2->sepfile.buffer,sizeof(sepfile), -1, STR_TERMINATE);
+	rpcstr_pull(sepfile, i2->sepfile.buffer,sizeof(sepfile), -1, STR_TERMINATE);
 
-	if (i2->printprocessor.buffer) 
-		rpcstr_pull(printprocessor, i2->printprocessor.buffer,sizeof(printprocessor), -1, STR_TERMINATE);
+	rpcstr_pull(printprocessor, i2->printprocessor.buffer,sizeof(printprocessor), -1, STR_TERMINATE);
 
-	if (i2->datatype.buffer)
-		rpcstr_pull(datatype, i2->datatype.buffer,sizeof(datatype), -1, STR_TERMINATE);
+	rpcstr_pull(datatype, i2->datatype.buffer,sizeof(datatype), -1, STR_TERMINATE);
 
-	if (i2->parameters.buffer)
-		rpcstr_pull(parameters, i2->parameters.buffer,sizeof(parameters), -1, STR_TERMINATE);
+	rpcstr_pull(parameters, i2->parameters.buffer,sizeof(parameters), -1, STR_TERMINATE);
 
 	printf("\tservername:[%s]\n", servername);
 	printf("\tprintername:[%s]\n", printername);
@@ -489,7 +472,7 @@
 		fstrcpy(comment, argv[2]);
 	}
 
-	slprintf (servername, sizeof(fstring)-1, "\\\\%s", cli->desthost);
+	slprintf (servername, sizeof(servername)-1, "\\\\%s", cli->desthost);
 	strupper (servername);
 	fstrcpy (printername, argv[1]);
 	fstrcpy  (user, cli->user_name);
@@ -557,9 +540,9 @@
 		info_level = atoi(argv[2]);
 	}
 
-	slprintf (servername, sizeof(fstring)-1, "\\\\%s", cli->desthost);
+	slprintf (servername, sizeof(servername)-1, "\\\\%s", cli->desthost);
 	strupper (servername);
-	slprintf (printername, sizeof(fstring)-1, "%s\\%s", servername, argv[1]);
+	slprintf (printername, sizeof(printername)-1, "%s\\%s", servername, argv[1]);
 	fstrcpy  (user, cli->user_name);
 	
 	/* get a printer handle */
@@ -675,12 +658,12 @@
 
 	/* Open a printer handle */
 
-	slprintf (servername, sizeof(fstring)-1, "\\\\%s", cli->desthost);
+	slprintf (servername, sizeof(servername)-1, "\\\\%s", cli->desthost);
 	strupper (servername);
 	if (strncmp(argv[1], ".", sizeof(".")) == 0)
 		fstrcpy(printername, servername);
 	else
-		slprintf (printername, sizeof(fstring)-1, "%s\\%s", 
+		slprintf (printername, sizeof(servername)-1, "%s\\%s", 
 			  servername, argv[1]);
 	fstrcpy  (user, cli->user_name);
 	
@@ -748,12 +731,12 @@
 
 	/* Open a printer handle */
 
-	slprintf (servername, sizeof(fstring)-1, "\\\\%s", cli->desthost);
+	slprintf (servername, sizeof(servername)-1, "\\\\%s", cli->desthost);
 	strupper (servername);
 	if (strncmp(argv[1], ".", sizeof(".")) == 0)
 		fstrcpy(printername, servername);
 	else
-		slprintf (printername, sizeof(fstring)-1, "%s\\%s", 
+		slprintf (printername, sizeof(printername)-1, "%s\\%s", 
 			  servername, argv[1]);
 	fstrcpy  (user, cli->user_name);
 	
@@ -847,15 +830,15 @@
 ****************************************************************************/
 static void display_print_driver_3(DRIVER_INFO_3 *i1)
 {
-	fstring name;
-	fstring architecture;
-	fstring driverpath;
-	fstring datafile;
-	fstring configfile;
-	fstring helpfile;
-	fstring dependentfiles;
-	fstring monitorname;
-	fstring defaultdatatype;
+	fstring name = "";
+	fstring architecture = "";
+	fstring driverpath = "";
+	fstring datafile = "";
+	fstring configfile = "";
+	fstring helpfile = "";
+	fstring dependentfiles = "";
+	fstring monitorname = "";
+	fstring defaultdatatype = "";
 	
 	int length=0;
 	BOOL valid = True;
@@ -930,7 +913,7 @@
 	}
 
 	/* get the arguments need to open the printer handle */
-	slprintf (servername, sizeof(fstring)-1, "\\\\%s", cli->desthost);
+	slprintf (servername, sizeof(servername)-1, "\\\\%s", cli->desthost);
 	strupper (servername);
 	fstrcpy  (user, cli->user_name);
 	fstrcpy  (printername, argv[1]);
@@ -1153,7 +1136,7 @@
  wrapper for strtok to get the next parameter from a delimited list.
  Needed to handle the empty parameter string denoted by "NULL"
  *************************************************************************/
-static char* get_driver_3_param (char* str, char* delim, UNISTR* dest)
+static char* get_driver_3_param (char* str, const char* delim, UNISTR* dest)
 {
 	char	*ptr;
 
@@ -1300,7 +1283,7 @@
 		return NT_STATUS_OK;
         }
 	
-        slprintf (servername, sizeof(fstring)-1, "\\\\%s", cli->desthost);
+        slprintf (servername, sizeof(servername)-1, "\\\\%s", cli->desthost);
         strupper (servername);
 
 	/* Fill in the DRIVER_INFO_3 struct */
@@ -1362,9 +1345,9 @@
 		return NT_STATUS_OK;
         }
 
-	slprintf (servername, sizeof(fstring)-1, "\\\\%s", cli->desthost);
+	slprintf (servername, sizeof(servername)-1, "\\\\%s", cli->desthost);
 	strupper (servername);
-	slprintf (printername, sizeof(fstring)-1, "%s\\%s", servername, argv[1]);
+	slprintf (printername, sizeof(printername)-1, "%s\\%s", servername, argv[1]);
 	fstrcpy  (user, cli->user_name);
 
 	/* Get a printer handle */
@@ -1433,7 +1416,7 @@
 		return NT_STATUS_OK;
         }
 
-	slprintf (servername, sizeof(fstring)-1, "\\\\%s", cli->desthost);
+	slprintf (servername, sizeof(servername)-1, "\\\\%s", cli->desthost);
 	strupper (servername);
 
 	/* delete the driver for all architectures */
@@ -1818,9 +1801,9 @@
 		return NT_STATUS_OK;
         }
 
-	slprintf (servername, sizeof(fstring)-1, "\\\\%s", cli->desthost);
+	slprintf (servername, sizeof(servername)-1, "\\\\%s", cli->desthost);
 	strupper (servername);
-	slprintf (printername, sizeof(fstring)-1, "%s\\%s", servername, argv[1]);
+	slprintf (printername, sizeof(servername)-1, "%s\\%s", servername, argv[1]);
 	fstrcpy  (user, cli->user_name);
 
 	/* get a printer handle */
@@ -1884,17 +1867,14 @@
 {
 	fstring username = "", document = "", text_status = "";
 
-	if (job->username.buffer)
-		rpcstr_pull(username, job->username.buffer,
-			   sizeof(username), -1, STR_TERMINATE);
-
-	if (job->document.buffer)
-		rpcstr_pull(document, job->document.buffer,
-			   sizeof(document), -1, STR_TERMINATE);
-
-	if (job->text_status.buffer)
-		rpcstr_pull(text_status, job->text_status.buffer,
-			   sizeof(text_status), -1, STR_TERMINATE);
+	rpcstr_pull(username, job->username.buffer,
+		    sizeof(username), -1, STR_TERMINATE);
+
+	rpcstr_pull(document, job->document.buffer,
+		    sizeof(document), -1, STR_TERMINATE);
+
+	rpcstr_pull(text_status, job->text_status.buffer,
+		    sizeof(text_status), -1, STR_TERMINATE);
 
 	printf("%d: jobid[%d]: %s %s %s %d/%d pages\n", job->position, job->jobid,
 	       username, document, text_status, job->pagesprinted,
@@ -1905,17 +1885,14 @@
 {
 	fstring username = "", document = "", text_status = "";
 
-	if (job->username.buffer)
-		rpcstr_pull(username, job->username.buffer,
-			   sizeof(username), -1, STR_TERMINATE);
-
-	if (job->document.buffer)
-		rpcstr_pull(document, job->document.buffer,
-			   sizeof(document), -1, STR_TERMINATE);
-
-	if (job->text_status.buffer)
-		rpcstr_pull(text_status, job->text_status.buffer,
-			   sizeof(text_status), -1, STR_TERMINATE);
+	rpcstr_pull(username, job->username.buffer,
+		    sizeof(username), -1, STR_TERMINATE);
+
+	rpcstr_pull(document, job->document.buffer,
+		    sizeof(document), -1, STR_TERMINATE);
+
+	rpcstr_pull(text_status, job->text_status.buffer,
+		    sizeof(text_status), -1, STR_TERMINATE);
 
 	printf("%d: jobid[%d]: %s %s %s %d/%d pages, %d bytes\n", job->position, job->jobid,
 	       username, document, text_status, job->pagesprinted,
@@ -1946,11 +1923,10 @@
 
 	/* Open printer handle */
 
-	slprintf(servername, sizeof(fstring)-1, "\\\\%s", cli->desthost);
+	slprintf(servername, sizeof(servername)-1, "\\\\%s", cli->desthost);
 	strupper(servername);
 	fstrcpy(user, cli->user_name);
-	fstrcpy(printername, argv[1]);
-	slprintf(printername, sizeof(pstring)-1, "\\\\%s\\", cli->desthost);
+	slprintf(printername, sizeof(servername)-1, "\\\\%s\\", cli->desthost);
 	strupper(printername);
 	pstrcat(printername, argv[1]);
 
@@ -2018,11 +1994,10 @@
 	
 	/* Open printer handle */
 
-	slprintf(servername, sizeof(fstring)-1, "\\\\%s", cli->desthost);
+	slprintf(servername, sizeof(servername)-1, "\\\\%s", cli->desthost);
 	strupper(servername);
 	fstrcpy(user, cli->user_name);
-	fstrcpy(printername, argv[1]);
-	slprintf(printername, sizeof(pstring)-1, "\\\\%s\\", cli->desthost);
+	slprintf(printername, sizeof(printername)-1, "\\\\%s\\", cli->desthost);
 	strupper(printername);
 	pstrcat(printername, argv[1]);
 
@@ -2082,11 +2057,10 @@
 
 	/* Open printer handle */
 
-	slprintf(servername, sizeof(fstring)-1, "\\\\%s", cli->desthost);
+	slprintf(servername, sizeof(servername)-1, "\\\\%s", cli->desthost);
 	strupper(servername);
 	fstrcpy(user, cli->user_name);
-	fstrcpy(printername, argv[1]);
-	slprintf(printername, sizeof(pstring)-1, "\\\\%s\\", cli->desthost);
+	slprintf(printername, sizeof(printername)-1, "\\\\%s\\", cli->desthost);
 	strupper(printername);
 	pstrcat(printername, argv[1]);
 
@@ -2135,7 +2109,7 @@
 	BOOL got_hnd = False;
 	pstring printername;
 	fstring servername, user;
-	char *keyname = NULL;
+	const char *keyname = NULL;
 	POLICY_HND hnd;
 	uint16 *keylist = NULL, *curkey;
 
@@ -2151,11 +2125,10 @@
 
 	/* Open printer handle */
 
-	slprintf(servername, sizeof(fstring)-1, "\\\\%s", cli->desthost);
+	slprintf(servername, sizeof(servername)-1, "\\\\%s", cli->desthost);
 	strupper(servername);
 	fstrcpy(user, cli->user_name);
-	fstrcpy(printername, argv[1]);
-	slprintf(printername, sizeof(pstring)-1, "\\\\%s\\", cli->desthost);
+	slprintf(printername, sizeof(printername)-1, "\\\\%s\\", cli->desthost);
 	strupper(printername);
 	pstrcat(printername, argv[1]);
 
@@ -2217,10 +2190,10 @@
 
 	/* Open printer */
 
-	slprintf(servername, sizeof(fstring) - 1, "\\\\%s", cli->desthost);
+	slprintf(servername, sizeof(servername) - 1, "\\\\%s", cli->desthost);
 	strupper(servername);
 
-	slprintf(printername, sizeof(fstring) - 1, "\\\\%s\\%s", cli->desthost,
+	slprintf(printername, sizeof(printername) - 1, "\\\\%s\\%s", cli->desthost,
 		 argv[1]);
 	strupper(printername);
 
@@ -2260,7 +2233,7 @@
 
 	/* Send rffpcnex */
 
-	slprintf(servername, sizeof(fstring) - 1, "\\\\%s", myhostname());
+	slprintf(servername, sizeof(servername) - 1, "\\\\%s", myhostname());
 	strupper(servername);
 
 	result = cli_spoolss_rffpcnex(
diff -uNr samba-3.0alpha21.orig/source/rpcclient/rpcclient.c samba-3.0alpha21/source/rpcclient/rpcclient.c
--- samba-3.0alpha21.orig/source/rpcclient/rpcclient.c	2003-02-16 19:06:33.000000000 -0600
+++ samba-3.0alpha21/source/rpcclient/rpcclient.c	2003-02-16 19:05:47.000000000 -0600
@@ -197,7 +197,7 @@
 
 	if (got_domain_sid) return;
 
-	if (!(mem_ctx=talloc_init()))
+	if (!(mem_ctx=talloc_init("fetch_machine_sid")))
 	{
 		DEBUG(0,("fetch_machine_sid: talloc_init returned NULL!\n"));
 		goto error;
@@ -479,7 +479,7 @@
 
                 /* Create mem_ctx */
 
-                if (!(mem_ctx = talloc_init())) {
+                if (!(mem_ctx = talloc_init("do_cmd"))) {
                         DEBUG(0, ("talloc_init() failed\n"));
                         goto done;
                 }
@@ -646,11 +646,11 @@
 		case 'U': {
 			char *lp;
 
-			pstrcpy(username,opt_username);
+			fstrcpy(username,opt_username);
 
 			if ((lp=strchr_m(username,'%'))) {
 				*lp = 0;
-				pstrcpy(password,lp+1);
+				fstrcpy(password,lp+1);
 				got_pass = 1;
 				memset(strchr_m(opt_username,'%') + 1, 'X',
 				       strlen(password));
@@ -664,7 +664,7 @@
 				return 1;
 			}
 		case 'W':
-			pstrcpy(domain, opt_domain);
+			fstrcpy(domain, opt_domain);
 			break;
 		}
 	}
@@ -700,7 +700,7 @@
 	/* Resolve the IP address */
 
 	if (!opt_ipaddr && !resolve_name(server, &server_ip, 0x20))  {
-		DEBUG(1,("Unable to resolve %s\n", server));
+		fprintf(stderr, "Unable to resolve %s\n", server);
 		return 1;
 	}
 	
diff -uNr samba-3.0alpha21.orig/source/rpcclient/rpcclient.h samba-3.0alpha21/source/rpcclient/rpcclient.h
--- samba-3.0alpha21.orig/source/rpcclient/rpcclient.h	2003-02-16 19:06:33.000000000 -0600
+++ samba-3.0alpha21/source/rpcclient/rpcclient.h	2003-02-16 19:05:47.000000000 -0600
@@ -23,12 +23,12 @@
 #define RPCCLIENT_H
 
 struct cmd_set {
-	char *name;
+	const char *name;
 	NTSTATUS (*fn)(struct cli_state*, TALLOC_CTX *mem_ctx, int argc, 
                        char **argv);
         int pipe_idx;
-	char *description;
-	char *usage;
+	const char *description;
+	const char *usage;
 };
 
 #endif /* RPCCLIENT_H */
diff -uNr samba-3.0alpha21.orig/source/rpcclient/samsync.c samba-3.0alpha21/source/rpcclient/samsync.c
--- samba-3.0alpha21.orig/source/rpcclient/samsync.c	2003-02-16 19:06:33.000000000 -0600
+++ samba-3.0alpha21/source/rpcclient/samsync.c	2003-02-16 19:05:47.000000000 -0600
@@ -373,7 +373,7 @@
 		      return result;
 	}
 
-	if (!(mem_ctx = talloc_init())) {
+	if (!(mem_ctx = talloc_init("sam_sync"))) {
 		DEBUG(0,("talloc_init failed\n"));
 		return result;
 	}
diff -uNr samba-3.0alpha21.orig/source/script/findsmb.in samba-3.0alpha21/source/script/findsmb.in
--- samba-3.0alpha21.orig/source/script/findsmb.in	2003-02-16 19:06:33.000000000 -0600
+++ samba-3.0alpha21/source/script/findsmb.in	2003-02-16 19:05:47.000000000 -0600
@@ -1,11 +1,11 @@
-#!/usr/bin/perl
+#!@PERL@
 #
 # Prints info on all smb responding machines on a subnet.
 # This script needs to be run on a machine without nmbd running and be
 # run as root to get correct info from WIN95 clients.
 #
 # syntax:
-#    findsmb [subnet broadcast address]
+#    findsmb [-d|-D] [-r] [subnet broadcast address]
 #
 # with no agrument it will list machines on the current subnet
 #
@@ -13,21 +13,28 @@
 # local master browsers for that workgroup. There will be an "*" in front
 # of the workgroup name for machines that are the domain master browser for
 # that workgroup.
+# 
+# Options:
+#
+# -d|-D		enable debug
+# -r		add -r option to nmblookup when finding netbios name
 #
 
 $SAMBABIN = "@prefix@/bin";
 
-for ($i = 0; $i < 2; $i++) {	# test for -d option and broadcast address
+for ($i = 0; $i < 2; $i++) {	# test for -d and -r options
   $_ = shift;
   if (m/-d|-D/) {
     $DEBUG = 1;
-  } else  {
-    if ($_) {
-      $BCAST = "-B $_";
-    }
+  } elsif (m/-r/) {
+    $R_OPTION = "-r";
   }
 }
 
+if ($_) {			# set broadcast address if it was specified
+      $BCAST = "-B $_";
+}
+
 sub ipsort			# do numeric sort on last field of IP address
 {
   @t1 = split(/\./,$a);
@@ -56,7 +63,7 @@
 
 # find the netbios names registered by each machine
 
-  open(NMBLOOKUP,"$SAMBABIN/nmblookup -r -A $ip|") || 
+  open(NMBLOOKUP,"$SAMBABIN/nmblookup $R_OPTION -A $ip|") || 
 	die("Can't get nmb name list.\n");
   @nmblookup = <NMBLOOKUP>;
   close NMBLOOKUP;
diff -uNr samba-3.0alpha21.orig/source/script/installmodules.sh samba-3.0alpha21/source/script/installmodules.sh
--- samba-3.0alpha21.orig/source/script/installmodules.sh	2003-02-16 19:06:33.000000000 -0600
+++ samba-3.0alpha21/source/script/installmodules.sh	2003-02-16 19:05:47.000000000 -0600
@@ -7,6 +7,16 @@
 shift
 shift
 
+for d in $BASEDIR $LIBDIR; do
+if [ ! -d $d ]; then
+mkdir $d
+if [ ! -d $d ]; then
+  echo Failed to make directory $d
+  exit 1
+fi
+fi
+done
+
 for p in $*; do
  p2=`basename $p`
  echo Installing $p as $LIBDIR/$p2
diff -uNr samba-3.0alpha21.orig/source/script/smbtar samba-3.0alpha21/source/script/smbtar
--- samba-3.0alpha21.orig/source/script/smbtar	2003-02-16 19:06:33.000000000 -0600
+++ samba-3.0alpha21/source/script/smbtar	2003-02-16 19:05:47.000000000 -0600
@@ -80,7 +80,8 @@
       tarcmd="x"
       ;;
    i) # [i]ncremental
-      tarargs=${tarargs}g
+      tarargs=${tarargs}ga
+      clientargs="-c 'tarmode inc'"
       ;;
    a) # [a]rchive
       tarargs=${tarargs}a
diff -uNr samba-3.0alpha21.orig/source/script/uninstallbin.sh samba-3.0alpha21/source/script/uninstallbin.sh
--- samba-3.0alpha21.orig/source/script/uninstallbin.sh	2003-02-16 19:06:33.000000000 -0600
+++ samba-3.0alpha21/source/script/uninstallbin.sh	2003-02-16 19:05:47.000000000 -0600
@@ -34,8 +34,8 @@
 ======================================================================
 The binaries have been uninstalled. You may restore the binaries using
 the command "make installbin" or "make install" to install binaries, 
-man pages and shell scripts. You can restore a previous version of the
-binaries (if there were any) using "make revert".
+man pages, modules and shell scripts. You can restore a previous
+version of the binaries (if there were any) using "make revert".
 ======================================================================
 EOF
 
diff -uNr samba-3.0alpha21.orig/source/smbadduser samba-3.0alpha21/source/smbadduser
--- samba-3.0alpha21.orig/source/smbadduser	2003-02-16 19:06:30.000000000 -0600
+++ samba-3.0alpha21/source/smbadduser	2003-02-16 19:05:45.000000000 -0600
@@ -6,13 +6,15 @@
 set path = ($path /usr/local/samba/bin)
 
 set smbpasswd = /usr/local/samba/private/smbpasswd
+#set smbpasswd = /etc/samba/smbpasswd
 set user_map  = /usr/local/samba/lib/users.map
+#set user_map  = /etc/samba/smbusers
 #
 # Set to site specific passwd command
 #
-#set passwd    = "cat /etc/passwd"
+set passwd    = "cat /etc/passwd"
 #set passwd    = "niscat passwd.org_dir"
-set passwd    = "ypcat passwd"
+#set passwd    = "ypcat passwd"
 
 set line = "----------------------------------------------------------"
 if ($#argv == 0) then
@@ -53,9 +55,7 @@
 	endif
 
 	echo "Adding: $unix to $smbpasswd"
-	eval $passwd | \
-	awk -F: '$1==USR { \
-	printf( "%s:%s:XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX:XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX:%s:%s:%s\n", $1, $3, $5, $6, $7) }' USR=$unix >> $smbpasswd
+	/usr/bin/smbpasswd -a -n $unix
 	if ($unix != $ntid) then
 		echo "Adding: {$unix = $ntid} to $user_map"
 		echo "$unix = $ntid" >> $user_map
diff -uNr samba-3.0alpha21.orig/source/smbd/blocking.c samba-3.0alpha21/source/smbd/blocking.c
--- samba-3.0alpha21.orig/source/smbd/blocking.c	2003-02-16 19:06:33.000000000 -0600
+++ samba-3.0alpha21/source/smbd/blocking.c	2003-02-16 19:05:47.000000000 -0600
@@ -267,20 +267,20 @@
 	ssize_t nread = -1;
 	char *data, *p;
 	int outsize = 0;
-	SMB_OFF_T startpos;
+	SMB_BIG_UINT startpos;
 	size_t numtoread;
 	NTSTATUS status;
 	connection_struct *conn = conn_find(SVAL(inbuf,smb_tid));
 	files_struct *fsp = blr->fsp;
 
 	numtoread = SVAL(inbuf,smb_vwv1);
-	startpos = IVAL(inbuf,smb_vwv2);
+	startpos = (SMB_BIG_UINT)IVAL(inbuf,smb_vwv2);
 	
 	numtoread = MIN(BUFFER_SIZE-outsize,numtoread);
 	data = smb_buf(outbuf) + 3;
  
 	status = do_lock_spin( fsp, conn, SVAL(inbuf,smb_pid), (SMB_BIG_UINT)numtoread, 
-			  (SMB_BIG_UINT)startpos, READ_LOCK);
+			  startpos, READ_LOCK);
 	if (NT_STATUS_V(status)) {
 		if (!NT_STATUS_EQUAL(status,NT_STATUS_LOCK_NOT_GRANTED) &&
 			!NT_STATUS_EQUAL(status,NT_STATUS_FILE_LOCK_CONFLICT)) {
@@ -337,17 +337,17 @@
 	char *outbuf = OutBuffer;
 	char *inbuf = blr->inbuf;
 	int outsize;
-	SMB_OFF_T count = 0, offset = 0;
+	SMB_BIG_UINT count = (SMB_BIG_UINT)0, offset = (SMB_BIG_UINT)0;
 	NTSTATUS status;
 	connection_struct *conn = conn_find(SVAL(inbuf,smb_tid));
 	files_struct *fsp = blr->fsp;
 
-	count = IVAL(inbuf,smb_vwv1);
-	offset = IVAL(inbuf,smb_vwv3);
+	count = IVAL_TO_SMB_OFF_T(inbuf,smb_vwv1);
+	offset = IVAL_TO_SMB_OFF_T(inbuf,smb_vwv3);
 
 	errno = 0;
-	status = do_lock_spin(fsp, conn, SVAL(inbuf,smb_pid), (SMB_BIG_UINT)count, 
-			 (SMB_BIG_UINT)offset, WRITE_LOCK);
+	status = do_lock_spin(fsp, conn, SVAL(inbuf,smb_pid), count, 
+			 offset, WRITE_LOCK);
 	if (NT_STATUS_IS_ERR(status)) {
 		if (!NT_STATUS_EQUAL(status,NT_STATUS_LOCK_NOT_GRANTED) &&
 			!NT_STATUS_EQUAL(status,NT_STATUS_FILE_LOCK_CONFLICT)) {
diff -uNr samba-3.0alpha21.orig/source/smbd/build_options.c samba-3.0alpha21/source/smbd/build_options.c
--- samba-3.0alpha21.orig/source/smbd/build_options.c	2003-02-16 19:06:33.000000000 -0600
+++ samba-3.0alpha21/source/smbd/build_options.c	2003-02-16 19:05:47.000000000 -0600
@@ -23,7 +23,7 @@
 #include "build_env.h"
 #include "dynconfig.h"
 
-static void output(BOOL screen, char *format, ...) PRINTF_ATTRIBUTE(2,3);
+static void output(BOOL screen, const char *format, ...) PRINTF_ATTRIBUTE(2,3);
 
 /*
 #define OUTPUT(x) snprintf(outstring,sizeof(outstring),x); output(screen,outstring);
@@ -31,7 +31,7 @@
 /****************************************************************************
 helper function for build_options
 ****************************************************************************/
-static void output(BOOL screen, char *format, ...)
+static void output(BOOL screen, const char *format, ...)
 {
        char *ptr;
        va_list ap;
@@ -188,7 +188,6 @@
        output(screen,"   SBINDIR: %s\n", dyn_SBINDIR);
        output(screen,"   BINDIR: %s\n", dyn_BINDIR);
        output(screen,"   LOCKDIR: %s\n",dyn_LOCKDIR);
-       output(screen,"   DRIVERFILE: %s\n", dyn_DRIVERFILE);
        output(screen,"   LOGFILEBASE: %s\n", dyn_LOGFILEBASE);
 
        /*Output various other options (most map to defines in the configure script*/
@@ -295,9 +294,6 @@
 #ifdef SEEKDIR_RETURNS_VOID
        output(screen,"   SEEKDIR_RETURNS_VOID\n");
 #endif
-#ifdef HAVE_FILE_MACRO
-       output(screen,"   HAVE_FILE_MACRO\n");
-#endif
 #ifdef HAVE_FUNCTION_MACRO
        output(screen,"   HAVE_FUNCTION_MACRO\n");
 #endif
diff -uNr samba-3.0alpha21.orig/source/smbd/change_trust_pw.c samba-3.0alpha21/source/smbd/change_trust_pw.c
--- samba-3.0alpha21.orig/source/smbd/change_trust_pw.c	2003-02-16 19:06:33.000000000 -0600
+++ samba-3.0alpha21/source/smbd/change_trust_pw.c	2003-02-16 19:05:47.000000000 -0600
@@ -31,107 +31,98 @@
 static NTSTATUS modify_trust_password( const char *domain, const char *remote_machine, 
 				   unsigned char orig_trust_passwd_hash[16])
 {
-  struct cli_state *cli;
-  DOM_SID domain_sid;
-  NTSTATUS nt_status;
-
-  /*
-   * Ensure we have the domain SID for this domain.
-   */
-
-  if (!secrets_fetch_domain_sid(domain, &domain_sid)) {
-    DEBUG(0, ("modify_trust_password: unable to fetch domain sid.\n"));
-    return NT_STATUS_UNSUCCESSFUL;
-  }
+	struct cli_state *cli;
+	DOM_SID domain_sid;
+	NTSTATUS nt_status;
+
+	/*
+	 * Ensure we have the domain SID for this domain.
+	 */
+
+	if (!secrets_fetch_domain_sid(domain, &domain_sid)) {
+		DEBUG(0, ("modify_trust_password: unable to fetch domain sid.\n"));
+		return NT_STATUS_UNSUCCESSFUL;
+	}
 
-  if (!NT_STATUS_IS_OK(cli_full_connection(&cli, global_myname(), remote_machine, 
+	if (!NT_STATUS_IS_OK(cli_full_connection(&cli, global_myname(), remote_machine, 
 					   NULL, 0,
 					   "IPC$", "IPC",  
 					   "", "",
-					   "", 0, NULL))) {
-	  DEBUG(0,("modify_trust_password: Connection to %s failed!\n", remote_machine));
-	  return NT_STATUS_UNSUCCESSFUL;
-  }
+					   "", 0, NULL))) 
+	{
+		DEBUG(0,("modify_trust_password: Connection to %s failed!\n", remote_machine));
+		return NT_STATUS_UNSUCCESSFUL;
+	}
       
-  /*
-   * Ok - we have an anonymous connection to the IPC$ share.
-   * Now start the NT Domain stuff :-).
-   */
-
-  if(cli_nt_session_open(cli, PI_NETLOGON) == False) {
-    DEBUG(0,("modify_trust_password: unable to open the domain client session to \
-machine %s. Error was : %s.\n", remote_machine, cli_errstr(cli)));
-    cli_nt_session_close(cli);
-    cli_ulogoff(cli);
-    cli_shutdown(cli);
-    return NT_STATUS_UNSUCCESSFUL;
-  } 
+	/*
+	 * Ok - we have an anonymous connection to the IPC$ share.
+	 * Now start the NT Domain stuff :-).
+	 */
+
+	if(cli_nt_session_open(cli, PI_NETLOGON) == False) {
+		DEBUG(0,("modify_trust_password: unable to open the domain client session to machine %s. Error was : %s.\n", 
+			remote_machine, cli_errstr(cli)));
+		cli_nt_session_close(cli);
+		cli_ulogoff(cli);
+		cli_shutdown(cli);
+		return NT_STATUS_UNSUCCESSFUL;
+	}
 
-  nt_status = trust_pw_change_and_store_it(cli, cli->mem_ctx,
+	nt_status = trust_pw_change_and_store_it(cli, cli->mem_ctx,
 					   orig_trust_passwd_hash);
   
-  cli_nt_session_close(cli);
-  cli_ulogoff(cli);
-  cli_shutdown(cli);
-  return nt_status;
+	cli_nt_session_close(cli);
+	cli_ulogoff(cli);
+	cli_shutdown(cli);
+	
+	return nt_status;
 }
 
 /************************************************************************
  Change the trust account password for a domain.
 ************************************************************************/
 
-NTSTATUS change_trust_account_password( const char *domain, const char *remote_machine_list)
+NTSTATUS change_trust_account_password( const char *domain, const char *remote_machine)
 {
-  fstring remote_machine;
-  unsigned char old_trust_passwd_hash[16];
-  time_t lct;
-  NTSTATUS res = NT_STATUS_UNSUCCESSFUL;
-
-  if(!secrets_fetch_trust_account_password(domain, old_trust_passwd_hash, &lct)) {
-    DEBUG(0,("change_trust_account_password: unable to read the machine \
-account password for domain %s.\n", domain));
-    return NT_STATUS_UNSUCCESSFUL;
-  }
-
-  while(remote_machine_list && 
-	next_token(&remote_machine_list, remote_machine, 
-		   LIST_SEP, sizeof(remote_machine))) {
-    strupper(remote_machine);
-    if(strequal(remote_machine, "*")) {
-
-      /*
-       * We have been asked to dynamcially determine the IP addresses of the PDC.
-       */
-
-      struct in_addr pdc_ip;
-      fstring dc_name;
-
-      /* Use the PDC *only* for this. */
-      if(!get_pdc_ip(domain, &pdc_ip))
-        continue;
-
-      /*
-       * Try and connect to the PDC/BDC list in turn as an IP
-       * address used as a string.
-       */
-
-        if(!lookup_dc_name(global_myname(), domain, &pdc_ip, dc_name))
-          continue;
-        if(NT_STATUS_IS_OK(res = modify_trust_password( domain, dc_name,
-                                         old_trust_passwd_hash)))
-          break;
-
-    } else {
-	    res = modify_trust_password( domain, remote_machine,
-					 old_trust_passwd_hash);
-    }
-
-  }
-
-  if (!NT_STATUS_IS_OK(res)) {
-	  DEBUG(0,("%s : change_trust_account_password: Failed to change password for \
-domain %s.\n", timestring(False), domain));
-  }
+	unsigned char old_trust_passwd_hash[16];
+	time_t lct;
+	NTSTATUS res = NT_STATUS_UNSUCCESSFUL;
+	struct in_addr pdc_ip;
+	fstring dc_name;
+
+
+	if(!secrets_fetch_trust_account_password(domain, old_trust_passwd_hash, &lct)) {
+		DEBUG(0,("change_trust_account_password: unable to read the machine account password for domain %s.\n", 
+			domain));
+		return NT_STATUS_UNSUCCESSFUL;
+	}
+
+	if (remote_machine == NULL || !strcmp(remote_machine, "*")) {
+		/* Use the PDC *only* for this */
+	
+		if ( !get_pdc_ip(domain, &pdc_ip) ) {
+			DEBUG(0,("Can't get IP for PDC for domain %s\n", domain));
+			goto failed;
+		}
+
+		if ( !lookup_dc_name(global_myname(), domain, &pdc_ip, dc_name) ) 
+			goto failed;
+	}
+	/* supoport old deprecated "smbpasswd -j DOMAIN -r MACHINE" behavior */
+	else {
+		fstrcpy( dc_name, remote_machine );
+	}
+	
+	/* if this next call fails, then give up.  We can't do
+	   password changes on BDC's  --jerry */
+	   
+	res = modify_trust_password(domain, dc_name, old_trust_passwd_hash);	
+	
+failed:
+	if (!NT_STATUS_IS_OK(res)) {
+		DEBUG(0,("%s : change_trust_account_password: Failed to change password for domain %s.\n", 
+			timestring(False), domain));
+	}
   
-  return res;
+	return res;
 }
diff -uNr samba-3.0alpha21.orig/source/smbd/chgpasswd.c samba-3.0alpha21/source/smbd/chgpasswd.c
--- samba-3.0alpha21.orig/source/smbd/chgpasswd.c	2003-02-16 19:06:33.000000000 -0600
+++ samba-3.0alpha21/source/smbd/chgpasswd.c	2003-02-16 19:05:47.000000000 -0600
@@ -2,6 +2,7 @@
    Unix SMB/CIFS implementation.
    Samba utility functions
    Copyright (C) Andrew Tridgell 1992-1998
+   Copyright (C) Andrew Bartlett 2001-2002
    
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -50,7 +51,7 @@
 
 extern struct passdb_ops pdb_ops;
 
-static BOOL check_oem_password(const char *user,
+static NTSTATUS check_oem_password(const char *user,
 			       uchar * lmdata, const uchar * lmhash,
 			       const uchar * ntdata, const uchar * nthash,
 			       SAM_ACCOUNT **hnd, char *new_passwd,
@@ -248,9 +249,9 @@
 		nread = 0;
 		buffer[nread] = 0;
 
-		while ((len = read_with_timeout(master, buffer + nread, 1,
-						sizeof(buffer) - nread - 1,
-						timeout)) > 0) {
+		while ((len = read_socket_with_timeout(master, buffer + nread, 1,
+						       sizeof(buffer) - nread - 1,
+						       timeout)) > 0) {
 			nread += len;
 			buffer[nread] = 0;
 
@@ -478,6 +479,10 @@
 		DEBUG(1, ("NULL username specfied to chgpasswd()!\n"));
 	}
 
+	if (!oldpass) {
+		oldpass = "";
+	}
+
 	DEBUG(3, ("Password change for user: %s\n", name));
 
 #if DEBUG_PASSWORD
@@ -667,8 +672,7 @@
  no longer be valid.
 ************************************************************/
 
-BOOL change_lanman_password(SAM_ACCOUNT *sampass, uchar * pass1,
-			    uchar * pass2)
+BOOL change_lanman_password(SAM_ACCOUNT *sampass, uchar *pass2)
 {
 	static uchar null_pw[16];
 	uchar unenc_new_pw[16];
@@ -732,15 +736,19 @@
 /***********************************************************
  Code to check and change the OEM hashed password.
 ************************************************************/
-BOOL pass_oem_change(char *user,
-		     uchar * lmdata, uchar * lmhash,
-		     uchar * ntdata, uchar * nthash)
+NTSTATUS pass_oem_change(char *user,
+			 uchar * lmdata, uchar * lmhash,
+			 uchar * ntdata, uchar * nthash)
 {
 	fstring new_passwd;
 	const char *unix_user;
 	SAM_ACCOUNT *sampass = NULL;
-	BOOL ret = check_oem_password(user, lmdata, lmhash, ntdata, nthash,
-				      &sampass, new_passwd, sizeof(new_passwd));
+	NTSTATUS nt_status 
+		= check_oem_password(user, lmdata, lmhash, ntdata, nthash,
+				     &sampass, new_passwd, sizeof(new_passwd));
+
+	if (!NT_STATUS_IS_OK(nt_status))
+		return nt_status;
 
 	/* 
 	 * At this point we have the new case-sensitive plaintext
@@ -753,17 +761,13 @@
 
 	unix_user = pdb_get_username(sampass);
 
-	if ((ret) && (unix_user) && (*unix_user) && lp_unix_password_sync())
-		ret = chgpasswd(unix_user, "", new_passwd, True);
-
-	if (ret)
-		ret = change_oem_password(sampass, new_passwd);
+	nt_status = change_oem_password(sampass, NULL, new_passwd);
 
 	memset(new_passwd, 0, sizeof(new_passwd));
 
 	pdb_free_sam(&sampass);
 
-	return ret;
+	return nt_status;
 }
 
 /***********************************************************
@@ -773,7 +777,8 @@
  but does use the lm OEM password to check the nt hashed-hash.
 
 ************************************************************/
-static BOOL check_oem_password(const char *user,
+
+static NTSTATUS check_oem_password(const char *user,
 			       uchar * lmdata, const uchar * lmhash,
 			       const uchar * ntdata, const uchar * nthash,
 			       SAM_ACCOUNT **hnd, char *new_passwd,
@@ -794,6 +799,8 @@
 
 	BOOL nt_pass_set = (ntdata != NULL && nthash != NULL);
 
+	*hnd = NULL;
+
 	pdb_init_sam(&sampass);
 
 	become_root();
@@ -802,16 +809,20 @@
 
 	if (ret == False) {
 		DEBUG(0, ("check_oem_password: getsmbpwnam returned NULL\n"));
-		return False;
+		pdb_free_sam(&sampass);
+		return NT_STATUS_WRONG_PASSWORD;
+		/*
+		  TODO: check what Win2k returns for this:
+		  return NT_STATUS_NO_SUCH_USER; 
+		*/
 	}
 
-	*hnd = sampass;
-	
 	acct_ctrl = pdb_get_acct_ctrl(sampass);
 	
 	if (acct_ctrl & ACB_DISABLED) {
 		DEBUG(0,("check_lanman_password: account %s disabled.\n", user));
-		return False;
+		pdb_free_sam(&sampass);
+		return NT_STATUS_ACCOUNT_DISABLED;
 	}
 
 	/* construct a null password (in case one is needed */
@@ -821,20 +832,22 @@
 
 	/* save pointers to passwords so we don't have to keep looking them up */
 	lanman_pw = pdb_get_lanman_passwd(sampass);
-	nt_pw     = pdb_get_nt_passwd    (sampass);
+	nt_pw = pdb_get_nt_passwd(sampass);
 
 	/* check for null passwords */
 	if (lanman_pw == NULL) {
 		if (!(acct_ctrl & ACB_PWNOTREQ)) {
 			DEBUG(0,("check_oem_password: no lanman password !\n"));
-			return False;
+			pdb_free_sam(&sampass);
+			return NT_STATUS_WRONG_PASSWORD;
 		}
 	}
 	
 	if (pdb_get_nt_passwd(sampass) == NULL && nt_pass_set) {
 		if (!(acct_ctrl & ACB_PWNOTREQ)) {
 			DEBUG(0,("check_oem_password: no ntlm password !\n"));
-			return False;
+			pdb_free_sam(&sampass);
+			return NT_STATUS_WRONG_PASSWORD;
 		}
 	}
 	
@@ -849,9 +862,11 @@
 	 */
 
 	new_pw_len = IVAL(lmdata, 512);
+
 	if (new_pw_len < 0 || new_pw_len > new_passwd_size - 1) {
 		DEBUG(0,("check_oem_password: incorrect password length (%d).\n", new_pw_len));
-		return False;
+		pdb_free_sam(&sampass);
+		return NT_STATUS_WRONG_PASSWORD;
 	}
 
 	if (nt_pass_set) {
@@ -873,25 +888,25 @@
 
 	nt_lm_owf_gen(new_passwd, new_ntp16, new_p16);
 
-	if (!nt_pass_set)
-	{
+	if (!nt_pass_set) {
 		/*
 		 * Now use new_p16 as the key to see if the old
 		 * password matches.
 		 */
 		D_P16(new_p16, lmhash, unenc_old_pw);
 
-		if (memcmp(lanman_pw, unenc_old_pw, 16))
-		{
+		if (memcmp(lanman_pw, unenc_old_pw, 16)) {
 			DEBUG(0,("check_oem_password: old lm password doesn't match.\n"));
-			return False;
+			pdb_free_sam(&sampass);
+			return NT_STATUS_WRONG_PASSWORD;
 		}
 
 #ifdef DEBUG_PASSWORD
 		DEBUG(100,
 		      ("check_oem_password: password %s ok\n", new_passwd));
 #endif
-		return True;
+		*hnd = sampass;
+		return NT_STATUS_OK;
 	}
 
 	/*
@@ -901,34 +916,81 @@
 	D_P16(new_ntp16, lmhash, unenc_old_pw);
 	D_P16(new_ntp16, nthash, unenc_old_ntpw);
 
-	if (memcmp(lanman_pw, unenc_old_pw, 16))
-	{
+	if (memcmp(lanman_pw, unenc_old_pw, 16)) {
 		DEBUG(0,("check_oem_password: old lm password doesn't match.\n"));
-		return False;
+		pdb_free_sam(&sampass);
+		return NT_STATUS_WRONG_PASSWORD;
 	}
 
-	if (memcmp(nt_pw, unenc_old_ntpw, 16))
-	{
+	if (memcmp(nt_pw, unenc_old_ntpw, 16)) {
 		DEBUG(0,("check_oem_password: old nt password doesn't match.\n"));
-		return False;
+		pdb_free_sam(&sampass);
+		return NT_STATUS_WRONG_PASSWORD;
 	}
 #ifdef DEBUG_PASSWORD
 	DEBUG(100, ("check_oem_password: password %s ok\n", new_passwd));
 #endif
-	return True;
+
+	*hnd = sampass;
+	return NT_STATUS_OK;
 }
 
 /***********************************************************
  Code to change the oem password. Changes both the lanman
- and NT hashes.
+ and NT hashes.  Old_passwd is almost always NULL.
 ************************************************************/
 
-BOOL change_oem_password(SAM_ACCOUNT *hnd, char *new_passwd)
+NTSTATUS change_oem_password(SAM_ACCOUNT *hnd, char *old_passwd, char *new_passwd)
 {
 	BOOL ret;
+	uint32 min_len;
+
+	if (time(NULL) < pdb_get_pass_can_change_time(hnd)) {
+		DEBUG(1, ("user %s cannot change password now, must wait until %s\n", 
+			  pdb_get_username(hnd), http_timestring(pdb_get_pass_can_change_time(hnd))));
+		return NT_STATUS_PASSWORD_RESTRICTION;
+	}
+
+	if (account_policy_get(AP_MIN_PASSWORD_LEN, &min_len) && (strlen(new_passwd) < min_len)) {
+		DEBUG(1, ("user %s cannot change password - password too short\n", 
+			  pdb_get_username(hnd)));
+		DEBUGADD(1, (" account policy min password len = %d\n", min_len));
+		return NT_STATUS_PASSWORD_RESTRICTION;
+/* 		return NT_STATUS_PWD_TOO_SHORT; */
+	}
+
+	/* Take the passed information and test it for minimum criteria */
+	/* Minimum password length */
+	if (strlen(new_passwd) < lp_min_passwd_length()) {
+		/* too short, must be at least MINPASSWDLENGTH */
+		DEBUG(1, ("Password Change: user %s, New password is shorter than minimum password length = %d\n",
+		       pdb_get_username(hnd), lp_min_passwd_length()));
+		return NT_STATUS_PASSWORD_RESTRICTION;
+/* 		return NT_STATUS_PWD_TOO_SHORT; */
+	}
+
+	/* TODO:  Add cracklib support here */
+
+	/*
+	 * If unix password sync was requested, attempt to change
+	 * the /etc/passwd database first. Return failure if this cannot
+	 * be done.
+	 *
+	 * This occurs before the oem change, becouse we don't want to
+	 * update it if chgpasswd failed.
+	 *
+	 * Conditional on lp_unix_password_sync() becouse we don't want
+	 * to touch the unix db unless we have admin permission.
+	 */
+	
+	if(lp_unix_password_sync() && IS_SAM_UNIX_USER(hnd) 
+	   && !chgpasswd(pdb_get_username(hnd),
+			 old_passwd, new_passwd, False)) {
+		return NT_STATUS_ACCESS_DENIED;
+	}
 
 	if (!pdb_set_plaintext_passwd (hnd, new_passwd)) {
-		return False;
+		return NT_STATUS_ACCESS_DENIED;
 	}
 
 	/* Now write it into the file. */
@@ -936,8 +998,9 @@
 	ret = pdb_update_sam_account (hnd);
 	unbecome_root();
 
-	return ret;
+	if (!ret) {
+		return NT_STATUS_ACCESS_DENIED;
+	}
+	
+	return NT_STATUS_OK;
 }
-
-
-
diff -uNr samba-3.0alpha21.orig/source/smbd/close.c samba-3.0alpha21/source/smbd/close.c
--- samba-3.0alpha21.orig/source/smbd/close.c	2003-02-16 19:06:33.000000000 -0600
+++ samba-3.0alpha21/source/smbd/close.c	2003-02-16 19:05:47.000000000 -0600
@@ -21,64 +21,65 @@
 #include "includes.h"
 
 /****************************************************************************
-run a file if it is a magic script
+ Run a file if it is a magic script.
 ****************************************************************************/
+
 static void check_magic(files_struct *fsp,connection_struct *conn)
 {
-  if (!*lp_magicscript(SNUM(conn)))
-    return;
+	if (!*lp_magicscript(SNUM(conn)))
+		return;
 
-  DEBUG(5,("checking magic for %s\n",fsp->fsp_name));
+	DEBUG(5,("checking magic for %s\n",fsp->fsp_name));
 
-  {
-    char *p;
-    if (!(p = strrchr_m(fsp->fsp_name,'/')))
-      p = fsp->fsp_name;
-    else
-      p++;
-
-    if (!strequal(lp_magicscript(SNUM(conn)),p))
-      return;
-  }
-
-  {
-    int ret;
-    pstring magic_output;
-    pstring fname;
-	SMB_STRUCT_STAT st;
-	int tmp_fd, outfd;
-
-    pstrcpy(fname,fsp->fsp_name);
-    if (*lp_magicoutput(SNUM(conn)))
-      pstrcpy(magic_output,lp_magicoutput(SNUM(conn)));
-    else
-      slprintf(magic_output,sizeof(fname)-1, "%s.out",fname);
-
-    chmod(fname,0755);
-    ret = smbrun(fname,&tmp_fd);
-    DEBUG(3,("Invoking magic command %s gave %d\n",fname,ret));
-    unlink(fname);
-	if (ret != 0 || tmp_fd == -1) {
-		if (tmp_fd != -1)
-			close(tmp_fd);
-		return;
-	}
-	outfd = open(magic_output, O_CREAT|O_EXCL|O_RDWR, 0600);
-	if (outfd == -1) {
-		close(tmp_fd);
-		return;
+	{
+		char *p;
+		if (!(p = strrchr_m(fsp->fsp_name,'/')))
+			p = fsp->fsp_name;
+		else
+			p++;
+
+		if (!strequal(lp_magicscript(SNUM(conn)),p))
+			return;
 	}
 
-	if (sys_fstat(tmp_fd,&st) == -1) {
+	{
+		int ret;
+		pstring magic_output;
+		pstring fname;
+		SMB_STRUCT_STAT st;
+		int tmp_fd, outfd;
+
+		pstrcpy(fname,fsp->fsp_name);
+		if (*lp_magicoutput(SNUM(conn)))
+			pstrcpy(magic_output,lp_magicoutput(SNUM(conn)));
+		else
+			slprintf(magic_output,sizeof(fname)-1, "%s.out",fname);
+
+		chmod(fname,0755);
+		ret = smbrun(fname,&tmp_fd);
+		DEBUG(3,("Invoking magic command %s gave %d\n",fname,ret));
+		unlink(fname);
+		if (ret != 0 || tmp_fd == -1) {
+			if (tmp_fd != -1)
+				close(tmp_fd);
+			return;
+		}
+		outfd = open(magic_output, O_CREAT|O_EXCL|O_RDWR, 0600);
+		if (outfd == -1) {
+			close(tmp_fd);
+			return;
+		}
+
+		if (sys_fstat(tmp_fd,&st) == -1) {
+			close(tmp_fd);
+			close(outfd);
+			return;
+		}
+
+		transfer_file(tmp_fd,outfd,(SMB_OFF_T)st.st_size);
 		close(tmp_fd);
 		close(outfd);
-		return;
 	}
-
-	transfer_file(tmp_fd,outfd,(SMB_OFF_T)st.st_size);
-	close(tmp_fd);
-	close(outfd);
-  }
 }
 
 /****************************************************************************
@@ -97,8 +98,6 @@
 		delete_write_cache(fsp);
 	}
 
-	fsp->is_directory = False; 
-    
 	conn->num_files_open--;
 	SAFE_FREE(fsp->wbmpx_ptr);
 
@@ -146,6 +145,22 @@
 	 */
 
 	lock_share_entry_fsp(fsp);
+
+	if (fsp->delete_on_close) {
+
+		/*
+		 * Modify the share mode entry for all files open
+		 * on this device and inode to tell other smbds we have
+		 * changed the delete on close flag. The last closer will delete the file
+		 * if flag is set.
+		 */
+
+		NTSTATUS status =set_delete_on_close_over_all(fsp, fsp->delete_on_close);
+		if (NT_STATUS_V(status) !=  NT_STATUS_V(NT_STATUS_OK))
+			DEBUG(0,("close_normal_file: failed to change delete on close flag for file %s\n",
+				fsp->fsp_name ));
+	}
+
 	share_entry_count = del_share_mode(fsp, &share_entry);
 
 	DEBUG(10,("close_normal_file: share_entry_count = %d for file %s\n",
@@ -258,17 +273,37 @@
 		string_free(&fsp->fsp_name);
 	
 	file_free(fsp);
+	return 0;
+}
 
+/****************************************************************************
+ Close a 'stat file' opened internally.
+****************************************************************************/
+  
+static int close_stat(files_struct *fsp)
+{
+	/*
+	 * Do the code common to files and directories.
+	 */
+	close_filestruct(fsp);
+	
+	if (fsp->fsp_name)
+		string_free(&fsp->fsp_name);
+	
+	file_free(fsp);
 	return 0;
 }
 
 /****************************************************************************
- Close a directory opened by an NT SMB call. 
+ Close a files_struct.
 ****************************************************************************/
   
 int close_file(files_struct *fsp, BOOL normal_close)
 {
 	if(fsp->is_directory)
 		return close_directory(fsp, normal_close);
-	return close_normal_file(fsp, normal_close);
+	else if (fsp->is_stat)
+		return close_stat(fsp);
+	else
+		return close_normal_file(fsp, normal_close);
 }
diff -uNr samba-3.0alpha21.orig/source/smbd/conn.c samba-3.0alpha21/source/smbd/conn.c
--- samba-3.0alpha21.orig/source/smbd/conn.c	2003-02-16 19:06:33.000000000 -0600
+++ samba-3.0alpha21/source/smbd/conn.c	2003-02-16 19:05:47.000000000 -0600
@@ -68,7 +68,7 @@
 /****************************************************************************
 find a conn given a cnum
 ****************************************************************************/
-connection_struct *conn_find(int cnum)
+connection_struct *conn_find(unsigned cnum)
 {
 	int count=0;
 	connection_struct *conn;
@@ -136,10 +136,12 @@
 }
 
 /****************************************************************************
-idle inactive connections
+ Idle inactive connections.
 ****************************************************************************/
+
 BOOL conn_idle_all(time_t t, int deadtime)
 {
+	pipes_struct *plist = NULL;
 	BOOL allidle = True;
 	connection_struct *conn, *next;
 
@@ -154,6 +156,15 @@
 			allidle = False;
 	}
 
+	/*
+	 * Check all pipes for any open handles. We cannot
+	 * idle with a handle open.
+	 */
+
+	for (plist = get_first_internal_pipe(); plist; plist = get_next_internal_pipe(plist))
+		if (plist->pipe_handles && plist->pipe_handles->count)
+			allidle = False;
+	
 	return allidle;
 }
 
@@ -163,7 +174,7 @@
 void conn_clear_vuid_cache(uint16 vuid)
 {
 	connection_struct *conn;
-	int i;
+	unsigned int i;
 
 	for (conn=Connections;conn;conn=conn->next) {
 		if (conn->vuid == vuid) {
diff -uNr samba-3.0alpha21.orig/source/smbd/connection.c samba-3.0alpha21/source/smbd/connection.c
--- samba-3.0alpha21.orig/source/smbd/connection.c	2003-02-16 19:06:33.000000000 -0600
+++ samba-3.0alpha21/source/smbd/connection.c	2003-02-16 19:05:47.000000000 -0600
@@ -35,7 +35,7 @@
 	return tdb;
 }
 
-static void make_conn_key(connection_struct *conn,char *name, TDB_DATA *pkbuf, struct connections_key *pkey)
+static void make_conn_key(connection_struct *conn, const char *name, TDB_DATA *pkbuf, struct connections_key *pkey)
 {
 	ZERO_STRUCTP(pkey);
 	pkey->pid = sys_getpid();
@@ -50,7 +50,7 @@
  Delete a connection record.
 ****************************************************************************/
 
-BOOL yield_connection(connection_struct *conn,char *name)
+BOOL yield_connection(connection_struct *conn, const char *name)
 {
 	struct connections_key key;
 	TDB_DATA kbuf;
@@ -116,7 +116,7 @@
  Claim an entry in the connections database.
 ****************************************************************************/
 
-BOOL claim_connection(connection_struct *conn,char *name,int max_connections,BOOL Clear, uint32 msg_flags)
+BOOL claim_connection(connection_struct *conn, const char *name,int max_connections,BOOL Clear, uint32 msg_flags)
 {
 	struct connections_key key;
 	struct connections_data crec;
diff -uNr samba-3.0alpha21.orig/source/smbd/dir.c samba-3.0alpha21/source/smbd/dir.c
--- samba-3.0alpha21.orig/source/smbd/dir.c	2003-02-16 19:06:33.000000000 -0600
+++ samba-3.0alpha21/source/smbd/dir.c	2003-02-16 19:05:47.000000000 -0600
@@ -49,17 +49,17 @@
 
 void init_dptrs(void)
 {
-  static BOOL dptrs_init=False;
+	static BOOL dptrs_init=False;
 
-  if (dptrs_init)
-    return;
+	if (dptrs_init)
+		return;
 
-  dptr_bmap = bitmap_allocate(MAX_DIRECTORY_HANDLES);
+	dptr_bmap = bitmap_allocate(MAX_DIRECTORY_HANDLES);
 
-  if (!dptr_bmap)
-    exit_server("out of memory in init_dptrs");
+	if (!dptr_bmap)
+		exit_server("out of memory in init_dptrs");
 
-  dptrs_init = True;
+	dptrs_init = True;
 }
 
 /****************************************************************************
@@ -68,12 +68,12 @@
 
 static void dptr_idle(dptr_struct *dptr)
 {
-  if (dptr->ptr) {
-    DEBUG(4,("Idling dptr dnum %d\n",dptr->dnum));
-    dptrs_open--;
-    CloseDir(dptr->ptr);
-    dptr->ptr = NULL;
-  }
+	if (dptr->ptr) {
+		DEBUG(4,("Idling dptr dnum %d\n",dptr->dnum));
+		dptrs_open--;
+		CloseDir(dptr->ptr);
+		dptr->ptr = NULL;
+	}
 }
 
 /****************************************************************************
@@ -82,29 +82,29 @@
 
 static void dptr_idleoldest(void)
 {
-  dptr_struct *dptr;
+	dptr_struct *dptr;
+
+	/*
+	 * Go to the end of the list.
+	 */
+	for(dptr = dirptrs; dptr && dptr->next; dptr = dptr->next)
+		;
+
+	if(!dptr) {
+		DEBUG(0,("No dptrs available to idle ?\n"));
+		return;
+	}
 
-  /*
-   * Go to the end of the list.
-   */
-  for(dptr = dirptrs; dptr && dptr->next; dptr = dptr->next)
-    ;
-
-  if(!dptr) {
-    DEBUG(0,("No dptrs available to idle ?\n"));
-    return;
-  }
-
-  /*
-   * Idle the oldest pointer.
-   */
-
-  for(; dptr; dptr = dptr->prev) {
-    if (dptr->ptr) {
-      dptr_idle(dptr);
-      return;
-    }
-  }
+	/*
+	 * Idle the oldest pointer.
+	 */
+
+	for(; dptr; dptr = dptr->prev) {
+		if (dptr->ptr) {
+			dptr_idle(dptr);
+			return;
+		}
+	}
 }
 
 /****************************************************************************
@@ -113,22 +113,22 @@
 
 static dptr_struct *dptr_get(int key, BOOL forclose)
 {
-  dptr_struct *dptr;
+	dptr_struct *dptr;
 
-  for(dptr = dirptrs; dptr; dptr = dptr->next) {
-    if(dptr->dnum == key) {
-      if (!forclose && !dptr->ptr) {
-        if (dptrs_open >= MAX_OPEN_DIRECTORIES)
-          dptr_idleoldest();
-        DEBUG(4,("Reopening dptr key %d\n",key));
-        if ((dptr->ptr = OpenDir(dptr->conn, dptr->path, True)))
-          dptrs_open++;
-      }
-      DLIST_PROMOTE(dirptrs,dptr);
-      return dptr;
-    }
-  }
-  return(NULL);
+	for(dptr = dirptrs; dptr; dptr = dptr->next) {
+		if(dptr->dnum == key) {
+			if (!forclose && !dptr->ptr) {
+				if (dptrs_open >= MAX_OPEN_DIRECTORIES)
+					dptr_idleoldest();
+				DEBUG(4,("Reopening dptr key %d\n",key));
+				if ((dptr->ptr = OpenDir(dptr->conn, dptr->path, True)))
+					dptrs_open++;
+			}
+			DLIST_PROMOTE(dirptrs,dptr);
+			return dptr;
+		}
+	}
+	return(NULL);
 }
 
 /****************************************************************************
@@ -137,11 +137,11 @@
 
 static void *dptr_ptr(int key)
 {
-  dptr_struct *dptr = dptr_get(key, False);
+	dptr_struct *dptr = dptr_get(key, False);
 
-  if (dptr)
-    return(dptr->ptr);
-  return(NULL);
+	if (dptr)
+		return(dptr->ptr);
+	return(NULL);
 }
 
 /****************************************************************************
@@ -150,11 +150,11 @@
 
 char *dptr_path(int key)
 {
-  dptr_struct *dptr = dptr_get(key, False);
+	dptr_struct *dptr = dptr_get(key, False);
 
-  if (dptr)
-    return(dptr->path);
-  return(NULL);
+	if (dptr)
+		return(dptr->path);
+	return(NULL);
 }
 
 /****************************************************************************
@@ -163,11 +163,11 @@
 
 char *dptr_wcard(int key)
 {
-  dptr_struct *dptr = dptr_get(key, False);
+	dptr_struct *dptr = dptr_get(key, False);
 
-  if (dptr)
-    return(dptr->wcard);
-  return(NULL);
+	if (dptr)
+		return(dptr->wcard);
+	return(NULL);
 }
 
 /****************************************************************************
@@ -177,13 +177,13 @@
 
 BOOL dptr_set_wcard(int key, char *wcard)
 {
-  dptr_struct *dptr = dptr_get(key, False);
+	dptr_struct *dptr = dptr_get(key, False);
 
-  if (dptr) {
-    dptr->wcard = wcard;
-    return True;
-  }
-  return False;
+	if (dptr) {
+		dptr->wcard = wcard;
+		return True;
+	}
+	return False;
 }
 
 /****************************************************************************
@@ -193,13 +193,13 @@
 
 BOOL dptr_set_attr(int key, uint16 attr)
 {
-  dptr_struct *dptr = dptr_get(key, False);
+	dptr_struct *dptr = dptr_get(key, False);
 
-  if (dptr) {
-    dptr->attr = attr;
-    return True;
-  }
-  return False;
+	if (dptr) {
+		dptr->attr = attr;
+		return True;
+	}
+	return False;
 }
 
 /****************************************************************************
@@ -208,11 +208,11 @@
 
 uint16 dptr_attr(int key)
 {
-  dptr_struct *dptr = dptr_get(key, False);
+	dptr_struct *dptr = dptr_get(key, False);
 
-  if (dptr)
-    return(dptr->attr);
-  return(0);
+	if (dptr)
+		return(dptr->attr);
+	return(0);
 }
 
 /****************************************************************************
@@ -221,31 +221,31 @@
 
 static void dptr_close_internal(dptr_struct *dptr)
 {
-  DEBUG(4,("closing dptr key %d\n",dptr->dnum));
+	DEBUG(4,("closing dptr key %d\n",dptr->dnum));
 
-  DLIST_REMOVE(dirptrs, dptr);
+	DLIST_REMOVE(dirptrs, dptr);
 
-  /* 
-   * Free the dnum in the bitmap. Remember the dnum value is always 
-   * biased by one with respect to the bitmap.
-   */
+	/* 
+	 * Free the dnum in the bitmap. Remember the dnum value is always 
+	 * biased by one with respect to the bitmap.
+	 */
 
-  if(bitmap_query( dptr_bmap, dptr->dnum - 1) != True) {
-    DEBUG(0,("dptr_close_internal : Error - closing dnum = %d and bitmap not set !\n",
+	if(bitmap_query( dptr_bmap, dptr->dnum - 1) != True) {
+		DEBUG(0,("dptr_close_internal : Error - closing dnum = %d and bitmap not set !\n",
 			dptr->dnum ));
-  }
+	}
+
+	bitmap_clear(dptr_bmap, dptr->dnum - 1);
 
-  bitmap_clear(dptr_bmap, dptr->dnum - 1);
+	if (dptr->ptr) {
+		CloseDir(dptr->ptr);
+		dptrs_open--;
+	}
 
-  if (dptr->ptr) {
-    CloseDir(dptr->ptr);
-    dptrs_open--;
-  }
-
-  /* Lanman 2 specific code */
-  SAFE_FREE(dptr->wcard);
-  string_set(&dptr->path,"");
-  SAFE_FREE(dptr);
+	/* Lanman 2 specific code */
+	SAFE_FREE(dptr->wcard);
+	string_set(&dptr->path,"");
+	SAFE_FREE(dptr);
 }
 
 /****************************************************************************
@@ -254,32 +254,32 @@
 
 void dptr_close(int *key)
 {
-  dptr_struct *dptr;
+	dptr_struct *dptr;
+
+	if(*key == INVALID_DPTR_KEY)
+		return;
+
+	/* OS/2 seems to use -1 to indicate "close all directories" */
+	if (*key == -1) {
+		dptr_struct *next;
+		for(dptr = dirptrs; dptr; dptr = next) {
+			next = dptr->next;
+			dptr_close_internal(dptr);
+		}
+		*key = INVALID_DPTR_KEY;
+		return;
+	}
 
-  if(*key == INVALID_DPTR_KEY)
-    return;
+	dptr = dptr_get(*key, True);
 
-  /* OS/2 seems to use -1 to indicate "close all directories" */
-  if (*key == -1) {
-    dptr_struct *next;
-    for(dptr = dirptrs; dptr; dptr = next) {
-      next = dptr->next;
-      dptr_close_internal(dptr);
-    }
-    *key = INVALID_DPTR_KEY;
-    return;
-  }
-
-  dptr = dptr_get(*key, True);
-
-  if (!dptr) {
-    DEBUG(0,("Invalid key %d given to dptr_close\n", *key));
-    return;
-  }
+	if (!dptr) {
+		DEBUG(0,("Invalid key %d given to dptr_close\n", *key));
+		return;
+	}
 
-  dptr_close_internal(dptr);
+	dptr_close_internal(dptr);
 
-  *key = INVALID_DPTR_KEY;
+	*key = INVALID_DPTR_KEY;
 }
 
 /****************************************************************************
@@ -288,12 +288,12 @@
 
 void dptr_closecnum(connection_struct *conn)
 {
-  dptr_struct *dptr, *next;
-  for(dptr = dirptrs; dptr; dptr = next) {
-    next = dptr->next;
-    if (dptr->conn == conn)
-      dptr_close_internal(dptr);
-  }
+	dptr_struct *dptr, *next;
+	for(dptr = dirptrs; dptr; dptr = next) {
+		next = dptr->next;
+		if (dptr->conn == conn)
+			dptr_close_internal(dptr);
+	}
 }
 
 /****************************************************************************
@@ -302,11 +302,11 @@
 
 void dptr_idlecnum(connection_struct *conn)
 {
-  dptr_struct *dptr;
-  for(dptr = dirptrs; dptr; dptr = dptr->next) {
-    if (dptr->conn == conn && dptr->ptr)
-      dptr_idle(dptr);
-  }
+	dptr_struct *dptr;
+	for(dptr = dirptrs; dptr; dptr = dptr->next) {
+		if (dptr->conn == conn && dptr->ptr)
+			dptr_idle(dptr);
+	}
 }
 
 /****************************************************************************
@@ -315,36 +315,41 @@
 
 void dptr_closepath(char *path,uint16 spid)
 {
-  dptr_struct *dptr, *next;
-  for(dptr = dirptrs; dptr; dptr = next) {
-    next = dptr->next;
-    if (spid == dptr->spid && strequal(dptr->path,path))
-      dptr_close_internal(dptr);
-  }
+	dptr_struct *dptr, *next;
+	for(dptr = dirptrs; dptr; dptr = next) {
+		next = dptr->next;
+		if (spid == dptr->spid && strequal(dptr->path,path))
+			dptr_close_internal(dptr);
+	}
 }
 
 /****************************************************************************
  Start a directory listing.
 ****************************************************************************/
 
-static BOOL start_dir(connection_struct *conn,char *directory)
+static BOOL start_dir(connection_struct *conn, pstring directory)
 {
-  DEBUG(5,("start_dir dir=%s\n",directory));
+	const char *dir2;
+
+	DEBUG(5,("start_dir dir=%s\n",directory));
+
+	if (!check_name(directory,conn))
+		return(False);
 
-  if (!check_name(directory,conn))
-    return(False);
+	/* use a const pointer from here on */
+	dir2 = directory;
   
-  if (! *directory)
-    directory = ".";
+	if (! *dir2)
+		dir2 = ".";
 
-  conn->dirptr = OpenDir(conn, directory, True);
-  if (conn->dirptr) {    
-    dptrs_open++;
-    string_set(&conn->dirpath,directory);
-    return(True);
-  }
+	conn->dirptr = OpenDir(conn, directory, True);
+	if (conn->dirptr) {    
+		dptrs_open++;
+		string_set(&conn->dirpath,directory);
+		return(True);
+	}
   
-  return(False);
+	return(False);
 }
 
 /****************************************************************************
@@ -355,32 +360,32 @@
 
 static void dptr_close_oldest(BOOL old)
 {
-  dptr_struct *dptr;
+	dptr_struct *dptr;
+
+	/*
+	 * Go to the end of the list.
+	 */
+	for(dptr = dirptrs; dptr && dptr->next; dptr = dptr->next)
+		;
+
+	if(!dptr) {
+		DEBUG(0,("No old dptrs available to close oldest ?\n"));
+		return;
+	}
 
-  /*
-   * Go to the end of the list.
-   */
-  for(dptr = dirptrs; dptr && dptr->next; dptr = dptr->next)
-    ;
-
-  if(!dptr) {
-    DEBUG(0,("No old dptrs available to close oldest ?\n"));
-    return;
-  }
-
-  /*
-   * If 'old' is true, close the oldest oldhandle dnum (ie. 1 < dnum < 256) that
-   * does not have expect_close set. If 'old' is false, close
-   * one of the new dnum handles.
-   */
-
-  for(; dptr; dptr = dptr->prev) {
-    if ((old && (dptr->dnum < 256) && !dptr->expect_close) ||
-        (!old && (dptr->dnum > 255))) {
-      dptr_close_internal(dptr);
-      return;
-    }
-  }
+	/*
+	 * If 'old' is true, close the oldest oldhandle dnum (ie. 1 < dnum < 256) that
+	 * does not have expect_close set. If 'old' is false, close
+	 * one of the new dnum handles.
+	 */
+
+	for(; dptr; dptr = dptr->prev) {
+		if ((old && (dptr->dnum < 256) && !dptr->expect_close) ||
+			(!old && (dptr->dnum > 255))) {
+				dptr_close_internal(dptr);
+				return;
+		}
+	}
 }
 
 /****************************************************************************
@@ -392,101 +397,100 @@
  me at Andrew's knee.... :-) :-). JRA.
 ****************************************************************************/
 
-int dptr_create(connection_struct *conn,char *path, BOOL old_handle, BOOL expect_close,uint16 spid)
+int dptr_create(connection_struct *conn, pstring path, BOOL old_handle, BOOL expect_close,uint16 spid)
 {
-  dptr_struct *dptr;
-
-  if (!start_dir(conn,path))
-    return(-2); /* Code to say use a unix error return code. */
+	dptr_struct *dptr;
 
-  if (dptrs_open >= MAX_OPEN_DIRECTORIES)
-    dptr_idleoldest();
+	if (!start_dir(conn,path))
+		return(-2); /* Code to say use a unix error return code. */
 
-  dptr = (dptr_struct *)malloc(sizeof(dptr_struct));
-  if(!dptr) {
-    DEBUG(0,("malloc fail in dptr_create.\n"));
-    return -1;
-  }
+	if (dptrs_open >= MAX_OPEN_DIRECTORIES)
+		dptr_idleoldest();
 
-  ZERO_STRUCTP(dptr);
+	dptr = (dptr_struct *)malloc(sizeof(dptr_struct));
+	if(!dptr) {
+		DEBUG(0,("malloc fail in dptr_create.\n"));
+		return -1;
+	}
 
-  if(old_handle) {
+	ZERO_STRUCTP(dptr);
 
-    /*
-     * This is an old-style SMBsearch request. Ensure the
-     * value we return will fit in the range 1-255.
-     */
+	if(old_handle) {
 
-    dptr->dnum = bitmap_find(dptr_bmap, 0);
+		/*
+		 * This is an old-style SMBsearch request. Ensure the
+		 * value we return will fit in the range 1-255.
+		 */
 
-    if(dptr->dnum == -1 || dptr->dnum > 254) {
+		dptr->dnum = bitmap_find(dptr_bmap, 0);
 
-      /*
-       * Try and close the oldest handle not marked for
-       * expect close in the hope that the client has
-       * finished with that one.
-       */
+		if(dptr->dnum == -1 || dptr->dnum > 254) {
 
-      dptr_close_oldest(True);
+			/*
+			 * Try and close the oldest handle not marked for
+			 * expect close in the hope that the client has
+			 * finished with that one.
+			 */
 
-      /* Now try again... */
-      dptr->dnum = bitmap_find(dptr_bmap, 0);
+			dptr_close_oldest(True);
 
-      if(dptr->dnum == -1 || dptr->dnum > 254) {
-        DEBUG(0,("dptr_create: returned %d: Error - all old dirptrs in use ?\n", dptr->dnum));
-        SAFE_FREE(dptr);
-        return -1;
-      }
-    }
-  } else {
+			/* Now try again... */
+			dptr->dnum = bitmap_find(dptr_bmap, 0);
+			if(dptr->dnum == -1 || dptr->dnum > 254) {
+				DEBUG(0,("dptr_create: returned %d: Error - all old dirptrs in use ?\n", dptr->dnum));
+				SAFE_FREE(dptr);
+				return -1;
+			}
+		}
+	} else {
 
-    /*
-     * This is a new-style trans2 request. Allocate from
-     * a range that will return 256 - MAX_DIRECTORY_HANDLES.
-     */
+		/*
+		 * This is a new-style trans2 request. Allocate from
+		 * a range that will return 256 - MAX_DIRECTORY_HANDLES.
+		 */
 
-    dptr->dnum = bitmap_find(dptr_bmap, 255);
+		dptr->dnum = bitmap_find(dptr_bmap, 255);
 
-    if(dptr->dnum == -1 || dptr->dnum < 255) {
+		if(dptr->dnum == -1 || dptr->dnum < 255) {
 
-      /*
-       * Try and close the oldest handle close in the hope that
-       * the client has finished with that one. This will only
-       * happen in the case of the Win98 client bug where it leaks
-       * directory handles.
-       */
+			/*
+			 * Try and close the oldest handle close in the hope that
+			 * the client has finished with that one. This will only
+			 * happen in the case of the Win98 client bug where it leaks
+			 * directory handles.
+			 */
 
-      dptr_close_oldest(False);
+			dptr_close_oldest(False);
 
-      /* Now try again... */
-      dptr->dnum = bitmap_find(dptr_bmap, 255);
+			/* Now try again... */
+			dptr->dnum = bitmap_find(dptr_bmap, 255);
 
-      if(dptr->dnum == -1 || dptr->dnum < 255) {
-        DEBUG(0,("dptr_create: returned %d: Error - all new dirptrs in use ?\n", dptr->dnum));
-        SAFE_FREE(dptr);
-        return -1;
-      }
-    }
-  }
+			if(dptr->dnum == -1 || dptr->dnum < 255) {
+				DEBUG(0,("dptr_create: returned %d: Error - all new dirptrs in use ?\n", dptr->dnum));
+				SAFE_FREE(dptr);
+				return -1;
+			}
+		}
+	}
 
-  bitmap_set(dptr_bmap, dptr->dnum);
+	bitmap_set(dptr_bmap, dptr->dnum);
 
-  dptr->dnum += 1; /* Always bias the dnum by one - no zero dnums allowed. */
+	dptr->dnum += 1; /* Always bias the dnum by one - no zero dnums allowed. */
 
-  dptr->ptr = conn->dirptr;
-  string_set(&dptr->path,path);
-  dptr->conn = conn;
-  dptr->spid = spid;
-  dptr->expect_close = expect_close;
-  dptr->wcard = NULL; /* Only used in lanman2 searches */
-  dptr->attr = 0; /* Only used in lanman2 searches */
+	dptr->ptr = conn->dirptr;
+	string_set(&dptr->path,path);
+	dptr->conn = conn;
+	dptr->spid = spid;
+	dptr->expect_close = expect_close;
+	dptr->wcard = NULL; /* Only used in lanman2 searches */
+	dptr->attr = 0; /* Only used in lanman2 searches */
 
-  DLIST_ADD(dirptrs, dptr);
+	DLIST_ADD(dirptrs, dptr);
 
-  DEBUG(3,("creating new dirptr %d for path %s, expect_close = %d\n",
-	   dptr->dnum,path,expect_close));  
+	DEBUG(3,("creating new dirptr %d for path %s, expect_close = %d\n",
+		dptr->dnum,path,expect_close));  
 
-  return(dptr->dnum);
+	return(dptr->dnum);
 }
 
 /****************************************************************************
@@ -495,19 +499,19 @@
 
 BOOL dptr_fill(char *buf1,unsigned int key)
 {
-  unsigned char *buf = (unsigned char *)buf1;
-  void *p = dptr_ptr(key);
-  uint32 offset;
-  if (!p) {
-    DEBUG(1,("filling null dirptr %d\n",key));
-    return(False);
-  }
-  offset = TellDir(p);
-  DEBUG(6,("fill on key %u dirptr 0x%lx now at %d\n",key,
-	   (long)p,(int)offset));
-  buf[0] = key;
-  SIVAL(buf,1,offset | DPTR_MASK);
-  return(True);
+	unsigned char *buf = (unsigned char *)buf1;
+	void *p = dptr_ptr(key);
+	uint32 offset;
+	if (!p) {
+		DEBUG(1,("filling null dirptr %d\n",key));
+		return(False);
+	}
+	offset = TellDir(p);
+	DEBUG(6,("fill on key %u dirptr 0x%lx now at %d\n",key,
+		(long)p,(int)offset));
+	buf[0] = key;
+	SIVAL(buf,1,offset | DPTR_MASK);
+	return(True);
 }
 
 /****************************************************************************
@@ -516,19 +520,20 @@
 
 void *dptr_fetch(char *buf,int *num)
 {
-  unsigned int key = *(unsigned char *)buf;
-  void *p = dptr_ptr(key);
-  uint32 offset;
-  if (!p) {
-    DEBUG(3,("fetched null dirptr %d\n",key));
-    return(NULL);
-  }
-  *num = key;
-  offset = IVAL(buf,1)&~DPTR_MASK;
-  SeekDir(p,offset);
-  DEBUG(3,("fetching dirptr %d for path %s at offset %d\n",
-	   key,dptr_path(key),offset));
-  return(p);
+	unsigned int key = *(unsigned char *)buf;
+	void *p = dptr_ptr(key);
+	uint32 offset;
+
+	if (!p) {
+		DEBUG(3,("fetched null dirptr %d\n",key));
+		return(NULL);
+	}
+	*num = key;
+	offset = IVAL(buf,1)&~DPTR_MASK;
+	SeekDir(p,offset);
+	DEBUG(3,("fetching dirptr %d for path %s at offset %d\n",
+		key,dptr_path(key),offset));
+	return(p);
 }
 
 /****************************************************************************
@@ -537,14 +542,14 @@
 
 void *dptr_fetch_lanman2(int dptr_num)
 {
-  void *p = dptr_ptr(dptr_num);
+	void *p = dptr_ptr(dptr_num);
 
-  if (!p) {
-    DEBUG(3,("fetched null dirptr %d\n",dptr_num));
-    return(NULL);
-  }
-  DEBUG(3,("fetching dirptr %d for path %s\n",dptr_num,dptr_path(dptr_num)));
-  return(p);
+	if (!p) {
+		DEBUG(3,("fetched null dirptr %d\n",dptr_num));
+		return(NULL);
+	}
+	DEBUG(3,("fetching dirptr %d for path %s\n",dptr_num,dptr_path(dptr_num)));
+	return(p);
 }
 
 /****************************************************************************
@@ -586,96 +591,88 @@
 BOOL get_dir_entry(connection_struct *conn,char *mask,int dirtype,char *fname,
                    SMB_OFF_T *size,int *mode,time_t *date,BOOL check_descend)
 {
-  char *dname;
-  BOOL found = False;
-  SMB_STRUCT_STAT sbuf;
-  pstring path;
-  pstring pathreal;
-  BOOL isrootdir;
-  pstring filename;
-  BOOL needslash;
-
-  *path = *pathreal = *filename = 0;
-
-  isrootdir = (strequal(conn->dirpath,"./") ||
-	       strequal(conn->dirpath,".") ||
-	       strequal(conn->dirpath,"/"));
+	char *dname;
+	BOOL found = False;
+	SMB_STRUCT_STAT sbuf;
+	pstring path;
+	pstring pathreal;
+	BOOL isrootdir;
+	pstring filename;
+	BOOL needslash;
+
+	*path = *pathreal = *filename = 0;
+
+	isrootdir = (strequal(conn->dirpath,"./") ||
+			strequal(conn->dirpath,".") ||
+			strequal(conn->dirpath,"/"));
   
-  needslash = ( conn->dirpath[strlen(conn->dirpath) -1] != '/');
+	needslash = ( conn->dirpath[strlen(conn->dirpath) -1] != '/');
 
-  if (!conn->dirptr)
-    return(False);
+	if (!conn->dirptr)
+		return(False);
 
-  while (!found)
-  {
-    dname = ReadDirName(conn->dirptr);
+	while (!found) {
+		dname = ReadDirName(conn->dirptr);
 
-    DEBUG(6,("readdir on dirptr 0x%lx now at offset %d\n",
-          (long)conn->dirptr,TellDir(conn->dirptr)));
+		DEBUG(6,("readdir on dirptr 0x%lx now at offset %d\n",
+			(long)conn->dirptr,TellDir(conn->dirptr)));
       
-    if (dname == NULL) 
-      return(False);
+		if (dname == NULL) 
+			return(False);
       
-    pstrcpy(filename,dname);      
-
-    /* notice the special *.* handling. This appears to be the only difference
-       between the wildcard handling in this routine and in the trans2 routines.
-       see masktest for a demo
-    */
-    if ((strcmp(mask,"*.*") == 0) ||
-	mask_match(filename,mask,False) ||
-        mangle_mask_match(conn,filename,mask))
-    {
-      if (isrootdir && (strequal(filename,"..") || strequal(filename,".")))
-        continue;
-
-      if (!mangle_is_8_3(filename, False)) {
-	      mangle_map(filename,True,False,SNUM(conn));
-      }
-
-      pstrcpy(fname,filename);
-      *path = 0;
-      pstrcpy(path,conn->dirpath);
-      if(needslash)
-        pstrcat(path,"/");
-      pstrcpy(pathreal,path);
-      pstrcat(path,fname);
-      pstrcat(pathreal,dname);
-      if (conn->vfs_ops.stat(conn, pathreal, &sbuf) != 0)
-      {
-        DEBUG(5,("Couldn't stat 1 [%s]. Error = %s\n",path, strerror(errno) ));
-        continue;
-      }
-	  
-      *mode = dos_mode(conn,pathreal,&sbuf);
+		pstrcpy(filename,dname);      
 
-      if (!dir_check_ftype(conn,*mode,&sbuf,dirtype)) 
-      {
-        DEBUG(5,("[%s] attribs didn't match %x\n",filename,dirtype));
-        continue;
-      }
+		/* notice the special *.* handling. This appears to be the only difference
+			between the wildcard handling in this routine and in the trans2 routines.
+			see masktest for a demo
+		*/
+		if ((strcmp(mask,"*.*") == 0) ||
+				mask_match(filename,mask,False) ||
+				mangle_mask_match(conn,filename,mask)) {
+			if (isrootdir && (strequal(filename,"..") || strequal(filename,".")))
+				continue;
 
-      *size = sbuf.st_size;
-      *date = sbuf.st_mtime;
+			if (!mangle_is_8_3(filename, False))
+				mangle_map(filename,True,False,SNUM(conn));
 
-      DEBUG(3,("get_dir_entry mask=[%s] found %s fname=%s\n",mask, pathreal,fname));
+			pstrcpy(fname,filename);
+			*path = 0;
+			pstrcpy(path,conn->dirpath);
+			if(needslash)
+				pstrcat(path,"/");
+			pstrcpy(pathreal,path);
+			pstrcat(path,fname);
+			pstrcat(pathreal,dname);
+			if (conn->vfs_ops.stat(conn, pathreal, &sbuf) != 0) {
+				DEBUG(5,("Couldn't stat 1 [%s]. Error = %s\n",path, strerror(errno) ));
+				continue;
+			}
 	  
-      found = True;
-    }
-  }
+			*mode = dos_mode(conn,pathreal,&sbuf);
 
-  return(found);
-}
+			if (!dir_check_ftype(conn,*mode,&sbuf,dirtype)) {
+				DEBUG(5,("[%s] attribs didn't match %x\n",filename,dirtype));
+				continue;
+			}
 
+			*size = sbuf.st_size;
+			*date = sbuf.st_mtime;
 
+			DEBUG(3,("get_dir_entry mask=[%s] found %s fname=%s\n",mask, pathreal,fname));
 
-typedef struct
-{
-  int pos;
-  int numentries;
-  int mallocsize;
-  char *data;
-  char *current;
+			found = True;
+		}
+	}
+
+	return(found);
+}
+
+typedef struct {
+	int pos;
+	int numentries;
+	int mallocsize;
+	char *data;
+	char *current;
 } Dir;
 
 /*******************************************************************
@@ -691,7 +688,6 @@
 	size_t sd_size;
 	files_struct *fsp;
 	int smb_action;
-	int access_mode;
 	NTSTATUS status;
 	uint32 access_granted;
 
@@ -713,15 +709,14 @@
 		 fsp = open_directory(conn, name, pst, 0, SET_DENY_MODE(DENY_NONE), (FILE_FAIL_IF_NOT_EXIST|FILE_EXISTS_OPEN),
 			unix_mode(conn,aRONLY|aDIR, name), &smb_action);
 	else
-		fsp = open_file_shared1(conn, name, pst, FILE_READ_ATTRIBUTES, SET_DENY_MODE(DENY_NONE),
-			(FILE_FAIL_IF_NOT_EXIST|FILE_EXISTS_OPEN), 0, 0, &access_mode, &smb_action);
+		fsp = open_file_stat(conn, name, pst);
 
 	if (!fsp)
 		return False;
 
 	/* Get NT ACL -allocated in main loop talloc context. No free needed here. */
 	sd_size = conn->vfs_ops.fget_nt_acl(fsp, fsp->fd, &psd);
-	close_file(fsp, False);
+	close_file(fsp, True);
 
 	/* No access if SD get failed. */
 	if (!sd_size)
@@ -812,10 +807,10 @@
  Open a directory.
 ********************************************************************/
 
-void *OpenDir(connection_struct *conn, char *name, BOOL use_veto)
+void *OpenDir(connection_struct *conn, const char *name, BOOL use_veto)
 {
 	Dir *dirp;
-	char *n;
+	const char *n;
 	DIR *p = conn->vfs_ops.opendir(conn,name);
 	int used=0;
 
@@ -912,7 +907,7 @@
 			dirp->current = dirp->data;
 		}
 
-		pstrcpy(dirp->data+used,n);
+		safe_strcpy(dirp->data+used,n, dirp->mallocsize - used - 1);
 		used += l;
 		dirp->numentries++;
 	}
@@ -928,9 +923,10 @@
 
 void CloseDir(void *p)
 {
-  if (!p) return;    
-  SAFE_FREE(((Dir *)p)->data);
-  SAFE_FREE(p);
+	if (!p)
+		return;    
+	SAFE_FREE(((Dir *)p)->data);
+	SAFE_FREE(p);
 }
 
 /*******************************************************************
@@ -939,37 +935,39 @@
 
 char *ReadDirName(void *p)
 {
-  char *ret;
-  Dir *dirp = (Dir *)p;
+	char *ret;
+	Dir *dirp = (Dir *)p;
 
-  if (!dirp || !dirp->current || dirp->pos >= dirp->numentries) return(NULL);
+	if (!dirp || !dirp->current || dirp->pos >= dirp->numentries)
+		return(NULL);
 
-  ret = dirp->current;
-  dirp->current = skip_string(dirp->current,1);
-  dirp->pos++;
+	ret = dirp->current;
+	dirp->current = skip_string(dirp->current,1);
+	dirp->pos++;
 
-  return(ret);
+	return(ret);
 }
 
-
 /*******************************************************************
  Seek a dir.
 ********************************************************************/
 
 BOOL SeekDir(void *p,int pos)
 {
-  Dir *dirp = (Dir *)p;
+	Dir *dirp = (Dir *)p;
 
-  if (!dirp) return(False);
+	if (!dirp)
+		return(False);
 
-  if (pos < dirp->pos) {
-    dirp->current = dirp->data;
-    dirp->pos = 0;
-  }
+	if (pos < dirp->pos) {
+		dirp->current = dirp->data;
+		dirp->pos = 0;
+	}
 
-  while (dirp->pos < pos && ReadDirName(p)) ;
+	while (dirp->pos < pos && ReadDirName(p))
+		;
 
-  return(dirp->pos == pos);
+	return (dirp->pos == pos);
 }
 
 /*******************************************************************
@@ -978,11 +976,12 @@
 
 int TellDir(void *p)
 {
-  Dir *dirp = (Dir *)p;
+	Dir *dirp = (Dir *)p;
 
-  if (!dirp) return(-1);
+	if (!dirp)
+		return(-1);
   
-  return(dirp->pos);
+	return(dirp->pos);
 }
 
 /*******************************************************************************
@@ -991,11 +990,11 @@
 ********************************************************************************/
 
 typedef struct {
-  ubi_dlNode  node;
-  char       *path;
-  char       *name;
-  char       *dname;
-  int         snum;
+	ubi_dlNode node;
+	char *path;
+	char *name;
+	char *dname;
+	int snum;
 } dir_cache_entry;
 
 static ubi_dlNewList( dir_cache );
@@ -1009,38 +1008,38 @@
  Output: None.
 *****************************************************************************/
 
-void DirCacheAdd( char *path, char *name, char *dname, int snum )
+void DirCacheAdd( const char *path, char *name, char *dname, int snum )
 {
-  int               pathlen;
-  int               namelen;
-  dir_cache_entry  *entry;
-
-  /* Allocate the structure & string space in one go so that it can be freed
-   * in one call to free().
-   */
-  pathlen = strlen( path ) +1;  /* Bytes required to store path (with nul). */
-  namelen = strlen( name ) +1;  /* Bytes required to store name (with nul). */
-  entry = (dir_cache_entry *)malloc( sizeof( dir_cache_entry )
-                                   + pathlen
-                                   + namelen
-                                   + strlen( dname ) +1 );
-  if( NULL == entry )   /* Not adding to the cache is not fatal,  */
-    return;             /* so just return as if nothing happened. */
-
-  /* Set pointers correctly and load values. */
-  entry->path  = pstrcpy( (char *)&entry[1],       path);
-  entry->name  = pstrcpy( &(entry->path[pathlen]), name);
-  entry->dname = pstrcpy( &(entry->name[namelen]), dname);
-  entry->snum  = snum;
-
-  /* Add the new entry to the linked list. */
-  (void)ubi_dlAddHead( dir_cache, entry );
-  DEBUG( 4, ("Added dir cache entry %s %s -> %s\n", path, name, dname ) );
-
-  /* Free excess cache entries. */
-  while( DIRCACHESIZE < dir_cache->count )
-    safe_free( ubi_dlRemTail( dir_cache ) );
+	int pathlen;
+	int namelen;
+	dir_cache_entry  *entry;
 
+	/*
+	 * Allocate the structure & string space in one go so that it can be freed
+	 * in one call to free().
+	 */
+	pathlen = strlen(path) + 1;  /* Bytes required to store path (with nul). */
+	namelen = strlen(name) + 1;  /* Bytes required to store name (with nul). */
+	entry = (dir_cache_entry *)malloc( sizeof( dir_cache_entry )
+					+ pathlen
+					+ namelen
+					+ strlen( dname ) +1 );
+	if( NULL == entry )   /* Not adding to the cache is not fatal,  */
+		return;             /* so just return as if nothing happened. */
+
+	/* Set pointers correctly and load values. */
+	entry->path  = pstrcpy( (char *)&entry[1], path);
+	entry->name  = pstrcpy( &(entry->path[pathlen]), name);
+	entry->dname = pstrcpy( &(entry->name[namelen]), dname);
+	entry->snum  = snum;
+
+	/* Add the new entry to the linked list. */
+	(void)ubi_dlAddHead( dir_cache, entry );
+	DEBUG( 4, ("Added dir cache entry %s %s -> %s\n", path, name, dname ) );
+
+	/* Free excess cache entries. */
+	while( DIRCACHESIZE < dir_cache->count )
+		safe_free( ubi_dlRemTail( dir_cache ) );
 }
 
 /*****************************************************************************
@@ -1056,24 +1055,22 @@
          for large caches.
 *****************************************************************************/
 
-char *DirCacheCheck( char *path, char *name, int snum )
+char *DirCacheCheck( const char *path, const char *name, int snum )
 {
-  dir_cache_entry *entry;
+	dir_cache_entry *entry;
 
-  for( entry = (dir_cache_entry *)ubi_dlFirst( dir_cache );
-       NULL != entry;
-       entry = (dir_cache_entry *)ubi_dlNext( entry ) )
-    {
-    if( entry->snum == snum
-        && 0 == strcmp( name, entry->name )
-        && 0 == strcmp( path, entry->path ) )
-      {
-      DEBUG(4, ("Got dir cache hit on %s %s -> %s\n",path,name,entry->dname));
-      return( entry->dname );
-      }
-    }
+	for( entry = (dir_cache_entry *)ubi_dlFirst( dir_cache );
+			NULL != entry;
+			entry = (dir_cache_entry *)ubi_dlNext( entry ) ) {
+		if( entry->snum == snum
+				&& 0 == strcmp( name, entry->name )
+				&& 0 == strcmp( path, entry->path ) ) {
+			DEBUG(4, ("Got dir cache hit on %s %s -> %s\n",path,name,entry->dname));
+			return( entry->dname );
+		}
+	}
 
-  return(NULL);
+	return(NULL);
 }
 
 /*****************************************************************************
diff -uNr samba-3.0alpha21.orig/source/smbd/fileio.c samba-3.0alpha21/source/smbd/fileio.c
--- samba-3.0alpha21.orig/source/smbd/fileio.c	2003-02-16 19:06:33.000000000 -0600
+++ samba-3.0alpha21/source/smbd/fileio.c	2003-02-16 19:05:47.000000000 -0600
@@ -158,8 +158,19 @@
 	ssize_t total_written = 0;
 	int write_path = -1; 
 
-	if (fsp->print_file)
-		return print_job_write(SNUM(fsp->conn), fsp->print_jobid, data, n);
+	if (fsp->print_file) {
+		int snum;
+		uint32 jobid;
+
+		if (!rap_to_pjobid(fsp->rap_print_jobid, &snum, &jobid)) {
+			DEBUG(3,("write_file: Unable to map RAP jobid %u to jobid.\n",
+						(unsigned int)fsp->rap_print_jobid ));
+			errno = EBADF;
+			return -1;
+		}
+
+		return print_job_write(SNUM(fsp->conn), jobid, data, n);
+	}
 
 	if (!fsp->can_write) {
 		errno = EPERM;
@@ -172,7 +183,7 @@
 
 		if (fsp->conn->vfs_ops.fstat(fsp,fsp->fd,&st) == 0) {
 			int dosmode = dos_mode(fsp->conn,fsp->fsp_name,&st);
-			fsp->size = st.st_size;
+			fsp->size = (SMB_BIG_UINT)st.st_size;
 			if (MAP_ARCHIVE(fsp->conn) && !IS_DOS_ARCHIVE(dosmode))
 				file_chmod(fsp->conn,fsp->fsp_name,dosmode | aARCH,&st);
 
@@ -233,8 +244,8 @@
 	if(!wcp) {
 		DO_PROFILE_INC(writecache_direct_writes);
 		total_written = real_write_file(fsp, data, pos, n);
-		if ((total_written != -1) && (pos + total_written > fsp->size))
-			fsp->size = pos + total_written;
+		if ((total_written != -1) && (pos + total_written > (SMB_OFF_T)fsp->size))
+			fsp->size = (SMB_BIG_UINT)(pos + total_written);
 		return total_written;
 	}
 
@@ -283,8 +294,10 @@
 			 * Update the file size if changed.
 			 */
 
-			if (wcp->offset + wcp->data_size > wcp->file_size)
-				fsp->size = wcp->file_size = wcp->offset + wcp->data_size;
+			if (wcp->offset + wcp->data_size > wcp->file_size) {
+				wcp->file_size = wcp->offset + wcp->data_size;
+				fsp->size = (SMB_BIG_UINT)wcp->file_size;
+			}
 
 			/*
 			 * If we used all the data then
@@ -344,8 +357,10 @@
 			 * Update the file size if changed.
 			 */
 
-			if (wcp->offset + wcp->data_size > wcp->file_size)
-				fsp->size = wcp->file_size = wcp->offset + wcp->data_size;
+			if (wcp->offset + wcp->data_size > wcp->file_size) {
+				wcp->file_size = wcp->offset + wcp->data_size;
+				fsp->size = (SMB_BIG_UINT)wcp->file_size;
+			}
 
 			/*
 			 * We don't need to move the start of data, but we
@@ -418,8 +433,10 @@
 			 * Update the file size if changed.
 			 */
 
-			if (wcp->offset + wcp->data_size > wcp->file_size)
-				fsp->size = wcp->file_size = wcp->offset + wcp->data_size;
+			if (wcp->offset + wcp->data_size > wcp->file_size) {
+				wcp->file_size = wcp->offset + wcp->data_size;
+				fsp->size = (SMB_BIG_UINT)wcp->file_size;
+			}
 
 			/*
 			 * If we used all the data then
@@ -493,8 +510,10 @@
 			 * Update the file size if needed.
 			 */
 
-			if(pos + n > wcp->file_size)
-				fsp->size = wcp->file_size = pos + n;
+			if(pos + n > wcp->file_size) {
+				wcp->file_size = pos + n;
+				fsp->size = (SMB_BIG_UINT)wcp->file_size;
+			}
 
 			/*
 			 * If write would fit in the cache, and is larger than
@@ -525,8 +544,10 @@
 				if (ret == -1)
 					return ret;
 
-				if (pos + ret > wcp->file_size)
-					fsp->size = wcp->file_size = pos + ret;
+				if (pos + ret > wcp->file_size) {
+					wcp->file_size = pos + ret;
+					fsp->size = (SMB_BIG_UINT)wcp->file_size;
+				}
 
 				return ret;
 			}
@@ -535,8 +556,10 @@
 
 		}
 
-		if(wcp->data_size > wcp->file_size)
-			fsp->size = wcp->file_size = wcp->data_size;
+		if(wcp->data_size > wcp->file_size) {
+			wcp->file_size = wcp->data_size;
+			fsp->size = (SMB_BIG_UINT)wcp->file_size;
+		}
 
 		if (cache_flush_needed) {
 			DEBUG(3,("WRITE_FLUSH:%d: due to noncontinuous write: fd = %d, size = %.0f, pos = %.0f, \
@@ -558,8 +581,10 @@
 		if (ret == -1)
 			return -1;
 
-		if (pos + ret > wcp->file_size)
-			fsp->size = wcp->file_size = pos + n;
+		if (pos + ret > wcp->file_size) {
+			wcp->file_size = pos + n;
+			fsp->size = (SMB_BIG_UINT)wcp->file_size;
+		}
 
 		DO_PROFILE_INC(writecache_direct_writes);
 		return total_written + n;
@@ -588,8 +613,10 @@
 		 * Update the file size if changed.
 		 */
 
-		if (wcp->offset + wcp->data_size > wcp->file_size)
-			fsp->size = wcp->file_size = wcp->offset + wcp->data_size;
+		if (wcp->offset + wcp->data_size > wcp->file_size) {
+			wcp->file_size = wcp->offset + wcp->data_size;
+			fsp->size = (SMB_BIG_UINT)wcp->file_size;
+		}
 		DEBUG(9,("wcp->offset = %.0f wcp->data_size = %u cache return %u\n",
 			(double)wcp->offset, (unsigned int)wcp->data_size, (unsigned int)n));
 
@@ -674,7 +701,7 @@
 
 void set_filelen_write_cache(files_struct *fsp, SMB_OFF_T file_size)
 {
-	fsp->size = file_size;
+	fsp->size = (SMB_BIG_UINT)file_size;
 	if(fsp->wcp) {
 		/* The cache *must* have been flushed before we do this. */
 		if (fsp->wcp->data_size != 0) {
diff -uNr samba-3.0alpha21.orig/source/smbd/filename.c samba-3.0alpha21/source/smbd/filename.c
--- samba-3.0alpha21.orig/source/smbd/filename.c	2003-02-16 19:06:33.000000000 -0600
+++ samba-3.0alpha21/source/smbd/filename.c	2003-02-16 19:05:47.000000000 -0600
@@ -31,7 +31,8 @@
 extern BOOL short_case_preserve;
 extern BOOL use_mangled_map;
 
-static BOOL scan_directory(char *path, char *name,connection_struct *conn,BOOL docache);
+static BOOL scan_directory(const char *path, char *name,size_t maxlength,
+			   connection_struct *conn,BOOL docache);
 
 /****************************************************************************
  Check if two filenames are equal.
@@ -266,7 +267,11 @@
 			 * Try to find this part of the path in the directory.
 			 */
 
-			if (ms_has_wild(start) || !scan_directory(dirpath, start, conn, end?True:False)) {
+			if (ms_has_wild(start) || 
+			    !scan_directory(dirpath, start, 
+					    sizeof(pstring) - 1 - (start - name), 
+					    conn, 
+					    end?True:False)) {
 				if (end) {
 					/*
 					 * An intermediate part of the name can't be found.
@@ -315,8 +320,10 @@
 			 */
 			if (end) {
 				end = start + strlen(start);
-				pstrcat(start,"/");
-				pstrcat(start,rest);
+				if (!safe_strcat(start, "/", sizeof(pstring) - 1 - (start - name)) ||
+				    !safe_strcat(start, rest, sizeof(pstring) - 1 - (start - name))) {
+					return False;
+				}
 				*end = '\0';
 			} else {
 				/*
@@ -387,7 +394,7 @@
  a valid one for the user to access.
 ****************************************************************************/
 
-BOOL check_name(char *name,connection_struct *conn)
+BOOL check_name(pstring name,connection_struct *conn)
 {
 	BOOL ret;
 
@@ -428,7 +435,8 @@
  If the name looks like a mangled name then try via the mangling functions
 ****************************************************************************/
 
-static BOOL scan_directory(char *path, char *name,connection_struct *conn,BOOL docache)
+static BOOL scan_directory(const char *path, char *name, size_t maxlength, 
+			   connection_struct *conn,BOOL docache)
 {
 	void *cur_dir;
 	char *dname;
@@ -441,7 +449,7 @@
 		path = ".";
 
 	if (docache && (dname = DirCacheCheck(path,name,SNUM(conn)))) {
-		pstrcpy(name, dname);	
+		safe_strcpy(name, dname, maxlength);	
 		return(True);
 	}      
 
@@ -481,7 +489,7 @@
 			/* we've found the file, change it's name and return */
 			if (docache)
 				DirCacheAdd(path,name,dname,SNUM(conn));
-			pstrcpy(name, dname);
+			safe_strcpy(name, dname, maxlength);
 			CloseDir(cur_dir);
 			return(True);
 		}
diff -uNr samba-3.0alpha21.orig/source/smbd/lanman.c samba-3.0alpha21/source/smbd/lanman.c
--- samba-3.0alpha21.orig/source/smbd/lanman.c	2003-02-16 19:06:33.000000000 -0600
+++ samba-3.0alpha21/source/smbd/lanman.c	2003-02-16 19:05:47.000000000 -0600
@@ -109,14 +109,14 @@
 /*******************************************************************
   check a API string for validity when we only need to check the prefix
   ******************************************************************/
-static BOOL prefix_ok(char *str,char *prefix)
+static BOOL prefix_ok(const char *str, const char *prefix)
 {
   return(strncmp(str,prefix,strlen(prefix)) == 0);
 }
 
 struct pack_desc {
-  char* format;	    /* formatstring for structure */
-  char* subformat;  /* subformat for structure */
+  const char* format;	    /* formatstring for structure */
+  const char* subformat;  /* subformat for structure */
   char* base;	    /* baseaddress of buffer */
   int buflen;	   /* remaining size for fixed part; on init: length of base */
   int subcount;	    /* count of substructures */
@@ -125,11 +125,11 @@
   char* stringbuf;  /* pointer into buffer for remaining variable part */
   int neededlen;    /* total needed size */
   int usedlen;	    /* total used size (usedlen <= neededlen and usedlen <= buflen) */
-  char* curpos;	    /* current position; pointer into format or subformat */
+  const char* curpos;	    /* current position; pointer into format or subformat */
   int errcode;
 };
 
-static int get_counter(char** p)
+static int get_counter(const char** p)
 {
   int i, n;
   if (!p || !(*p)) return(1);
@@ -144,7 +144,7 @@
   }
 }
 
-static int getlen(char* p)
+static int getlen(const char* p)
 {
   int n = 0;
   if (!p) return(0);
@@ -329,7 +329,7 @@
 #define PACKl(desc,t,v,l) package(desc,v,l)
 #endif
 
-static void PACKI(struct pack_desc* desc,char *t,int v)
+static void PACKI(struct pack_desc* desc, const char *t,int v)
 {
   PACK(desc,t,v);
 }
@@ -1008,7 +1008,7 @@
     if (!next_token(&ptr,s->comment, NULL, sizeof(s->comment))) continue;
     if (!next_token(&ptr,s->domain , NULL, sizeof(s->domain))) {
       /* this allows us to cope with an old nmbd */
-      pstrcpy(s->domain,lp_workgroup()); 
+      fstrcpy(s->domain,lp_workgroup()); 
     }
     
     if (sscanf(stype,"%X",&s->type) != 1) { 
@@ -1704,7 +1704,7 @@
 	char *UserName = skip_string(str2,1);
 	char *p = skip_string(UserName,1);
 	int uLevel = SVAL(p,0);
-	char *p2;
+	const char *level_string;
 	int count=0;
 
 	*rparam_len = 8;
@@ -1715,13 +1715,13 @@
 		return False;
 	switch( uLevel ) {
 		case 0:
-			p2 = "B21";
+			level_string = "B21";
 			break;
 		default:
 			return False;
 	}
 
-	if (strcmp(p2,str2) != 0)
+	if (strcmp(level_string,str2) != 0)
 		return False;
 
 	*rdata_len = mdrcnt + 1024;
@@ -1930,25 +1930,7 @@
 	  DATA_BLOB password = data_blob(pass1, strlen(pass1)+1);
 	  if (NT_STATUS_IS_OK(check_plaintext_password(user,password,&server_info))) {
 
-		  /*
-		   * If unix password sync was requested, attempt to change
-		   * the /etc/passwd database first. Return failure if this cannot
-		   * be done.
-		   *
-		   * This occurs before the oem change, becouse we don't want to
-                   * update it if chgpasswd failed.
-		   *
-		   * Conditional on lp_unix_password_sync() becouse we don't want
-                   * to touch the unix db unless we have admin permission.
-		   */
-		  
-		  if(lp_unix_password_sync() && IS_SAM_UNIX_USER(server_info->sam_account) 
-		     && !chgpasswd(pdb_get_username(server_info->sam_account),
-				   pass1,pass2,False)) {
-			  SSVAL(*rparam,0,NERR_badpass);
-		  }
-		  
-		  if (change_oem_password(server_info->sam_account,pass2))
+		  if (NT_STATUS_IS_OK(change_oem_password(server_info->sam_account, pass1, pass2)))
 		  {
 			  SSVAL(*rparam,0,NERR_Success);
 		  }
@@ -1973,7 +1955,7 @@
     SAM_ACCOUNT *hnd = NULL;
 
     if (check_lanman_password(user,(unsigned char *)pass1,(unsigned char *)pass2, &hnd) && 
-       change_lanman_password(hnd,(unsigned char *)pass1,(unsigned char *)pass2))
+       change_lanman_password(hnd,pass2))
     {
       SSVAL(*rparam,0,NERR_Success);
     }
@@ -2031,7 +2013,7 @@
 
   (void)map_username(user);
 
-  if (pass_oem_change(user, (uchar*) data, (uchar *)&data[516], NULL, NULL))
+  if (NT_STATUS_IS_OK(pass_oem_change(user, (uchar*) data, (uchar *)&data[516], NULL, NULL)))
   {
     SSVAL(*rparam,0,NERR_Success);
   }
@@ -2602,6 +2584,7 @@
 	char *p = skip_string(UserName,1);
 	int uLevel = SVAL(p,0);
 	char *p2;
+	const char *level_string;
 
     /* get NIS home of a previously validated user - simeon */
     /* With share level security vuid will always be zero.
@@ -2620,15 +2603,15 @@
 	if (strcmp(str1,"zWrLh") != 0) return False;
 	switch( uLevel )
 	{
-		case 0: p2 = "B21"; break;
-		case 1: p2 = "B21BB16DWzzWz"; break;
-		case 2: p2 = "B21BB16DWzzWzDzzzzDDDDWb21WWzWW"; break;
-		case 10: p2 = "B21Bzzz"; break;
-		case 11: p2 = "B21BzzzWDDzzDDWWzWzDWb21W"; break;
+		case 0: level_string = "B21"; break;
+		case 1: level_string = "B21BB16DWzzWz"; break;
+		case 2: level_string = "B21BB16DWzzWzDzzzzDDDDWb21WWzWW"; break;
+		case 10: level_string = "B21Bzzz"; break;
+		case 11: level_string = "B21BzzzWDDzzDDWWzWzDWb21W"; break;
 		default: return False;
 	}
 
-	if (strcmp(p2,str2) != 0) return False;
+	if (strcmp(level_string,str2) != 0) return False;
 
 	*rdata_len = mdrcnt + 1024;
 	*rdata = REALLOC(*rdata,*rdata_len);
@@ -3425,9 +3408,9 @@
 
 
 
-const static struct
+static const struct
 {
-  char *name;
+  const char *name;
   int id;
   BOOL (*fn)(connection_struct *,uint16,char *,char *,
 	     int,int,char **,char **,int *,int *);
diff -uNr samba-3.0alpha21.orig/source/smbd/mangle.c samba-3.0alpha21/source/smbd/mangle.c
--- samba-3.0alpha21.orig/source/smbd/mangle.c	2003-02-16 19:06:33.000000000 -0600
+++ samba-3.0alpha21/source/smbd/mangle.c	2003-02-16 19:05:47.000000000 -0600
@@ -23,8 +23,8 @@
 static struct mangle_fns *mangle_fns;
 
 /* this allows us to add more mangling backends */
-static struct {
-	char *name;
+static const struct {
+	const char *name;
 	struct mangle_fns *(*init_fn)(void);
 } mangle_backends[] = {
 	{ "hash", mangle_hash_init },
diff -uNr samba-3.0alpha21.orig/source/smbd/mangle_hash.c samba-3.0alpha21/source/smbd/mangle_hash.c
--- samba-3.0alpha21.orig/source/smbd/mangle_hash.c	2003-02-16 19:06:33.000000000 -0600
+++ samba-3.0alpha21/source/smbd/mangle_hash.c	2003-02-16 19:05:47.000000000 -0600
@@ -361,15 +361,15 @@
  */
 static void init_chartest( void )
 {
-	char          *illegalchars = "*\\/?<>|\":";
-	unsigned char *s;
+	const char          *illegalchars = "*\\/?<>|\":";
+	const unsigned char *s;
   
 	memset( (char *)chartest, '\0', 256 );
 
-	for( s = (unsigned char *)illegalchars; *s; s++ )
+	for( s = (const unsigned char *)illegalchars; *s; s++ )
 		chartest[*s] = ILLEGAL_MASK;
 
-	for( s = (unsigned char *)basechars; *s; s++ )
+	for( s = (const unsigned char *)basechars; *s; s++ )
 		chartest[*s] |= BASECHAR_MASK;
 
 	ct_initialized = True;
@@ -730,7 +730,7 @@
 	DEBUG(5,("name_map( %s, need83 = %s, cache83 = %s)\n", OutName,
 		 need83 ? "True" : "False", cache83 ? "True" : "False"));
 	
-	if (push_ucs2_allocate(&OutName_ucs2, OutName) < 0) {
+	if (push_ucs2_allocate(&OutName_ucs2, OutName) == (size_t)-1) {
 		DEBUG(0, ("push_ucs2_allocate failed!\n"));
 		return;
 	}
diff -uNr samba-3.0alpha21.orig/source/smbd/negprot.c samba-3.0alpha21/source/smbd/negprot.c
--- samba-3.0alpha21.orig/source/smbd/negprot.c	2003-02-16 19:06:33.000000000 -0600
+++ samba-3.0alpha21/source/smbd/negprot.c	2003-02-16 19:05:47.000000000 -0600
@@ -377,9 +377,9 @@
 #define ARCH_ALL      0x3F
  
 /* List of supported protocols, most desired first */
-static struct {
-	char *proto_name;
-	char *short_name;
+static const struct {
+	const char *proto_name;
+	const char *short_name;
 	int (*proto_reply_fn)(char *, char *);
 	int protocol_level;
 } supported_protocols[] = {
diff -uNr samba-3.0alpha21.orig/source/smbd/notify.c samba-3.0alpha21/source/smbd/notify.c
--- samba-3.0alpha21.orig/source/smbd/notify.c	2003-02-16 19:06:33.000000000 -0600
+++ samba-3.0alpha21/source/smbd/notify.c	2003-02-16 19:05:47.000000000 -0600
@@ -207,7 +207,8 @@
 BOOL init_change_notify(void)
 {
 #if HAVE_KERNEL_CHANGE_NOTIFY
-	cnotify = kernel_notify_init();
+	if (lp_kernel_change_notify())
+		cnotify = kernel_notify_init();
 #endif
 	if (!cnotify) cnotify = hash_notify_init();
 	
diff -uNr samba-3.0alpha21.orig/source/smbd/notify_kernel.c samba-3.0alpha21/source/smbd/notify_kernel.c
--- samba-3.0alpha21.orig/source/smbd/notify_kernel.c	2003-02-16 19:06:33.000000000 -0600
+++ samba-3.0alpha21/source/smbd/notify_kernel.c	2003-02-16 19:05:47.000000000 -0600
@@ -215,6 +215,8 @@
 	static struct cnotify_fns cnotify;
         struct sigaction act;
 
+	ZERO_STRUCT(act);
+
         act.sa_handler = NULL;
         act.sa_sigaction = signal_handler;
         act.sa_flags = SA_SIGINFO;
diff -uNr samba-3.0alpha21.orig/source/smbd/nttrans.c samba-3.0alpha21/source/smbd/nttrans.c
--- samba-3.0alpha21.orig/source/smbd/nttrans.c	2003-02-16 19:06:33.000000000 -0600
+++ samba-3.0alpha21/source/smbd/nttrans.c	2003-02-16 19:05:47.000000000 -0600
@@ -27,7 +27,7 @@
 extern BOOL case_preserve;
 extern BOOL short_case_preserve;
 
-static char *known_nt_pipes[] = {
+static const char *known_nt_pipes[] = {
 	"\\LANMAN",
 	"\\srvsvc",
 	"\\samr",
@@ -548,7 +548,7 @@
 	uint32 create_disposition = IVAL(inbuf,smb_ntcreate_CreateDisposition);
 	uint32 create_options = IVAL(inbuf,smb_ntcreate_CreateOptions);
 	uint16 root_dir_fid = (uint16)IVAL(inbuf,smb_ntcreate_RootDirectoryFid);
-	SMB_OFF_T allocation_size = 0;
+	SMB_BIG_UINT allocation_size = 0;
 	int smb_ofun;
 	int smb_open_mode;
 	int smb_attr = (file_attributes & SAMBA_ATTRIBUTES_MASK);
@@ -629,6 +629,16 @@
 				END_PROFILE(SMBntcreateX);
 				return ERROR_NT(NT_STATUS_OBJECT_PATH_NOT_FOUND);
 			}
+
+
+			/*
+			  we need to handle the case when we get a
+			  relative open relative to a file and the
+			  pathname is blank - this is a reopen!
+			  (hint from demyn plantenberg)
+			*/
+			
+
 			END_PROFILE(SMBntcreateX);
 			return(ERROR_DOS(ERRDOS,ERRbadfid));
 		}
@@ -807,11 +817,11 @@
 	} 
 	
 	/* Save the requested allocation size. */
-	allocation_size = IVAL(inbuf,smb_ntcreate_AllocationSize);
+	allocation_size = (SMB_BIG_UINT)IVAL(inbuf,smb_ntcreate_AllocationSize);
 #ifdef LARGE_SMB_OFF_T
-	allocation_size |= (((SMB_OFF_T)IVAL(inbuf,smb_ntcreate_AllocationSize + 4)) << 32);
+	allocation_size |= (((SMB_BIG_UINT)IVAL(inbuf,smb_ntcreate_AllocationSize + 4)) << 32);
 #endif
-	if (allocation_size && (allocation_size > file_len)) {
+	if (allocation_size && (allocation_size > (SMB_BIG_UINT)file_len)) {
 		fsp->initial_allocation_size = SMB_ROUNDUP(allocation_size,SMB_ROUNDUP_ALLOCATION_SIZE);
 		if (vfs_allocate_file_space(fsp, fsp->initial_allocation_size) == -1) {
 			close_file(fsp,False);
@@ -819,7 +829,7 @@
 			return ERROR_NT(NT_STATUS_DISK_FULL);
 		}
 	} else {
-		fsp->initial_allocation_size = SMB_ROUNDUP(file_len,SMB_ROUNDUP_ALLOCATION_SIZE);
+		fsp->initial_allocation_size = SMB_ROUNDUP(((SMB_BIG_UINT)file_len),SMB_ROUNDUP_ALLOCATION_SIZE);
 	}
 
 	/* 
@@ -985,7 +995,7 @@
 	 * Init the parse struct we will unmarshall from.
 	 */
 
-	if ((mem_ctx = talloc_init()) == NULL) {
+	if ((mem_ctx = talloc_init("set_sd")) == NULL) {
 		DEBUG(0,("set_sd: talloc_init failed.\n"));
 		return NT_STATUS_NO_MEMORY;
 	}
@@ -1065,7 +1075,7 @@
 	uint32 create_options;
 	uint32 sd_len;
 	uint16 root_dir_fid;
-	SMB_OFF_T allocation_size = 0;
+	SMB_BIG_UINT allocation_size = 0;
 	int smb_ofun;
 	int smb_open_mode;
 	int smb_attr;
@@ -1304,9 +1314,9 @@
 	restore_case_semantics(file_attributes);
 
 	/* Save the requested allocation size. */
-	allocation_size = IVAL(params,12);
+	allocation_size = (SMB_BIG_UINT)IVAL(params,12);
 #ifdef LARGE_SMB_OFF_T
-	allocation_size |= (((SMB_OFF_T)IVAL(params,16)) << 32);
+	allocation_size |= (((SMB_BIG_UINT)IVAL(params,16)) << 32);
 #endif
 	if (allocation_size && (allocation_size > file_len)) {
 		fsp->initial_allocation_size = SMB_ROUNDUP(allocation_size,SMB_ROUNDUP_ALLOCATION_SIZE);
@@ -1316,7 +1326,7 @@
 			return ERROR_NT(NT_STATUS_DISK_FULL);
 		}
 	} else {
-		fsp->initial_allocation_size = SMB_ROUNDUP(file_len,SMB_ROUNDUP_ALLOCATION_SIZE);
+		fsp->initial_allocation_size = SMB_ROUNDUP(((SMB_BIG_UINT)file_len),SMB_ROUNDUP_ALLOCATION_SIZE);
 	}
 
 	/* Realloc the size of parameters and data we will return */
@@ -1538,7 +1548,7 @@
 
 	*ppparams = params;
 
-	if ((mem_ctx = talloc_init()) == NULL) {
+	if ((mem_ctx = talloc_init("call_nt_transact_query_security_desc")) == NULL) {
 		DEBUG(0,("call_nt_transact_query_security_desc: talloc_init failed.\n"));
 		return ERROR_DOS(ERRDOS,ERRnomem);
 	}
diff -uNr samba-3.0alpha21.orig/source/smbd/open.c samba-3.0alpha21/source/smbd/open.c
--- samba-3.0alpha21.orig/source/smbd/open.c	2003-02-16 19:06:33.000000000 -0600
+++ samba-3.0alpha21/source/smbd/open.c	2003-02-16 19:05:47.000000000 -0600
@@ -79,6 +79,7 @@
 		DEBUG(3,("Rejecting named pipe open for %s\n",fname));
 		unix_ERR_class = ERRSRV;
 		unix_ERR_code = ERRaccess;
+		unix_ERR_ntstatus = NT_STATUS_ACCESS_DENIED;
 	}
 }
 
@@ -228,8 +229,8 @@
 	fsp->oplock_type = NO_OPLOCK;
 	fsp->sent_oplock_break = NO_BREAK_SENT;
 	fsp->is_directory = False;
+	fsp->is_stat = False;
 	fsp->directory_delete_on_close = False;
-	fsp->conn = conn;
 	string_set(&fsp->fsp_name,fname);
 	fsp->wcp = NULL; /* Write cache pointer. */
 
@@ -255,6 +256,7 @@
 		errno = EACCES;
 		unix_ERR_class = ERRDOS;
 		unix_ERR_code = ERRlock;
+		unix_ERR_ntstatus = dos_to_ntstatus(ERRDOS, ERRlock);
 		return -1;
 	} else {
 		return conn->vfs_ops.ftruncate(fsp,fsp->fd,0); 
@@ -399,9 +401,10 @@
 	if (GET_DELETE_ON_CLOSE_FLAG(share->share_mode)) {
 		DEBUG(5,("check_share_mode: Failing open on file %s as delete on close flag is set.\n",
 			fname ));
-		unix_ERR_class = ERRDOS;
-		unix_ERR_code = ERRnoaccess;
-		unix_ERR_ntstatus = NT_STATUS_DELETE_PENDING;
+		/* Use errno to map to correct error. */
+		unix_ERR_class = SMB_SUCCESS;
+		unix_ERR_code = 0;
+		unix_ERR_ntstatus = NT_STATUS_OK;
 		return False;
 	}
 
@@ -444,6 +447,7 @@
 				fname ));
 			unix_ERR_class = ERRDOS;
 			unix_ERR_code = ERRbadshare;
+			unix_ERR_ntstatus = NT_STATUS_SHARING_VIOLATION;
 
 			return False;
 		}
@@ -464,6 +468,7 @@
 			fname ));
 		unix_ERR_class = ERRDOS;
 		unix_ERR_code = ERRbadshare;
+		unix_ERR_ntstatus = NT_STATUS_SHARING_VIOLATION;
 
 		return False;
 	}
@@ -479,6 +484,7 @@
 			fname ));
 		unix_ERR_class = ERRDOS;
 		unix_ERR_code = ERRbadshare;
+		unix_ERR_ntstatus = NT_STATUS_SHARING_VIOLATION;
 
 		return False;
 	}
@@ -510,6 +516,7 @@
 
 			unix_ERR_class = ERRDOS;
 			unix_ERR_code = ERRbadshare;
+			unix_ERR_ntstatus = NT_STATUS_SHARING_VIOLATION;
 
 			return False;
 		}
@@ -584,7 +591,7 @@
 				/* Oplock break - unlock to request it. */
 				unlock_share_entry(conn, dev, inode);
 				
-				opb_ret = request_oplock_break(share_entry);
+				opb_ret = request_oplock_break(share_entry, False);
 				
 				/* Now relock. */
 				lock_share_entry(conn, dev, inode);
@@ -596,6 +603,7 @@
 					errno = EACCES;
 					unix_ERR_class = ERRDOS;
 					unix_ERR_code = ERRbadshare;
+					unix_ERR_ntstatus = NT_STATUS_SHARING_VIOLATION;
 					return -1;
 				}
 				
@@ -646,6 +654,7 @@
 						errno = EACCES;
 						unix_ERR_class = ERRDOS;
 						unix_ERR_code = ERRbadshare;
+						unix_ERR_ntstatus = NT_STATUS_SHARING_VIOLATION;
 						return -1;
 					}
 					
@@ -697,9 +706,11 @@
 }
 
 
-static BOOL open_match_attributes(connection_struct *conn, char *path, mode_t existing_mode, mode_t new_mode)
+static BOOL open_match_attributes(connection_struct *conn, char *path, mode_t existing_mode,
+		mode_t new_mode, mode_t *returned_mode)
 {
 	uint32 old_dos_mode, new_dos_mode;
+	uint32 noarch_old_dos_mode, noarch_new_dos_mode;
 	SMB_STRUCT_STAT sbuf;
 
 	ZERO_STRUCT(sbuf);
@@ -710,6 +721,19 @@
 	sbuf.st_mode = new_mode;
 	new_dos_mode = dos_mode(conn, path, &sbuf);
 
+	noarch_old_dos_mode = (old_dos_mode & ~FILE_ATTRIBUTE_ARCHIVE);
+	noarch_new_dos_mode = (new_dos_mode & ~FILE_ATTRIBUTE_ARCHIVE);
+
+	if((noarch_old_dos_mode == 0 && noarch_new_dos_mode != 0) || 
+	   (noarch_old_dos_mode != 0 && ((noarch_old_dos_mode & noarch_new_dos_mode) == noarch_old_dos_mode)))
+		*returned_mode = new_mode;
+	else
+		*returned_mode = (mode_t)0;
+
+	DEBUG(10,("open_match_attributes: file %s old_dos_mode = 0x%x, existing_mode = 0%o, new_dos_mode = 0x%x returned_mode = 0%o\n",
+		path,
+		old_dos_mode, (unsigned int)existing_mode, new_dos_mode, (unsigned int)*returned_mode ));
+
 	/* If we're mapping SYSTEM and HIDDEN ensure they match. */
 	if (lp_map_system(SNUM(conn))) {
 		if ((old_dos_mode & FILE_ATTRIBUTE_SYSTEM) && !(new_dos_mode & FILE_ATTRIBUTE_SYSTEM))
@@ -723,9 +747,9 @@
 }
 
 /****************************************************************************
- Open a file with a share mode. On output from this open we are guarenteeing
- that 
+ Open a file with a share mode.
 ****************************************************************************/
+
 files_struct *open_file_shared(connection_struct *conn,char *fname, SMB_STRUCT_STAT *psbuf, 
 			       int share_mode,int ofun, mode_t mode,int oplock_request, 
 			       int *Access,int *action)
@@ -735,9 +759,9 @@
 }
 
 /****************************************************************************
- Open a file with a share mode. On output from this open we are guarenteeing
- that 
+ Open a file with a share mode.
 ****************************************************************************/
+
 files_struct *open_file_shared1(connection_struct *conn,char *fname, SMB_STRUCT_STAT *psbuf, 
 				uint32 desired_access, 
 				int share_mode,int ofun, mode_t mode,int oplock_request, 
@@ -759,6 +783,7 @@
 	files_struct *fsp = NULL;
 	int open_mode=0;
 	uint16 port = 0;
+	mode_t new_mode = (mode_t)0;
 
 	if (conn->printer) {
 		/* printers are handled completely differently. Most of the passed parameters are
@@ -818,7 +843,7 @@
 
 	/* We only care about matching attributes on file exists and truncate. */
 	if (file_existed && (GET_FILE_OPEN_DISPOSITION(ofun) == FILE_EXISTS_TRUNCATE)) {
-		if (!open_match_attributes(conn, fname, psbuf->st_mode, mode)) {
+		if (!open_match_attributes(conn, fname, psbuf->st_mode, mode, &new_mode)) {
 			DEBUG(5,("open_file_shared: attributes missmatch for file %s (0%o, 0%o)\n",
 						fname, psbuf->st_mode, mode ));
 			file_free(fsp);
@@ -906,6 +931,7 @@
 			 * we can do. We also ensure we're not going to create or tuncate
 			 * the file as we only want an access decision at this stage. JRA.
 			 */
+			errno = 0;
 			fsp_open = open_file(fsp,conn,fname,psbuf,
 						flags|(flags2&~(O_TRUNC|O_CREAT)),mode,desired_access);
 
@@ -913,6 +939,12 @@
 flags=0x%X flags2=0x%X mode=0%o returned %d\n",
 				flags,(flags2&~(O_TRUNC|O_CREAT)),(int)mode,(int)fsp_open ));
 
+			if (!fsp_open && errno) {
+				unix_ERR_class = ERRDOS;
+				unix_ERR_code = ERRnoaccess;
+				unix_ERR_ntstatus = NT_STATUS_ACCESS_DENIED;
+			}
+
 			unlock_share_entry(conn, dev, inode);
 			if (fsp_open)
 				fd_close(conn, fsp);
@@ -1088,11 +1120,36 @@
 	 */
 
 	if (!file_existed && !def_acl && (conn->vfs_ops.fchmod_acl != NULL)) {
+
 		int saved_errno = errno; /* We might get ENOSYS in the next call.. */
+
 		if (conn->vfs_ops.fchmod_acl(fsp, fsp->fd, mode) == -1 && errno == ENOSYS)
 			errno = saved_errno; /* Ignore ENOSYS */
+
+	} else if (new_mode) {
+
+		int ret = -1;
+
+		/* Attributes need changing. File already existed. */
+
+		if (conn->vfs_ops.fchmod_acl != NULL) {
+			int saved_errno = errno; /* We might get ENOSYS in the next call.. */
+			ret = conn->vfs_ops.fchmod_acl(fsp, fsp->fd, new_mode);
+
+			if (ret == -1 && errno == ENOSYS) {
+				errno = saved_errno; /* Ignore ENOSYS */
+			} else {
+				DEBUG(5, ("open_file_shared: failed to reset attributes of file %s to 0%o\n",
+					fname, (int)new_mode));
+				ret = 0; /* Don't do the fchmod below. */
+			}
+		}
+
+		if ((ret == -1) && (conn->vfs_ops.fchmod(fsp, fsp->fd, new_mode) == -1))
+			DEBUG(5, ("open_file_shared: failed to reset attributes of file %s to 0%o\n",
+				fname, (int)new_mode));
 	}
-		
+
 	unlock_share_entry_fsp(fsp);
 
 	conn->num_files_open++;
@@ -1160,8 +1217,6 @@
 	if(!fsp)
 		return NULL;
 
-	fsp->conn = conn; /* The vfs_fXXX() macros need this. */
-
 	if (VALID_STAT(*psbuf))
 		got_stat = True;
 
@@ -1255,8 +1310,8 @@
 	fsp->oplock_type = NO_OPLOCK;
 	fsp->sent_oplock_break = NO_BREAK_SENT;
 	fsp->is_directory = True;
+	fsp->is_stat = False;
 	fsp->directory_delete_on_close = False;
-	fsp->conn = conn;
 	string_set(&fsp->fsp_name,fname);
 
 	if (delete_on_close) {
@@ -1271,118 +1326,58 @@
 
 	return fsp;
 }
-#if 0
 
-Old code - I have replaced with correct desired_access checking. JRA.
-
-/*******************************************************************
- Check if the share mode on a file allows it to be deleted or unlinked.
- Return True if sharing doesn't prevent the operation.
-********************************************************************/
+/****************************************************************************
+ Open a pseudo-file (no locking checks - a 'stat' open).
+****************************************************************************/
 
-BOOL check_file_sharing(connection_struct *conn,char *fname, BOOL rename_op)
+files_struct *open_file_stat(connection_struct *conn, char *fname, SMB_STRUCT_STAT *psbuf)
 {
-	int i;
-	int ret = False;
-	share_mode_entry *old_shares = 0;
-	int num_share_modes;
-	SMB_STRUCT_STAT sbuf;
-	pid_t pid = sys_getpid();
-	SMB_DEV_T dev;
-	SMB_INO_T inode;
-
-	if (vfs_stat(conn,fname,&sbuf) == -1)
-		return(True);
-
-	dev = sbuf.st_dev;
-	inode = sbuf.st_ino;
-
-	lock_share_entry(conn, dev, inode);
-	num_share_modes = get_share_modes(conn, dev, inode, &old_shares);
-
-	/*
-	 * Check if the share modes will give us access.
-	 */
-
-	if(num_share_modes != 0) {
-		BOOL broke_oplock;
-
-		do {
-
-			broke_oplock = False;
-			for(i = 0; i < num_share_modes; i++) {
-				share_mode_entry *share_entry = &old_shares[i];
-
-				/* 
-				 * Break oplocks before checking share modes. See comment in
-				 * open_file_shared for details. 
-				 * Check if someone has an oplock on this file. If so we must 
-				 * break it before continuing. 
-				 */
-				if(BATCH_OPLOCK_TYPE(share_entry->op_type)) {
-
-					DEBUG(5,("check_file_sharing: breaking oplock (%x) on file %s, \
-dev = %x, inode = %.0f\n", share_entry->op_type, fname, (unsigned int)dev, (double)inode));
-
-					/* Oplock break.... */
-					unlock_share_entry(conn, dev, inode);
+	extern struct current_user current_user;
+	files_struct *fsp = NULL;
 
-					if(request_oplock_break(share_entry) == False) {
-						DEBUG(0,("check_file_sharing: FAILED when breaking oplock (%x) on file %s, \
-dev = %x, inode = %.0f\n", old_shares[i].op_type, fname, (unsigned int)dev, (double)inode));
+	if (!VALID_STAT(*psbuf))
+		return NULL;
 
-						SAFE_FREE(old_shares);
-						return False;
-					}
-					lock_share_entry(conn, dev, inode);
-					broke_oplock = True;
-					break;
-				}
+	/* Can't 'stat' open directories. */
+	if(S_ISDIR(psbuf->st_mode))
+		return NULL;
 
-				/* 
-				 * If this is a delete request and ALLOW_SHARE_DELETE is set then allow 
-				 * this to proceed. This takes precedence over share modes.
-				 */
-
-				if(!rename_op && GET_ALLOW_SHARE_DELETE(share_entry->share_mode))
-					continue;
-
-				/* 
-				 * Someone else has a share lock on it, check to see 
-				 * if we can too.
-				 */
-       			 	if ((GET_DENY_MODE(share_entry->share_mode) != DENY_DOS) || 
-							(share_entry->pid != pid))
-					goto free_and_exit;
-	
-			} /* end for */
+	fsp = file_new(conn);
+	if(!fsp)
+		return NULL;
 
-			if(broke_oplock) {
-				SAFE_FREE(old_shares);
-				num_share_modes = get_share_modes(conn, dev, inode, &old_shares);
-			}
-		} while(broke_oplock);
-	}
+	DEBUG(5,("open_file_stat: 'opening' file %s\n", fname));
 
 	/*
-	 * XXXX exactly what share mode combinations should be allowed for
-	 * deleting/renaming?
+	 * Setup the files_struct for it.
 	 */
-
+	
+	fsp->mode = psbuf->st_mode;
 	/* 
-	 * If we got here then either there were no share modes or
-	 * all share modes were DENY_DOS and the pid == getpid() or
-	 * delete access was requested and all share modes had the
-	 * ALLOW_SHARE_DELETE bit set (takes precedence over other
-	 * share modes).
+	 * Don't store dev or inode, we don't want any iterator
+	 * to see this.
 	 */
+	fsp->inode = (SMB_INO_T)0;
+	fsp->dev = (SMB_DEV_T)0;
+	fsp->size = psbuf->st_size;
+	fsp->vuid = current_user.vuid;
+	fsp->pos = -1;
+	fsp->can_lock = False;
+	fsp->can_read = False;
+	fsp->can_write = False;
+	fsp->share_mode = 0;
+	fsp->desired_access = 0;
+	fsp->print_file = False;
+	fsp->modified = False;
+	fsp->oplock_type = NO_OPLOCK;
+	fsp->sent_oplock_break = NO_BREAK_SENT;
+	fsp->is_directory = False;
+	fsp->is_stat = True;
+	fsp->directory_delete_on_close = False;
+	string_set(&fsp->fsp_name,fname);
 
-	ret = True;
-
-free_and_exit:
+	conn->num_files_open++;
 
-	unlock_share_entry(conn, dev, inode);
-	SAFE_FREE(old_shares);
-	return(ret);
+	return fsp;
 }
-#endif
diff -uNr samba-3.0alpha21.orig/source/smbd/oplock.c samba-3.0alpha21/source/smbd/oplock.c
--- samba-3.0alpha21.orig/source/smbd/oplock.c	2003-02-16 19:06:33.000000000 -0600
+++ samba-3.0alpha21/source/smbd/oplock.c	2003-02-16 19:05:47.000000000 -0600
@@ -368,6 +368,7 @@
 
 		case OPLOCK_BREAK_CMD:
 		case LEVEL_II_OPLOCK_BREAK_CMD:
+		case ASYNC_LEVEL_II_OPLOCK_BREAK_CMD:
 
 			/* Ensure that the msg length is correct. */
 			if(msg_len != OPLOCK_BREAK_MSG_LEN) {
@@ -438,14 +439,14 @@
 	}
 
 	/* 
-	 * Do the appropriate reply - none in the kernel or level II case.
+	 * Do the appropriate reply - none in the kernel or async level II case.
 	 */
 
-	if(SVAL(msg_start,OPBRK_MESSAGE_CMD_OFFSET) == OPLOCK_BREAK_CMD) {
+	if(break_cmd_type == OPLOCK_BREAK_CMD || break_cmd_type == LEVEL_II_OPLOCK_BREAK_CMD) {
 		struct sockaddr_in toaddr;
 
 		/* Send the message back after OR'ing in the 'REPLY' bit. */
-		SSVAL(msg_start,OPBRK_MESSAGE_CMD_OFFSET,OPLOCK_BREAK_CMD | CMD_REPLY);
+		SSVAL(msg_start,OPBRK_MESSAGE_CMD_OFFSET,break_cmd_type | CMD_REPLY);
 
 		memset((char *)&toaddr,'\0',sizeof(toaddr));
 		toaddr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
@@ -902,7 +903,7 @@
 by the local smbd then call the oplock break function directly.
 ****************************************************************************/
 
-BOOL request_oplock_break(share_mode_entry *share_entry)
+BOOL request_oplock_break(share_mode_entry *share_entry, BOOL async)
 {
 	char op_break_msg[OPLOCK_BREAK_MSG_LEN];
 	struct sockaddr_in addr_out;
@@ -912,6 +913,7 @@
 	SMB_DEV_T dev = share_entry->dev;
 	SMB_INO_T inode = share_entry->inode;
 	unsigned long file_id = share_entry->share_file_id;
+	uint16 break_cmd_type;
 
 	if(pid == share_entry->pid) {
 		/* We are breaking our own oplock, make sure it's us. */
@@ -942,11 +944,12 @@
 	/* We need to send a OPLOCK_BREAK_CMD message to the port in the share mode entry. */
 
 	if (LEVEL_II_OPLOCK_TYPE(share_entry->op_type)) {
-		SSVAL(op_break_msg,OPBRK_MESSAGE_CMD_OFFSET,LEVEL_II_OPLOCK_BREAK_CMD);
+		break_cmd_type = async ? ASYNC_LEVEL_II_OPLOCK_BREAK_CMD : LEVEL_II_OPLOCK_BREAK_CMD;
 	} else {
-		SSVAL(op_break_msg,OPBRK_MESSAGE_CMD_OFFSET,OPLOCK_BREAK_CMD);
+		break_cmd_type = OPLOCK_BREAK_CMD;
 	}
 
+	SSVAL(op_break_msg,OPBRK_MESSAGE_CMD_OFFSET,break_cmd_type);
 	memcpy(op_break_msg+OPLOCK_BREAK_PID_OFFSET,(char *)&pid,sizeof(pid));
 	memcpy(op_break_msg+OPLOCK_BREAK_DEV_OFFSET,(char *)&dev,sizeof(dev));
 	memcpy(op_break_msg+OPLOCK_BREAK_INODE_OFFSET,(char *)&inode,sizeof(inode));
@@ -959,7 +962,7 @@
 	addr_out.sin_family = AF_INET;
    
 	if( DEBUGLVL( 3 ) ) {
-		dbgtext( "request_oplock_break: sending a oplock break message to " );
+		dbgtext( "request_oplock_break: sending a %s oplock break message to ", async ? "asynchronous" : "synchronous" );
 		dbgtext( "pid %d on port %d ", (int)share_entry->pid, share_entry->op_port );
 		dbgtext( "for dev = %x, inode = %.0f, file_id = %lu\n",
             (unsigned int)dev, (double)inode, file_id );
@@ -972,19 +975,19 @@
 			dbgtext( "break message to pid %d ", (int)share_entry->pid );
 			dbgtext( "on port %d ", share_entry->op_port );
 			dbgtext( "for dev = %x, inode = %.0f, file_id = %lu\n",
-          (unsigned int)dev, (double)inode, file_id );
+				(unsigned int)dev, (double)inode, file_id );
 			dbgtext( "Error was %s\n", strerror(errno) );
 		}
 		return False;
 	}
 
 	/*
-	 * If we just sent a message to a level II oplock share entry then
+	 * If we just sent a message to a level II oplock share entry in async mode then
 	 * we are done and may return.
 	 */
 
-	if (LEVEL_II_OPLOCK_TYPE(share_entry->op_type)) {
-		DEBUG(3,("request_oplock_break: sent break message to level II entry.\n"));
+	if (LEVEL_II_OPLOCK_TYPE(share_entry->op_type) && async) {
+		DEBUG(3,("request_oplock_break: sent async break message to level II entry.\n"));
 		return True;
 	}
 
@@ -1039,10 +1042,10 @@
 		reply_msg_start = &op_break_reply[OPBRK_CMD_HEADER_LEN];
 
 		/*
-		 * Test to see if this is the reply we are awaiting.
+		 * Test to see if this is the reply we are awaiting (ie. the one we sent with the CMD_REPLY flag OR'ed in).
 		 */
 		if((SVAL(reply_msg_start,OPBRK_MESSAGE_CMD_OFFSET) & CMD_REPLY) &&
-			((SVAL(reply_msg_start,OPBRK_MESSAGE_CMD_OFFSET) & ~CMD_REPLY) == OPLOCK_BREAK_CMD) &&
+			((SVAL(reply_msg_start,OPBRK_MESSAGE_CMD_OFFSET) & ~CMD_REPLY) == break_cmd_type) &&
 			(reply_from_port == share_entry->op_port) && 
 			(memcmp(&reply_msg_start[OPLOCK_BREAK_PID_OFFSET], &op_break_msg[OPLOCK_BREAK_PID_OFFSET],
 				OPLOCK_BREAK_MSG_LEN - OPLOCK_BREAK_PID_OFFSET) == 0)) {
@@ -1185,8 +1188,8 @@
 			 * message.
 			 */
 
-			DEBUG(10,("release_level_2_oplocks_on_change: breaking remote oplock.\n"));
-			request_oplock_break(share_entry);
+			DEBUG(10,("release_level_2_oplocks_on_change: breaking remote oplock (async).\n"));
+			request_oplock_break(share_entry, True);
 		}
 	}
 
diff -uNr samba-3.0alpha21.orig/source/smbd/oplock_linux.c samba-3.0alpha21/source/smbd/oplock_linux.c
--- samba-3.0alpha21.orig/source/smbd/oplock_linux.c	2003-02-16 19:06:33.000000000 -0600
+++ samba-3.0alpha21/source/smbd/oplock_linux.c	2003-02-16 19:05:47.000000000 -0600
@@ -279,6 +279,8 @@
 		return NULL;
 	}
 
+	ZERO_STRUCT(act);
+
 	act.sa_handler = NULL;
 	act.sa_sigaction = signal_handler;
 	act.sa_flags = SA_SIGINFO;
diff -uNr samba-3.0alpha21.orig/source/smbd/posix_acls.c samba-3.0alpha21/source/smbd/posix_acls.c
--- samba-3.0alpha21.orig/source/smbd/posix_acls.c	2003-02-16 19:06:33.000000000 -0600
+++ samba-3.0alpha21/source/smbd/posix_acls.c	2003-02-16 19:05:47.000000000 -0600
@@ -1551,7 +1551,7 @@
 ****************************************************************************/
 
 static canon_ace *canonicalise_acl( files_struct *fsp, SMB_ACL_T posix_acl, SMB_STRUCT_STAT *psbuf,
-					DOM_SID *powner, DOM_SID *pgroup, SMB_ACL_TYPE_T acl_type)
+					DOM_SID *powner, DOM_SID *pgroup, SMB_ACL_TYPE_T the_acl_type)
 {
 	extern DOM_SID global_sid_World;
 	connection_struct *conn = fsp->conn;
@@ -1603,7 +1603,7 @@
 					 * entries out of the blue when setting ACLs, so a get/set
 					 * cycle will drop them.
 					 */
-					if (acl_type == SMB_ACL_TYPE_ACCESS && *puid == psbuf->st_uid)
+					if (the_acl_type == SMB_ACL_TYPE_ACCESS && *puid == psbuf->st_uid)
 						continue;
 					uid_to_sid( &sid, *puid);
 					unix_ug.uid = *puid;
diff -uNr samba-3.0alpha21.orig/source/smbd/process.c samba-3.0alpha21/source/smbd/process.c
--- samba-3.0alpha21.orig/source/smbd/process.c	2003-02-16 19:06:33.000000000 -0600
+++ samba-3.0alpha21/source/smbd/process.c	2003-02-16 19:05:47.000000000 -0600
@@ -339,7 +339,7 @@
    functions. Any message that has a NULL function is unimplemented -
    please feel free to contribute implementations!
 */
-const static struct smb_message_struct
+static const struct smb_message_struct
 {
   const char *name;
   int (*fn)(connection_struct *conn, char *, char *, int, int);
@@ -799,6 +799,32 @@
  'hard' limit Samba overhead on resource constrained systems. 
 ****************************************************************************/
 
+static BOOL process_count_update_successful = False;
+
+static int32 increment_smbd_process_count(void)
+{
+	int32 total_smbds;
+
+	if (lp_max_smbd_processes()) {
+		total_smbds = 0;
+		if (tdb_change_int32_atomic(conn_tdb_ctx(), "INFO/total_smbds", &total_smbds, 1) == -1)
+			return 1;
+		process_count_update_successful = True;
+		return total_smbds + 1;
+	}
+	return 1;
+}
+
+void decrement_smbd_process_count(void)
+{
+	int32 total_smbds;
+
+	if (lp_max_smbd_processes() && process_count_update_successful) {
+		total_smbds = 1;
+		tdb_change_int32_atomic(conn_tdb_ctx(), "INFO/total_smbds", &total_smbds, -1);
+	}
+}
+
 static BOOL smbd_process_limit(void)
 {
 	int32  total_smbds;
@@ -809,17 +835,13 @@
 		 * subtracts one.
 		 */
 
-		total_smbds = 1; /* In case we need to create the entry. */
-
 		if (!conn_tdb_ctx()) {
 			DEBUG(0,("smbd_process_limit: max smbd processes parameter set with status parameter not \
 set. Ignoring max smbd restriction.\n"));
 			return False;
 		}
 
-		if (tdb_change_int32_atomic(conn_tdb_ctx(), "INFO/total_smbds", &total_smbds, 1) == -1)
-			return True;
-
+		total_smbds = increment_smbd_process_count();
 		return total_smbds > lp_max_smbd_processes();
 	}
 	else
@@ -890,7 +912,7 @@
 ****************************************************************************/
 const char *smb_fn_name(int type)
 {
-	static char *unknown_name = "SMBunknown";
+	const char *unknown_name = "SMBunknown";
 
 	if (smb_messages[type].name == NULL)
 		return(unknown_name);
@@ -1140,7 +1162,6 @@
   {
     unsigned char trust_passwd_hash[16];
     time_t lct;
-    pstring remote_machine_list;
 
     /*
      * We're in domain level security, and the code that
@@ -1175,9 +1196,9 @@
       return True;
     }
 
-    pstrcpy(remote_machine_list, lp_passwordserver());
-
-    change_trust_account_password( lp_workgroup(), remote_machine_list);
+    /* always just contact the PDC here */
+    
+    change_trust_account_password( lp_workgroup(), NULL);
     global_machine_password_needs_changing = False;
     secrets_lock_trust_account_password(lp_workgroup(), False);
   }
@@ -1188,6 +1209,10 @@
    */
   process_blocking_lock_queue(t);
 
+  /* update printer queue caches if necessary */
+  
+  update_monitored_printq_cache();
+  
   /*
    * Check to see if we have any change notifies 
    * outstanding on the queue.
@@ -1203,7 +1228,7 @@
 
   /* Send any queued printer notify message to interested smbd's. */
 
-  print_notify_send_messages();
+  print_notify_send_messages(0);
 
   /*
    * Modify the select timeout depending upon
@@ -1289,5 +1314,17 @@
 				last_timeout_processing_time = new_check_time; /* Reset time. */
 			}
 		}
+
+		/* The timeout_processing function isn't run nearly
+		   often enough to implement 'max log size' without
+		   overrunning the size of the file by many megabytes.
+		   This is especially true if we are running at debug
+		   level 10.  Checking every 50 SMBs is a nice
+		   tradeoff of performance vs log file size overrun. */
+
+		if ((num_smbs % 50) == 0 && need_to_check_log_size()) {
+			change_to_root_user();
+			check_log_size();
+		}
 	}
 }
diff -uNr samba-3.0alpha21.orig/source/smbd/quotas.c samba-3.0alpha21/source/smbd/quotas.c
--- samba-3.0alpha21.orig/source/smbd/quotas.c	2003-02-16 19:06:33.000000000 -0600
+++ samba-3.0alpha21/source/smbd/quotas.c	2003-02-16 19:05:47.000000000 -0600
@@ -886,10 +886,21 @@
 #if !defined(__FreeBSD__) && !defined(AIX) && !defined(__OpenBSD__)
   char dev_disk[256];
   SMB_STRUCT_STAT S;
+
   /* find the block device file */
-  if ((sys_stat(path, &S)<0) ||
-      (devnm(S_IFBLK, S.st_dev, dev_disk, 256, 0)<0)) return (False);
-#endif
+
+#ifdef HPUX
+  /* Need to set the cache flag to 1 for HPUX. Seems
+   * to have a significant performance boost when
+   * lstat calls on /dev access this function.
+   */
+  if ((sys_stat(path, &S)<0) || (devnm(S_IFBLK, S.st_dev, dev_disk, 256, 1)<0))
+#else
+  if ((sys_stat(path, &S)<0) || (devnm(S_IFBLK, S.st_dev, dev_disk, 256, 0)<0)) 
+	return (False);
+#endif /* ifdef HPUX */
+
+#endif /* !defined(__FreeBSD__) && !defined(AIX) && !defined(__OpenBSD__) */
 
   euser_id = geteuid();
 
diff -uNr samba-3.0alpha21.orig/source/smbd/reply.c samba-3.0alpha21/source/smbd/reply.c
--- samba-3.0alpha21.orig/source/smbd/reply.c	2003-02-16 19:06:33.000000000 -0600
+++ samba-3.0alpha21/source/smbd/reply.c	2003-02-16 19:05:47.000000000 -0600
@@ -271,7 +271,7 @@
 		set_message_end(outbuf,p);
 	} else {
 		/* NT sets the fstype of IPC$ to the null string */
-		char *fsname = IS_IPC(conn) ? "" : lp_fstype(SNUM(conn));
+		const char *fsname = IS_IPC(conn) ? "" : lp_fstype(SNUM(conn));
 
 		set_message(outbuf,3,0,True);
 
@@ -353,8 +353,7 @@
 	switch (ioctl_code) {
 		case IOCTL_QUERY_JOB_INFO:		    
 		{
-			uint16 rap_jobid = pjobid_to_rap(SNUM(fsp->conn), fsp->print_jobid);
-			SSVAL(p,0,rap_jobid);             /* Job number */
+			SSVAL(p,0,fsp->rap_print_jobid);             /* Job number */
 			srvstr_push(outbuf, p+2, global_myname(), 15, STR_TERMINATE|STR_ASCII);
 			srvstr_push(outbuf, p+18, lp_servicename(SNUM(conn)), 13, STR_TERMINATE|STR_ASCII);
 			break;
@@ -418,74 +417,69 @@
 
 int reply_getatr(connection_struct *conn, char *inbuf,char *outbuf, int dum_size, int dum_buffsize)
 {
-  pstring fname;
-  int outsize = 0;
-  SMB_STRUCT_STAT sbuf;
-  BOOL ok = False;
-  int mode=0;
-  SMB_OFF_T size=0;
-  time_t mtime=0;
-  BOOL bad_path = False;
-  char *p;
-  START_PROFILE(SMBgetatr);
-
-  p = smb_buf(inbuf) + 1;
-  p += srvstr_pull_buf(inbuf, fname, p, sizeof(fname), STR_TERMINATE);
-
-  RESOLVE_DFSPATH(fname, conn, inbuf, outbuf);
-  
-  /* dos smetimes asks for a stat of "" - it returns a "hidden directory"
-     under WfWg - weird! */
-  if (! (*fname))
-  {
-    mode = aHIDDEN | aDIR;
-    if (!CAN_WRITE(conn)) mode |= aRONLY;
-    size = 0;
-    mtime = 0;
-    ok = True;
-  }
-  else
-  {
-    unix_convert(fname,conn,0,&bad_path,&sbuf);
-    if (check_name(fname,conn))
-    {
-      if (VALID_STAT(sbuf) || vfs_stat(conn,fname,&sbuf) == 0)
-      {
-        mode = dos_mode(conn,fname,&sbuf);
-        size = sbuf.st_size;
-        mtime = sbuf.st_mtime;
-        if (mode & aDIR)
-          size = 0;
-        ok = True;
-      }
-      else
-        DEBUG(3,("stat of %s failed (%s)\n",fname,strerror(errno)));
-    }
-  }
-  
-  if (!ok)
-  {
-    set_bad_path_error(errno, bad_path);
-    END_PROFILE(SMBgetatr);
-    return(UNIXERROR(ERRDOS,ERRbadfile));
-  }
+	pstring fname;
+	int outsize = 0;
+	SMB_STRUCT_STAT sbuf;
+	BOOL ok = False;
+	int mode=0;
+	SMB_OFF_T size=0;
+	time_t mtime=0;
+	BOOL bad_path = False;
+	char *p;
+	START_PROFILE(SMBgetatr);
+
+	p = smb_buf(inbuf) + 1;
+	p += srvstr_pull_buf(inbuf, fname, p, sizeof(fname), STR_TERMINATE);
+
+	RESOLVE_DFSPATH(fname, conn, inbuf, outbuf);
+  
+	/* dos smetimes asks for a stat of "" - it returns a "hidden directory"
+		under WfWg - weird! */
+	if (! (*fname)) {
+		mode = aHIDDEN | aDIR;
+		if (!CAN_WRITE(conn))
+			mode |= aRONLY;
+		size = 0;
+		mtime = 0;
+		ok = True;
+	} else {
+		unix_convert(fname,conn,0,&bad_path,&sbuf);
+		if (check_name(fname,conn)) {
+			if (VALID_STAT(sbuf) || vfs_stat(conn,fname,&sbuf) == 0) {
+				mode = dos_mode(conn,fname,&sbuf);
+				size = sbuf.st_size;
+				mtime = sbuf.st_mtime;
+				if (mode & aDIR)
+					size = 0;
+				ok = True;
+			} else {
+				DEBUG(3,("stat of %s failed (%s)\n",fname,strerror(errno)));
+			}
+		}
+	}
+  
+	if (!ok) {
+		set_bad_path_error(errno, bad_path);
+		END_PROFILE(SMBgetatr);
+		return(UNIXERROR(ERRDOS,ERRbadfile));
+	}
  
-  outsize = set_message(outbuf,10,0,True);
+	outsize = set_message(outbuf,10,0,True);
 
-  SSVAL(outbuf,smb_vwv0,mode);
-  if(lp_dos_filetime_resolution(SNUM(conn)) )
-    put_dos_date3(outbuf,smb_vwv1,mtime & ~1);
-  else
-    put_dos_date3(outbuf,smb_vwv1,mtime);
-  SIVAL(outbuf,smb_vwv3,(uint32)size);
+	SSVAL(outbuf,smb_vwv0,mode);
+	if(lp_dos_filetime_resolution(SNUM(conn)) )
+		put_dos_date3(outbuf,smb_vwv1,mtime & ~1);
+	else
+		put_dos_date3(outbuf,smb_vwv1,mtime);
+	SIVAL(outbuf,smb_vwv3,(uint32)size);
 
-  if (Protocol >= PROTOCOL_NT1)
-	  SSVAL(outbuf,smb_flg2,SVAL(outbuf, smb_flg2) | FLAGS2_IS_LONG_NAME);
+	if (Protocol >= PROTOCOL_NT1)
+		SSVAL(outbuf,smb_flg2,SVAL(outbuf, smb_flg2) | FLAGS2_IS_LONG_NAME);
   
-  DEBUG( 3, ( "getatr name=%s mode=%d size=%d\n", fname, mode, (uint32)size ) );
+	DEBUG( 3, ( "getatr name=%s mode=%d size=%d\n", fname, mode, (uint32)size ) );
   
-  END_PROFILE(SMBgetatr);
-  return(outsize);
+	END_PROFILE(SMBgetatr);
+	return(outsize);
 }
 
 /****************************************************************************
@@ -494,47 +488,46 @@
 
 int reply_setatr(connection_struct *conn, char *inbuf,char *outbuf, int dum_size, int dum_buffsize)
 {
-  pstring fname;
-  int outsize = 0;
-  BOOL ok=False;
-  int mode;
-  time_t mtime;
-  SMB_STRUCT_STAT sbuf;
-  BOOL bad_path = False;
-  char *p;
-
-  START_PROFILE(SMBsetatr);
-
-  p = smb_buf(inbuf) + 1;
-  p += srvstr_pull_buf(inbuf, fname, p, sizeof(fname), STR_TERMINATE);
-  unix_convert(fname,conn,0,&bad_path,&sbuf);
-
-  mode = SVAL(inbuf,smb_vwv0);
-  mtime = make_unix_date3(inbuf+smb_vwv1);
-  
-  if (VALID_STAT_OF_DIR(sbuf))
-    mode |= aDIR;
-  else
-    mode &= ~aDIR;
-
-  if (check_name(fname,conn))
-    ok =  (file_chmod(conn,fname,mode,NULL) == 0);
-  if (ok)
-    ok = set_filetime(conn,fname,mtime);
-  
-  if (!ok)
-  {
-    set_bad_path_error(errno, bad_path);
-    END_PROFILE(SMBsetatr);
-    return(UNIXERROR(ERRDOS,ERRnoaccess));
-  }
+	pstring fname;
+	int outsize = 0;
+	BOOL ok=False;
+	int mode;
+	time_t mtime;
+	SMB_STRUCT_STAT sbuf;
+	BOOL bad_path = False;
+	char *p;
+
+	START_PROFILE(SMBsetatr);
+
+	p = smb_buf(inbuf) + 1;
+	p += srvstr_pull_buf(inbuf, fname, p, sizeof(fname), STR_TERMINATE);
+	unix_convert(fname,conn,0,&bad_path,&sbuf);
+
+	mode = SVAL(inbuf,smb_vwv0);
+	mtime = make_unix_date3(inbuf+smb_vwv1);
+  
+	if (VALID_STAT_OF_DIR(sbuf))
+		mode |= aDIR;
+	else
+		mode &= ~aDIR;
+
+	if (check_name(fname,conn))
+		ok =  (file_chmod(conn,fname,mode,NULL) == 0);
+	if (ok)
+		ok = set_filetime(conn,fname,mtime);
+  
+	if (!ok) {
+		set_bad_path_error(errno, bad_path);
+		END_PROFILE(SMBsetatr);
+		return(UNIXERROR(ERRDOS,ERRnoaccess));
+	}
  
-  outsize = set_message(outbuf,0,0,True);
+	outsize = set_message(outbuf,0,0,True);
   
-  DEBUG( 3, ( "setatr name=%s mode=%d\n", fname, mode ) );
+	DEBUG( 3, ( "setatr name=%s mode=%d\n", fname, mode ) );
   
-  END_PROFILE(SMBsetatr);
-  return(outsize);
+	END_PROFILE(SMBsetatr);
+	return(outsize);
 }
 
 /****************************************************************************
@@ -592,206 +585,190 @@
 
 int reply_search(connection_struct *conn, char *inbuf,char *outbuf, int dum_size, int dum_buffsize)
 {
-  pstring mask;
-  pstring directory;
-  pstring fname;
-  SMB_OFF_T size;
-  int mode;
-  time_t date;
-  int dirtype;
-  int outsize = 0;
-  int numentries = 0;
-  BOOL finished = False;
-  int maxentries;
-  int i;
-  char *p;
-  BOOL ok = False;
-  int status_len;
-  pstring path;
-  char status[21];
-  int dptr_num= -1;
-  BOOL check_descend = False;
-  BOOL expect_close = False;
-  BOOL can_open = True;
-  BOOL bad_path = False;
-  START_PROFILE(SMBsearch);
-
-  *mask = *directory = *fname = 0;
-
-  /* If we were called as SMBffirst then we must expect close. */
-  if(CVAL(inbuf,smb_com) == SMBffirst)
-    expect_close = True;
-  
-  outsize = set_message(outbuf,1,3,True);
-  maxentries = SVAL(inbuf,smb_vwv0); 
-  dirtype = SVAL(inbuf,smb_vwv1);
-  p = smb_buf(inbuf) + 1;
-  p += srvstr_pull_buf(inbuf, path, p, sizeof(path), STR_TERMINATE);
-  p++;
-  status_len = SVAL(p, 0);
-  p += 2;
-  
-  /* dirtype &= ~aDIR; */
-  
-  if (status_len == 0)
-  {
-    SMB_STRUCT_STAT sbuf;
-    pstring dir2;
-
-    pstrcpy(directory,path);
-    pstrcpy(dir2,path);
-    unix_convert(directory,conn,0,&bad_path,&sbuf);
-    unix_format(dir2);
-
-    if (!check_name(directory,conn))
-      can_open = False;
-
-    p = strrchr_m(dir2,'/');
-    if (p == NULL) 
-    {
-      pstrcpy(mask,dir2);
-      *dir2 = 0;
-    }
-    else
-    {
-      *p = 0;
-      pstrcpy(mask,p+1);
-    }
-
-    p = strrchr_m(directory,'/');
-    if (!p) 
-      *directory = 0;
-    else
-      *p = 0;
-
-    if (strlen(directory) == 0)
-      pstrcpy(directory,"./");
-    memset((char *)status,'\0',21);
-    SCVAL(status,0,(dirtype & 0x1F));
-  }
-  else
-  {
-    int status_dirtype;
-    memcpy(status,p,21);
-    status_dirtype = CVAL(status,0) & 0x1F;
-    if (status_dirtype != (dirtype & 0x1F))
-      dirtype = status_dirtype;
-
-    conn->dirptr = dptr_fetch(status+12,&dptr_num);      
-    if (!conn->dirptr)
-      goto SearchEmpty;
-    string_set(&conn->dirpath,dptr_path(dptr_num));
-    fstrcpy(mask, dptr_wcard(dptr_num));
-  }
-
-  if (can_open)
-  {
-    p = smb_buf(outbuf) + 3;
-      
-    ok = True;
+	pstring mask;
+	pstring directory;
+	pstring fname;
+	SMB_OFF_T size;
+	int mode;
+	time_t date;
+	int dirtype;
+	int outsize = 0;
+	int numentries = 0;
+	BOOL finished = False;
+	int maxentries;
+	int i;
+	char *p;
+	BOOL ok = False;
+	int status_len;
+	pstring path;
+	char status[21];
+	int dptr_num= -1;
+	BOOL check_descend = False;
+	BOOL expect_close = False;
+	BOOL can_open = True;
+	BOOL bad_path = False;
+	START_PROFILE(SMBsearch);
+
+	*mask = *directory = *fname = 0;
+
+	/* If we were called as SMBffirst then we must expect close. */
+	if(CVAL(inbuf,smb_com) == SMBffirst)
+		expect_close = True;
+  
+	outsize = set_message(outbuf,1,3,True);
+	maxentries = SVAL(inbuf,smb_vwv0); 
+	dirtype = SVAL(inbuf,smb_vwv1);
+	p = smb_buf(inbuf) + 1;
+	p += srvstr_pull_buf(inbuf, path, p, sizeof(path), STR_TERMINATE);
+	p++;
+	status_len = SVAL(p, 0);
+	p += 2;
+  
+	/* dirtype &= ~aDIR; */
+
+	if (status_len == 0) {
+		SMB_STRUCT_STAT sbuf;
+		pstring dir2;
+
+		pstrcpy(directory,path);
+		pstrcpy(dir2,path);
+		unix_convert(directory,conn,0,&bad_path,&sbuf);
+		unix_format(dir2);
+
+		if (!check_name(directory,conn))
+			can_open = False;
+
+		p = strrchr_m(dir2,'/');
+		if (p == NULL) {
+			pstrcpy(mask,dir2);
+			*dir2 = 0;
+		} else {
+			*p = 0;
+			pstrcpy(mask,p+1);
+		}
+
+		p = strrchr_m(directory,'/');
+		if (!p) 
+			*directory = 0;
+		else
+			*p = 0;
+
+		if (strlen(directory) == 0)
+			pstrcpy(directory,".");
+		memset((char *)status,'\0',21);
+		SCVAL(status,0,(dirtype & 0x1F));
+	} else {
+		int status_dirtype;
+
+		memcpy(status,p,21);
+		status_dirtype = CVAL(status,0) & 0x1F;
+		if (status_dirtype != (dirtype & 0x1F))
+			dirtype = status_dirtype;
+
+		conn->dirptr = dptr_fetch(status+12,&dptr_num);      
+		if (!conn->dirptr)
+			goto SearchEmpty;
+		string_set(&conn->dirpath,dptr_path(dptr_num));
+		pstrcpy(mask, dptr_wcard(dptr_num));
+	}
+
+	if (can_open) {
+		p = smb_buf(outbuf) + 3;
+		ok = True;
      
-    if (status_len == 0)
-    {
-      dptr_num = dptr_create(conn,directory,True,expect_close,SVAL(inbuf,smb_pid));
-      if (dptr_num < 0)
-      {
-        if(dptr_num == -2)
-        {
-          set_bad_path_error(errno, bad_path);
-          END_PROFILE(SMBsearch);
-          return (UNIXERROR(ERRDOS,ERRnofids));
-        }
-		END_PROFILE(SMBsearch);
-        return ERROR_DOS(ERRDOS,ERRnofids);
-      }
-      dptr_set_wcard(dptr_num, strdup(mask));
-    }
-
-    DEBUG(4,("dptr_num is %d\n",dptr_num));
-
-    if (ok)
-    {
-      if ((dirtype&0x1F) == aVOLID)
-      {	  
-        memcpy(p,status,21);
-        make_dir_struct(p,"???????????",volume_label(SNUM(conn)),0,aVOLID,0);
-        dptr_fill(p+12,dptr_num);
-        if (dptr_zero(p+12) && (status_len==0))
-          numentries = 1;
-        else
-          numentries = 0;
-        p += DIR_STRUCT_SIZE;
-      }
-      else 
-      {
-        DEBUG(8,("dirpath=<%s> dontdescend=<%s>\n",
-              conn->dirpath,lp_dontdescend(SNUM(conn))));
-        if (in_list(conn->dirpath, lp_dontdescend(SNUM(conn)),True))
-          check_descend = True;
-
-        for (i=numentries;(i<maxentries) && !finished;i++)
-        {
-          finished = 
-            !get_dir_entry(conn,mask,dirtype,fname,&size,&mode,&date,check_descend);
-          if (!finished)
-          {
-            memcpy(p,status,21);
-            make_dir_struct(p,mask,fname,size,mode,date);
-            dptr_fill(p+12,dptr_num);
-            numentries++;
-	  }
-	  p += DIR_STRUCT_SIZE;
-        }
-      }
-	} /* if (ok ) */
-  }
+		if (status_len == 0) {
+			dptr_num = dptr_create(conn,directory,True,expect_close,SVAL(inbuf,smb_pid));
+			if (dptr_num < 0) {
+				if(dptr_num == -2) {
+					set_bad_path_error(errno, bad_path);
+					END_PROFILE(SMBsearch);
+					return (UNIXERROR(ERRDOS,ERRnofids));
+				}
+				END_PROFILE(SMBsearch);
+				return ERROR_DOS(ERRDOS,ERRnofids);
+			}
+			dptr_set_wcard(dptr_num, strdup(mask));
+			dptr_set_attr(dptr_num, dirtype);
+		} else {
+			dirtype = dptr_attr(dptr_num);
+		}
+
+		DEBUG(4,("dptr_num is %d\n",dptr_num));
+
+		if (ok) {
+			if ((dirtype&0x1F) == aVOLID) {	  
+				memcpy(p,status,21);
+				make_dir_struct(p,"???????????",volume_label(SNUM(conn)),0,aVOLID,0);
+				dptr_fill(p+12,dptr_num);
+				if (dptr_zero(p+12) && (status_len==0))
+					numentries = 1;
+				else
+					numentries = 0;
+				p += DIR_STRUCT_SIZE;
+			} else {
+				DEBUG(8,("dirpath=<%s> dontdescend=<%s>\n",
+				conn->dirpath,lp_dontdescend(SNUM(conn))));
+				if (in_list(conn->dirpath, lp_dontdescend(SNUM(conn)),True))
+					check_descend = True;
+
+				for (i=numentries;(i<maxentries) && !finished;i++) {
+					finished = !get_dir_entry(conn,mask,dirtype,fname,&size,&mode,&date,check_descend);
+					if (!finished) {
+						memcpy(p,status,21);
+						make_dir_struct(p,mask,fname,size,mode,date);
+						dptr_fill(p+12,dptr_num);
+						numentries++;
+					}
+					p += DIR_STRUCT_SIZE;
+				}
+			}
+		} /* if (ok ) */
+	}
 
 
   SearchEmpty:
 
-  if (numentries == 0 || !ok)
-  {
-    SCVAL(outbuf,smb_rcls,ERRDOS);
-    SSVAL(outbuf,smb_err,ERRnofiles);
-    dptr_close(&dptr_num);
-  }
-
-  /* If we were called as SMBffirst with smb_search_id == NULL
-     and no entries were found then return error and close dirptr 
-     (X/Open spec) */
-
-  if(ok && expect_close && numentries == 0 && status_len == 0)
-  {
-    SCVAL(outbuf,smb_rcls,ERRDOS);
-    SSVAL(outbuf,smb_err,ERRnofiles);
-    /* Also close the dptr - we know it's gone */
-    dptr_close(&dptr_num);
-  }
-
-  /* If we were called as SMBfunique, then we can close the dirptr now ! */
-  if(dptr_num >= 0 && CVAL(inbuf,smb_com) == SMBfunique)
-    dptr_close(&dptr_num);
-
-  SSVAL(outbuf,smb_vwv0,numentries);
-  SSVAL(outbuf,smb_vwv1,3 + numentries * DIR_STRUCT_SIZE);
-  SCVAL(smb_buf(outbuf),0,5);
-  SSVAL(smb_buf(outbuf),1,numentries*DIR_STRUCT_SIZE);
-
-  if (Protocol >= PROTOCOL_NT1)
-    SSVAL(outbuf,smb_flg2,SVAL(outbuf, smb_flg2) | FLAGS2_IS_LONG_NAME);
-  
-  outsize += DIR_STRUCT_SIZE*numentries;
-  smb_setlen(outbuf,outsize - 4);
-  
-  if ((! *directory) && dptr_path(dptr_num))
-    slprintf(directory, sizeof(directory)-1, "(%s)",dptr_path(dptr_num));
-
-  DEBUG( 4, ( "%s mask=%s path=%s dtype=%d nument=%d of %d\n",
-        smb_fn_name(CVAL(inbuf,smb_com)), 
-        mask, directory, dirtype, numentries, maxentries ) );
+	if (numentries == 0 || !ok) {
+		SCVAL(outbuf,smb_rcls,ERRDOS);
+		SSVAL(outbuf,smb_err,ERRnofiles);
+		dptr_close(&dptr_num);
+	}
+
+	/* If we were called as SMBffirst with smb_search_id == NULL
+		and no entries were found then return error and close dirptr 
+		(X/Open spec) */
+
+	if(ok && expect_close && numentries == 0 && status_len == 0) {
+		SCVAL(outbuf,smb_rcls,ERRDOS);
+		SSVAL(outbuf,smb_err,ERRnofiles);
+		/* Also close the dptr - we know it's gone */
+		dptr_close(&dptr_num);
+	}
+
+	/* If we were called as SMBfunique, then we can close the dirptr now ! */
+	if(dptr_num >= 0 && CVAL(inbuf,smb_com) == SMBfunique)
+		dptr_close(&dptr_num);
+
+	SSVAL(outbuf,smb_vwv0,numentries);
+	SSVAL(outbuf,smb_vwv1,3 + numentries * DIR_STRUCT_SIZE);
+	SCVAL(smb_buf(outbuf),0,5);
+	SSVAL(smb_buf(outbuf),1,numentries*DIR_STRUCT_SIZE);
+
+	if (Protocol >= PROTOCOL_NT1)
+		SSVAL(outbuf,smb_flg2,SVAL(outbuf, smb_flg2) | FLAGS2_IS_LONG_NAME);
+  
+	outsize += DIR_STRUCT_SIZE*numentries;
+	smb_setlen(outbuf,outsize - 4);
+  
+	if ((! *directory) && dptr_path(dptr_num))
+		slprintf(directory, sizeof(directory)-1, "(%s)",dptr_path(dptr_num));
+
+	DEBUG( 4, ( "%s mask=%s path=%s dtype=%d nument=%d of %d\n",
+		smb_fn_name(CVAL(inbuf,smb_com)), 
+		mask, directory, dirtype, numentries, maxentries ) );
 
-  END_PROFILE(SMBsearch);
-  return(outsize);
+	END_PROFILE(SMBsearch);
+	return(outsize);
 }
 
 /****************************************************************************
@@ -800,40 +777,40 @@
 
 int reply_fclose(connection_struct *conn, char *inbuf,char *outbuf, int dum_size, int dum_buffsize)
 {
-  int outsize = 0;
-  int status_len;
-  pstring path;
-  char status[21];
-  int dptr_num= -2;
-  char *p;
-
-  START_PROFILE(SMBfclose);
-
-  outsize = set_message(outbuf,1,0,True);
-  p = smb_buf(inbuf) + 1;
-  p += srvstr_pull_buf(inbuf, path, p, sizeof(path), STR_TERMINATE);
-  p++;
-  status_len = SVAL(p,0);
-  p += 2;
-
-  if (status_len == 0) {
-    END_PROFILE(SMBfclose);
-    return ERROR_DOS(ERRSRV,ERRsrverror);
-  }
-
-  memcpy(status,p,21);
-
-  if(dptr_fetch(status+12,&dptr_num)) {
-    /*  Close the dptr - we know it's gone */
-    dptr_close(&dptr_num);
-  }
+	int outsize = 0;
+	int status_len;
+	pstring path;
+	char status[21];
+	int dptr_num= -2;
+	char *p;
+
+	START_PROFILE(SMBfclose);
+
+	outsize = set_message(outbuf,1,0,True);
+	p = smb_buf(inbuf) + 1;
+	p += srvstr_pull_buf(inbuf, path, p, sizeof(path), STR_TERMINATE);
+	p++;
+	status_len = SVAL(p,0);
+	p += 2;
+
+	if (status_len == 0) {
+		END_PROFILE(SMBfclose);
+		return ERROR_DOS(ERRSRV,ERRsrverror);
+	}
+
+	memcpy(status,p,21);
+
+	if(dptr_fetch(status+12,&dptr_num)) {
+		/*  Close the dptr - we know it's gone */
+		dptr_close(&dptr_num);
+	}
 
-  SSVAL(outbuf,smb_vwv0,0);
+	SSVAL(outbuf,smb_vwv0,0);
 
-  DEBUG(3,("search close\n"));
+	DEBUG(3,("search close\n"));
 
-  END_PROFILE(SMBfclose);
-  return(outsize);
+	END_PROFILE(SMBfclose);
+	return(outsize);
 }
 
 /****************************************************************************
@@ -842,69 +819,67 @@
 
 int reply_open(connection_struct *conn, char *inbuf,char *outbuf, int dum_size, int dum_buffsize)
 {
-  pstring fname;
-  int outsize = 0;
-  int fmode=0;
-  int share_mode;
-  SMB_OFF_T size = 0;
-  time_t mtime=0;
-  mode_t unixmode;
-  int rmode=0;
-  SMB_STRUCT_STAT sbuf;
-  BOOL bad_path = False;
-  files_struct *fsp;
-  int oplock_request = CORE_OPLOCK_REQUEST(inbuf);
-  START_PROFILE(SMBopen);
+	pstring fname;
+	int outsize = 0;
+	int fmode=0;
+	int share_mode;
+	SMB_OFF_T size = 0;
+	time_t mtime=0;
+	mode_t unixmode;
+	int rmode=0;
+	SMB_STRUCT_STAT sbuf;
+	BOOL bad_path = False;
+	files_struct *fsp;
+	int oplock_request = CORE_OPLOCK_REQUEST(inbuf);
+	START_PROFILE(SMBopen);
  
-  share_mode = SVAL(inbuf,smb_vwv0);
+	share_mode = SVAL(inbuf,smb_vwv0);
 
-  srvstr_pull_buf(inbuf, fname, smb_buf(inbuf)+1, sizeof(fname), STR_TERMINATE);
+	srvstr_pull_buf(inbuf, fname, smb_buf(inbuf)+1, sizeof(fname), STR_TERMINATE);
 
-  RESOLVE_DFSPATH(fname, conn, inbuf, outbuf);
+	RESOLVE_DFSPATH(fname, conn, inbuf, outbuf);
 
-  unix_convert(fname,conn,0,&bad_path,&sbuf);
+	unix_convert(fname,conn,0,&bad_path,&sbuf);
     
-  unixmode = unix_mode(conn,aARCH,fname);
+	unixmode = unix_mode(conn,aARCH,fname);
       
-  fsp = open_file_shared(conn,fname,&sbuf,share_mode,(FILE_FAIL_IF_NOT_EXIST|FILE_EXISTS_OPEN),
-                   unixmode, oplock_request,&rmode,NULL);
+	fsp = open_file_shared(conn,fname,&sbuf,share_mode,(FILE_FAIL_IF_NOT_EXIST|FILE_EXISTS_OPEN),
+			unixmode, oplock_request,&rmode,NULL);
+
+	if (!fsp) {
+		set_bad_path_error(errno, bad_path);
+		END_PROFILE(SMBopen);
+		return(UNIXERROR(ERRDOS,ERRnoaccess));
+	}
 
-  if (!fsp)
-  {
-    set_bad_path_error(errno, bad_path);
-    END_PROFILE(SMBopen);
-    return(UNIXERROR(ERRDOS,ERRnoaccess));
-  }
-
-  size = sbuf.st_size;
-  fmode = dos_mode(conn,fname,&sbuf);
-  mtime = sbuf.st_mtime;
-
-  if (fmode & aDIR) {
-    DEBUG(3,("attempt to open a directory %s\n",fname));
-    close_file(fsp,False);
-    END_PROFILE(SMBopen);
-    return ERROR_DOS(ERRDOS,ERRnoaccess);
-  }
-  
-  outsize = set_message(outbuf,7,0,True);
-  SSVAL(outbuf,smb_vwv0,fsp->fnum);
-  SSVAL(outbuf,smb_vwv1,fmode);
-  if(lp_dos_filetime_resolution(SNUM(conn)) )
-    put_dos_date3(outbuf,smb_vwv2,mtime & ~1);
-  else
-    put_dos_date3(outbuf,smb_vwv2,mtime);
-  SIVAL(outbuf,smb_vwv4,(uint32)size);
-  SSVAL(outbuf,smb_vwv6,rmode);
-
-  if (oplock_request && lp_fake_oplocks(SNUM(conn))) {
-    SCVAL(outbuf,smb_flg,CVAL(outbuf,smb_flg)|CORE_OPLOCK_GRANTED);
-  }
+	size = sbuf.st_size;
+	fmode = dos_mode(conn,fname,&sbuf);
+	mtime = sbuf.st_mtime;
+
+	if (fmode & aDIR) {
+		DEBUG(3,("attempt to open a directory %s\n",fname));
+		close_file(fsp,False);
+		END_PROFILE(SMBopen);
+		return ERROR_DOS(ERRDOS,ERRnoaccess);
+	}
+  
+	outsize = set_message(outbuf,7,0,True);
+	SSVAL(outbuf,smb_vwv0,fsp->fnum);
+	SSVAL(outbuf,smb_vwv1,fmode);
+	if(lp_dos_filetime_resolution(SNUM(conn)) )
+		put_dos_date3(outbuf,smb_vwv2,mtime & ~1);
+	else
+		put_dos_date3(outbuf,smb_vwv2,mtime);
+	SIVAL(outbuf,smb_vwv4,(uint32)size);
+	SSVAL(outbuf,smb_vwv6,rmode);
+
+	if (oplock_request && lp_fake_oplocks(SNUM(conn)))
+		SCVAL(outbuf,smb_flg,CVAL(outbuf,smb_flg)|CORE_OPLOCK_GRANTED);
     
-  if(EXCLUSIVE_OPLOCK_TYPE(fsp->oplock_type))
-    SCVAL(outbuf,smb_flg,CVAL(outbuf,smb_flg)|CORE_OPLOCK_GRANTED);
-  END_PROFILE(SMBopen);
-  return(outsize);
+	if(EXCLUSIVE_OPLOCK_TYPE(fsp->oplock_type))
+		SCVAL(outbuf,smb_flg,CVAL(outbuf,smb_flg)|CORE_OPLOCK_GRANTED);
+	END_PROFILE(SMBopen);
+	return(outsize);
 }
 
 /****************************************************************************
@@ -913,107 +888,102 @@
 
 int reply_open_and_X(connection_struct *conn, char *inbuf,char *outbuf,int length,int bufsize)
 {
-  pstring fname;
-  int smb_mode = SVAL(inbuf,smb_vwv3);
-  int smb_attr = SVAL(inbuf,smb_vwv5);
-  /* Breakout the oplock request bits so we can set the
-     reply bits separately. */
-  BOOL ex_oplock_request = EXTENDED_OPLOCK_REQUEST(inbuf);
-  BOOL core_oplock_request = CORE_OPLOCK_REQUEST(inbuf);
-  BOOL oplock_request = ex_oplock_request | core_oplock_request;
+	pstring fname;
+	int smb_mode = SVAL(inbuf,smb_vwv3);
+	int smb_attr = SVAL(inbuf,smb_vwv5);
+	/* Breakout the oplock request bits so we can set the
+		reply bits separately. */
+	BOOL ex_oplock_request = EXTENDED_OPLOCK_REQUEST(inbuf);
+	BOOL core_oplock_request = CORE_OPLOCK_REQUEST(inbuf);
+	BOOL oplock_request = ex_oplock_request | core_oplock_request;
 #if 0
-  int open_flags = SVAL(inbuf,smb_vwv2);
-  int smb_sattr = SVAL(inbuf,smb_vwv4); 
-  uint32 smb_time = make_unix_date3(inbuf+smb_vwv6);
+	int open_flags = SVAL(inbuf,smb_vwv2);
+	int smb_sattr = SVAL(inbuf,smb_vwv4); 
+	uint32 smb_time = make_unix_date3(inbuf+smb_vwv6);
 #endif
-  int smb_ofun = SVAL(inbuf,smb_vwv8);
-  mode_t unixmode;
-  SMB_OFF_T size=0;
-  int fmode=0,mtime=0,rmode=0;
-  SMB_STRUCT_STAT sbuf;
-  int smb_action = 0;
-  BOOL bad_path = False;
-  files_struct *fsp;
-  START_PROFILE(SMBopenX);
-
-  /* If it's an IPC, pass off the pipe handler. */
-  if (IS_IPC(conn)) {
-    if (lp_nt_pipe_support()) {
-	    END_PROFILE(SMBopenX);
-	    return reply_open_pipe_and_X(conn, inbuf,outbuf,length,bufsize);
-    } else {
-		END_PROFILE(SMBopenX);
-        return ERROR_DOS(ERRSRV,ERRaccess);
-    }
-  }
+	int smb_ofun = SVAL(inbuf,smb_vwv8);
+	mode_t unixmode;
+	SMB_OFF_T size=0;
+	int fmode=0,mtime=0,rmode=0;
+	SMB_STRUCT_STAT sbuf;
+	int smb_action = 0;
+	BOOL bad_path = False;
+	files_struct *fsp;
+	START_PROFILE(SMBopenX);
+
+	/* If it's an IPC, pass off the pipe handler. */
+	if (IS_IPC(conn)) {
+		if (lp_nt_pipe_support()) {
+			END_PROFILE(SMBopenX);
+			return reply_open_pipe_and_X(conn, inbuf,outbuf,length,bufsize);
+		} else {
+			END_PROFILE(SMBopenX);
+			return ERROR_DOS(ERRSRV,ERRaccess);
+		}
+	}
 
-  /* XXXX we need to handle passed times, sattr and flags */
-  srvstr_pull_buf(inbuf, fname, smb_buf(inbuf), sizeof(fname), STR_TERMINATE);
+	/* XXXX we need to handle passed times, sattr and flags */
+	srvstr_pull_buf(inbuf, fname, smb_buf(inbuf), sizeof(fname), STR_TERMINATE);
 
-  RESOLVE_DFSPATH(fname, conn, inbuf, outbuf);
+	RESOLVE_DFSPATH(fname, conn, inbuf, outbuf);
 
-  unix_convert(fname,conn,0,&bad_path,&sbuf);
+	unix_convert(fname,conn,0,&bad_path,&sbuf);
     
-  unixmode = unix_mode(conn,smb_attr | aARCH, fname);
+	unixmode = unix_mode(conn,smb_attr | aARCH, fname);
       
-  fsp = open_file_shared(conn,fname,&sbuf,smb_mode,smb_ofun,unixmode,
-	               oplock_request, &rmode,&smb_action);
+	fsp = open_file_shared(conn,fname,&sbuf,smb_mode,smb_ofun,unixmode,
+			oplock_request, &rmode,&smb_action);
       
-  if (!fsp)
-  {
-    set_bad_path_error(errno, bad_path);
-    END_PROFILE(SMBopenX);
-    return(UNIXERROR(ERRDOS,ERRnoaccess));
-  }
-
-  size = sbuf.st_size;
-  fmode = dos_mode(conn,fname,&sbuf);
-  mtime = sbuf.st_mtime;
-  if (fmode & aDIR) {
-    close_file(fsp,False);
-    END_PROFILE(SMBopenX);
-    return ERROR_DOS(ERRDOS,ERRnoaccess);
-  }
-
-  /* If the caller set the extended oplock request bit
-     and we granted one (by whatever means) - set the
-     correct bit for extended oplock reply.
-   */
-
-  if (ex_oplock_request && lp_fake_oplocks(SNUM(conn))) {
-    smb_action |= EXTENDED_OPLOCK_GRANTED;
-  }
-
-  if(ex_oplock_request && EXCLUSIVE_OPLOCK_TYPE(fsp->oplock_type)) {
-    smb_action |= EXTENDED_OPLOCK_GRANTED;
-  }
-
-  /* If the caller set the core oplock request bit
-     and we granted one (by whatever means) - set the
-     correct bit for core oplock reply.
-   */
-
-  if (core_oplock_request && lp_fake_oplocks(SNUM(conn))) {
-    SCVAL(outbuf,smb_flg,CVAL(outbuf,smb_flg)|CORE_OPLOCK_GRANTED);
-  }
-
-  if(core_oplock_request && EXCLUSIVE_OPLOCK_TYPE(fsp->oplock_type)) {
-    SCVAL(outbuf,smb_flg,CVAL(outbuf,smb_flg)|CORE_OPLOCK_GRANTED);
-  }
-
-  set_message(outbuf,15,0,True);
-  SSVAL(outbuf,smb_vwv2,fsp->fnum);
-  SSVAL(outbuf,smb_vwv3,fmode);
-  if(lp_dos_filetime_resolution(SNUM(conn)) )
-    put_dos_date3(outbuf,smb_vwv4,mtime & ~1);
-  else
-    put_dos_date3(outbuf,smb_vwv4,mtime);
-  SIVAL(outbuf,smb_vwv6,(uint32)size);
-  SSVAL(outbuf,smb_vwv8,rmode);
-  SSVAL(outbuf,smb_vwv11,smb_action);
+	if (!fsp) {
+		set_bad_path_error(errno, bad_path);
+		END_PROFILE(SMBopenX);
+		return(UNIXERROR(ERRDOS,ERRnoaccess));
+	}
+
+	size = sbuf.st_size;
+	fmode = dos_mode(conn,fname,&sbuf);
+	mtime = sbuf.st_mtime;
+	if (fmode & aDIR) {
+		close_file(fsp,False);
+		END_PROFILE(SMBopenX);
+		return ERROR_DOS(ERRDOS,ERRnoaccess);
+	}
+
+	/* If the caller set the extended oplock request bit
+		and we granted one (by whatever means) - set the
+		correct bit for extended oplock reply.
+	*/
+
+	if (ex_oplock_request && lp_fake_oplocks(SNUM(conn)))
+		smb_action |= EXTENDED_OPLOCK_GRANTED;
+
+	if(ex_oplock_request && EXCLUSIVE_OPLOCK_TYPE(fsp->oplock_type))
+		smb_action |= EXTENDED_OPLOCK_GRANTED;
 
-  END_PROFILE(SMBopenX);
-  return chain_reply(inbuf,outbuf,length,bufsize);
+	/* If the caller set the core oplock request bit
+		and we granted one (by whatever means) - set the
+		correct bit for core oplock reply.
+	*/
+
+	if (core_oplock_request && lp_fake_oplocks(SNUM(conn)))
+		SCVAL(outbuf,smb_flg,CVAL(outbuf,smb_flg)|CORE_OPLOCK_GRANTED);
+
+	if(core_oplock_request && EXCLUSIVE_OPLOCK_TYPE(fsp->oplock_type))
+		SCVAL(outbuf,smb_flg,CVAL(outbuf,smb_flg)|CORE_OPLOCK_GRANTED);
+
+	set_message(outbuf,15,0,True);
+	SSVAL(outbuf,smb_vwv2,fsp->fnum);
+	SSVAL(outbuf,smb_vwv3,fmode);
+	if(lp_dos_filetime_resolution(SNUM(conn)) )
+		put_dos_date3(outbuf,smb_vwv4,mtime & ~1);
+	else
+		put_dos_date3(outbuf,smb_vwv4,mtime);
+	SIVAL(outbuf,smb_vwv6,(uint32)size);
+	SSVAL(outbuf,smb_vwv8,rmode);
+	SSVAL(outbuf,smb_vwv11,smb_action);
+
+	END_PROFILE(SMBopenX);
+	return chain_reply(inbuf,outbuf,length,bufsize);
 }
 
 /****************************************************************************
@@ -1022,28 +992,26 @@
 
 int reply_ulogoffX(connection_struct *conn, char *inbuf,char *outbuf,int length,int bufsize)
 {
-  uint16 vuid = SVAL(inbuf,smb_uid);
-  user_struct *vuser = get_valid_user_struct(vuid);
-  START_PROFILE(SMBulogoffX);
+	uint16 vuid = SVAL(inbuf,smb_uid);
+	user_struct *vuser = get_valid_user_struct(vuid);
+	START_PROFILE(SMBulogoffX);
+
+	if(vuser == 0)
+		DEBUG(3,("ulogoff, vuser id %d does not map to user.\n", vuid));
+
+	/* in user level security we are supposed to close any files
+		open by this user */
+	if ((vuser != 0) && (lp_security() != SEC_SHARE))
+		file_close_user(vuid);
 
-  if(vuser == 0) {
-    DEBUG(3,("ulogoff, vuser id %d does not map to user.\n", vuid));
-  }
+	invalidate_vuid(vuid);
 
-  /* in user level security we are supposed to close any files
-     open by this user */
-  if ((vuser != 0) && (lp_security() != SEC_SHARE)) {
-	  file_close_user(vuid);
-  }
-
-  invalidate_vuid(vuid);
-
-  set_message(outbuf,2,0,True);
+	set_message(outbuf,2,0,True);
 
-  DEBUG( 3, ( "ulogoffX vuid=%d\n", vuid ) );
+	DEBUG( 3, ( "ulogoffX vuid=%d\n", vuid ) );
 
-  END_PROFILE(SMBulogoffX);
-  return chain_reply(inbuf,outbuf,length,bufsize);
+	END_PROFILE(SMBulogoffX);
+	return chain_reply(inbuf,outbuf,length,bufsize);
 }
 
 /****************************************************************************
@@ -1052,71 +1020,64 @@
 
 int reply_mknew(connection_struct *conn, char *inbuf,char *outbuf, int dum_size, int dum_buffsize)
 {
-  pstring fname;
-  int com;
-  int outsize = 0;
-  int createmode;
-  mode_t unixmode;
-  int ofun = 0;
-  BOOL bad_path = False;
-  files_struct *fsp;
-  int oplock_request = CORE_OPLOCK_REQUEST(inbuf);
-  SMB_STRUCT_STAT sbuf;
-  START_PROFILE(SMBcreate);
+	pstring fname;
+	int com;
+	int outsize = 0;
+	int createmode;
+	mode_t unixmode;
+	int ofun = 0;
+	BOOL bad_path = False;
+	files_struct *fsp;
+	int oplock_request = CORE_OPLOCK_REQUEST(inbuf);
+	SMB_STRUCT_STAT sbuf;
+	START_PROFILE(SMBcreate);
  
-  com = SVAL(inbuf,smb_com);
+	com = SVAL(inbuf,smb_com);
 
-  createmode = SVAL(inbuf,smb_vwv0);
-  srvstr_pull_buf(inbuf, fname, smb_buf(inbuf) + 1, sizeof(fname), STR_TERMINATE);
+	createmode = SVAL(inbuf,smb_vwv0);
+	srvstr_pull_buf(inbuf, fname, smb_buf(inbuf) + 1, sizeof(fname), STR_TERMINATE);
 
-  RESOLVE_DFSPATH(fname, conn, inbuf, outbuf);
+	RESOLVE_DFSPATH(fname, conn, inbuf, outbuf);
 
-  unix_convert(fname,conn,0,&bad_path,&sbuf);
+	unix_convert(fname,conn,0,&bad_path,&sbuf);
 
-  if (createmode & aVOLID) {
-      DEBUG(0,("Attempt to create file (%s) with volid set - please report this\n",fname));
-  }
-  
-  unixmode = unix_mode(conn,createmode,fname);
-  
-  if(com == SMBmknew)
-  {
-    /* We should fail if file exists. */
-    ofun = FILE_CREATE_IF_NOT_EXIST;
-  }
-  else
-  {
-    /* SMBcreate - Create if file doesn't exist, truncate if it does. */
-    ofun = FILE_CREATE_IF_NOT_EXIST|FILE_EXISTS_TRUNCATE;
-  }
-
-  /* Open file in dos compatibility share mode. */
-  fsp = open_file_shared(conn,fname,&sbuf,SET_DENY_MODE(DENY_FCB)|SET_OPEN_MODE(DOS_OPEN_FCB), 
-                   ofun, unixmode, oplock_request, NULL, NULL);
-  
-  if (!fsp)
-  {
-    set_bad_path_error(errno, bad_path);
-    END_PROFILE(SMBcreate);
-    return(UNIXERROR(ERRDOS,ERRnoaccess));
-  }
+	if (createmode & aVOLID)
+		DEBUG(0,("Attempt to create file (%s) with volid set - please report this\n",fname));
+  
+	unixmode = unix_mode(conn,createmode,fname);
+  
+	if(com == SMBmknew) {
+		/* We should fail if file exists. */
+		ofun = FILE_CREATE_IF_NOT_EXIST;
+	} else {
+		/* SMBcreate - Create if file doesn't exist, truncate if it does. */
+		ofun = FILE_CREATE_IF_NOT_EXIST|FILE_EXISTS_TRUNCATE;
+	}
+
+	/* Open file in dos compatibility share mode. */
+	fsp = open_file_shared(conn,fname,&sbuf,SET_DENY_MODE(DENY_FCB)|SET_OPEN_MODE(DOS_OPEN_FCB), 
+			ofun, unixmode, oplock_request, NULL, NULL);
+  
+	if (!fsp) {
+		set_bad_path_error(errno, bad_path);
+		END_PROFILE(SMBcreate);
+		return(UNIXERROR(ERRDOS,ERRnoaccess));
+	}
  
-  outsize = set_message(outbuf,1,0,True);
-  SSVAL(outbuf,smb_vwv0,fsp->fnum);
+	outsize = set_message(outbuf,1,0,True);
+	SSVAL(outbuf,smb_vwv0,fsp->fnum);
 
-  if (oplock_request && lp_fake_oplocks(SNUM(conn))) {
-    SCVAL(outbuf,smb_flg,CVAL(outbuf,smb_flg)|CORE_OPLOCK_GRANTED);
-  }
+	if (oplock_request && lp_fake_oplocks(SNUM(conn)))
+		SCVAL(outbuf,smb_flg,CVAL(outbuf,smb_flg)|CORE_OPLOCK_GRANTED);
  
-  if(EXCLUSIVE_OPLOCK_TYPE(fsp->oplock_type))
-    SCVAL(outbuf,smb_flg,CVAL(outbuf,smb_flg)|CORE_OPLOCK_GRANTED);
+	if(EXCLUSIVE_OPLOCK_TYPE(fsp->oplock_type))
+		SCVAL(outbuf,smb_flg,CVAL(outbuf,smb_flg)|CORE_OPLOCK_GRANTED);
  
-  DEBUG( 2, ( "new file %s\n", fname ) );
-  DEBUG( 3, ( "mknew %s fd=%d dmode=%d umode=%o\n",
-        fname, fsp->fd, createmode, (int)unixmode ) );
+	DEBUG( 2, ( "new file %s\n", fname ) );
+	DEBUG( 3, ( "mknew %s fd=%d dmode=%d umode=%o\n", fname, fsp->fd, createmode, (int)unixmode ) );
 
-  END_PROFILE(SMBcreate);
-  return(outsize);
+	END_PROFILE(SMBcreate);
+	return(outsize);
 }
 
 /****************************************************************************
@@ -1125,84 +1086,82 @@
 
 int reply_ctemp(connection_struct *conn, char *inbuf,char *outbuf, int dum_size, int dum_buffsize)
 {
-  pstring fname;
-  int outsize = 0;
-  int createmode;
-  mode_t unixmode;
-  BOOL bad_path = False;
-  files_struct *fsp;
-  int oplock_request = CORE_OPLOCK_REQUEST(inbuf);
-  int tmpfd;
-  SMB_STRUCT_STAT sbuf;
-  char *p, *s;
-
-  START_PROFILE(SMBctemp);
-
-  createmode = SVAL(inbuf,smb_vwv0);
-  srvstr_pull_buf(inbuf, fname, smb_buf(inbuf)+1, sizeof(fname), STR_TERMINATE);
-  pstrcat(fname,"\\TMXXXXXX");
-
-  RESOLVE_DFSPATH(fname, conn, inbuf, outbuf);
-
-  unix_convert(fname,conn,0,&bad_path,&sbuf);
-  
-  unixmode = unix_mode(conn,createmode,fname);
-  
-  tmpfd = smb_mkstemp(fname);
-  if (tmpfd == -1) {
-      END_PROFILE(SMBctemp);
-      return(UNIXERROR(ERRDOS,ERRnoaccess));
-  }
-
-  vfs_stat(conn,fname,&sbuf);
-
-  /* Open file in dos compatibility share mode. */
-  /* We should fail if file does not exist. */
-  fsp = open_file_shared(conn,fname,&sbuf,
-			 SET_DENY_MODE(DENY_FCB)|SET_OPEN_MODE(DOS_OPEN_FCB),
-			 FILE_EXISTS_OPEN|FILE_FAIL_IF_NOT_EXIST,
-			 unixmode, oplock_request, NULL, NULL);
-
-  /* close fd from smb_mkstemp() */
-  close(tmpfd);
-
-  if (!fsp) {
-    set_bad_path_error(errno, bad_path);
-    END_PROFILE(SMBctemp);
-    return(UNIXERROR(ERRDOS,ERRnoaccess));
-  }
-
-  outsize = set_message(outbuf,1,0,True);
-  SSVAL(outbuf,smb_vwv0,fsp->fnum);
-
-  /* the returned filename is relative to the directory */
-  s = strrchr_m(fname, '/');
-  if (!s) {
-	  s = fname;
-  } else {
-	  s++;
-  }
-
-  p = smb_buf(outbuf);
-  SSVALS(p, 0, -1); /* what is this? not in spec */
-  SSVAL(p, 2, strlen(s));
-  p += 4;
-  p += srvstr_push(outbuf, p, s, -1, STR_ASCII);
-  outsize = set_message_end(outbuf, p);
-
-  if (oplock_request && lp_fake_oplocks(SNUM(conn))) {
-	  SCVAL(outbuf,smb_flg,CVAL(outbuf,smb_flg)|CORE_OPLOCK_GRANTED);
-  }
-  
-  if (EXCLUSIVE_OPLOCK_TYPE(fsp->oplock_type))
-	  SCVAL(outbuf,smb_flg,CVAL(outbuf,smb_flg)|CORE_OPLOCK_GRANTED);
-
-  DEBUG( 2, ( "created temp file %s\n", fname ) );
-  DEBUG( 3, ( "ctemp %s fd=%d dmode=%d umode=%o\n",
-        fname, fsp->fd, createmode, (int)unixmode ) );
+	pstring fname;
+	int outsize = 0;
+	int createmode;
+	mode_t unixmode;
+	BOOL bad_path = False;
+	files_struct *fsp;
+	int oplock_request = CORE_OPLOCK_REQUEST(inbuf);
+	int tmpfd;
+	SMB_STRUCT_STAT sbuf;
+	char *p, *s;
+
+	START_PROFILE(SMBctemp);
+
+	createmode = SVAL(inbuf,smb_vwv0);
+	srvstr_pull_buf(inbuf, fname, smb_buf(inbuf)+1, sizeof(fname), STR_TERMINATE);
+	pstrcat(fname,"\\TMXXXXXX");
+
+	RESOLVE_DFSPATH(fname, conn, inbuf, outbuf);
+
+	unix_convert(fname,conn,0,&bad_path,&sbuf);
+  
+	unixmode = unix_mode(conn,createmode,fname);
+  
+	tmpfd = smb_mkstemp(fname);
+	if (tmpfd == -1) {
+		END_PROFILE(SMBctemp);
+		return(UNIXERROR(ERRDOS,ERRnoaccess));
+	}
+
+	vfs_stat(conn,fname,&sbuf);
+
+	/* Open file in dos compatibility share mode. */
+	/* We should fail if file does not exist. */
+	fsp = open_file_shared(conn,fname,&sbuf,
+		SET_DENY_MODE(DENY_FCB)|SET_OPEN_MODE(DOS_OPEN_FCB),
+		FILE_EXISTS_OPEN|FILE_FAIL_IF_NOT_EXIST,
+		unixmode, oplock_request, NULL, NULL);
+
+	/* close fd from smb_mkstemp() */
+	close(tmpfd);
 
-  END_PROFILE(SMBctemp);
-  return(outsize);
+	if (!fsp) {
+		set_bad_path_error(errno, bad_path);
+		END_PROFILE(SMBctemp);
+		return(UNIXERROR(ERRDOS,ERRnoaccess));
+	}
+
+	outsize = set_message(outbuf,1,0,True);
+	SSVAL(outbuf,smb_vwv0,fsp->fnum);
+
+	/* the returned filename is relative to the directory */
+	s = strrchr_m(fname, '/');
+	if (!s)
+		s = fname;
+	else
+		s++;
+
+	p = smb_buf(outbuf);
+	SSVALS(p, 0, -1); /* what is this? not in spec */
+	SSVAL(p, 2, strlen(s));
+	p += 4;
+	p += srvstr_push(outbuf, p, s, -1, STR_ASCII);
+	outsize = set_message_end(outbuf, p);
+
+	if (oplock_request && lp_fake_oplocks(SNUM(conn)))
+		SCVAL(outbuf,smb_flg,CVAL(outbuf,smb_flg)|CORE_OPLOCK_GRANTED);
+  
+	if (EXCLUSIVE_OPLOCK_TYPE(fsp->oplock_type))
+		SCVAL(outbuf,smb_flg,CVAL(outbuf,smb_flg)|CORE_OPLOCK_GRANTED);
+
+	DEBUG( 2, ( "created temp file %s\n", fname ) );
+	DEBUG( 3, ( "ctemp %s fd=%d dmode=%d umode=%o\n",
+			fname, fsp->fd, createmode, (int)unixmode ) );
+
+	END_PROFILE(SMBctemp);
+	return(outsize);
 }
 
 /*******************************************************************
@@ -1532,7 +1491,7 @@
 
 	flush_write_cache(fsp, READRAW_FLUSH);
 
-	startpos = IVAL(inbuf,smb_vwv1);
+	startpos = IVAL_TO_SMB_OFF_T(inbuf,smb_vwv1);
 	if(CVAL(inbuf,smb_wct) == 10) {
 		/*
 		 * This is a large offset (64 bit) read.
@@ -1627,7 +1586,7 @@
 	release_level_2_oplocks_on_change(fsp);
 
 	numtoread = SVAL(inbuf,smb_vwv1);
-	startpos = IVAL(inbuf,smb_vwv2);
+	startpos = IVAL_TO_SMB_OFF_T(inbuf,smb_vwv2);
   
 	outsize = set_message(outbuf,5,3,True);
 	numtoread = MIN(BUFFER_SIZE-outsize,numtoread);
@@ -1696,7 +1655,7 @@
 	CHECK_READ(fsp);
 
 	numtoread = SVAL(inbuf,smb_vwv1);
-	startpos = IVAL(inbuf,smb_vwv2);
+	startpos = IVAL_TO_SMB_OFF_T(inbuf,smb_vwv2);
 
 	outsize = set_message(outbuf,5,3,True);
 	numtoread = MIN(BUFFER_SIZE-outsize,numtoread);
@@ -1822,7 +1781,7 @@
 int reply_read_and_X(connection_struct *conn, char *inbuf,char *outbuf,int length,int bufsize)
 {
 	files_struct *fsp = file_fsp(inbuf,smb_vwv2);
-	SMB_OFF_T startpos = IVAL(inbuf,smb_vwv3);
+	SMB_OFF_T startpos = IVAL_TO_SMB_OFF_T(inbuf,smb_vwv3);
 	ssize_t nread = -1;
 	size_t smb_maxcnt = SVAL(inbuf,smb_vwv5);
 #if 0
@@ -1900,7 +1859,7 @@
 	CHECK_WRITE(fsp);
   
 	tcount = IVAL(inbuf,smb_vwv1);
-	startpos = IVAL(inbuf,smb_vwv3);
+	startpos = IVAL_TO_SMB_OFF_T(inbuf,smb_vwv3);
 	write_through = BITSETW(inbuf+smb_vwv7,0);
 
 	/* We have to deal with slightly different formats depending
@@ -1929,7 +1888,7 @@
 	DEBUG(3,("writebraw1 fnum=%d start=%.0f num=%d wrote=%d sync=%d\n",
 		fsp->fnum, (double)startpos, (int)numtowrite, (int)nwritten, (int)write_through));
 
-	if (nwritten < numtowrite)  {
+	if (nwritten < (ssize_t)numtowrite)  {
 		END_PROFILE(SMBwritebraw);
 		return(UNIXERROR(ERRHRD,ERRdiskfull));
 	}
@@ -2030,7 +1989,7 @@
 	CHECK_WRITE(fsp);
 
 	numtowrite = SVAL(inbuf,smb_vwv1);
-	startpos = IVAL(inbuf,smb_vwv2);
+	startpos = IVAL_TO_SMB_OFF_T(inbuf,smb_vwv2);
 	data = smb_buf(inbuf) + 3;
   
 	if (is_locked(fsp,conn,(SMB_BIG_UINT)numtowrite,(SMB_BIG_UINT)startpos, 
@@ -2052,7 +2011,7 @@
 
 	if(((nwritten == 0) && (numtowrite != 0))||(nwritten < 0)) {
 		END_PROFILE(SMBwriteunlock);
-		return(UNIXERROR(ERRDOS,ERRnoaccess));
+		return(UNIXERROR(ERRHRD,ERRdiskfull));
 	}
 
 	status = do_unlock(fsp, conn, SVAL(inbuf,smb_pid), (SMB_BIG_UINT)numtowrite, 
@@ -2097,7 +2056,7 @@
 	CHECK_WRITE(fsp);
 
 	numtowrite = SVAL(inbuf,smb_vwv1);
-	startpos = IVAL(inbuf,smb_vwv2);
+	startpos = IVAL_TO_SMB_OFF_T(inbuf,smb_vwv2);
 	data = smb_buf(inbuf) + 3;
   
 	if (is_locked(fsp,conn,(SMB_BIG_UINT)numtowrite,(SMB_BIG_UINT)startpos, WRITE_LOCK,False)) {
@@ -2133,7 +2092,7 @@
 
 	if(((nwritten == 0) && (numtowrite != 0))||(nwritten < 0)) {
 		END_PROFILE(SMBwrite);
-		return(UNIXERROR(ERRDOS,ERRnoaccess));
+		return(UNIXERROR(ERRHRD,ERRdiskfull));
 	}
 
 	outsize = set_message(outbuf,1,0,True);
@@ -2157,98 +2116,99 @@
 
 int reply_write_and_X(connection_struct *conn, char *inbuf,char *outbuf,int length,int bufsize)
 {
-  files_struct *fsp = file_fsp(inbuf,smb_vwv2);
-  SMB_OFF_T startpos = IVAL(inbuf,smb_vwv3);
-  size_t numtowrite = SVAL(inbuf,smb_vwv10);
-  BOOL write_through = BITSETW(inbuf+smb_vwv7,0);
-  ssize_t nwritten = -1;
-  unsigned int smb_doff = SVAL(inbuf,smb_vwv11);
-  unsigned int smblen = smb_len(inbuf);
-  char *data;
-  BOOL large_writeX = ((CVAL(inbuf,smb_wct) == 14) && (smblen > 0xFFFF));
-  START_PROFILE(SMBwriteX);
-
-  /* If it's an IPC, pass off the pipe handler. */
-  if (IS_IPC(conn)) {
-    END_PROFILE(SMBwriteX);
-    return reply_pipe_write_and_X(inbuf,outbuf,length,bufsize);
-  }
-
-  CHECK_FSP(fsp,conn);
-  CHECK_WRITE(fsp);
-
-  /* Deal with possible LARGE_WRITEX */
-  if (large_writeX)
-    numtowrite |= ((((size_t)SVAL(inbuf,smb_vwv9)) & 1 )<<16);
-
-  if(smb_doff > smblen || (smb_doff + numtowrite > smblen)) {
-    END_PROFILE(SMBwriteX);
-    return ERROR_DOS(ERRDOS,ERRbadmem);
-  }
+	files_struct *fsp = file_fsp(inbuf,smb_vwv2);
+	SMB_OFF_T startpos = IVAL_TO_SMB_OFF_T(inbuf,smb_vwv3);
+	size_t numtowrite = SVAL(inbuf,smb_vwv10);
+	BOOL write_through = BITSETW(inbuf+smb_vwv7,0);
+	ssize_t nwritten = -1;
+	unsigned int smb_doff = SVAL(inbuf,smb_vwv11);
+	unsigned int smblen = smb_len(inbuf);
+	char *data;
+	BOOL large_writeX = ((CVAL(inbuf,smb_wct) == 14) && (smblen > 0xFFFF));
+	START_PROFILE(SMBwriteX);
+
+	/* If it's an IPC, pass off the pipe handler. */
+	if (IS_IPC(conn)) {
+		END_PROFILE(SMBwriteX);
+		return reply_pipe_write_and_X(inbuf,outbuf,length,bufsize);
+	}
+
+	CHECK_FSP(fsp,conn);
+	CHECK_WRITE(fsp);
 
-  data = smb_base(inbuf) + smb_doff;
+	/* Deal with possible LARGE_WRITEX */
+	if (large_writeX)
+		numtowrite |= ((((size_t)SVAL(inbuf,smb_vwv9)) & 1 )<<16);
+
+	if(smb_doff > smblen || (smb_doff + numtowrite > smblen)) {
+		END_PROFILE(SMBwriteX);
+		return ERROR_DOS(ERRDOS,ERRbadmem);
+	}
+
+	data = smb_base(inbuf) + smb_doff;
 
-  if(CVAL(inbuf,smb_wct) == 14) {
+	if(CVAL(inbuf,smb_wct) == 14) {
 #ifdef LARGE_SMB_OFF_T
-    /*
-     * This is a large offset (64 bit) write.
-     */
-    startpos |= (((SMB_OFF_T)IVAL(inbuf,smb_vwv12)) << 32);
+		/*
+		 * This is a large offset (64 bit) write.
+		 */
+		startpos |= (((SMB_OFF_T)IVAL(inbuf,smb_vwv12)) << 32);
 
 #else /* !LARGE_SMB_OFF_T */
 
-    /*
-     * Ensure we haven't been sent a >32 bit offset.
-     */
+		/*
+		 * Ensure we haven't been sent a >32 bit offset.
+		 */
 
-    if(IVAL(inbuf,smb_vwv12) != 0) {
-      DEBUG(0,("reply_write_and_X - large offset (%x << 32) used and we don't support \
+		if(IVAL(inbuf,smb_vwv12) != 0) {
+			DEBUG(0,("reply_write_and_X - large offset (%x << 32) used and we don't support \
 64 bit offsets.\n", (unsigned int)IVAL(inbuf,smb_vwv12) ));
-      END_PROFILE(SMBwriteX);
-      return ERROR_DOS(ERRDOS,ERRbadaccess);
-    }
+			END_PROFILE(SMBwriteX);
+			return ERROR_DOS(ERRDOS,ERRbadaccess);
+		}
 
 #endif /* LARGE_SMB_OFF_T */
-  }
+	}
+
+	if (is_locked(fsp,conn,(SMB_BIG_UINT)numtowrite,(SMB_BIG_UINT)startpos, WRITE_LOCK,False)) {
+		END_PROFILE(SMBwriteX);
+		return ERROR_DOS(ERRDOS,ERRlock);
+	}
+
+	/* X/Open SMB protocol says that, unlike SMBwrite
+	if the length is zero then NO truncation is
+	done, just a write of zero. To truncate a file,
+	use SMBwrite. */
+
+	if(numtowrite == 0)
+		nwritten = 0;
+	else
+		nwritten = write_file(fsp,data,startpos,numtowrite);
+  
+	if(((nwritten == 0) && (numtowrite != 0))||(nwritten < 0)) {
+		END_PROFILE(SMBwriteX);
+		return(UNIXERROR(ERRHRD,ERRdiskfull));
+	}
 
-  if (is_locked(fsp,conn,(SMB_BIG_UINT)numtowrite,(SMB_BIG_UINT)startpos, WRITE_LOCK,False)) {
-    END_PROFILE(SMBwriteX);
-    return ERROR_DOS(ERRDOS,ERRlock);
-  }
-
-  /* X/Open SMB protocol says that, unlike SMBwrite
-     if the length is zero then NO truncation is
-     done, just a write of zero. To truncate a file,
-     use SMBwrite. */
-  if(numtowrite == 0)
-    nwritten = 0;
-  else
-    nwritten = write_file(fsp,data,startpos,numtowrite);
-  
-  if(((nwritten == 0) && (numtowrite != 0))||(nwritten < 0)) {
-    END_PROFILE(SMBwriteX);
-    return(UNIXERROR(ERRDOS,ERRnoaccess));
-  }
-
-  set_message(outbuf,6,0,True);
-  
-  SSVAL(outbuf,smb_vwv2,nwritten);
-  if (large_writeX)
-    SSVAL(outbuf,smb_vwv4,(nwritten>>16)&1);
-
-  if (nwritten < (ssize_t)numtowrite) {
-    SCVAL(outbuf,smb_rcls,ERRHRD);
-    SSVAL(outbuf,smb_err,ERRdiskfull);      
-  }
+	set_message(outbuf,6,0,True);
+  
+	SSVAL(outbuf,smb_vwv2,nwritten);
+	if (large_writeX)
+		SSVAL(outbuf,smb_vwv4,(nwritten>>16)&1);
 
-  DEBUG(3,("writeX fnum=%d num=%d wrote=%d\n",
-	   fsp->fnum, (int)numtowrite, (int)nwritten));
+	if (nwritten < (ssize_t)numtowrite) {
+		SCVAL(outbuf,smb_rcls,ERRHRD);
+		SSVAL(outbuf,smb_err,ERRdiskfull);      
+	}
+
+	DEBUG(3,("writeX fnum=%d num=%d wrote=%d\n",
+		fsp->fnum, (int)numtowrite, (int)nwritten));
 
-  if (lp_syncalways(SNUM(conn)) || write_through)
-    sync_file(conn,fsp);
+	if (lp_syncalways(SNUM(conn)) || write_through)
+		sync_file(conn,fsp);
 
-  END_PROFILE(SMBwriteX);
-  return chain_reply(inbuf,outbuf,length,bufsize);
+	END_PROFILE(SMBwriteX);
+	return chain_reply(inbuf,outbuf,length,bufsize);
 }
 
 /****************************************************************************
@@ -2257,79 +2217,87 @@
 
 int reply_lseek(connection_struct *conn, char *inbuf,char *outbuf, int size, int dum_buffsize)
 {
-  SMB_OFF_T startpos;
-  SMB_OFF_T res= -1;
-  int mode,umode;
-  int outsize = 0;
-  files_struct *fsp = file_fsp(inbuf,smb_vwv0);
-  START_PROFILE(SMBlseek);
+	SMB_OFF_T startpos;
+	SMB_OFF_T res= -1;
+	int mode,umode;
+	int outsize = 0;
+	files_struct *fsp = file_fsp(inbuf,smb_vwv0);
+	START_PROFILE(SMBlseek);
 
-  CHECK_FSP(fsp,conn);
+	CHECK_FSP(fsp,conn);
 
-  flush_write_cache(fsp, SEEK_FLUSH);
+	flush_write_cache(fsp, SEEK_FLUSH);
 
-  mode = SVAL(inbuf,smb_vwv1) & 3;
-  startpos = IVALS(inbuf,smb_vwv2);
+	mode = SVAL(inbuf,smb_vwv1) & 3;
+	/* NB. This doesn't use IVAL_TO_SMB_OFF_T as startpos can be signed in this case. */
+	startpos = (SMB_OFF_T)IVALS(inbuf,smb_vwv2);
+
+	switch (mode) {
+		case 0:
+			umode = SEEK_SET;
+			break;
+		case 1:
+			umode = SEEK_CUR;
+			break;
+		case 2:
+			umode = SEEK_END;
+			break;
+		default:
+			umode = SEEK_SET;
+			break;
+	}
 
-  switch (mode) {
-    case 0: umode = SEEK_SET; break;
-    case 1: umode = SEEK_CUR; break;
-    case 2: umode = SEEK_END; break;
-    default:
-      umode = SEEK_SET; break;
-  }
+	if((res = conn->vfs_ops.lseek(fsp,fsp->fd,startpos,umode)) == -1) {
+		/*
+		 * Check for the special case where a seek before the start
+		 * of the file sets the offset to zero. Added in the CIFS spec,
+		 * section 4.2.7.
+		 */
 
-  if((res = conn->vfs_ops.lseek(fsp,fsp->fd,startpos,umode)) == -1) {
-    /*
-     * Check for the special case where a seek before the start
-     * of the file sets the offset to zero. Added in the CIFS spec,
-     * section 4.2.7.
-     */
+		if(errno == EINVAL) {
+			SMB_OFF_T current_pos = startpos;
 
-    if(errno == EINVAL) {
-      SMB_OFF_T current_pos = startpos;
+			if(umode == SEEK_CUR) {
 
-      if(umode == SEEK_CUR) {
+				if((current_pos = conn->vfs_ops.lseek(fsp,fsp->fd,0,SEEK_CUR)) == -1) {
+					END_PROFILE(SMBlseek);
+					return(UNIXERROR(ERRDOS,ERRnoaccess));
+				}
 
-        if((current_pos = conn->vfs_ops.lseek(fsp,fsp->fd,0,SEEK_CUR)) == -1) {
-	  		END_PROFILE(SMBlseek);
-          return(UNIXERROR(ERRDOS,ERRnoaccess));
-	}
+				current_pos += startpos;
 
-        current_pos += startpos;
+			} else if (umode == SEEK_END) {
 
-      } else if (umode == SEEK_END) {
+				SMB_STRUCT_STAT sbuf;
 
-        SMB_STRUCT_STAT sbuf;
+				if(vfs_fstat(fsp,fsp->fd, &sbuf) == -1) {
+					END_PROFILE(SMBlseek);
+					return(UNIXERROR(ERRDOS,ERRnoaccess));
+				}
 
-        if(vfs_fstat(fsp,fsp->fd, &sbuf) == -1) {
-		  END_PROFILE(SMBlseek);
-          return(UNIXERROR(ERRDOS,ERRnoaccess));
+				current_pos += sbuf.st_size;
+			}
+ 
+			if(current_pos < 0)
+				res = conn->vfs_ops.lseek(fsp,fsp->fd,0,SEEK_SET);
+		}
+
+		if(res == -1) {
+			END_PROFILE(SMBlseek);
+			return(UNIXERROR(ERRDOS,ERRnoaccess));
+		}
 	}
 
-        current_pos += sbuf.st_size;
-      }
- 
-      if(current_pos < 0)
-        res = conn->vfs_ops.lseek(fsp,fsp->fd,0,SEEK_SET);
-    }
-
-    if(res == -1) {
-      END_PROFILE(SMBlseek);
-      return(UNIXERROR(ERRDOS,ERRnoaccess));
-    }
-  }
-
-  fsp->pos = res;
+	fsp->pos = res;
   
-  outsize = set_message(outbuf,2,0,True);
-  SIVAL(outbuf,smb_vwv0,res);
+	outsize = set_message(outbuf,2,0,True);
+	SIVAL(outbuf,smb_vwv0,res);
   
-  DEBUG(3,("lseek fnum=%d ofs=%.0f newpos = %.0f mode=%d\n",
-	   fsp->fnum, (double)startpos, (double)res, mode));
+	DEBUG(3,("lseek fnum=%d ofs=%.0f newpos = %.0f mode=%d\n",
+		fsp->fnum, (double)startpos, (double)res, mode));
 
-  END_PROFILE(SMBlseek);
-  return(outsize);
+	END_PROFILE(SMBlseek);
+	return(outsize);
 }
 
 /****************************************************************************
@@ -2478,7 +2446,7 @@
 	CHECK_WRITE(fsp);
 
 	numtowrite = SVAL(inbuf,smb_vwv1);
-	startpos = IVAL(inbuf,smb_vwv2);
+	startpos = IVAL_TO_SMB_OFF_T(inbuf,smb_vwv2);
 	mtime = make_unix_date3(inbuf+smb_vwv4);
 	data = smb_buf(inbuf) + 1;
   
@@ -2497,9 +2465,9 @@
 		 fsp->fnum, (int)numtowrite, (int)nwritten,
 		 conn->num_files_open));
   
-	if (nwritten <= 0) {
+	if(((nwritten == 0) && (numtowrite != 0))||(nwritten < 0)) {
 		END_PROFILE(SMBwriteclose);
-		return(UNIXERROR(ERRDOS,ERRnoaccess));
+		return(UNIXERROR(ERRHRD,ERRdiskfull));
 	}
  
 	if(close_err != 0) {
@@ -2695,6 +2663,7 @@
 /****************************************************************************
  Reply to a printclose.
 ****************************************************************************/
+
 int reply_printclose(connection_struct *conn,
 		     char *inbuf,char *outbuf, int dum_size, int dum_buffsize)
 {
@@ -2802,32 +2771,33 @@
 
 int reply_printwrite(connection_struct *conn, char *inbuf,char *outbuf, int dum_size, int dum_buffsize)
 {
-  int numtowrite;
-  int outsize = set_message(outbuf,0,0,True);
-  char *data;
-  files_struct *fsp = file_fsp(inbuf,smb_vwv0);
-  START_PROFILE(SMBsplwr);
-  
-  if (!CAN_PRINT(conn)) {
-    END_PROFILE(SMBsplwr);
-    return ERROR_DOS(ERRDOS,ERRnoaccess);
-  }
-
-  CHECK_FSP(fsp,conn);
-  CHECK_WRITE(fsp);
-
-  numtowrite = SVAL(smb_buf(inbuf),1);
-  data = smb_buf(inbuf) + 3;
-  
-  if (write_file(fsp,data,-1,numtowrite) != numtowrite) {
-    END_PROFILE(SMBsplwr);
-    return(UNIXERROR(ERRDOS,ERRnoaccess));
-  }
+	int numtowrite;
+	int outsize = set_message(outbuf,0,0,True);
+	char *data;
+	files_struct *fsp = file_fsp(inbuf,smb_vwv0);
+
+	START_PROFILE(SMBsplwr);
+  
+	if (!CAN_PRINT(conn)) {
+		END_PROFILE(SMBsplwr);
+		return ERROR_DOS(ERRDOS,ERRnoaccess);
+	}
 
-  DEBUG( 3, ( "printwrite fnum=%d num=%d\n", fsp->fnum, numtowrite ) );
+	CHECK_FSP(fsp,conn);
+	CHECK_WRITE(fsp);
+
+	numtowrite = SVAL(smb_buf(inbuf),1);
+	data = smb_buf(inbuf) + 3;
   
-  END_PROFILE(SMBsplwr);
-  return(outsize);
+	if (write_file(fsp,data,-1,numtowrite) != numtowrite) {
+		END_PROFILE(SMBsplwr);
+		return(UNIXERROR(ERRHRD,ERRdiskfull));
+	}
+
+	DEBUG( 3, ( "printwrite fnum=%d num=%d\n", fsp->fnum, numtowrite ) );
+  
+	END_PROFILE(SMBsplwr);
+	return(outsize);
 }
 
 /****************************************************************************
@@ -3023,38 +2993,36 @@
 
 int reply_rmdir(connection_struct *conn, char *inbuf,char *outbuf, int dum_size, int dum_buffsize)
 {
-  pstring directory;
-  int outsize = 0;
-  BOOL ok = False;
-  BOOL bad_path = False;
-  SMB_STRUCT_STAT sbuf;
-  START_PROFILE(SMBrmdir);
-
-  srvstr_pull_buf(inbuf, directory, smb_buf(inbuf) + 1, sizeof(directory), STR_TERMINATE);
-
-  RESOLVE_DFSPATH(directory, conn, inbuf, outbuf)
-
-  unix_convert(directory,conn, NULL,&bad_path,&sbuf);
-  
-  if (check_name(directory,conn))
-  {
-    dptr_closepath(directory,SVAL(inbuf,smb_pid));
-    ok = rmdir_internals(conn, directory);
-  }
-  
-  if (!ok)
-  {
-    set_bad_path_error(errno, bad_path);
-    END_PROFILE(SMBrmdir);
-    return(UNIXERROR(ERRDOS,ERRbadpath));
-  }
+	pstring directory;
+	int outsize = 0;
+	BOOL ok = False;
+	BOOL bad_path = False;
+	SMB_STRUCT_STAT sbuf;
+	START_PROFILE(SMBrmdir);
+
+	srvstr_pull_buf(inbuf, directory, smb_buf(inbuf) + 1, sizeof(directory), STR_TERMINATE);
+
+	RESOLVE_DFSPATH(directory, conn, inbuf, outbuf)
+
+	unix_convert(directory,conn, NULL,&bad_path,&sbuf);
+  
+	if (check_name(directory,conn)) {
+		dptr_closepath(directory,SVAL(inbuf,smb_pid));
+		ok = rmdir_internals(conn, directory);
+	}
+  
+	if (!ok) {
+		set_bad_path_error(errno, bad_path);
+		END_PROFILE(SMBrmdir);
+		return(UNIXERROR(ERRDOS,ERRbadpath));
+	}
  
-  outsize = set_message(outbuf,0,0,True);
+	outsize = set_message(outbuf,0,0,True);
   
-  DEBUG( 3, ( "rmdir %s\n", directory ) );
+	DEBUG( 3, ( "rmdir %s\n", directory ) );
   
-  END_PROFILE(SMBrmdir);
-  return(outsize);
+	END_PROFILE(SMBrmdir);
+	return(outsize);
 }
 
 /*******************************************************************
@@ -3063,63 +3031,66 @@
 
 static BOOL resolve_wildcards(char *name1,char *name2)
 {
-  fstring root1,root2;
-  fstring ext1,ext2;
-  char *p,*p2;
-
-  name1 = strrchr_m(name1,'/');
-  name2 = strrchr_m(name2,'/');
-
-  if (!name1 || !name2) return(False);
-  
-  fstrcpy(root1,name1);
-  fstrcpy(root2,name2);
-  p = strrchr_m(root1,'.');
-  if (p) {
-    *p = 0;
-    fstrcpy(ext1,p+1);
-  } else {
-    fstrcpy(ext1,"");    
-  }
-  p = strrchr_m(root2,'.');
-  if (p) {
-    *p = 0;
-    fstrcpy(ext2,p+1);
-  } else {
-    fstrcpy(ext2,"");    
-  }
-
-  p = root1;
-  p2 = root2;
-  while (*p2) {
-    if (*p2 == '?') {
-      *p2 = *p;
-      p2++;
-    } else {
-      p2++;
-    }
-    if (*p) p++;
-  }
-
-  p = ext1;
-  p2 = ext2;
-  while (*p2) {
-    if (*p2 == '?') {
-      *p2 = *p;
-      p2++;
-    } else {
-      p2++;
-    }
-    if (*p) p++;
-  }
-
-  pstrcpy(name2,root2);
-  if (ext2[0]) {
-    pstrcat(name2,".");
-    pstrcat(name2,ext2);
-  }
+	fstring root1,root2;
+	fstring ext1,ext2;
+	char *p,*p2;
+
+	name1 = strrchr_m(name1,'/');
+	name2 = strrchr_m(name2,'/');
+
+	if (!name1 || !name2)
+		return(False);
+  
+	fstrcpy(root1,name1);
+	fstrcpy(root2,name2);
+	p = strrchr_m(root1,'.');
+	if (p) {
+		*p = 0;
+		fstrcpy(ext1,p+1);
+	} else {
+		fstrcpy(ext1,"");    
+	}
+	p = strrchr_m(root2,'.');
+	if (p) {
+		*p = 0;
+		fstrcpy(ext2,p+1);
+	} else {
+		fstrcpy(ext2,"");    
+	}
+
+	p = root1;
+	p2 = root2;
+	while (*p2) {
+		if (*p2 == '?') {
+			*p2 = *p;
+			p2++;
+		} else {
+			p2++;
+		}
+		if (*p)
+			p++;
+	}
+
+	p = ext1;
+	p2 = ext2;
+	while (*p2) {
+		if (*p2 == '?') {
+			*p2 = *p;
+			p2++;
+		} else {
+			p2++;
+		}
+		if (*p)
+			p++;
+	}
 
-  return(True);
+	pstrcpy(name2,root2);
+	if (ext2[0]) {
+		pstrcat(name2,".");
+		pstrcat(name2,ext2);
+	}
+
+	return(True);
 }
 
 /****************************************************************************
@@ -3501,163 +3472,165 @@
 
 int reply_copy(connection_struct *conn, char *inbuf,char *outbuf, int dum_size, int dum_buffsize)
 {
-  int outsize = 0;
-  pstring name;
-  pstring directory;
-  pstring mask,newname;
-  char *p;
-  int count=0;
-  int error = ERRnoaccess;
-  int err = 0;
-  BOOL has_wild;
-  BOOL exists=False;
-  int tid2 = SVAL(inbuf,smb_vwv0);
-  int ofun = SVAL(inbuf,smb_vwv1);
-  int flags = SVAL(inbuf,smb_vwv2);
-  BOOL target_is_directory=False;
-  BOOL bad_path1 = False;
-  BOOL bad_path2 = False;
-  BOOL rc = True;
-  SMB_STRUCT_STAT sbuf1, sbuf2;
-  START_PROFILE(SMBcopy);
-
-  *directory = *mask = 0;
-
-  p = smb_buf(inbuf);
-  p += srvstr_pull_buf(inbuf, name, p, sizeof(name), STR_TERMINATE);
-  p += srvstr_pull_buf(inbuf, newname, p, sizeof(newname), STR_TERMINATE);
+	int outsize = 0;
+	pstring name;
+	pstring directory;
+	pstring mask,newname;
+	char *p;
+	int count=0;
+	int error = ERRnoaccess;
+	int err = 0;
+	BOOL has_wild;
+	BOOL exists=False;
+	int tid2 = SVAL(inbuf,smb_vwv0);
+	int ofun = SVAL(inbuf,smb_vwv1);
+	int flags = SVAL(inbuf,smb_vwv2);
+	BOOL target_is_directory=False;
+	BOOL bad_path1 = False;
+	BOOL bad_path2 = False;
+	BOOL rc = True;
+	SMB_STRUCT_STAT sbuf1, sbuf2;
+
+	START_PROFILE(SMBcopy);
+
+	*directory = *mask = 0;
+
+	p = smb_buf(inbuf);
+	p += srvstr_pull_buf(inbuf, name, p, sizeof(name), STR_TERMINATE);
+	p += srvstr_pull_buf(inbuf, newname, p, sizeof(newname), STR_TERMINATE);
    
-  DEBUG(3,("reply_copy : %s -> %s\n",name,newname));
+	DEBUG(3,("reply_copy : %s -> %s\n",name,newname));
    
-  if (tid2 != conn->cnum) {
-    /* can't currently handle inter share copies XXXX */
-    DEBUG(3,("Rejecting inter-share copy\n"));
-    END_PROFILE(SMBcopy);
-    return ERROR_DOS(ERRSRV,ERRinvdevice);
-  }
-
-  RESOLVE_DFSPATH(name, conn, inbuf, outbuf);
-  RESOLVE_DFSPATH(newname, conn, inbuf, outbuf);
-
-  rc = unix_convert(name,conn,0,&bad_path1,&sbuf1);
-  unix_convert(newname,conn,0,&bad_path2,&sbuf2);
-
-  target_is_directory = VALID_STAT_OF_DIR(sbuf2);
-
-  if ((flags&1) && target_is_directory) {
-    END_PROFILE(SMBcopy);
-    return ERROR_DOS(ERRDOS,ERRbadfile);
-  }
-
-  if ((flags&2) && !target_is_directory) {
-    END_PROFILE(SMBcopy);
-    return ERROR_DOS(ERRDOS,ERRbadpath);
-  }
-
-  if ((flags&(1<<5)) && VALID_STAT_OF_DIR(sbuf1)) {
-    /* wants a tree copy! XXXX */
-    DEBUG(3,("Rejecting tree copy\n"));
-    END_PROFILE(SMBcopy);
-    return ERROR_DOS(ERRSRV,ERRerror);
-  }
-
-  p = strrchr_m(name,'/');
-  if (!p) {
-    pstrcpy(directory,"./");
-    pstrcpy(mask,name);
-  } else {
-    *p = 0;
-    pstrcpy(directory,name);
-    pstrcpy(mask,p+1);
-  }
-
-  /*
-   * We should only check the mangled cache
-   * here if unix_convert failed. This means
-   * that the path in 'mask' doesn't exist
-   * on the file system and so we need to look
-   * for a possible mangle. This patch from
-   * Tine Smukavec <valentin.smukavec@hermes.si>.
-   */
-
-  if (!rc && mangle_is_mangled(mask))
-	  mangle_check_cache( mask );
-
-  has_wild = ms_has_wild(mask);
-
-  if (!has_wild) {
-    pstrcat(directory,"/");
-    pstrcat(directory,mask);
-    if (resolve_wildcards(directory,newname) && 
-	copy_file(directory,newname,conn,ofun,
-		  count,target_is_directory,&err)) count++;
-    if(!count && err) {
-		errno = err;
+	if (tid2 != conn->cnum) {
+		/* can't currently handle inter share copies XXXX */
+		DEBUG(3,("Rejecting inter-share copy\n"));
 		END_PROFILE(SMBcopy);
-		return(UNIXERROR(ERRHRD,ERRgeneral));
+		return ERROR_DOS(ERRSRV,ERRinvdevice);
 	}
-    if (!count) exists = vfs_file_exist(conn,directory,NULL);
-  } else {
-    void *dirptr = NULL;
-    char *dname;
-    pstring destname;
-
-    if (check_name(directory,conn))
-      dirptr = OpenDir(conn, directory, True);
-
-    if (dirptr) {
-	error = ERRbadfile;
-
-	if (strequal(mask,"????????.???"))
-	  pstrcpy(mask,"*");
-
-	while ((dname = ReadDirName(dirptr))) {
-	    pstring fname;
-	    pstrcpy(fname,dname);
-	    
-	    if(!mask_match(fname, mask, case_sensitive))
-			continue;
 
-	    error = ERRnoaccess;
-	    slprintf(fname,sizeof(fname)-1, "%s/%s",directory,dname);
-	    pstrcpy(destname,newname);
-	    if (resolve_wildcards(fname,destname) && 
-		copy_file(fname,destname,conn,ofun,
-			  count,target_is_directory,&err)) count++;
-	    DEBUG(3,("reply_copy : doing copy on %s -> %s\n",fname,destname));
-	  }
-	CloseDir(dirptr);
-    }
-  }
+	RESOLVE_DFSPATH(name, conn, inbuf, outbuf);
+	RESOLVE_DFSPATH(newname, conn, inbuf, outbuf);
+
+	rc = unix_convert(name,conn,0,&bad_path1,&sbuf1);
+	unix_convert(newname,conn,0,&bad_path2,&sbuf2);
+
+	target_is_directory = VALID_STAT_OF_DIR(sbuf2);
+
+	if ((flags&1) && target_is_directory) {
+		END_PROFILE(SMBcopy);
+		return ERROR_DOS(ERRDOS,ERRbadfile);
+	}
+
+	if ((flags&2) && !target_is_directory) {
+		END_PROFILE(SMBcopy);
+		return ERROR_DOS(ERRDOS,ERRbadpath);
+	}
+
+	if ((flags&(1<<5)) && VALID_STAT_OF_DIR(sbuf1)) {
+		/* wants a tree copy! XXXX */
+		DEBUG(3,("Rejecting tree copy\n"));
+		END_PROFILE(SMBcopy);
+		return ERROR_DOS(ERRSRV,ERRerror);
+	}
+
+	p = strrchr_m(name,'/');
+	if (!p) {
+		pstrcpy(directory,"./");
+		pstrcpy(mask,name);
+	} else {
+		*p = 0;
+		pstrcpy(directory,name);
+		pstrcpy(mask,p+1);
+	}
+
+	/*
+	 * We should only check the mangled cache
+	 * here if unix_convert failed. This means
+	 * that the path in 'mask' doesn't exist
+	 * on the file system and so we need to look
+	 * for a possible mangle. This patch from
+	 * Tine Smukavec <valentin.smukavec@hermes.si>.
+	 */
+
+	if (!rc && mangle_is_mangled(mask))
+		mangle_check_cache( mask );
+
+	has_wild = ms_has_wild(mask);
+
+	if (!has_wild) {
+		pstrcat(directory,"/");
+		pstrcat(directory,mask);
+		if (resolve_wildcards(directory,newname) &&
+				copy_file(directory,newname,conn,ofun, count,target_is_directory,&err))
+			count++;
+		if(!count && err) {
+			errno = err;
+			END_PROFILE(SMBcopy);
+			return(UNIXERROR(ERRHRD,ERRgeneral));
+		}
+		if (!count) {
+			exists = vfs_file_exist(conn,directory,NULL);
+		}
+	} else {
+		void *dirptr = NULL;
+		char *dname;
+		pstring destname;
+
+		if (check_name(directory,conn))
+			dirptr = OpenDir(conn, directory, True);
+
+		if (dirptr) {
+			error = ERRbadfile;
+
+			if (strequal(mask,"????????.???"))
+				pstrcpy(mask,"*");
+
+			while ((dname = ReadDirName(dirptr))) {
+				pstring fname;
+				pstrcpy(fname,dname);
+    
+				if(!mask_match(fname, mask, case_sensitive))
+					continue;
+
+				error = ERRnoaccess;
+				slprintf(fname,sizeof(fname)-1, "%s/%s",directory,dname);
+				pstrcpy(destname,newname);
+				if (resolve_wildcards(fname,destname) && 
+						copy_file(fname,destname,conn,ofun,
+						count,target_is_directory,&err))
+					count++;
+				DEBUG(3,("reply_copy : doing copy on %s -> %s\n",fname,destname));
+			}
+			CloseDir(dirptr);
+		}
+	}
   
-  if (count == 0) {
-    if(err) {
-      /* Error on close... */
-      errno = err;
-      END_PROFILE(SMBcopy);
-      return(UNIXERROR(ERRHRD,ERRgeneral));
-    }
-
-    if (exists) {
-      END_PROFILE(SMBcopy);
-      return ERROR_DOS(ERRDOS,error);
-    } else
-    {
-      if((errno == ENOENT) && (bad_path1 || bad_path2))
-      {
-        unix_ERR_class = ERRDOS;
-        unix_ERR_code = ERRbadpath;
-      }
-      END_PROFILE(SMBcopy);
-      return(UNIXERROR(ERRDOS,error));
-    }
-  }
+	if (count == 0) {
+		if(err) {
+			/* Error on close... */
+			errno = err;
+			END_PROFILE(SMBcopy);
+			return(UNIXERROR(ERRHRD,ERRgeneral));
+		}
+
+		if (exists) {
+			END_PROFILE(SMBcopy);
+			return ERROR_DOS(ERRDOS,error);
+		} else {
+			if((errno == ENOENT) && (bad_path1 || bad_path2)) {
+				unix_ERR_class = ERRDOS;
+				unix_ERR_code = ERRbadpath;
+			}
+			END_PROFILE(SMBcopy);
+			return(UNIXERROR(ERRDOS,error));
+		}
+	}
   
-  outsize = set_message(outbuf,1,0,True);
-  SSVAL(outbuf,smb_vwv0,count);
+	outsize = set_message(outbuf,1,0,True);
+	SSVAL(outbuf,smb_vwv0,count);
 
-  END_PROFILE(SMBcopy);
-  return(outsize);
+	END_PROFILE(SMBcopy);
+	return(outsize);
 }
 
 /****************************************************************************
@@ -3666,41 +3639,41 @@
 
 int reply_setdir(connection_struct *conn, char *inbuf,char *outbuf, int dum_size, int dum_buffsize)
 {
-  int snum;
-  int outsize = 0;
-  BOOL ok = False;
-  pstring newdir;
-  START_PROFILE(pathworks_setdir);
-  
-  snum = SNUM(conn);
-  if (!CAN_SETDIR(snum)) {
-    END_PROFILE(pathworks_setdir);
-    return ERROR_DOS(ERRDOS,ERRnoaccess);
-  }
-
-  srvstr_pull_buf(inbuf, newdir, smb_buf(inbuf) + 1, sizeof(newdir), STR_TERMINATE);
-  
-  if (strlen(newdir) == 0) {
-	  ok = True;
-  } else {
-	  ok = vfs_directory_exist(conn,newdir,NULL);
-	  if (ok) {
-		  string_set(&conn->connectpath,newdir);
-	  }
-  }
-  
-  if (!ok) {
-	  END_PROFILE(pathworks_setdir);
-	  return ERROR_DOS(ERRDOS,ERRbadpath);
-  }
+	int snum;
+	int outsize = 0;
+	BOOL ok = False;
+	pstring newdir;
+
+	START_PROFILE(pathworks_setdir);
+  
+	snum = SNUM(conn);
+	if (!CAN_SETDIR(snum)) {
+		END_PROFILE(pathworks_setdir);
+		return ERROR_DOS(ERRDOS,ERRnoaccess);
+	}
+
+	srvstr_pull_buf(inbuf, newdir, smb_buf(inbuf) + 1, sizeof(newdir), STR_TERMINATE);
   
-  outsize = set_message(outbuf,0,0,True);
-  SCVAL(outbuf,smb_reh,CVAL(inbuf,smb_reh));
+	if (strlen(newdir) == 0) {
+		ok = True;
+	} else {
+		ok = vfs_directory_exist(conn,newdir,NULL);
+		if (ok)
+			string_set(&conn->connectpath,newdir);
+	}
+  
+	if (!ok) {
+		END_PROFILE(pathworks_setdir);
+		return ERROR_DOS(ERRDOS,ERRbadpath);
+	}
+  
+	outsize = set_message(outbuf,0,0,True);
+	SCVAL(outbuf,smb_reh,CVAL(inbuf,smb_reh));
   
-  DEBUG(3,("setdir %s\n", newdir));
+	DEBUG(3,("setdir %s\n", newdir));
 
-  END_PROFILE(pathworks_setdir);
-  return(outsize);
+	END_PROFILE(pathworks_setdir);
+	return(outsize);
 }
 
 /****************************************************************************
@@ -3721,36 +3694,36 @@
 
 SMB_BIG_UINT get_lock_count( char *data, int data_offset, BOOL large_file_format)
 {
-  SMB_BIG_UINT count = 0;
+	SMB_BIG_UINT count = 0;
 
-  if(!large_file_format) {
-    count = (SMB_BIG_UINT)IVAL(data,SMB_LKLEN_OFFSET(data_offset));
-  } else {
+	if(!large_file_format) {
+		count = (SMB_BIG_UINT)IVAL(data,SMB_LKLEN_OFFSET(data_offset));
+	} else {
 
 #if defined(HAVE_LONGLONG)
-    count = (((SMB_BIG_UINT) IVAL(data,SMB_LARGE_LKLEN_OFFSET_HIGH(data_offset))) << 32) |
-            ((SMB_BIG_UINT) IVAL(data,SMB_LARGE_LKLEN_OFFSET_LOW(data_offset)));
+		count = (((SMB_BIG_UINT) IVAL(data,SMB_LARGE_LKLEN_OFFSET_HIGH(data_offset))) << 32) |
+			((SMB_BIG_UINT) IVAL(data,SMB_LARGE_LKLEN_OFFSET_LOW(data_offset)));
 #else /* HAVE_LONGLONG */
 
-    /*
-     * NT4.x seems to be broken in that it sends large file (64 bit)
-     * lockingX calls even if the CAP_LARGE_FILES was *not*
-     * negotiated. For boxes without large unsigned ints truncate the
-     * lock count by dropping the top 32 bits.
-     */
-
-    if(IVAL(data,SMB_LARGE_LKLEN_OFFSET_HIGH(data_offset)) != 0) {
-      DEBUG(3,("get_lock_count: truncating lock count (high)0x%x (low)0x%x to just low count.\n",
-            (unsigned int)IVAL(data,SMB_LARGE_LKLEN_OFFSET_HIGH(data_offset)),
-            (unsigned int)IVAL(data,SMB_LARGE_LKLEN_OFFSET_LOW(data_offset)) ));
-      SIVAL(data,SMB_LARGE_LKLEN_OFFSET_HIGH(data_offset),0);
-    }
+		/*
+		 * NT4.x seems to be broken in that it sends large file (64 bit)
+		 * lockingX calls even if the CAP_LARGE_FILES was *not*
+		 * negotiated. For boxes without large unsigned ints truncate the
+		 * lock count by dropping the top 32 bits.
+		 */
 
-    count = (SMB_BIG_UINT)IVAL(data,SMB_LARGE_LKLEN_OFFSET_LOW(data_offset));
+		if(IVAL(data,SMB_LARGE_LKLEN_OFFSET_HIGH(data_offset)) != 0) {
+			DEBUG(3,("get_lock_count: truncating lock count (high)0x%x (low)0x%x to just low count.\n",
+				(unsigned int)IVAL(data,SMB_LARGE_LKLEN_OFFSET_HIGH(data_offset)),
+				(unsigned int)IVAL(data,SMB_LARGE_LKLEN_OFFSET_LOW(data_offset)) ));
+				SIVAL(data,SMB_LARGE_LKLEN_OFFSET_HIGH(data_offset),0);
+		}
+
+		count = (SMB_BIG_UINT)IVAL(data,SMB_LARGE_LKLEN_OFFSET_LOW(data_offset));
 #endif /* HAVE_LONGLONG */
-  }
+	}
 
-  return count;
+	return count;
 }
 
 #if !defined(HAVE_LONGLONG)
@@ -3793,47 +3766,47 @@
 
 SMB_BIG_UINT get_lock_offset( char *data, int data_offset, BOOL large_file_format, BOOL *err)
 {
-  SMB_BIG_UINT offset = 0;
+	SMB_BIG_UINT offset = 0;
 
-  *err = False;
+	*err = False;
 
-  if(!large_file_format) {
-    offset = (SMB_BIG_UINT)IVAL(data,SMB_LKOFF_OFFSET(data_offset));
-  } else {
+	if(!large_file_format) {
+		offset = (SMB_BIG_UINT)IVAL(data,SMB_LKOFF_OFFSET(data_offset));
+	} else {
 
 #if defined(HAVE_LONGLONG)
-    offset = (((SMB_BIG_UINT) IVAL(data,SMB_LARGE_LKOFF_OFFSET_HIGH(data_offset))) << 32) |
-            ((SMB_BIG_UINT) IVAL(data,SMB_LARGE_LKOFF_OFFSET_LOW(data_offset)));
+		offset = (((SMB_BIG_UINT) IVAL(data,SMB_LARGE_LKOFF_OFFSET_HIGH(data_offset))) << 32) |
+				((SMB_BIG_UINT) IVAL(data,SMB_LARGE_LKOFF_OFFSET_LOW(data_offset)));
 #else /* HAVE_LONGLONG */
 
-    /*
-     * NT4.x seems to be broken in that it sends large file (64 bit)
-     * lockingX calls even if the CAP_LARGE_FILES was *not*
-     * negotiated. For boxes without large unsigned ints mangle the
-     * lock offset by mapping the top 32 bits onto the lower 32.
-     */
+		/*
+		 * NT4.x seems to be broken in that it sends large file (64 bit)
+		 * lockingX calls even if the CAP_LARGE_FILES was *not*
+		 * negotiated. For boxes without large unsigned ints mangle the
+		 * lock offset by mapping the top 32 bits onto the lower 32.
+		 */
       
-    if(IVAL(data,SMB_LARGE_LKOFF_OFFSET_HIGH(data_offset)) != 0) {
-      uint32 low = IVAL(data,SMB_LARGE_LKOFF_OFFSET_LOW(data_offset));
-      uint32 high = IVAL(data,SMB_LARGE_LKOFF_OFFSET_HIGH(data_offset));
-      uint32 new_low = 0;
-
-      if((new_low = map_lock_offset(high, low)) == 0) {
-        *err = True;
-        return (SMB_BIG_UINT)-1;
-      }
-
-      DEBUG(3,("get_lock_offset: truncating lock offset (high)0x%x (low)0x%x to offset 0x%x.\n",
-            (unsigned int)high, (unsigned int)low, (unsigned int)new_low ));
-      SIVAL(data,SMB_LARGE_LKOFF_OFFSET_HIGH(data_offset),0);
-      SIVAL(data,SMB_LARGE_LKOFF_OFFSET_LOW(data_offset),new_low);
-    }
+		if(IVAL(data,SMB_LARGE_LKOFF_OFFSET_HIGH(data_offset)) != 0) {
+			uint32 low = IVAL(data,SMB_LARGE_LKOFF_OFFSET_LOW(data_offset));
+			uint32 high = IVAL(data,SMB_LARGE_LKOFF_OFFSET_HIGH(data_offset));
+			uint32 new_low = 0;
+
+			if((new_low = map_lock_offset(high, low)) == 0) {
+				*err = True;
+				return (SMB_BIG_UINT)-1;
+			}
 
-    offset = (SMB_BIG_UINT)IVAL(data,SMB_LARGE_LKOFF_OFFSET_LOW(data_offset));
+			DEBUG(3,("get_lock_offset: truncating lock offset (high)0x%x (low)0x%x to offset 0x%x.\n",
+				(unsigned int)high, (unsigned int)low, (unsigned int)new_low ));
+			SIVAL(data,SMB_LARGE_LKOFF_OFFSET_HIGH(data_offset),0);
+			SIVAL(data,SMB_LARGE_LKOFF_OFFSET_LOW(data_offset),new_low);
+		}
+
+		offset = (SMB_BIG_UINT)IVAL(data,SMB_LARGE_LKOFF_OFFSET_LOW(data_offset));
 #endif /* HAVE_LONGLONG */
-  }
+	}
 
-  return offset;
+	return offset;
 }
 
 /****************************************************************************
@@ -4056,7 +4029,7 @@
 	CHECK_FSP(fsp,conn);
 	CHECK_READ(fsp);
 
-	startpos = IVAL(inbuf,smb_vwv1);
+	startpos = IVAL_TO_SMB_OFF_T(inbuf,smb_vwv1);
 	maxcount = SVAL(inbuf,smb_vwv3);
 
 	data = smb_buf(outbuf);
@@ -4184,7 +4157,7 @@
 	CHECK_ERROR(fsp);
 
 	tcount = SVAL(inbuf,smb_vwv1);
-	startpos = IVAL(inbuf,smb_vwv3);
+	startpos = IVAL_TO_SMB_OFF_T(inbuf,smb_vwv3);
 	write_through = BITSETW(inbuf+smb_vwv7,0);
 	numtowrite = SVAL(inbuf,smb_vwv10);
 	smb_doff = SVAL(inbuf,smb_vwv11);
@@ -4284,7 +4257,7 @@
 	CHECK_WRITE(fsp);
 
 	tcount = SVAL(inbuf,smb_vwv1);
-	startpos = IVAL(inbuf,smb_vwv2);
+	startpos = IVAL_TO_SMB_OFF_T(inbuf,smb_vwv2);
 	numtowrite = SVAL(inbuf,smb_vwv6);
 	smb_doff = SVAL(inbuf,smb_vwv7);
 
diff -uNr samba-3.0alpha21.orig/source/smbd/server.c samba-3.0alpha21/source/smbd/server.c
--- samba-3.0alpha21.orig/source/smbd/server.c	2003-02-16 19:06:33.000000000 -0600
+++ samba-3.0alpha21/source/smbd/server.c	2003-02-16 19:05:47.000000000 -0600
@@ -142,10 +142,44 @@
 
 
 /****************************************************************************
+ Have we reached the process limit ?
+****************************************************************************/
+
+BOOL allowable_number_of_smbd_processes(void)
+{
+	int max_processes = lp_max_smbd_processes();
+
+	if (!max_processes)
+		return True;
+
+	{
+		TDB_CONTEXT *tdb = conn_tdb_ctx();
+		int32 val;
+		if (!tdb) {
+			DEBUG(0,("allowable_number_of_smbd_processes: can't open connection tdb.\n" ));
+			return False;
+		}
+
+		val = tdb_fetch_int32(tdb, "INFO/total_smbds");
+		if (val == -1 && (tdb_error(tdb) != TDB_ERR_NOEXIST)) {
+			DEBUG(0,("allowable_number_of_smbd_processes: can't fetch INFO/total_smbds. Error %s\n",
+				tdb_errorstr(tdb) ));
+			return False;
+		}
+		if (val > max_processes) {
+			DEBUG(0,("allowable_number_of_smbd_processes: number of processes (%d) is over allowed limit (%d)\n",
+				val, max_processes ));
+			return False;
+		}
+	}
+	return True;
+}
+
+/****************************************************************************
  Open the socket communication.
 ****************************************************************************/
 
-static BOOL open_sockets_smbd(BOOL is_daemon,const char *smb_ports)
+static BOOL open_sockets_smbd(BOOL is_daemon, BOOL interactive, const char *smb_ports)
 {
 	int num_interfaces = iface_count();
 	int num_sockets = 0;
@@ -179,11 +213,12 @@
 	if (!smb_ports) {
 		ports = lp_smb_ports();
 		if (!ports || !*ports) {
-			ports = SMB_PORTS;
+			ports = smb_xstrdup(SMB_PORTS);
+		} else {
+			ports = smb_xstrdup(ports);
 		}
-		ports = strdup(ports);
 	} else {
-		ports = strdup(smb_ports);
+		ports = smb_xstrdup(smb_ports);
 	}
 
 	if (lp_interfaces() && lp_bind_interfaces_only()) {
@@ -320,7 +355,7 @@
 		for( ; num > 0; num--) {
 			struct sockaddr addr;
 			socklen_t in_addrlen = sizeof(addr);
-			
+
 			s = -1;
 			for(i = 0; i < num_sockets; i++) {
 				if(FD_ISSET(fd_listenset[i],&lfds)) {
@@ -342,8 +377,11 @@
 					 strerror(errno)));
 				continue;
 			}
+
+			if (smbd_server_fd() != -1 && interactive)
+				return True;
 			
-			if (smbd_server_fd() != -1 && sys_fork()==0) {
+			if (allowable_number_of_smbd_processes() && smbd_server_fd() != -1 && sys_fork()==0) {
 				/* Child code ... */
 				
 				/* close the listening socket(s) */
@@ -463,6 +501,25 @@
 	return(ret);
 }
 
+/*******************************************************************
+ Print out all talloc memory info.
+********************************************************************/
+
+void return_all_talloc_info(int msg_type, pid_t src_pid, void *buf, size_t len)
+{
+	TALLOC_CTX *ctx = talloc_init("info context");
+	char *info = NULL;
+
+	if (!ctx)
+		return;
+
+	info = talloc_describe_all(ctx);
+	if (info)
+		DEBUG(10,(info));
+	message_send_pid(src_pid, MSG_TALLOC_USAGE, info, info ? strlen(info) + 1 : 0, True);
+	talloc_destroy(ctx);
+}
+
 #if DUMP_CORE
 /*******************************************************************
 prepare to dump a core file - carefully!
@@ -503,24 +560,10 @@
 #endif
 
 /****************************************************************************
-update the current smbd process count
-****************************************************************************/
-
-static void decrement_smbd_process_count(void)
-{
-	int32 total_smbds;
-
-	if (lp_max_smbd_processes()) {
-		total_smbds = 0;
-		tdb_change_int32_atomic(conn_tdb_ctx(), "INFO/total_smbds", &total_smbds, -1);
-	}
-}
-
-/****************************************************************************
  Exit the server.
 ****************************************************************************/
 
-void exit_server(char *reason)
+void exit_server(const char *reason)
 {
 	static int firsttime=1;
 	extern char *last_inbuf;
@@ -541,7 +584,7 @@
 
 	invalidate_all_vuids();
 
-	print_notify_send_messages();	
+	print_notify_send_messages(3); /* 3 second timeout. */
 
 	/* delete our entry in the connections database. */
 	yield_connection(NULL,"");
@@ -612,6 +655,8 @@
 	/* shall I run as a daemon */
 	static BOOL is_daemon = False;
 	static BOOL interactive = False;
+	static BOOL Fork = True;
+	static BOOL log_stdout = False;
 	static char *ports = NULL;
 	int opt;
 	poptContext pc;
@@ -620,6 +665,8 @@
 		POPT_AUTOHELP
 	{"daemon", 'D', POPT_ARG_VAL, &is_daemon, True, "Become a daemon (default)" },
 	{"interactive", 'i', POPT_ARG_VAL, &interactive, True, "Run interactive (not a daemon)"},
+	{"foreground", 'F', POPT_ARG_VAL, &Fork, False, "Run daemon in foreground (for daemontools & etc)" },
+	{"log-stdout", 'S', POPT_ARG_VAL, &log_stdout, True, "Log to stdout" },
 	{"build-options", 'b', POPT_ARG_NONE, NULL, 'b', "Print build options" },
 	{"port", 'p', POPT_ARG_STRING, &ports, 0, "Listen on the specified ports"},
 	{NULL, 0, POPT_ARG_INCLUDE_TABLE, popt_common_debug},
@@ -658,7 +705,17 @@
 
 	set_remote_machine_name("smbd");
 
-	setup_logging(argv[0],interactive);
+	if (interactive) {
+		Fork = False;
+		log_stdout = True;
+	}
+
+	if (log_stdout && Fork) {
+		DEBUG(0,("ERROR: Can't log to stdout (-S) unless daemon is in foreground (-F) or interactive (-i)\n"));
+		exit(1);
+	}
+
+	setup_logging(argv[0],log_stdout);
 
 	/* we want to re-seed early to prevent time delays causing
            client problems at a later date. (tridge) */
@@ -747,7 +804,7 @@
 
 	if (is_daemon && !interactive) {
 		DEBUG( 3, ( "Becoming a daemon.\n" ) );
-		become_daemon();
+		become_daemon(Fork);
 	}
 
 #if HAVE_SETPGID
@@ -759,19 +816,18 @@
 		setpgid( (pid_t)0, (pid_t)0);
 #endif
 
-	if (!directory_exist(lp_lockdir(), NULL)) {
+	if (!directory_exist(lp_lockdir(), NULL))
 		mkdir(lp_lockdir(), 0755);
-	}
 
-	if (is_daemon) {
+	if (is_daemon)
 		pidfile_create("smbd");
-	}
 
-	if (!message_init()) {
+	if (!message_init())
 		exit(1);
-	}
+
 	register_msg_pool_usage();
 	register_dmalloc_msgs();
+	message_register(MSG_REQ_TALLOC_USAGE, return_all_talloc_info);
 
 	if (!print_backend_init())
 		exit(1);
@@ -786,7 +842,7 @@
 	   start_background_queue(); 
 	*/
 
-	if (!open_sockets_smbd(is_daemon,ports))
+	if (!open_sockets_smbd(is_daemon, interactive, ports))
 		exit(1);
 
 	/*
@@ -840,7 +896,6 @@
 
 	/* register our message handlers */
 	message_register(MSG_SMB_FORCE_TDIS, msg_force_tdis);
-	talloc_init_named("dummy!");
 
 	smbd_process();
 	
diff -uNr samba-3.0alpha21.orig/source/smbd/service.c samba-3.0alpha21/source/smbd/service.c
--- samba-3.0alpha21.orig/source/smbd/service.c	2003-02-16 19:06:33.000000000 -0600
+++ samba-3.0alpha21/source/smbd/service.c	2003-02-16 19:05:47.000000000 -0600
@@ -155,7 +155,7 @@
          char *pszTemp;
 
          DEBUG(3,("checking whether %s is a valid printer name...\n", service));
-         pszTemp = PRINTCAP;
+         pszTemp = lp_printcapname();
          if ((pszTemp != NULL) && pcap_printername_ok(service, pszTemp))
          {
             DEBUG(3,("%s is a valid printer name\n", service));
@@ -569,7 +569,7 @@
 	if (!smbd_vfs_init(conn)) {
 		DEBUG(0, ("vfs_init failed for service %s\n", lp_servicename(SNUM(conn))));
 		conn_free(conn);
-		*status = NT_STATUS_UNSUCCESSFUL;
+		*status = NT_STATUS_BAD_NETWORK_NAME;
 		return NULL;
 	}
 
@@ -598,7 +598,7 @@
 			DEBUG(1,("root preexec gave %d - failing connection\n", ret));
 			yield_connection(conn, lp_servicename(SNUM(conn)));
 			conn_free(conn);
-			*status = NT_STATUS_UNSUCCESSFUL;
+			*status = NT_STATUS_ACCESS_DENIED;
 			return NULL;
 		}
 	}
@@ -627,7 +627,7 @@
 			change_to_root_user();
 			yield_connection(conn, lp_servicename(SNUM(conn)));
 			conn_free(conn);
-			*status = NT_STATUS_UNSUCCESSFUL;
+			*status = NT_STATUS_ACCESS_DENIED;
 			return NULL;
 		}
 	}
@@ -751,7 +751,7 @@
 {
 	uid_t euid;
 	user_struct *vuser = NULL;
-	pstring service;
+	fstring service;
 	int snum = -1;
 
 	/* This must ONLY BE CALLED AS ROOT. As it exits this function as root. */
@@ -814,7 +814,7 @@
 					    dev, status);
 	}
 	
-	pstrcpy(service, service_in);
+	fstrcpy(service, service_in);
 
 	strlower(service);
 
@@ -833,6 +833,13 @@
 		return NULL;
 	}
 
+	/* Handle non-Dfs clients attempting connections to msdfs proxy */
+	if (lp_host_msdfs() && (*lp_msdfs_proxy(snum) != '\0'))  {
+		DEBUG(3, ("refusing connection to dfs proxy '%s'\n", service));
+		*status = NT_STATUS_BAD_NETWORK_NAME;
+		return NULL;
+	}
+
 	DEBUG(5, ("making a connection to 'normal' service %s\n", service));
 
 	return make_connection_snum(snum, vuser,
diff -uNr samba-3.0alpha21.orig/source/smbd/sesssetup.c samba-3.0alpha21/source/smbd/sesssetup.c
--- samba-3.0alpha21.orig/source/smbd/sesssetup.c	2003-02-16 19:06:33.000000000 -0600
+++ samba-3.0alpha21/source/smbd/sesssetup.c	2003-02-16 19:05:47.000000000 -0600
@@ -23,7 +23,8 @@
 #include "includes.h"
 
 uint32 global_client_caps = 0;
-static struct auth_context *ntlmssp_auth_context = NULL;
+
+static struct auth_ntlmssp_state *global_ntlmssp_state;
 
 /*
   on a logon error possibly map the error to success if "map to guest"
@@ -68,6 +69,37 @@
 }
 
 /****************************************************************************
+send a security blob via a session setup reply
+****************************************************************************/
+static BOOL reply_sesssetup_blob(connection_struct *conn, char *outbuf,
+				 DATA_BLOB blob, NTSTATUS nt_status)
+{
+	char *p;
+
+	set_message(outbuf,4,0,True);
+
+	/* we set NT_STATUS_MORE_PROCESSING_REQUIRED to tell the other end
+	   that we aren't finished yet */
+
+	nt_status = nt_status_squash(nt_status);
+	SIVAL(outbuf, smb_rcls, NT_STATUS_V(nt_status));
+	SSVAL(outbuf, smb_vwv0, 0xFF); /* no chaining possible */
+	SSVAL(outbuf, smb_vwv3, blob.length);
+	p = smb_buf(outbuf);
+
+	/* should we cap this? */
+	memcpy(p, blob.data, blob.length);
+	p += blob.length;
+
+	p += srvstr_push(outbuf, p, "Unix", -1, STR_TERMINATE);
+	p += srvstr_push(outbuf, p, "Samba", -1, STR_TERMINATE);
+	p += srvstr_push(outbuf, p, lp_workgroup(), -1, STR_TERMINATE);
+	set_message_end(outbuf,p);
+
+	return send_smb(smbd_server_fd(),outbuf);
+}
+
+/****************************************************************************
  Do a 'guest' logon, getting back the 
 ****************************************************************************/
 static NTSTATUS check_guest_password(auth_serversupplied_info **server_info) 
@@ -209,30 +241,54 @@
 
 
 /****************************************************************************
-send a security blob via a session setup reply
-****************************************************************************/
-static BOOL reply_sesssetup_blob(connection_struct *conn, char *outbuf,
-				 DATA_BLOB blob, uint32 errcode)
+ send a session setup reply, wrapped in SPNEGO.
+ get vuid and check first.
+ end the NTLMSSP exchange context if we are OK/complete fail
+***************************************************************************/
+static BOOL reply_spnego_ntlmssp(connection_struct *conn, char *outbuf,
+				 AUTH_NTLMSSP_STATE **auth_ntlmssp_state,
+				 DATA_BLOB *ntlmssp_blob, NTSTATUS nt_status) 
 {
-	char *p;
+	BOOL ret;
+	DATA_BLOB response;
+	struct auth_serversupplied_info *server_info;
+	server_info = (*auth_ntlmssp_state)->server_info;
 
-	set_message(outbuf,4,0,True);
+	if (!NT_STATUS_IS_OK(nt_status)) {
+		nt_status = do_map_to_guest(nt_status, 
+					    &server_info, 
+					    (*auth_ntlmssp_state)->ntlmssp_state->user, 
+					    (*auth_ntlmssp_state)->ntlmssp_state->domain);
+	}
 
-	/* we set NT_STATUS_MORE_PROCESSING_REQUIRED to tell the other end
-	   that we aren't finished yet */
+	if (NT_STATUS_IS_OK(nt_status)) {
+		int sess_vuid;
+		sess_vuid = register_vuid(server_info, (*auth_ntlmssp_state)->ntlmssp_state->user /* check this for weird */);
+		
+		if (sess_vuid == -1) {
+			nt_status = NT_STATUS_LOGON_FAILURE;
+		} else {
+			
+			set_message(outbuf,4,0,True);
+			SSVAL(outbuf, smb_vwv3, 0);
+			
+			if ((*auth_ntlmssp_state)->server_info && (*auth_ntlmssp_state)->server_info->guest) {
+				SSVAL(outbuf,smb_vwv2,1);
+			}
+			
+			SSVAL(outbuf,smb_uid,sess_vuid);
+		}
+	}
 
-	SIVAL(outbuf, smb_rcls, errcode);
-	SSVAL(outbuf, smb_vwv0, 0xFF); /* no chaining possible */
-	SSVAL(outbuf, smb_vwv3, blob.length);
-	p = smb_buf(outbuf);
-	memcpy(p, blob.data, blob.length);
-	p += blob.length;
-	p += srvstr_push(outbuf, p, "Unix", -1, STR_TERMINATE);
-	p += srvstr_push(outbuf, p, "Samba", -1, STR_TERMINATE);
-	p += srvstr_push(outbuf, p, lp_workgroup(), -1, STR_TERMINATE);
-	set_message_end(outbuf,p);
-	
-	return send_smb(smbd_server_fd(),outbuf);
+        response = spnego_gen_auth_response(ntlmssp_blob, nt_status);
+	ret = reply_sesssetup_blob(conn, outbuf, response, nt_status);
+	data_blob_free(&response);
+
+	if (!ret || !NT_STATUS_EQUAL(nt_status, NT_STATUS_MORE_PROCESSING_REQUIRED)) {
+		auth_ntlmssp_end(&global_ntlmssp_state);
+	}
+
+	return ret;
 }
 
 /****************************************************************************
@@ -247,12 +303,9 @@
 	char *OIDs[ASN1_MAX_OIDS];
 	DATA_BLOB secblob;
 	int i;
-	uint32 ntlmssp_command, neg_flags, chal_flags;
-	DATA_BLOB chal, spnego_chal;
-	const uint8 *cryptkey;
+	DATA_BLOB chal;
 	BOOL got_kerberos = False;
 	NTSTATUS nt_status;
-	char *cliname=NULL, *domname=NULL;
 
 	/* parse out the OIDs and the first sec blob */
 	if (!parse_negTokenTarg(blob1, OIDs, &secblob)) {
@@ -278,95 +331,26 @@
 	}
 #endif
 
-	/* parse the NTLMSSP packet */
-#if 0
-	file_save("secblob.dat", secblob.data, secblob.length);
-#endif
-
-	if (!msrpc_parse(&secblob, "CddAA",
-			 "NTLMSSP",
-			 &ntlmssp_command,
-			 &neg_flags,
-			 &cliname,
-			 &domname)) {
-		return ERROR_NT(NT_STATUS_LOGON_FAILURE);
+	if (global_ntlmssp_state) {
+		auth_ntlmssp_end(&global_ntlmssp_state);
 	}
-       
-	data_blob_free(&secblob);
 
-	if (ntlmssp_command != NTLMSSP_NEGOTIATE) {
-		return ERROR_NT(NT_STATUS_LOGON_FAILURE);
-	}
-
-	debug_ntlmssp_flags(neg_flags);
-
-	if (ntlmssp_auth_context) {
-		(ntlmssp_auth_context->free)(&ntlmssp_auth_context);
-	}
-
-	if (!NT_STATUS_IS_OK(nt_status = make_auth_context_subsystem(&ntlmssp_auth_context))) {
+	nt_status = auth_ntlmssp_start(&global_ntlmssp_state);
+	if (!NT_STATUS_IS_OK(nt_status)) {
 		return ERROR_NT(nt_status);
 	}
 
-	cryptkey = ntlmssp_auth_context->get_ntlm_challenge(ntlmssp_auth_context);
+	nt_status = auth_ntlmssp_update(global_ntlmssp_state, 
+					secblob, &chal);
 
-	/* Give them the challenge. For now, ignore neg_flags and just
-	   return the flags we want. Obviously this is not correct */
-	
-	chal_flags = NTLMSSP_NEGOTIATE_UNICODE | 
-		NTLMSSP_NEGOTIATE_128 | 
-		NTLMSSP_NEGOTIATE_NTLM |
-		NTLMSSP_CHAL_TARGET_INFO;
-	
-	{
-		DATA_BLOB domain_blob, struct_blob;
-		fstring dnsname, dnsdomname;
-		
-		msrpc_gen(&domain_blob, 
-			  "U",
-			  lp_workgroup());
-
-		fstrcpy(dnsdomname, (SEC_ADS == lp_security())?lp_realm():"");
-		strlower(dnsdomname);
-
-		fstrcpy(dnsname, global_myname());
-		fstrcat(dnsname, ".");
-		fstrcat(dnsname, dnsdomname);
-		strlower(dnsname);
-
-		msrpc_gen(&struct_blob, "aaaaa",
-			  2, lp_workgroup(),
-			  1, global_myname(),
-			  4, dnsdomname,
-			  3, dnsname,
-			  0, "");
-
-		msrpc_gen(&chal, "CdUdbddB",
-			  "NTLMSSP", 
-			  NTLMSSP_CHALLENGE,
-			  lp_workgroup(),
-			  chal_flags,
-			  cryptkey, 8,
-			  0, 0,
-			  struct_blob.data, struct_blob.length);
-
-		data_blob_free(&domain_blob);
-		data_blob_free(&struct_blob);
-	}
-
-	if (!spnego_gen_challenge(&spnego_chal, &chal, &chal)) {
-		DEBUG(3,("Failed to generate challenge\n"));
-		data_blob_free(&chal);
-		return ERROR_NT(NT_STATUS_LOGON_FAILURE);
-	}
-
-	/* now tell the client to send the auth packet */
-	reply_sesssetup_blob(conn, outbuf, spnego_chal, NT_STATUS_V(NT_STATUS_MORE_PROCESSING_REQUIRED));
+	data_blob_free(&secblob);
 
+	reply_spnego_ntlmssp(conn, outbuf, &global_ntlmssp_state,
+			     &chal, nt_status);
+		
 	data_blob_free(&chal);
-	data_blob_free(&spnego_chal);
 
-	/* and tell smbd that we have already replied to this packet */
+	/* already replied */
 	return -1;
 }
 
@@ -378,23 +362,8 @@
 			     int length, int bufsize,
 			     DATA_BLOB blob1)
 {
-	DATA_BLOB auth, response;
-	char *workgroup = NULL, *user = NULL, *machine = NULL;
-	DATA_BLOB lmhash, nthash, sess_key;
-	DATA_BLOB plaintext_password = data_blob(NULL, 0);
-	uint32 ntlmssp_command, neg_flags;
+	DATA_BLOB auth, auth_reply;
 	NTSTATUS nt_status;
-	int sess_vuid;
-	BOOL as_guest;
-	uint32 auth_flags = AUTH_FLAG_NONE;
-	auth_usersupplied_info *user_info = NULL;
-	auth_serversupplied_info *server_info = NULL;
-
-	/* we must have setup the auth context by now */
-	if (!ntlmssp_auth_context) {
-		DEBUG(2,("ntlmssp_auth_context is NULL in reply_spnego_auth\n"));
-		return ERROR_NT(NT_STATUS_LOGON_FAILURE);
-	}
 
 	if (!spnego_parse_auth(blob1, &auth)) {
 #if 0
@@ -403,107 +372,15 @@
 		return ERROR_NT(NT_STATUS_LOGON_FAILURE);
 	}
 
-	/* now the NTLMSSP encoded auth hashes */
-	if (!msrpc_parse(&auth, "CdBBUUUBd", 
-			 "NTLMSSP", 
-			 &ntlmssp_command, 
-			 &lmhash,
-			 &nthash,
-			 &workgroup, 
-			 &user, 
-			 &machine,
-			 &sess_key,
-			 &neg_flags)) {
-		return ERROR_NT(NT_STATUS_LOGON_FAILURE);
-	}
+	nt_status = auth_ntlmssp_update(global_ntlmssp_state, 
+					  auth, &auth_reply);
 
 	data_blob_free(&auth);
-	data_blob_free(&sess_key);
-	
-	DEBUG(3,("Got user=[%s] workgroup=[%s] machine=[%s] len1=%d len2=%d\n",
-		 user, workgroup, machine, lmhash.length, nthash.length));
 
-	/* the client has given us its machine name (which we otherwise would not get on port 445).
-	   we need to possibly reload smb.conf if smb.conf includes depend on the machine name */
-
-	set_remote_machine_name(machine);
-
-	/* setup the string used by %U */
-	sub_set_smb_name(user);
-
-	reload_services(True);
-
-#if 0
-	file_save("nthash1.dat", nthash.data, nthash.length);
-	file_save("lmhash1.dat", lmhash.data, lmhash.length);
-#endif
-
-	if (lmhash.length) {
-		auth_flags |= AUTH_FLAG_LM_RESP;
-	}
-
-	if (nthash.length == 24) {
-		auth_flags |= AUTH_FLAG_NTLM_RESP;
-	} else if (nthash.length > 24) {
-		auth_flags |= AUTH_FLAG_NTLMv2_RESP;
-	};
-
-	nt_status = make_user_info_map(&user_info, user, workgroup, machine, 
-	                               lmhash, nthash, plaintext_password, 
-	                               auth_flags, True);
-
-	/* it looks a bit weird, but this function returns int type... */
-	if (!NT_STATUS_IS_OK(nt_status)) {
-		return ERROR_NT(NT_STATUS_NO_MEMORY);
-	}
-
-	nt_status = ntlmssp_auth_context->check_ntlm_password(ntlmssp_auth_context, user_info, &server_info); 
-
-	if (!NT_STATUS_IS_OK(nt_status)) {
-		nt_status = do_map_to_guest(nt_status, &server_info, user, workgroup);
-	}
-
-	SAFE_FREE(workgroup);
-	SAFE_FREE(machine);
-			
-	(ntlmssp_auth_context->free)(&ntlmssp_auth_context);
-
-	free_user_info(&user_info);
-	
-	data_blob_free(&lmhash);
-	
-	data_blob_free(&nthash);
-
-	if (!NT_STATUS_IS_OK(nt_status)) {
-		SAFE_FREE(user);
-		return ERROR_NT(nt_status_squash(nt_status));
-	}
-
-	as_guest = server_info->guest;
-
-	sess_vuid = register_vuid(server_info, user);
-	free_server_info(&server_info);
-
-	SAFE_FREE(user);
-  
-	if (sess_vuid == -1) {
-		return ERROR_NT(NT_STATUS_LOGON_FAILURE);
-	}
-
-	set_message(outbuf,4,0,True);
-	SSVAL(outbuf, smb_vwv3, 0);
-
-	if (as_guest) {
-		SSVAL(outbuf,smb_vwv2,1);
-	}
-
-	add_signature(outbuf);
- 
-	SSVAL(outbuf,smb_uid,sess_vuid);
-	SSVAL(inbuf,smb_uid,sess_vuid);
-
-        response = spnego_gen_auth_response();
-	reply_sesssetup_blob(conn, outbuf, response, 0);
+	reply_spnego_ntlmssp(conn, outbuf, &global_ntlmssp_state,
+			     &auth_reply, nt_status);
+		
+	data_blob_free(&auth_reply);
 
 	/* and tell smbd that we have already replied to this packet */
 	return -1;
@@ -511,49 +388,16 @@
 
 
 /****************************************************************************
-reply to a session setup spnego anonymous packet
-****************************************************************************/
-static int reply_spnego_anonymous(connection_struct *conn, char *inbuf, char *outbuf,
-				  int length, int bufsize)
-{
-	int sess_vuid;
-	auth_serversupplied_info *server_info = NULL;
-	NTSTATUS nt_status;
-
-	nt_status = check_guest_password(&server_info);
-
-	if (!NT_STATUS_IS_OK(nt_status)) {
-		return ERROR_NT(nt_status_squash(nt_status));
-	}
-
-	sess_vuid = register_vuid(server_info, lp_guestaccount());
-
-	free_server_info(&server_info);
-  
-	if (sess_vuid == -1) {
-		return ERROR_NT(NT_STATUS_LOGON_FAILURE);
-	}
-
-	set_message(outbuf,4,0,True);
-	SSVAL(outbuf, smb_vwv3, 0);
-	add_signature(outbuf);
- 
-	SSVAL(outbuf,smb_uid,sess_vuid);
-	SSVAL(inbuf,smb_uid,sess_vuid);
-	
-	return chain_reply(inbuf,outbuf,length,bufsize);
-}
-
-
-/****************************************************************************
 reply to a session setup command
 ****************************************************************************/
-static int reply_sesssetup_and_X_spnego(connection_struct *conn, char *inbuf,char *outbuf,
+static int reply_sesssetup_and_X_spnego(connection_struct *conn, char *inbuf,
+					char *outbuf,
 					int length,int bufsize)
 {
 	uint8 *p;
 	DATA_BLOB blob1;
 	int ret;
+	size_t bufrem;
 
 	DEBUG(3,("Doing spnego session setup\n"));
 
@@ -564,12 +408,13 @@
 	p = (uint8 *)smb_buf(inbuf);
 
 	if (SVAL(inbuf, smb_vwv7) == 0) {
-		/* an anonymous request */
-		return reply_spnego_anonymous(conn, inbuf, outbuf, length, bufsize);
+		/* an invalid request */
+		return ERROR_NT(NT_STATUS_LOGON_FAILURE);
 	}
 
+	bufrem = smb_bufrem(inbuf, p);
 	/* pull the spnego blob */
-	blob1 = data_blob(p, SVAL(inbuf, smb_vwv7));
+	blob1 = data_blob(p, MIN(bufrem, SVAL(inbuf, smb_vwv7)));
 
 #if 0
 	file_save("negotiate.dat", blob1.data, blob1.length);
@@ -609,8 +454,8 @@
 	DATA_BLOB lm_resp;
 	DATA_BLOB nt_resp;
 	DATA_BLOB plaintext_password;
-	pstring user;
-	pstring sub_user; /* Sainitised username for substituion */
+	fstring user;
+	fstring sub_user; /* Sainitised username for substituion */
 	fstring domain;
 	fstring native_os;
 	fstring native_lanman;
@@ -756,15 +601,15 @@
 			DEBUG(0,("reply_sesssetup_and_X:  Rejecting attempt at 'normal' session setup after negotiating spnego.\n"));
 			return ERROR_NT(NT_STATUS_UNSUCCESSFUL);
 		}
-		pstrcpy(sub_user, user);
+		fstrcpy(sub_user, user);
 
 		/* setup the string used by %U */
 		sub_set_smb_name(user);
 	} else {
-		pstrcpy(sub_user, lp_guestaccount());
+		fstrcpy(sub_user, lp_guestaccount());
 	}
 
-	pstrcpy(current_user_info.smb_name,sub_user);
+	fstrcpy(current_user_info.smb_name,sub_user);
 
 	reload_services(True);
 	
@@ -786,6 +631,10 @@
 		nt_status = check_guest_password(&server_info);
 
 	} else if (doencrypt) {
+		if (!negprot_global_auth_context) {
+			DEBUG(0, ("reply_sesssetup_and_X:  Attempted encrypted session setup without negprot denied!\n"));
+			return ERROR_NT(NT_STATUS_LOGON_FAILURE);
+		}
 		nt_status = make_user_info_for_reply_enc(&user_info, user, domain,
 		                                         lm_resp, nt_resp);
 		if (NT_STATUS_IS_OK(nt_status)) {
@@ -830,10 +679,8 @@
 	}
 	
 	/* it's ok - setup a reply */
-	if (Protocol < PROTOCOL_NT1) {
-		set_message(outbuf,3,0,True);
-	} else {
-		set_message(outbuf,3,0,True);
+	set_message(outbuf,3,0,True);
+	if (Protocol >= PROTOCOL_NT1) {
 		add_signature(outbuf);
 		/* perhaps grab OS version here?? */
 	}
diff -uNr samba-3.0alpha21.orig/source/smbd/statcache.c samba-3.0alpha21/source/smbd/statcache.c
--- samba-3.0alpha21.orig/source/smbd/statcache.c	2003-02-16 19:06:33.000000000 -0600
+++ samba-3.0alpha21/source/smbd/statcache.c	2003-02-16 19:05:47.000000000 -0600
@@ -122,8 +122,8 @@
       DEBUG(0,("stat_cache_add: Out of memory !\n"));
       return;
     }
-    pstrcpy(scp->names, orig_name);
-    pstrcpy(scp->names+namelen+1, translated_path);
+    safe_strcpy(scp->names, orig_name, namelen);
+    safe_strcpy(scp->names+namelen+1, translated_path, namelen);
     scp->name_len = namelen;
     hash_insert(&stat_cache, (char *)scp, orig_name);
   }
diff -uNr samba-3.0alpha21.orig/source/smbd/trans2.c samba-3.0alpha21/source/smbd/trans2.c
--- samba-3.0alpha21.orig/source/smbd/trans2.c	2003-02-16 19:06:33.000000000 -0600
+++ samba-3.0alpha21/source/smbd/trans2.c	2003-02-16 19:05:47.000000000 -0600
@@ -29,19 +29,17 @@
 extern int global_oplock_break;
 extern uint32 global_client_caps;
 
-#define get_file_size(sbuf) (sbuf.st_size)
+#define get_file_size(sbuf) ((sbuf).st_size)
 
 /* given a stat buffer return the allocated size on disk, taking into
    account sparse files */
-SMB_OFF_T get_allocation_size(files_struct *fsp, SMB_STRUCT_STAT *sbuf)
+SMB_BIG_UINT get_allocation_size(files_struct *fsp, SMB_STRUCT_STAT *sbuf)
 {
-	SMB_OFF_T ret;
-#if defined(HAVE_STAT_ST_BLKSIZE) && defined(HAVE_STAT_ST_BLOCKS)
-	ret = sbuf->st_blksize * (SMB_OFF_T)sbuf->st_blocks;
-#elif defined(HAVE_STAT_ST_BLOCKS) && defined(STAT_ST_BLOCKSIZE)
-	ret = (SMB_OFF_T)STAT_ST_BLOCKSIZE * (SMB_OFF_T)sbuf->st_blocks;
+	SMB_BIG_UINT ret;
+#if defined(HAVE_STAT_ST_BLOCKS) && defined(STAT_ST_BLOCKSIZE)
+	ret = (SMB_BIG_UINT)STAT_ST_BLOCKSIZE * (SMB_BIG_UINT)sbuf->st_blocks;
 #else
-	ret = get_file_size(*sbuf);
+	ret = (SMB_BIG_UINT)get_file_size(*sbuf);
 #endif
 	if (!ret && fsp && fsp->initial_allocation_size)
 		ret = fsp->initial_allocation_size;
@@ -473,7 +471,7 @@
 	int prev_dirpos=0;
 	int mode=0;
 	SMB_OFF_T file_size = 0;
-	SMB_OFF_T allocation_size = 0;
+	SMB_BIG_UINT allocation_size = 0;
 	uint32 len;
 	time_t mdate=0, adate=0, cdate=0;
 	char *nameptr;
@@ -1552,7 +1550,7 @@
 	uint16 info_level;
 	int mode=0;
 	SMB_OFF_T file_size=0;
-	SMB_OFF_T allocation_size=0;
+	SMB_BIG_UINT allocation_size=0;
 	unsigned int data_size;
 	SMB_STRUCT_STAT sbuf;
 	pstring fname, dos_fname;
@@ -1796,7 +1794,7 @@
 			if(!mangle_is_8_3(short_name, True)) {
 				mangle_map(short_name,True,True,SNUM(conn));
 			}
-			len = srvstr_push(outbuf, pdata+4, short_name, -1, STR_TERMINATE|STR_UPPER);
+			len = srvstr_push(outbuf, pdata+4, short_name, -1, STR_UNICODE);
 			data_size = 4 + len;
 			SIVAL(pdata,0,len);
 			break;
@@ -2103,59 +2101,39 @@
 		DEBUG(10, ("set_delete_on_close_internal: %s delete on close flag for fnum = %d, directory %s\n",
 			delete_on_close ? "Added" : "Removed", fsp->fnum, fsp->fsp_name ));
 	} else {
+		fsp->delete_on_close = delete_on_close;
+		DEBUG(10, ("set_delete_on_close_internal: %s delete on close flag for fnum = %d, file %s\n",
+			delete_on_close ? "Added" : "Removed", fsp->fnum, fsp->fsp_name ));
+	}
 
-		files_struct *iterate_fsp;
-
-		/*
-		 * Modify the share mode entry for all files open
-		 * on this device and inode to tell other smbds we have 
-		 * changed the delete on close flag. This will be noticed
-		 * in the close code, the last closer will delete the file
-		 * if flag is set.
-		 */
-
-		DEBUG(10,("set_delete_on_close_internal: %s delete on close flag for fnum = %d, file %s\n",
-					delete_on_close ? "Adding" : "Removing", fsp->fnum, fsp->fsp_name ));
+	return NT_STATUS_OK;
+}
 
-		if (lock_share_entry_fsp(fsp) == False)
-				return NT_STATUS_ACCESS_DENIED;
+/****************************************************************************
+ Sets the delete on close flag over all share modes on this file.
+ Modify the share mode entry for all files open
+ on this device and inode to tell other smbds we have
+ changed the delete on close flag. This will be noticed
+ in the close code, the last closer will delete the file
+ if flag is set.
+****************************************************************************/
 
-		if (!modify_delete_flag(fsp->dev, fsp->inode, delete_on_close)) {
-			DEBUG(0,("set_delete_on_close_internal: failed to change delete on close flag for file %s\n",
-					fsp->fsp_name ));
-			unlock_share_entry_fsp(fsp);
-			return NT_STATUS_ACCESS_DENIED;
-		}
+NTSTATUS set_delete_on_close_over_all(files_struct *fsp, BOOL delete_on_close)
+{
+	DEBUG(10,("set_delete_on_close_over_all: %s delete on close flag for fnum = %d, file %s\n",
+		delete_on_close ? "Adding" : "Removing", fsp->fnum, fsp->fsp_name ));
 
-		/*
-		 * Release the lock.
-		 */
+	if (lock_share_entry_fsp(fsp) == False)
+		return NT_STATUS_ACCESS_DENIED;
 
+	if (!modify_delete_flag(fsp->dev, fsp->inode, delete_on_close)) {
+		DEBUG(0,("set_delete_on_close_internal: failed to change delete on close flag for file %s\n",
+			fsp->fsp_name ));
 		unlock_share_entry_fsp(fsp);
-
-		/*
-		 * Go through all files we have open on the same device and
-		 * inode (hanging off the same hash bucket) and set the DELETE_ON_CLOSE_FLAG.
-		 * Other smbd's that have this file open will look in the share_mode on close.
-		 * take care of this (rare) case in close_file(). See the comment there.
-		 * NB. JRA. We don't really need to do this anymore - all should be taken
-		 * care of in the share_mode changes in the tdb.
-		 */
-
-		for(iterate_fsp = file_find_di_first(fsp->dev, fsp->inode);
-				iterate_fsp; iterate_fsp = file_find_di_next(iterate_fsp))
-						fsp->delete_on_close = delete_on_close;
-
-		/*
-		 * Set the delete on close flag in the fsp.
-		 */
-		fsp->delete_on_close = delete_on_close;
-
-		DEBUG(10, ("set_delete_on_close_internal: %s delete on close flag for fnum = %d, file %s\n",
-			delete_on_close ? "Added" : "Removed", fsp->fnum, fsp->fsp_name ));
-
+		return NT_STATUS_ACCESS_DENIED;
 	}
 
+	unlock_share_entry_fsp(fsp);
 	return NT_STATUS_OK;
 }
 
@@ -2428,14 +2406,14 @@
 		case SMB_SET_FILE_ALLOCATION_INFO:
 		{
 			int ret = -1;
-			SMB_OFF_T allocation_size;
+			SMB_BIG_UINT allocation_size;
 
 			if (total_data < 8)
 				return(ERROR_DOS(ERRDOS,ERRinvalidparam));
 
-			allocation_size = IVAL(pdata,0);
+			allocation_size = (SMB_BIG_UINT)IVAL(pdata,0);
 #ifdef LARGE_SMB_OFF_T
-			allocation_size |= (((SMB_OFF_T)IVAL(pdata,4)) << 32);
+			allocation_size |= (((SMB_BIG_UINT)IVAL(pdata,4)) << 32);
 #else /* LARGE_SMB_OFF_T */
 			if (IVAL(pdata,4) != 0) /* more than 32 bits? */
 				return ERROR_DOS(ERRDOS,ERRunknownlevel);
@@ -2536,6 +2514,11 @@
 			if (NT_STATUS_V(status) !=  NT_STATUS_V(NT_STATUS_OK))
 				return ERROR_NT(status);
 
+			/* The set is across all open files on this dev/inode pair. */
+			status =set_delete_on_close_over_all(fsp, delete_on_close);
+			if (NT_STATUS_V(status) !=  NT_STATUS_V(NT_STATUS_OK))
+				return ERROR_NT(status);
+
 			break;
 		}
 
@@ -3008,8 +2991,6 @@
 	
 	if ((SVAL(inbuf,(smb_setup+4)) == LMCAT_SPL) &&
 			(SVAL(inbuf,(smb_setup+6)) == LMFUNC_GETJOBID)) {
-		uint16 rap_jobid;
-
 		pdata = Realloc(*ppdata, 32);
 		if(pdata == NULL)
 			return ERROR_DOS(ERRDOS,ERRnomem);
@@ -3018,8 +2999,7 @@
 		/* NOTE - THIS IS ASCII ONLY AT THE MOMENT - NOT SURE IF OS/2
 			CAN ACCEPT THIS IN UNICODE. JRA. */
 
-		rap_jobid = pjobid_to_rap(SNUM(fsp->conn), fsp->print_jobid);                     /* Job number */
-		SSVAL(pdata,0,rap_jobid);                     /* Job number */
+		SSVAL(pdata,0,fsp->rap_print_jobid);                     /* Job number */
 		srvstr_push( outbuf, pdata + 2, global_myname(), 15, STR_ASCII|STR_TERMINATE); /* Our NetBIOS name */
 		srvstr_push( outbuf, pdata+18, lp_servicename(SNUM(conn)), 13, STR_ASCII|STR_TERMINATE); /* Service name */
 		send_trans2_replies(outbuf,bufsize,*pparams,0,*ppdata,32);
diff -uNr samba-3.0alpha21.orig/source/smbd/uid.c samba-3.0alpha21/source/smbd/uid.c
--- samba-3.0alpha21.orig/source/smbd/uid.c	2003-02-16 19:06:33.000000000 -0600
+++ samba-3.0alpha21/source/smbd/uid.c	2003-02-16 19:05:47.000000000 -0600
@@ -532,6 +532,183 @@
 }
 
 /*****************************************************************
+ Id mapping cache.  This is to avoid Winbind mappings already
+ seen by smbd to be queried too frequently, keeping winbindd
+ busy, and blocking smbd while winbindd is busy with other
+ stuff. Written by Michael Steffens <michael.steffens@hp.com>,
+ modified to use linked lists by jra.
+*****************************************************************/  
+
+#define MAX_UID_SID_CACHE_SIZE 100
+#define TURNOVER_UID_SID_CACHE_SIZE 10
+#define MAX_GID_SID_CACHE_SIZE 100
+#define TURNOVER_GID_SID_CACHE_SIZE 10
+
+static size_t n_uid_sid_cache = 0;
+static size_t n_gid_sid_cache = 0;
+
+static struct uid_sid_cache {
+	struct uid_sid_cache *next, *prev;
+	uid_t uid;
+	DOM_SID sid;
+} *uid_sid_cache_head;
+
+static struct gid_sid_cache {
+	struct gid_sid_cache *next, *prev;
+	gid_t gid;
+	DOM_SID sid;
+} *gid_sid_cache_head;
+
+/*****************************************************************
+  Find a SID given a uid.
+*****************************************************************/  
+
+static BOOL fetch_sid_from_uid_cache(DOM_SID *psid, uid_t uid)
+{
+	struct uid_sid_cache *pc;
+
+	for (pc = uid_sid_cache_head; pc; pc = pc->next) {
+		if (pc->uid == uid) {
+			fstring sid;
+			*psid = pc->sid;
+			DEBUG(3,("fetch sid from uid cache %u -> %s\n",
+				(unsigned int)uid, sid_to_string(sid, psid)));
+			DLIST_PROMOTE(uid_sid_cache_head, pc);
+			return True;
+		}
+	}
+	return False;
+}
+
+/*****************************************************************
+  Find a uid given a SID.
+*****************************************************************/  
+
+static BOOL fetch_uid_from_cache(uid_t *puid, const DOM_SID *psid)
+{
+	struct uid_sid_cache *pc;
+
+	for (pc = uid_sid_cache_head; pc; pc = pc->next) {
+		if (sid_compare(&pc->sid, psid) == 0) {
+			fstring sid;
+			*puid = pc->uid;
+			DEBUG(3,("fetch uid from cache %u -> %s\n",
+				(unsigned int)*puid, sid_to_string(sid, psid)));
+			DLIST_PROMOTE(uid_sid_cache_head, pc);
+			return True;
+		}
+	}
+	return False;
+}
+
+/*****************************************************************
+ Store uid to SID mapping in cache.
+*****************************************************************/  
+
+static void store_uid_sid_cache(const DOM_SID *psid, uid_t uid)
+{
+	struct uid_sid_cache *pc;
+
+	if (n_uid_sid_cache >= MAX_UID_SID_CACHE_SIZE && n_uid_sid_cache > TURNOVER_UID_SID_CACHE_SIZE) {
+		/* Delete the last TURNOVER_UID_SID_CACHE_SIZE entries. */
+		struct uid_sid_cache *pc_next;
+		size_t i;
+
+		for (i = 0, pc = uid_sid_cache_head; i < (n_uid_sid_cache - TURNOVER_UID_SID_CACHE_SIZE); i++, pc = pc->next)
+			;
+		for(; pc; pc = pc_next) {
+			pc_next = pc->next;
+			DLIST_REMOVE(uid_sid_cache_head,pc);
+			SAFE_FREE(pc);
+			n_uid_sid_cache--;
+		}
+	}
+
+	pc = (struct uid_sid_cache *)malloc(sizeof(struct uid_sid_cache));
+	if (!pc)
+		return;
+	pc->uid = uid;
+	sid_copy(&pc->sid, psid);
+	DLIST_ADD(uid_sid_cache_head, pc);
+	n_uid_sid_cache++;
+}
+
+/*****************************************************************
+  Find a SID given a gid.
+*****************************************************************/  
+
+static BOOL fetch_sid_from_gid_cache(DOM_SID *psid, gid_t gid)
+{
+	struct gid_sid_cache *pc;
+
+	for (pc = gid_sid_cache_head; pc; pc = pc->next) {
+		if (pc->gid == gid) {
+			fstring sid;
+			*psid = pc->sid;
+			DEBUG(3,("fetch sid from gid cache %u -> %s\n",
+				(unsigned int)gid, sid_to_string(sid, psid)));
+			DLIST_PROMOTE(gid_sid_cache_head, pc);
+			return True;
+		}
+	}
+	return False;
+}
+
+/*****************************************************************
+  Find a gid given a SID.
+*****************************************************************/  
+
+static BOOL fetch_gid_from_cache(gid_t *pgid, const DOM_SID *psid)
+{
+	struct gid_sid_cache *pc;
+
+	for (pc = gid_sid_cache_head; pc; pc = pc->next) {
+		if (sid_compare(&pc->sid, psid) == 0) {
+			fstring sid;
+			*pgid = pc->gid;
+			DEBUG(3,("fetch uid from cache %u -> %s\n",
+				(unsigned int)*pgid, sid_to_string(sid, psid)));
+			DLIST_PROMOTE(gid_sid_cache_head, pc);
+			return True;
+		}
+	}
+	return False;
+}
+
+/*****************************************************************
+ Store gid to SID mapping in cache.
+*****************************************************************/  
+
+static void store_gid_sid_cache(const DOM_SID *psid, gid_t gid)
+{
+	struct gid_sid_cache *pc;
+
+	if (n_gid_sid_cache >= MAX_GID_SID_CACHE_SIZE && n_gid_sid_cache > TURNOVER_GID_SID_CACHE_SIZE) {
+		/* Delete the last TURNOVER_GID_SID_CACHE_SIZE entries. */
+		struct gid_sid_cache *pc_next;
+		size_t i;
+
+		for (i = 0, pc = gid_sid_cache_head; i < (n_gid_sid_cache - TURNOVER_GID_SID_CACHE_SIZE); i++, pc = pc->next)
+			;
+		for(; pc; pc = pc_next) {
+			pc_next = pc->next;
+			DLIST_REMOVE(gid_sid_cache_head,pc);
+			SAFE_FREE(pc);
+			n_gid_sid_cache--;
+		}
+	}
+
+	pc = (struct gid_sid_cache *)malloc(sizeof(struct gid_sid_cache));
+	if (!pc)
+		return;
+	pc->gid = gid;
+	sid_copy(&pc->sid, psid);
+	DLIST_ADD(gid_sid_cache_head, pc);
+	n_gid_sid_cache++;
+}
+
+
+/*****************************************************************
  *THE CANONICAL* convert uid_t to SID function.
  Tries winbind first - then uses local lookup.
  Returns SID pointer.
@@ -542,12 +719,17 @@
 	uid_t low, high;
 	fstring sid;
 
+	if (fetch_sid_from_uid_cache(psid, uid))
+		return psid;
+
 	if (lp_winbind_uid(&low, &high) && uid >= low && uid <= high) {
 		if (winbind_uid_to_sid(psid, uid)) {
 
 			DEBUG(10,("uid_to_sid: winbindd %u -> %s\n",
 				(unsigned int)uid, sid_to_string(sid, psid)));
 
+			if (psid)
+				store_uid_sid_cache(psid, uid);
 			return psid;
 		}
 	}
@@ -558,6 +740,8 @@
         unbecome_root();
 
 	DEBUG(10,("uid_to_sid: local %u -> %s\n", (unsigned int)uid, sid_to_string(sid, psid)));
+	if (psid)
+		store_uid_sid_cache(psid, uid);
 
 	return psid;
 }
@@ -573,20 +757,26 @@
 	gid_t low, high;
 	fstring sid;
 
+	if (fetch_sid_from_gid_cache(psid, gid))
+		return psid;
+
 	if (lp_winbind_gid(&low, &high) && gid >= low && gid <= high) {
 		if (winbind_gid_to_sid(psid, gid)) {
 
 			DEBUG(10,("gid_to_sid: winbindd %u -> %s\n",
 				(unsigned int)gid, sid_to_string(sid, psid)));
                         
+			if (psid)
+				store_gid_sid_cache(psid, gid);
 			return psid;
 		}
 	}
 
 	/* Make sure we report failure, (when psid == NULL) */
 	psid = local_gid_to_sid(psid, gid);
-        
 	DEBUG(10,("gid_to_sid: local %u -> %s\n", (unsigned int)gid, sid_to_string(sid, psid)));
+	if (psid)
+		store_gid_sid_cache(psid, gid);
 
 	return psid;
 }
@@ -602,12 +792,17 @@
 {
 	fstring sid_str;
 
+	if (fetch_uid_from_cache(puid, psid))
+		return True;
+
 	/* if we know its local then don't try winbindd */
 	if (sid_compare_domain(get_global_sam_sid(), psid) == 0) {
 		BOOL result;
 		become_root();
 		result = local_sid_to_uid(puid, psid, sidtype);
 		unbecome_root();
+		if (result)
+			store_uid_sid_cache(psid, *puid);
 		return result;
 	}
 
@@ -657,6 +852,8 @@
 		become_root();
 		result = local_sid_to_uid(puid, psid, sidtype);
 		unbecome_root();
+		if (result)
+			store_uid_sid_cache(psid, *puid);
 		return result;
 	}
 
@@ -664,6 +861,7 @@
 		sid_to_string(sid_str, psid),
 		(unsigned int)*puid ));
 
+	store_uid_sid_cache(psid, *puid);
 	return True;
 }
 
@@ -681,6 +879,9 @@
 
 	*sidtype = SID_NAME_UNKNOWN;
 
+	if (fetch_gid_from_cache(pgid, psid))
+		return True;
+
 	/*
 	 * First we must look up the name and decide if this is a group sid.
 	 */
@@ -691,6 +892,8 @@
 		become_root();
 		result = local_sid_to_gid(pgid, psid, sidtype);
 		unbecome_root();
+		if (result)
+			store_gid_sid_cache(psid, *pgid);
 		return result;
 	}
 
@@ -729,6 +932,7 @@
 		sid_to_string(sid_str, psid),
 		(unsigned int)*pgid ));
 
+	store_gid_sid_cache(psid, *pgid);
 	return True;
 }
 
diff -uNr samba-3.0alpha21.orig/source/smbd/utmp.c samba-3.0alpha21/source/smbd/utmp.c
--- samba-3.0alpha21.orig/source/smbd/utmp.c	2003-02-16 19:06:33.000000000 -0600
+++ samba-3.0alpha21/source/smbd/utmp.c	2003-02-16 19:05:47.000000000 -0600
@@ -457,7 +457,7 @@
 static int ut_id_encode(int i, char *fourbyte)
 {
 	int nbase;
-	char *ut_id_encstr = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
+	const char *ut_id_encstr = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
 	
 	fourbyte[0] = 'S';
 	fourbyte[1] = 'M';
diff -uNr samba-3.0alpha21.orig/source/smbd/vfs.c samba-3.0alpha21/source/smbd/vfs.c
--- samba-3.0alpha21.orig/source/smbd/vfs.c	2003-02-16 19:06:33.000000000 -0600
+++ samba-3.0alpha21/source/smbd/vfs.c	2003-02-16 19:05:47.000000000 -0600
@@ -164,6 +164,7 @@
 
 	if (init_fptr == NULL) {
 		DEBUG(0, ("No vfs_init() symbol found in %s\n", vfs_object));
+		sys_dlclose(conn->vfs_private->handle);
 		return False;
 	}
 
@@ -171,12 +172,14 @@
 
  	if ((ops = init_fptr(&vfs_version, &conn->vfs_ops, conn->vfs_private)) == NULL) {
  		DEBUG(0, ("vfs_init() function from %s failed\n", vfs_object));
+		sys_dlclose(conn->vfs_private->handle);
  		return False;
  	}
   
  	if ((vfs_version < SMB_VFS_INTERFACE_CASCADED)) {
  		DEBUG(0, ("vfs_init() returned wrong interface version info (was %d, should be no less than %d)\n",
  			vfs_version, SMB_VFS_INTERFACE_VERSION ));
+		sys_dlclose(conn->vfs_private->handle);
   		return False;
   	}
   
@@ -184,6 +187,7 @@
  		DEBUG(0, ("Warning: vfs_init() states that module confirms interface version #%d, current interface version is #%d.\n\
 Proceeding in compatibility mode, new operations (since version #%d) will fallback to default ones.\n",
  			vfs_version, SMB_VFS_INTERFACE_VERSION, vfs_version ));
+		sys_dlclose(conn->vfs_private->handle);
   		return False;
   	}
   
@@ -249,6 +253,8 @@
 						DEBUG(0, ("smbd_vfs_init: vfs_init_custom failed for %s\n", vfs_module));
 						string_free(&vfsobj);
 						SAFE_FREE(vfs_module);
+						DLIST_REMOVE(conn->vfs_private, handle);
+						SAFE_FREE(handle);
 						return False;
 					}
 					SAFE_FREE(vfs_module);
@@ -423,13 +429,13 @@
  Returns 0 on success, -1 on failure.
 ****************************************************************************/
 
-int vfs_allocate_file_space(files_struct *fsp, SMB_OFF_T len)
+int vfs_allocate_file_space(files_struct *fsp, SMB_BIG_UINT len)
 {
 	int ret;
 	SMB_STRUCT_STAT st;
 	connection_struct *conn = fsp->conn;
 	struct vfs_ops *vfs_ops = &conn->vfs_ops;
-	SMB_OFF_T space_avail;
+	SMB_BIG_UINT space_avail;
 	SMB_BIG_UINT bsize,dfree,dsize;
 
 	release_level_2_oplocks_on_change(fsp);
@@ -440,21 +446,26 @@
 
 	DEBUG(10,("vfs_allocate_file_space: file %s, len %.0f\n", fsp->fsp_name, (double)len ));
 
+	if (((SMB_OFF_T)len) < 0) {
+		DEBUG(0,("vfs_allocate_file_space: %s negative len requested.\n", fsp->fsp_name ));
+		return -1;
+	}
+
 	ret = vfs_fstat(fsp,fsp->fd,&st);
 	if (ret == -1)
 		return ret;
 
-	if (len == st.st_size)
+	if (len == (SMB_BIG_UINT)st.st_size)
 		return 0;
 
-	if (len < st.st_size) {
+	if (len < (SMB_BIG_UINT)st.st_size) {
 		/* Shrink - use ftruncate. */
 
 		DEBUG(10,("vfs_allocate_file_space: file %s, shrink. Current size %.0f\n",
 				fsp->fsp_name, (double)st.st_size ));
 
 		flush_write_cache(fsp, SIZECHANGE_FLUSH);
-		if ((ret = vfs_ops->ftruncate(fsp, fsp->fd, len)) != -1) {
+		if ((ret = vfs_ops->ftruncate(fsp, fsp->fd, (SMB_OFF_T)len)) != -1) {
 			set_filelen_write_cache(fsp, len);
 		}
 		return ret;
@@ -467,10 +478,10 @@
 
 	len -= st.st_size;
 	len /= 1024; /* Len is now number of 1k blocks needed. */
-	space_avail = (SMB_OFF_T)conn->vfs_ops.disk_free(conn,fsp->fsp_name,False,&bsize,&dfree,&dsize);
+	space_avail = conn->vfs_ops.disk_free(conn,fsp->fsp_name,False,&bsize,&dfree,&dsize);
 
-	DEBUG(10,("vfs_allocate_file_space: file %s, grow. Current size %.0f, needed blocks = %lu, space avail = %lu\n",
-			fsp->fsp_name, (double)st.st_size, (unsigned long)len, (unsigned long)space_avail ));
+	DEBUG(10,("vfs_allocate_file_space: file %s, grow. Current size %.0f, needed blocks = %.0f, space avail = %.0f\n",
+			fsp->fsp_name, (double)st.st_size, (double)len, (double)space_avail ));
 
 	if (len > space_avail) {
 		errno = ENOSPC;
@@ -769,6 +780,63 @@
 	return (path);
 }
 
+
+/* check if the file 'nmae' is a symlink, in that case check that it point to
+   a file that reside under the 'dir' tree */
+
+static BOOL readlink_check(connection_struct *conn, char *dir, char *name)
+{
+	BOOL ret = True;
+	pstring flink;
+	pstring cleanlink;
+	pstring savedir;
+	pstring realdir;
+	size_t reallen;
+
+	if (!vfs_GetWd(conn, savedir)) {
+		DEBUG(0,("couldn't vfs_GetWd for %s %s\n", name, dir));
+		return False;
+	}
+
+	if (vfs_ChDir(conn, dir) != 0) {
+		DEBUG(0,("couldn't vfs_ChDir to %s\n", dir));
+		return False;
+	}
+
+	if (!vfs_GetWd(conn, realdir)) {
+		DEBUG(0,("couldn't vfs_GetWd for %s\n", dir));
+		vfs_ChDir(conn, savedir);
+		return(False);
+	}
+	
+	reallen = strlen(realdir);
+	if (realdir[reallen -1] == '/') {
+		reallen--;
+		realdir[reallen] = 0;
+	}
+
+	if (conn->vfs_ops.readlink(conn, name, flink, sizeof(pstring) -1) != -1) {
+		DEBUG(3,("reduce_name: file path name %s is a symlink\nChecking it's path\n", name));
+		if (*flink == '/') {
+			pstrcpy(cleanlink, flink);
+		} else {
+			pstrcpy(cleanlink, realdir);
+			pstrcat(cleanlink, "/");
+			pstrcat(cleanlink, flink);
+		}
+		unix_clean_name(cleanlink);
+
+		if (strncmp(cleanlink, realdir, reallen) != 0) {
+			DEBUG(2,("Bad access attempt? s=%s dir=%s newname=%s l=%d\n", name, realdir, cleanlink, (int)reallen));
+			ret = False;
+		}
+	}
+
+	vfs_ChDir(conn, savedir);
+	
+	return ret;
+}
+
 /*******************************************************************
  Reduce a file name, removing .. elements and checking that
  it is below dir in the heirachy. This uses vfs_GetWd() and so must be run
@@ -776,7 +844,7 @@
  Widelinks are allowed if widelinks is true.
 ********************************************************************/
 
-BOOL reduce_name(connection_struct *conn, char *s,char *dir,BOOL widelinks)
+BOOL reduce_name(connection_struct *conn, pstring s, const char *dir,BOOL widelinks)
 {
 #ifndef REDUCE_PATHS
 	return True;
@@ -813,7 +881,7 @@
 	p = strrchr_m(base_name,'/');
 
 	if (!p)
-		return(True);
+		return readlink_check(conn, dir, s);
 
 	if (!vfs_GetWd(conn,wd)) {
 		DEBUG(0,("couldn't vfs_GetWd for %s %s\n",s,dir));
@@ -847,7 +915,7 @@
 
 	if (!vfs_GetWd(conn,newname)) {
 		vfs_ChDir(conn,wd);
-		DEBUG(2,("couldn't get vfs_GetWd for %s %s\n",s,dir2));
+		DEBUG(2,("couldn't get vfs_GetWd for %s %s\n",s,base_name));
 		return(False);
 	}
 
@@ -867,6 +935,11 @@
 			return(False);
 		}
 
+		if (!readlink_check(conn, dir, newname)) {
+			DEBUG(2, ("Bad access attemt? %s is a symlink outside the share path", s));
+			return(False);
+		}
+
 		if (relative) {
 			if (newname[l] == '/')
 				pstrcpy(s,newname + l + 1);
@@ -885,3 +958,4 @@
 	return(True);
 #endif
 }
+
diff -uNr samba-3.0alpha21.orig/source/tdb/tdb.c samba-3.0alpha21/source/tdb/tdb.c
--- samba-3.0alpha21.orig/source/tdb/tdb.c	2003-02-16 19:06:33.000000000 -0600
+++ samba-3.0alpha21/source/tdb/tdb.c	2003-02-16 19:05:47.000000000 -0600
@@ -4,7 +4,7 @@
    Copyright (C) Andrew Tridgell              1999-2000
    Copyright (C) Luke Kenneth Casson Leighton      2000
    Copyright (C) Paul `Rusty' Russell		   2000
-   Copyright (C) Jeremy Allison			   2000
+   Copyright (C) Jeremy Allison			   2000-2003
    
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -1018,37 +1018,35 @@
 
 /* update an entry in place - this only works if the new data size
    is <= the old data size and the key exists.
-   on failure return -1
+   on failure return -1.
 */
+
 static int tdb_update(TDB_CONTEXT *tdb, TDB_DATA key, TDB_DATA dbuf)
 {
 	struct list_struct rec;
 	tdb_off rec_ptr;
-	int ret = -1;
 
 	/* find entry */
-	if (!(rec_ptr = tdb_find_lock(tdb, key, F_WRLCK, &rec)))
+	if (!(rec_ptr = tdb_find(tdb, key, tdb_hash(&key), &rec)))
 		return -1;
 
 	/* must be long enough key, data and tailer */
 	if (rec.rec_len < key.dsize + dbuf.dsize + sizeof(tdb_off)) {
 		tdb->ecode = TDB_SUCCESS; /* Not really an error */
-		goto out;
+		return -1;
 	}
 
 	if (tdb_write(tdb, rec_ptr + sizeof(rec) + rec.key_len,
 		      dbuf.dptr, dbuf.dsize) == -1)
-		goto out;
+		return -1;
 
 	if (dbuf.dsize != rec.data_len) {
 		/* update size */
 		rec.data_len = dbuf.dsize;
-		ret = rec_write(tdb, rec_ptr, &rec);
-	} else
-		ret = 0;
- out:
-	tdb_unlock(tdb, BUCKET(rec.full_hash), F_WRLCK);
-	return ret;
+		return rec_write(tdb, rec_ptr, &rec);
+	}
+ 
+	return 0;
 }
 
 /* find an entry in the database given a key */
@@ -1476,6 +1474,133 @@
 	goto out;
 }
 
+/* Attempt to append data to an entry in place - this only works if the new data size
+   is <= the old data size and the key exists.
+   on failure return -1. Record must be locked before calling.
+*/
+static int tdb_append_inplace(TDB_CONTEXT *tdb, TDB_DATA key, TDB_DATA new_dbuf)
+{
+	struct list_struct rec;
+	tdb_off rec_ptr;
+
+	/* find entry */
+	if (!(rec_ptr = tdb_find(tdb, key, tdb_hash(&key), &rec)))
+		return -1;
+
+	/* Append of 0 is always ok. */
+	if (new_dbuf.dsize == 0)
+		return 0;
+
+	/* must be long enough for key, old data + new data and tailer */
+	if (rec.rec_len < key.dsize + rec.data_len + new_dbuf.dsize + sizeof(tdb_off)) {
+		/* No room. */
+		tdb->ecode = TDB_SUCCESS; /* Not really an error */
+		return -1;
+	}
+
+	if (tdb_write(tdb, rec_ptr + sizeof(rec) + rec.key_len + rec.data_len,
+		      new_dbuf.dptr, new_dbuf.dsize) == -1)
+		return -1;
+
+	/* update size */
+	rec.data_len += new_dbuf.dsize;
+	return rec_write(tdb, rec_ptr, &rec);
+}
+
+/* Append to an entry. Create if not exist. */
+
+int tdb_append(TDB_CONTEXT *tdb, TDB_DATA key, TDB_DATA new_dbuf)
+{
+	struct list_struct rec;
+	u32 hash;
+	tdb_off rec_ptr;
+	char *p = NULL;
+	int ret = 0;
+	size_t new_data_size = 0;
+
+	/* find which hash bucket it is in */
+	hash = tdb_hash(&key);
+	if (!tdb_keylocked(tdb, hash))
+		return -1;
+	if (tdb_lock(tdb, BUCKET(hash), F_WRLCK) == -1)
+		return -1;
+
+	/* first try in-place. */
+	if (tdb_append_inplace(tdb, key, new_dbuf) == 0)
+		goto out;
+
+	/* reset the error code potentially set by the tdb_append_inplace() */
+	tdb->ecode = TDB_SUCCESS;
+
+	/* find entry */
+	if (!(rec_ptr = tdb_find(tdb, key, hash, &rec))) {
+		if (tdb->ecode != TDB_ERR_NOEXIST)
+			goto fail;
+
+		/* Not found - create. */
+
+		ret = tdb_store(tdb, key, new_dbuf, TDB_INSERT);
+		goto out;
+	}
+
+	new_data_size = rec.data_len + new_dbuf.dsize;
+
+	/* Copy key+old_value+value *before* allocating free space in case malloc
+	   fails and we are left with a dead spot in the tdb. */
+
+	if (!(p = (char *)malloc(key.dsize + new_data_size))) {
+		tdb->ecode = TDB_ERR_OOM;
+		goto fail;
+	}
+
+	/* Copy the key in place. */
+	memcpy(p, key.dptr, key.dsize);
+
+	/* Now read the old data into place. */
+	if (rec.data_len &&
+		tdb_read(tdb, rec_ptr + sizeof(rec) + rec.key_len, p + key.dsize, rec.data_len, 0) == -1)
+			goto fail;
+
+	/* Finally append the new data. */
+	if (new_dbuf.dsize)
+		memcpy(p+key.dsize+rec.data_len, new_dbuf.dptr, new_dbuf.dsize);
+
+	/* delete any existing record - if it doesn't exist we don't
+           care.  Doing this first reduces fragmentation, and avoids
+           coalescing with `allocated' block before it's updated. */
+
+	tdb_delete(tdb, key);
+
+	if (!(rec_ptr = tdb_allocate(tdb, key.dsize + new_data_size, &rec)))
+		goto fail;
+
+	/* Read hash top into next ptr */
+	if (ofs_read(tdb, TDB_HASH_TOP(hash), &rec.next) == -1)
+		goto fail;
+
+	rec.key_len = key.dsize;
+	rec.data_len = new_data_size;
+	rec.full_hash = hash;
+	rec.magic = TDB_MAGIC;
+
+	/* write out and point the top of the hash chain at it */
+	if (rec_write(tdb, rec_ptr, &rec) == -1
+	    || tdb_write(tdb, rec_ptr+sizeof(rec), p, key.dsize+new_data_size)==-1
+	    || ofs_write(tdb, TDB_HASH_TOP(hash), &rec_ptr) == -1) {
+		/* Need to tdb_unallocate() here */
+		goto fail;
+	}
+
+ out:
+	SAFE_FREE(p); 
+	tdb_unlock(tdb, BUCKET(hash), F_WRLCK);
+	return ret;
+
+fail:
+	ret = -1;
+	goto out;
+}
+
 static int tdb_already_open(dev_t device,
 			    ino_t ino)
 {
@@ -1584,7 +1709,8 @@
 
 	if (read(tdb->fd, &tdb->header, sizeof(tdb->header)) != sizeof(tdb->header)
 	    || strcmp(tdb->header.magic_food, TDB_MAGIC_FOOD) != 0
-	    || (tdb->header.version != TDB_VERSION
+	    || tdb->header.version != TDB_VERSION
+	    || (tdb->header.hash_size != hash_size
 		&& !(rev = (tdb->header.version==TDB_BYTEREV(TDB_VERSION))))) {
 		/* its not a valid database - possibly initialise it */
 		if (!(open_flags & O_CREAT) || tdb_new_database(tdb, hash_size) == -1) {
diff -uNr samba-3.0alpha21.orig/source/tdb/tdb.h samba-3.0alpha21/source/tdb/tdb.h
--- samba-3.0alpha21.orig/source/tdb/tdb.h	2003-02-16 19:06:33.000000000 -0600
+++ samba-3.0alpha21/source/tdb/tdb.h	2003-02-16 19:05:47.000000000 -0600
@@ -115,6 +115,7 @@
 TDB_DATA tdb_fetch(TDB_CONTEXT *tdb, TDB_DATA key);
 int tdb_delete(TDB_CONTEXT *tdb, TDB_DATA key);
 int tdb_store(TDB_CONTEXT *tdb, TDB_DATA key, TDB_DATA dbuf, int flag);
+int tdb_append(TDB_CONTEXT *tdb, TDB_DATA key, TDB_DATA new_dbuf);
 int tdb_close(TDB_CONTEXT *tdb);
 TDB_DATA tdb_firstkey(TDB_CONTEXT *tdb);
 TDB_DATA tdb_nextkey(TDB_CONTEXT *tdb, TDB_DATA key);
diff -uNr samba-3.0alpha21.orig/source/tdb/tdbbackup.c samba-3.0alpha21/source/tdb/tdbbackup.c
--- samba-3.0alpha21.orig/source/tdb/tdbbackup.c	2003-02-16 19:06:33.000000000 -0600
+++ samba-3.0alpha21/source/tdb/tdbbackup.c	2003-02-16 19:05:47.000000000 -0600
@@ -303,3 +303,13 @@
 
 	return ret;
 }
+
+#ifdef VALGRIND
+size_t valgrind_strlen(const char *s)
+{
+	size_t count;
+	for(count = 0; *s++; count++)
+		;
+	return count;
+}
+#endif
diff -uNr samba-3.0alpha21.orig/source/tdb/tdbtool.c samba-3.0alpha21/source/tdb/tdbtool.c
--- samba-3.0alpha21.orig/source/tdb/tdbtool.c	2003-02-16 19:06:33.000000000 -0600
+++ samba-3.0alpha21/source/tdb/tdbtool.c	2003-02-16 19:05:47.000000000 -0600
@@ -251,7 +251,8 @@
 	}
 
 	key.dptr = k;
-	key.dsize = strlen(k)+1;
+/*	key.dsize = strlen(k)+1;*/
+	key.dsize = strlen(k);
 
 	dbuf = tdb_fetch(tdb, key);
 	if (!dbuf.dptr) {
diff -uNr samba-3.0alpha21.orig/source/tdb/tdbtorture.c samba-3.0alpha21/source/tdb/tdbtorture.c
--- samba-3.0alpha21.orig/source/tdb/tdbtorture.c	2003-02-16 19:06:33.000000000 -0600
+++ samba-3.0alpha21/source/tdb/tdbtorture.c	2003-02-16 19:05:47.000000000 -0600
@@ -21,6 +21,7 @@
 #define REOPEN_PROB 30
 #define DELETE_PROB 8
 #define STORE_PROB 4
+#define APPEND_PROB 6
 #define LOCKSTORE_PROB 0
 #define TRAVERSE_PROB 20
 #define CULL_PROB 100
@@ -122,6 +123,15 @@
 	}
 #endif
 
+#if APPEND_PROB
+	if (random() % APPEND_PROB == 0) {
+		if (tdb_append(db, key, data) != 0) {
+			fatal("tdb_append failed");
+		}
+		goto next;
+	}
+#endif
+
 #if LOCKSTORE_PROB
 	if (random() % LOCKSTORE_PROB == 0) {
 		tdb_chainlock(db, lockkey);
diff -uNr samba-3.0alpha21.orig/source/tdb/tdbutil.c samba-3.0alpha21/source/tdb/tdbutil.c
--- samba-3.0alpha21.orig/source/tdb/tdbutil.c	2003-02-16 19:06:33.000000000 -0600
+++ samba-3.0alpha21/source/tdb/tdbutil.c	2003-02-16 19:05:47.000000000 -0600
@@ -35,11 +35,23 @@
 	gotalarm = 1;
 }
 
+/***************************************************************
+ Make a TDB_DATA and keep the const warning in one place
+****************************************************************/
+
+static TDB_DATA make_tdb_data(const char *dptr, size_t dsize)
+{
+	TDB_DATA ret;
+	ret.dptr = dptr;
+	ret.dsize = dsize;
+	return ret;
+}
+
 /****************************************************************************
  Lock a chain with timeout (in seconds).
 ****************************************************************************/
 
-static int tdb_chainlock_with_timeout( TDB_CONTEXT *tdb, TDB_DATA key, unsigned int timeout, int rw_type)
+static int tdb_chainlock_with_timeout_internal( TDB_CONTEXT *tdb, TDB_DATA key, unsigned int timeout, int rw_type)
 {
 	/* Allow tdb_chainlock to be interrupted by an alarm. */
 	int ret;
@@ -60,8 +72,12 @@
 		alarm(0);
 		CatchSignal(SIGALRM, SIGNAL_CAST SIG_IGN);
 		if (gotalarm) {
-			DEBUG(0,("tdb_chainlock_with_timeout: alarm (%u) timed out for key %s in tdb %s\n",
+			DEBUG(0,("tdb_chainlock_with_timeout_internal: alarm (%u) timed out for key %s in tdb %s\n",
 				timeout, key.dptr, tdb->name ));
+			/* TODO: If we time out waiting for a lock, it might
+			 * be nice to use F_GETLK to get the pid of the
+			 * process currently holding the lock and print that
+			 * as part of the debugging message. -- mbp */
 			return -1;
 		}
 	}
@@ -70,30 +86,33 @@
 }
 
 /****************************************************************************
- Lock a chain by string. Return -1 if timeout or lock failed.
+ Write lock a chain. Return -1 if timeout or lock failed.
 ****************************************************************************/
 
-int tdb_lock_bystring(TDB_CONTEXT *tdb, char *keyval, unsigned int timeout)
+int tdb_chainlock_with_timeout( TDB_CONTEXT *tdb, TDB_DATA key, unsigned int timeout)
 {
-	TDB_DATA key;
+	return tdb_chainlock_with_timeout_internal(tdb, key, timeout, F_WRLCK);
+}
+
+/****************************************************************************
+ Lock a chain by string. Return -1 if timeout or lock failed.
+****************************************************************************/
 
-	key.dptr = keyval;
-	key.dsize = strlen(keyval)+1;
+int tdb_lock_bystring(TDB_CONTEXT *tdb, const char *keyval, unsigned int timeout)
+{
+	TDB_DATA key = make_tdb_data(keyval, strlen(keyval)+1);
 	
-	return tdb_chainlock_with_timeout(tdb, key, timeout, F_WRLCK);
+	return tdb_chainlock_with_timeout_internal(tdb, key, timeout, F_WRLCK);
 }
 
 /****************************************************************************
  Unlock a chain by string.
 ****************************************************************************/
 
-void tdb_unlock_bystring(TDB_CONTEXT *tdb, char *keyval)
+void tdb_unlock_bystring(TDB_CONTEXT *tdb, const char *keyval)
 {
-	TDB_DATA key;
+	TDB_DATA key = make_tdb_data(keyval, strlen(keyval)+1);
 
-	key.dptr = keyval;
-	key.dsize = strlen(keyval)+1;
-	
 	tdb_chainunlock(tdb, key);
 }
 
@@ -101,26 +120,20 @@
  Read lock a chain by string. Return -1 if timeout or lock failed.
 ****************************************************************************/
 
-int tdb_read_lock_bystring(TDB_CONTEXT *tdb, char *keyval, unsigned int timeout)
+int tdb_read_lock_bystring(TDB_CONTEXT *tdb, const char *keyval, unsigned int timeout)
 {
-	TDB_DATA key;
-
-	key.dptr = keyval;
-	key.dsize = strlen(keyval)+1;
+	TDB_DATA key = make_tdb_data(keyval, strlen(keyval)+1);
 	
-	return tdb_chainlock_with_timeout(tdb, key, timeout, F_RDLCK);
+	return tdb_chainlock_with_timeout_internal(tdb, key, timeout, F_RDLCK);
 }
 
 /****************************************************************************
  Read unlock a chain by string.
 ****************************************************************************/
 
-void tdb_read_unlock_bystring(TDB_CONTEXT *tdb, char *keyval)
+void tdb_read_unlock_bystring(TDB_CONTEXT *tdb, const char *keyval)
 {
-	TDB_DATA key;
-
-	key.dptr = keyval;
-	key.dsize = strlen(keyval)+1;
+	TDB_DATA key = make_tdb_data(keyval, strlen(keyval)+1);
 	
 	tdb_chainunlock_read(tdb, key);
 }
@@ -131,13 +144,12 @@
  Output is int32 in native byte order.
 ****************************************************************************/
 
-int32 tdb_fetch_int32_byblob(TDB_CONTEXT *tdb, char *keyval, size_t len)
+int32 tdb_fetch_int32_byblob(TDB_CONTEXT *tdb, const char *keyval, size_t len)
 {
-	TDB_DATA key, data;
+	TDB_DATA key = make_tdb_data(keyval, len);
+	TDB_DATA data;
 	int32 ret;
 
-	key.dptr = keyval;
-	key.dsize = len;
 	data = tdb_fetch(tdb, key);
 	if (!data.dptr || data.dsize != sizeof(int32)) {
 		SAFE_FREE(data.dptr);
@@ -154,7 +166,7 @@
  Output is int32 in native byte order.
 ****************************************************************************/
 
-int32 tdb_fetch_int32(TDB_CONTEXT *tdb, char *keystr)
+int32 tdb_fetch_int32(TDB_CONTEXT *tdb, const char *keystr)
 {
 	return tdb_fetch_int32_byblob(tdb, keystr, strlen(keystr) + 1);
 }
@@ -164,13 +176,12 @@
  Input is int32 in native byte order. Output in tdb is in little-endian.
 ****************************************************************************/
 
-int tdb_store_int32_byblob(TDB_CONTEXT *tdb, char *keystr, size_t len, int32 v)
+int tdb_store_int32_byblob(TDB_CONTEXT *tdb, const char *keystr, size_t len, int32 v)
 {
-	TDB_DATA key, data;
+	TDB_DATA key = make_tdb_data(keystr, len);
+	TDB_DATA data;
 	int32 v_store;
 
-	key.dptr = keystr;
-	key.dsize = len;
 	SIVAL(&v_store,0,v);
 	data.dptr = (void *)&v_store;
 	data.dsize = sizeof(int32);
@@ -183,7 +194,7 @@
  Input is int32 in native byte order. Output in tdb is in little-endian.
 ****************************************************************************/
 
-int tdb_store_int32(TDB_CONTEXT *tdb, char *keystr, int32 v)
+int tdb_store_int32(TDB_CONTEXT *tdb, const char *keystr, int32 v)
 {
 	return tdb_store_int32_byblob(tdb, keystr, strlen(keystr) + 1, v);
 }
@@ -193,12 +204,11 @@
  Output is uint32 in native byte order.
 ****************************************************************************/
 
-BOOL tdb_fetch_uint32_byblob(TDB_CONTEXT *tdb, char *keyval, size_t len, uint32 *value)
+BOOL tdb_fetch_uint32_byblob(TDB_CONTEXT *tdb, const char *keyval, size_t len, uint32 *value)
 {
-	TDB_DATA key, data;
+	TDB_DATA key = make_tdb_data(keyval, len);
+	TDB_DATA data;
 
-	key.dptr = keyval;
-	key.dsize = len;
 	data = tdb_fetch(tdb, key);
 	if (!data.dptr || data.dsize != sizeof(uint32)) {
 		SAFE_FREE(data.dptr);
@@ -215,7 +225,7 @@
  Output is uint32 in native byte order.
 ****************************************************************************/
 
-BOOL tdb_fetch_uint32(TDB_CONTEXT *tdb, char *keystr, uint32 *value)
+BOOL tdb_fetch_uint32(TDB_CONTEXT *tdb, const char *keystr, uint32 *value)
 {
 	return tdb_fetch_uint32_byblob(tdb, keystr, strlen(keystr) + 1, value);
 }
@@ -225,14 +235,13 @@
  Input is uint32 in native byte order. Output in tdb is in little-endian.
 ****************************************************************************/
 
-BOOL tdb_store_uint32_byblob(TDB_CONTEXT *tdb, char *keystr, size_t len, uint32 value)
+BOOL tdb_store_uint32_byblob(TDB_CONTEXT *tdb, const char *keystr, size_t len, uint32 value)
 {
-	TDB_DATA key, data;
+	TDB_DATA key = make_tdb_data(keystr, len);
+	TDB_DATA data;
 	uint32 v_store;
 	BOOL ret = True;
 
-	key.dptr = keystr;
-	key.dsize = len;
 	SIVAL(&v_store, 0, value);
 	data.dptr = (void *)&v_store;
 	data.dsize = sizeof(uint32);
@@ -248,7 +257,7 @@
  Input is uint32 in native byte order. Output in tdb is in little-endian.
 ****************************************************************************/
 
-BOOL tdb_store_uint32(TDB_CONTEXT *tdb, char *keystr, uint32 value)
+BOOL tdb_store_uint32(TDB_CONTEXT *tdb, const char *keystr, uint32 value)
 {
 	return tdb_store_uint32_byblob(tdb, keystr, strlen(keystr) + 1, value);
 }
@@ -257,14 +266,11 @@
  on failure.
 ****************************************************************************/
 
-int tdb_store_by_string(TDB_CONTEXT *tdb, char *keystr, TDB_DATA data, int flags)
+int tdb_store_by_string(TDB_CONTEXT *tdb, const char *keystr, TDB_DATA data, int flags)
 {
-    TDB_DATA key;
-
-    key.dptr = keystr;
-    key.dsize = strlen(keystr) + 1;
-
-    return tdb_store(tdb, key, data, flags);
+	TDB_DATA key = make_tdb_data(keystr, strlen(keystr)+1);
+	
+	return tdb_store(tdb, key, data, flags);
 }
 
 /****************************************************************************
@@ -272,35 +278,29 @@
  free() on the result dptr.
 ****************************************************************************/
 
-TDB_DATA tdb_fetch_by_string(TDB_CONTEXT *tdb, char *keystr)
+TDB_DATA tdb_fetch_by_string(TDB_CONTEXT *tdb, const char *keystr)
 {
-    TDB_DATA key;
+	TDB_DATA key = make_tdb_data(keystr, strlen(keystr)+1);
 
-    key.dptr = keystr;
-    key.dsize = strlen(keystr) + 1;
-
-    return tdb_fetch(tdb, key);
+	return tdb_fetch(tdb, key);
 }
 
 /****************************************************************************
  Delete an entry using a null terminated string key. 
 ****************************************************************************/
 
-int tdb_delete_by_string(TDB_CONTEXT *tdb, char *keystr)
+int tdb_delete_by_string(TDB_CONTEXT *tdb, const char *keystr)
 {
-    TDB_DATA key;
-
-    key.dptr = keystr;
-    key.dsize = strlen(keystr) + 1;
+	TDB_DATA key = make_tdb_data(keystr, strlen(keystr)+1);
 
-    return tdb_delete(tdb, key);
+	return tdb_delete(tdb, key);
 }
 
 /****************************************************************************
  Atomic integer change. Returns old value. To create, set initial value in *oldval. 
 ****************************************************************************/
 
-int32 tdb_change_int32_atomic(TDB_CONTEXT *tdb, char *keystr, int32 *oldval, int32 change_val)
+int32 tdb_change_int32_atomic(TDB_CONTEXT *tdb, const char *keystr, int32 *oldval, int32 change_val)
 {
 	int32 val;
 	int32 ret = -1;
@@ -341,7 +341,7 @@
  Atomic unsigned integer change. Returns old value. To create, set initial value in *oldval. 
 ****************************************************************************/
 
-BOOL tdb_change_uint32_atomic(TDB_CONTEXT *tdb, char *keystr, uint32 *oldval, uint32 change_val)
+BOOL tdb_change_uint32_atomic(TDB_CONTEXT *tdb, const char *keystr, uint32 *oldval, uint32 change_val)
 {
 	uint32 val;
 	BOOL ret = False;
@@ -384,7 +384,7 @@
  integers and strings.
 ****************************************************************************/
 
-size_t tdb_pack(char *buf, int bufsize, char *fmt, ...)
+size_t tdb_pack(char *buf, int bufsize, const char *fmt, ...)
 {
 	va_list ap;
 	uint16 w;
@@ -395,7 +395,7 @@
 	char *s;
 	char c;
 	char *buf0 = buf;
-	char *fmt0 = fmt;
+	const char *fmt0 = fmt;
 	int bufsize0 = bufsize;
 
 	va_start(ap, fmt);
@@ -468,7 +468,7 @@
  integers and strings.
 ****************************************************************************/
 
-int tdb_unpack(char *buf, int bufsize, char *fmt, ...)
+int tdb_unpack(char *buf, int bufsize, const char *fmt, ...)
 {
 	va_list ap;
 	uint16 *w;
@@ -479,7 +479,7 @@
 	char *s, **b;
 	char c;
 	char *buf0 = buf;
-	char *fmt0 = fmt;
+	const char *fmt0 = fmt;
 	int bufsize0 = bufsize;
 
 	va_start(ap, fmt);
diff -uNr samba-3.0alpha21.orig/source/torture/denytest.c samba-3.0alpha21/source/torture/denytest.c
--- samba-3.0alpha21.orig/source/torture/denytest.c	2003-02-16 19:06:33.000000000 -0600
+++ samba-3.0alpha21/source/torture/denytest.c	2003-02-16 19:05:47.000000000 -0600
@@ -27,11 +27,11 @@
 enum deny_result {A_0=0, A_X=1, A_R=2, A_W=3, A_RW=5};
 
 
-static char *denystr(int denymode)
+static const char *denystr(int denymode)
 {
 	struct {
 		int v;
-		char *name; 
+		const char *name; 
 	} deny_modes[] = {
 		{DENY_DOS, "DENY_DOS"},
 		{DENY_ALL, "DENY_ALL"},
@@ -47,11 +47,11 @@
 	return "DENY_XXX";
 }
 
-static char *openstr(int mode)
+static const char *openstr(int mode)
 {
 	struct {
 		int v;
-		char *name; 
+		const char *name; 
 	} open_modes[] = {
 		{O_RDWR, "O_RDWR"},
 		{O_RDONLY, "O_RDONLY"},
@@ -64,11 +64,11 @@
 	return "O_XXX";
 }
 
-static char *resultstr(enum deny_result res)
+static const char *resultstr(enum deny_result res)
 {
 	struct {
 		enum deny_result res;
-		char *name; 
+		const char *name; 
 	} results[] = {
 		{A_X, "X"},
 		{A_0, "-"},
@@ -1412,7 +1412,7 @@
 	int fnum1, fnum2;
 	int i;
 	BOOL correct = True;
-	char *fnames[2] = {"\\denytest1.dat", "\\denytest1.exe"};
+	const char *fnames[2] = {"\\denytest1.dat", "\\denytest1.exe"};
 
 	if (!torture_open_connection(&cli1)) {
 		return False;
@@ -1431,7 +1431,7 @@
 
 	for (i=0; i<ARRAY_SIZE(denytable1); i++) {
 		enum deny_result res;
-		char *fname = fnames[denytable1[i].isexe];
+		const char *fname = fnames[denytable1[i].isexe];
 
 		progress_bar(i, ARRAY_SIZE(denytable1));
 
@@ -1498,7 +1498,7 @@
 	int fnum1, fnum2;
 	int i;
 	BOOL correct = True;
-	char *fnames[2] = {"\\denytest2.dat", "\\denytest2.exe"};
+	const char *fnames[2] = {"\\denytest2.dat", "\\denytest2.exe"};
 
 	if (!torture_open_connection(&cli1) || !torture_open_connection(&cli2)) {
 		return False;
@@ -1515,7 +1515,7 @@
 
 	for (i=0; i<ARRAY_SIZE(denytable2); i++) {
 		enum deny_result res;
-		char *fname = fnames[denytable2[i].isexe];
+		const char *fname = fnames[denytable2[i].isexe];
 
 		progress_bar(i, ARRAY_SIZE(denytable1));
 
diff -uNr samba-3.0alpha21.orig/source/torture/locktest.c samba-3.0alpha21/source/torture/locktest.c
--- samba-3.0alpha21.orig/source/torture/locktest.c	2003-02-16 19:06:33.000000000 -0600
+++ samba-3.0alpha21/source/torture/locktest.c	2003-02-16 19:05:47.000000000 -0600
@@ -193,14 +193,14 @@
 	if (!got_pass) {
 		char *pass = getpass("Password: ");
 		if (pass) {
-			pstrcpy(password[0], pass);
-			pstrcpy(password[1], pass);
+			fstrcpy(password[0], pass);
+			fstrcpy(password[1], pass);
 		}
 	}
 
 	if (got_pass == 1) {
-		pstrcpy(password[1], password[0]);
-		pstrcpy(username[1], username[0]);
+		fstrcpy(password[1], password[0]);
+		fstrcpy(username[1], username[0]);
 	}
 
 	if (!cli_session_setup(c, username[snum], 
@@ -591,8 +591,8 @@
 	load_interfaces();
 
 	if (getenv("USER")) {
-		pstrcpy(username[0],getenv("USER"));
-		pstrcpy(username[1],getenv("USER"));
+		fstrcpy(username[0],getenv("USER"));
+		fstrcpy(username[1],getenv("USER"));
 	}
 
 	seed = time(NULL);
@@ -613,11 +613,11 @@
 				d_printf("Max of 2 usernames\n");
 				exit(1);
 			}
-			pstrcpy(username[got_pass],optarg);
+			fstrcpy(username[got_pass],optarg);
 			p = strchr_m(username[got_pass],'%');
 			if (p) {
 				*p = 0;
-				pstrcpy(password[got_pass], p+1);
+				fstrcpy(password[got_pass], p+1);
 				got_pass++;
 			}
 			break;
diff -uNr samba-3.0alpha21.orig/source/torture/locktest2.c samba-3.0alpha21/source/torture/locktest2.c
--- samba-3.0alpha21.orig/source/torture/locktest2.c	2003-02-16 19:06:33.000000000 -0600
+++ samba-3.0alpha21/source/torture/locktest2.c	2003-02-16 19:05:47.000000000 -0600
@@ -62,7 +62,7 @@
 
 static struct record *recorded;
 
-static int try_open(struct cli_state *c, char *nfs, int fstype, char *fname, int flags)
+static int try_open(struct cli_state *c, char *nfs, int fstype, const char *fname, int flags)
 {
 	pstring path;
 
@@ -169,7 +169,7 @@
 	if (!got_pass) {
 		char *pass = getpass("Password: ");
 		if (pass) {
-			pstrcpy(password, pass);
+			fstrcpy(password, pass);
 		}
 	}
 
@@ -504,7 +504,7 @@
 	load_interfaces();
 
 	if (getenv("USER")) {
-		pstrcpy(username,getenv("USER"));
+		fstrcpy(username,getenv("USER"));
 	}
 
 	seed = time(NULL);
@@ -512,11 +512,11 @@
 	while ((opt = getopt(argc, argv, "U:s:ho:aAW:O")) != EOF) {
 		switch (opt) {
 		case 'U':
-			pstrcpy(username,optarg);
+			fstrcpy(username,optarg);
 			p = strchr_m(username,'%');
 			if (p) {
 				*p = 0;
-				pstrcpy(password, p+1);
+				fstrcpy(password, p+1);
 				got_pass = 1;
 			}
 			break;
diff -uNr samba-3.0alpha21.orig/source/torture/masktest.c samba-3.0alpha21/source/torture/masktest.c
--- samba-3.0alpha21.orig/source/torture/masktest.c	2003-02-16 19:06:33.000000000 -0600
+++ samba-3.0alpha21/source/torture/masktest.c	2003-02-16 19:05:47.000000000 -0600
@@ -28,16 +28,16 @@
 static int max_protocol = PROTOCOL_NT1;
 static BOOL showall = False;
 static BOOL old_list = False;
-static char *maskchars = "<>\"?*abc.";
-static char *filechars = "abcdefghijklm.";
+static const char *maskchars = "<>\"?*abc.";
+static const char *filechars = "abcdefghijklm.";
 static int verbose;
 static int die_on_error;
 static int NumLoops = 0;
 
 /* a test fn for LANMAN mask support */
-int ms_fnmatch_lanman_core(char *pattern, char *string)
+int ms_fnmatch_lanman_core(const char *pattern, const char *string)
 {
-	char *p = pattern, *n = string;
+	const char *p = pattern, *n = string;
 	char c;
 
 	if (strcmp(p,"?")==0 && strcmp(n,".")==0) goto match;
@@ -109,10 +109,12 @@
 	return 0;
 }
 
-int ms_fnmatch_lanman(char *pattern, char *string)
+int ms_fnmatch_lanman(const char *pattern, const char *string)
 {
 	if (!strpbrk(pattern, "?*<>\"")) {
-		if (strcmp(string,"..") == 0) string = ".";
+		if (strcmp(string,"..") == 0) 
+			string = ".";
+
 		return strcmp(pattern, string);
 	}
 
@@ -124,7 +126,7 @@
 	return ms_fnmatch_lanman_core(pattern, string);
 }
 
-static BOOL reg_match_one(struct cli_state *cli, char *pattern, char *file)
+static BOOL reg_match_one(struct cli_state *cli, const char *pattern, const char *file)
 {
 	/* oh what a weird world this is */
 	if (old_list && strcmp(pattern, "*.*") == 0) return True;
@@ -211,7 +213,7 @@
 	if (!got_pass) {
 		char *pass = getpass("Password: ");
 		if (pass) {
-			pstrcpy(password, pass);
+			fstrcpy(password, pass);
 		}
 	}
 
@@ -454,7 +456,7 @@
 	load_interfaces();
 
 	if (getenv("USER")) {
-		pstrcpy(username,getenv("USER"));
+		fstrcpy(username,getenv("USER"));
 	}
 
 	seed = time(NULL);
@@ -477,11 +479,11 @@
 			max_protocol = interpret_protocol(optarg, max_protocol);
 			break;
 		case 'U':
-			pstrcpy(username,optarg);
+			fstrcpy(username,optarg);
 			p = strchr_m(username,'%');
 			if (p) {
 				*p = 0;
-				pstrcpy(password, p+1);
+				fstrcpy(password, p+1);
 				got_pass = 1;
 			}
 			break;
diff -uNr samba-3.0alpha21.orig/source/torture/nsstest.c samba-3.0alpha21/source/torture/nsstest.c
--- samba-3.0alpha21.orig/source/torture/nsstest.c	2003-02-16 19:06:33.000000000 -0600
+++ samba-3.0alpha21/source/torture/nsstest.c	2003-02-16 19:05:47.000000000 -0600
@@ -20,8 +20,8 @@
 
 #include "includes.h"
 
-static char *so_path = "/lib/libnss_winbind.so";
-static char *nss_name = "winbind";
+static const char *so_path = "/lib/libnss_winbind.so";
+static const char *nss_name = "winbind";
 static int nss_errno;
 static NSS_STATUS last_error;
 static int total_errors;
diff -uNr samba-3.0alpha21.orig/source/torture/rpctorture.c samba-3.0alpha21/source/torture/rpctorture.c
--- samba-3.0alpha21.orig/source/torture/rpctorture.c	2003-02-16 19:06:33.000000000 -0600
+++ samba-3.0alpha21/source/torture/rpctorture.c	2003-02-16 19:05:47.000000000 -0600
@@ -225,7 +225,6 @@
 	pstring term_code;
 	BOOL got_pass = False;
 	char *cmd_str="";
-	mode_t myumask = 0755;
 	enum client_action cli_action = CLIENT_NONE;
 	int nprocs = 1;
 	int numops = 100;
@@ -290,9 +289,6 @@
 
 	setup_logging(pname, True);
 
-	myumask = umask(0);
-	umask(myumask);
-
 	if (!get_myname(global_myname))
 	{
 		fprintf(stderr, "Failed to get my hostname.\n");
diff -uNr samba-3.0alpha21.orig/source/torture/scanner.c samba-3.0alpha21/source/torture/scanner.c
--- samba-3.0alpha21.orig/source/torture/scanner.c	2003-02-16 19:06:33.000000000 -0600
+++ samba-3.0alpha21/source/torture/scanner.c	2003-02-16 19:05:47.000000000 -0600
@@ -29,7 +29,7 @@
 /****************************************************************************
 look for a partial hit
 ****************************************************************************/
-static void trans2_check_hit(char *format, int op, int level, NTSTATUS status)
+static void trans2_check_hit(const char *format, int op, int level, NTSTATUS status)
 {
 	if (NT_STATUS_V(status) == NT_STATUS_V(NT_STATUS_INVALID_LEVEL) ||
 	    NT_STATUS_V(status) == NT_STATUS_V(NT_STATUS_NOT_IMPLEMENTED) ||
@@ -78,7 +78,7 @@
 
 
 static NTSTATUS try_trans2_len(struct cli_state *cli, 
-			     char *format,
+			     const char *format,
 			     int op, int level,
 			     char *param, char *data,
 			     int param_len, int *data_len,
@@ -113,7 +113,7 @@
 check for existance of a trans2 call
 ****************************************************************************/
 static BOOL scan_trans2(struct cli_state *cli, int op, int level, 
-			int fnum, int dnum, char *fname)
+			int fnum, int dnum, const char *fname)
 {
 	int data_len = 0;
 	int param_len = 0;
@@ -193,7 +193,7 @@
 {
 	static struct cli_state cli;
 	int op, level;
-	char *fname = "\\scanner.dat";
+	const char *fname = "\\scanner.dat";
 	int fnum, dnum;
 
 	printf("starting trans2 scan test\n");
@@ -233,7 +233,7 @@
 /****************************************************************************
 look for a partial hit
 ****************************************************************************/
-static void nttrans_check_hit(char *format, int op, int level, NTSTATUS status)
+static void nttrans_check_hit(const char *format, int op, int level, NTSTATUS status)
 {
 	if (NT_STATUS_V(status) == NT_STATUS_V(NT_STATUS_INVALID_LEVEL) ||
 	    NT_STATUS_V(status) == NT_STATUS_V(NT_STATUS_NOT_IMPLEMENTED) ||
@@ -280,7 +280,7 @@
 
 
 static NTSTATUS try_nttrans_len(struct cli_state *cli, 
-			     char *format,
+			     const char *format,
 			     int op, int level,
 			     char *param, char *data,
 			     int param_len, int *data_len,
@@ -315,7 +315,7 @@
 check for existance of a nttrans call
 ****************************************************************************/
 static BOOL scan_nttrans(struct cli_state *cli, int op, int level, 
-			int fnum, int dnum, char *fname)
+			int fnum, int dnum, const char *fname)
 {
 	int data_len = 0;
 	int param_len = 0;
@@ -395,7 +395,7 @@
 {
 	static struct cli_state cli;
 	int op, level;
-	char *fname = "\\scanner.dat";
+	const char *fname = "\\scanner.dat";
 	int fnum, dnum;
 
 	printf("starting nttrans scan test\n");
diff -uNr samba-3.0alpha21.orig/source/torture/torture.c samba-3.0alpha21/source/torture/torture.c
--- samba-3.0alpha21.orig/source/torture/torture.c	2003-02-16 19:06:33.000000000 -0600
+++ samba-3.0alpha21/source/torture/torture.c	2003-02-16 19:05:47.000000000 -0600
@@ -24,7 +24,7 @@
 
 static fstring host, workgroup, share, password, username, myname;
 static int max_protocol = PROTOCOL_NT1;
-static char *sockops="TCP_NODELAY";
+static const char *sockops="TCP_NODELAY";
 static int nprocs=1;
 int torture_numops=100;
 static int procnum; /* records process count number when forking */
@@ -32,7 +32,7 @@
 static fstring randomfname;
 static BOOL use_oplocks;
 static BOOL use_level_II_oplocks;
-static char *client_txt = "client_oplocks.txt";
+static const char *client_txt = "client_oplocks.txt";
 static BOOL use_kerberos;
 
 BOOL torture_showall = False;
@@ -221,7 +221,7 @@
 
 static BOOL rw_torture(struct cli_state *c)
 {
-	char *lockfname = "\\torture.lck";
+	const char *lockfname = "\\torture.lck";
 	fstring fname;
 	int fnum;
 	int fnum2;
@@ -428,7 +428,7 @@
 
 static BOOL rw_torture2(struct cli_state *c1, struct cli_state *c2)
 {
-	char *lockfname = "\\torture2.lck";
+	const char *lockfname = "\\torture2.lck";
 	int fnum1;
 	int fnum2;
 	int i;
@@ -554,7 +554,7 @@
 {
 	static struct cli_state cli1;
 	int fnum1;
-	char *lockfname = "\\large.dat";
+	const char *lockfname = "\\large.dat";
 	size_t fsize;
 	char buf[126*1024];
 	BOOL correct = True;
@@ -782,7 +782,7 @@
 static BOOL run_locktest1(int dummy)
 {
 	static struct cli_state cli1, cli2;
-	char *fname = "\\lockt1.lck";
+	const char *fname = "\\lockt1.lck";
 	int fnum1, fnum2, fnum3;
 	time_t t1, t2;
 	unsigned lock_timeout;
@@ -893,7 +893,7 @@
 static BOOL run_tcon_test(int dummy)
 {
 	static struct cli_state cli1;
-	char *fname = "\\tcontest.tmp";
+	const char *fname = "\\tcontest.tmp";
 	int fnum1;
 	uint16 cnum;
 	char buf[4];
@@ -976,7 +976,7 @@
 static BOOL run_locktest2(int dummy)
 {
 	static struct cli_state cli;
-	char *fname = "\\lockt2.lck";
+	const char *fname = "\\lockt2.lck";
 	int fnum1, fnum2, fnum3;
 	BOOL correct = True;
 
@@ -1112,7 +1112,7 @@
 static BOOL run_locktest3(int dummy)
 {
 	static struct cli_state cli1, cli2;
-	char *fname = "\\lockt3.lck";
+	const char *fname = "\\lockt3.lck";
 	int fnum1, fnum2, i;
 	uint32 offset;
 	BOOL correct = True;
@@ -1237,7 +1237,7 @@
 static BOOL run_locktest4(int dummy)
 {
 	static struct cli_state cli1, cli2;
-	char *fname = "\\lockt4.lck";
+	const char *fname = "\\lockt4.lck";
 	int fnum1, fnum2, f;
 	BOOL ret;
 	char buf[1000];
@@ -1408,7 +1408,7 @@
 static BOOL run_locktest5(int dummy)
 {
 	static struct cli_state cli1, cli2;
-	char *fname = "\\lockt5.lck";
+	const char *fname = "\\lockt5.lck";
 	int fnum1, fnum2, fnum3;
 	BOOL ret;
 	char buf[1000];
@@ -1532,7 +1532,7 @@
 static BOOL run_locktest6(int dummy)
 {
 	static struct cli_state cli;
-	char *fname[1] = { "\\lock6.txt" };
+	const char *fname[1] = { "\\lock6.txt" };
 	int i;
 	int fnum;
 	NTSTATUS status;
@@ -1576,7 +1576,7 @@
 static BOOL run_fdpasstest(int dummy)
 {
 	static struct cli_state cli1, cli2, cli3;
-	char *fname = "\\fdpass.tst";
+	const char *fname = "\\fdpass.tst";
 	int fnum1;
 	pstring buf;
 
@@ -1631,7 +1631,7 @@
 static BOOL run_unlinktest(int dummy)
 {
 	static struct cli_state cli;
-	char *fname = "\\unlink.tst";
+	const char *fname = "\\unlink.tst";
 	int fnum;
 	BOOL correct = True;
 
@@ -1680,7 +1680,7 @@
 static BOOL run_maxfidtest(int dummy)
 {
 	static struct cli_state cli;
-	char *template = "\\maxfid.%d.%d";
+	const char *template = "\\maxfid.%d.%d";
 	fstring fname;
 	int fnums[0x11000], i;
 	int retries=4;
@@ -1866,7 +1866,7 @@
 	static struct cli_state cli;
 	int fnum;
 	time_t t, t2;
-	char *fname = "\\attrib.tst";
+	const char *fname = "\\attrib.tst";
 	BOOL correct = True;
 
 	printf("starting attrib test\n");
@@ -1931,9 +1931,9 @@
 	int fnum;
 	size_t size;
 	time_t c_time, a_time, m_time, w_time, m_time2;
-	char *fname = "\\trans2.tst";
-	char *dname = "\\trans2";
-	char *fname2 = "\\trans2\\trans2.tst";
+	const char *fname = "\\trans2.tst";
+	const char *dname = "\\trans2";
+	const char *fname2 = "\\trans2\\trans2.tst";
 	pstring pname;
 	BOOL correct = True;
 
@@ -2083,7 +2083,7 @@
 {
 	static struct cli_state cli;
 	int fnum;
-	char *fname = "\\w2ktest\\w2k.tst";
+	const char *fname = "\\w2ktest\\w2k.tst";
 	int level;
 	BOOL correct = True;
 
@@ -2118,7 +2118,7 @@
 static BOOL run_oplock1(int dummy)
 {
 	static struct cli_state cli1;
-	char *fname = "\\lockt1.lck";
+	const char *fname = "\\lockt1.lck";
 	int fnum1;
 	BOOL correct = True;
 
@@ -2167,7 +2167,7 @@
 static BOOL run_oplock2(int dummy)
 {
 	static struct cli_state cli1, cli2;
-	char *fname = "\\lockt2.lck";
+	const char *fname = "\\lockt2.lck";
 	int fnum1, fnum2;
 	int saved_use_oplocks = use_oplocks;
 	char buf[4];
@@ -2309,7 +2309,7 @@
 static BOOL run_oplock3(int dummy)
 {
 	static struct cli_state cli;
-	char *fname = "\\oplockt3.dat";
+	const char *fname = "\\oplockt3.dat";
 	int fnum;
 	char buf[4] = "abcd";
 	BOOL correct = True;
@@ -2364,7 +2364,7 @@
 {
 	static struct cli_state cli1;
 	static struct cli_state cli2;
-	char *fname = "\\delete.file";
+	const char *fname = "\\delete.file";
 	int fnum1 = -1;
 	int fnum2 = -1;
 	BOOL correct = True;
@@ -2843,7 +2843,7 @@
 static BOOL run_xcopy(int dummy)
 {
 	static struct cli_state cli1;
-	char *fname = "\\test.txt";
+	const char *fname = "\\test.txt";
 	BOOL correct = True;
 	int fnum1, fnum2;
 
@@ -2885,8 +2885,8 @@
 static BOOL run_rename(int dummy)
 {
 	static struct cli_state cli1;
-	char *fname = "\\test.txt";
-	char *fname1 = "\\test1.txt";
+	const char *fname = "\\test.txt";
+	const char *fname1 = "\\test1.txt";
 	BOOL correct = True;
 	int fnum1;
 
@@ -3004,7 +3004,7 @@
 static BOOL run_pipe_number(int dummy)
 {
 	static struct cli_state cli1;
-	char *pipe_name = "\\SPOOLSS";
+	const char *pipe_name = "\\SPOOLSS";
 	int fnum;
 	int num_pipes = 0;
 
@@ -3037,7 +3037,7 @@
 {
 	static struct cli_state cli1;
 	static struct cli_state cli2;
-	char *fname = "\\readonly.file";
+	const char *fname = "\\readonly.file";
 	int fnum1, fnum2;
 	char buf[20];
 	size_t fsize;
@@ -3884,7 +3884,7 @@
 #define FLAG_MULTIPROC 1
 
 static struct {
-	char *name;
+	const char *name;
 	BOOL (*fn)(int);
 	unsigned flags;
 } torture_ops[] = {
@@ -3935,7 +3935,7 @@
 /****************************************************************************
 run a specified test or "ALL"
 ****************************************************************************/
-static BOOL run_test(char *name)
+static BOOL run_test(const char *name)
 {
 	BOOL ret = True;
 	BOOL result = True;
@@ -4055,7 +4055,7 @@
 	get_myname(myname);
 
 	if (*username == 0 && getenv("LOGNAME")) {
-	  pstrcpy(username,getenv("LOGNAME"));
+	  fstrcpy(username,getenv("LOGNAME"));
 	}
 
 	argc--;
@@ -4110,11 +4110,11 @@
 #endif
 			break;
 		case 'U':
-			pstrcpy(username,optarg);
+			fstrcpy(username,optarg);
 			p = strchr_m(username,'%');
 			if (p) {
 				*p = 0;
-				pstrcpy(password, p+1);
+				fstrcpy(password, p+1);
 				gotpass = 1;
 			}
 			break;
@@ -4128,7 +4128,7 @@
 	while (!gotpass) {
 		p = getpass("Password:");
 		if (p) {
-			pstrcpy(password, p);
+			fstrcpy(password, p);
 			gotpass = 1;
 		}
 	}
diff -uNr samba-3.0alpha21.orig/source/torture/vfstest.c samba-3.0alpha21/source/torture/vfstest.c
--- samba-3.0alpha21.orig/source/torture/vfstest.c	2003-02-16 19:06:33.000000000 -0600
+++ samba-3.0alpha21/source/torture/vfstest.c	2003-02-16 19:05:47.000000000 -0600
@@ -304,7 +304,7 @@
 
 		if (mem_ctx == NULL) {
 			/* Create mem_ctx */
-			if (!(mem_ctx = talloc_init())) {
+			if (!(mem_ctx = talloc_init("do_cmd"))) {
 		       		DEBUG(0, ("talloc_init() failed\n"));
 				goto done;
 			}
@@ -403,7 +403,7 @@
 	}
 }
 
-void exit_server(char *reason)
+void exit_server(const char *reason)
 {
 	DEBUG(3,("Server exit (%s)\n", (reason ? reason : "")));
 	exit(0);
@@ -484,7 +484,7 @@
 	extern BOOL 		AllowDebugChange;
 	static struct vfs_state vfs;
 	int i;
-	static char		*filename = "";
+	static const char	*filename = "";
 
 	/* make sure the vars that get altered (4th field) are in
 	   a fixed location or certain compilers complain */
diff -uNr samba-3.0alpha21.orig/source/torture/vfstest.h samba-3.0alpha21/source/torture/vfstest.h
--- samba-3.0alpha21.orig/source/torture/vfstest.h	2003-02-16 19:06:33.000000000 -0600
+++ samba-3.0alpha21/source/torture/vfstest.h	2003-02-16 19:05:47.000000000 -0600
@@ -37,9 +37,9 @@
 };
 
 struct cmd_set {
-	char *name;
+	const char *name;
 	NTSTATUS (*fn)(struct vfs_state *vfs, TALLOC_CTX *mem_ctx, int argc, 
                        char **argv);
-	char *description;
-	char *usage;
+	const char *description;
+	const char *usage;
 };
diff -uNr samba-3.0alpha21.orig/source/ubiqx/debugparse.c samba-3.0alpha21/source/ubiqx/debugparse.c
--- samba-3.0alpha21.orig/source/ubiqx/debugparse.c	2003-02-16 19:06:33.000000000 -0600
+++ samba-3.0alpha21/source/ubiqx/debugparse.c	2003-02-16 19:05:47.000000000 -0600
@@ -45,7 +45,7 @@
  * Functions...
  */
 
-char *dbg_token2string( dbg_Token tok )
+const char *dbg_token2string( dbg_Token tok )
   /* ------------------------------------------------------------------------ **
    * Given a token, return a string describing the token.
    *
diff -uNr samba-3.0alpha21.orig/source/ubiqx/debugparse.h samba-3.0alpha21/source/ubiqx/debugparse.h
--- samba-3.0alpha21.orig/source/ubiqx/debugparse.h	2003-02-16 19:06:33.000000000 -0600
+++ samba-3.0alpha21/source/ubiqx/debugparse.h	2003-02-16 19:05:47.000000000 -0600
@@ -62,7 +62,7 @@
  * Function prototypes...
  */
 
- char *dbg_token2string( dbg_Token tok );
+ const char *dbg_token2string( dbg_Token tok );
   /* ------------------------------------------------------------------------ **
    * Given a token, return a string describing the token.
    *
diff -uNr samba-3.0alpha21.orig/source/utils/net.c samba-3.0alpha21/source/utils/net.c
--- samba-3.0alpha21.orig/source/utils/net.c	2003-02-16 19:06:34.000000000 -0600
+++ samba-3.0alpha21/source/utils/net.c	2003-02-16 19:05:47.000000000 -0600
@@ -56,10 +56,10 @@
 /************************************************************************************/
 
 /* Yes, these buggers are globals.... */
-char *opt_requester_name = NULL;
-char *opt_host = NULL; 
-char *opt_password = NULL;
-char *opt_user_name = NULL;
+const char *opt_requester_name = NULL;
+const char *opt_host = NULL; 
+const char *opt_password = NULL;
+const char *opt_user_name = NULL;
 BOOL opt_user_specified = False;
 const char *opt_workgroup = NULL;
 int opt_long_list_entries = 0;
@@ -67,11 +67,12 @@
 int opt_force = 0;
 int opt_port = 0;
 int opt_maxusers = -1;
-char *opt_comment = "";
+const char *opt_comment = "";
+char *opt_container = "cn=Users";
 int opt_flags = -1;
 int opt_jobid = 0;
 int opt_timeout = 0;
-char *opt_target_workgroup = NULL;
+const char *opt_target_workgroup = NULL;
 static int opt_machine_pass = 0;
 
 BOOL opt_have_ip = False;
@@ -389,6 +390,84 @@
 	return 0;
 }
 
+static uint32 get_maxrid(void)
+{
+	SAM_ACCOUNT *pwd = NULL;
+	uint32 max_rid = 0;
+	GROUP_MAP *map = NULL;
+	int num_entries = 0;
+	int i;
+
+	if (!pdb_setsampwent(False)) {
+		DEBUG(0, ("load_sampwd_entries: Unable to open passdb.\n"));
+		return 0;
+	}
+
+	for (; (NT_STATUS_IS_OK(pdb_init_sam(&pwd))) 
+		     && pdb_getsampwent(pwd) == True; pwd=NULL) {
+		uint32 rid;
+
+		if (!sid_peek_rid(pdb_get_user_sid(pwd), &rid)) {
+			DEBUG(0, ("can't get RID for user '%s'\n",
+				  pdb_get_username(pwd)));
+			pdb_free_sam(&pwd);
+			continue;
+		}
+
+		if (rid > max_rid)
+			max_rid = rid;
+
+		DEBUG(1,("%d is user '%s'\n", rid, pdb_get_username(pwd)));
+		pdb_free_sam(&pwd);
+	}
+
+	pdb_endsampwent();
+	pdb_free_sam(&pwd);
+
+	if (!pdb_enum_group_mapping(SID_NAME_UNKNOWN, &map, &num_entries,
+				    ENUM_ONLY_MAPPED, MAPPING_WITHOUT_PRIV))
+		return max_rid;
+
+	for (i = 0; i < num_entries; i++) {
+		uint32 rid;
+
+		if (!sid_peek_check_rid(get_global_sam_sid(), &map[i].sid,
+					&rid)) {
+			DEBUG(3, ("skipping map for group '%s', SID %s\n",
+				  map[i].nt_name,
+				  sid_string_static(&map[i].sid)));
+			continue;
+		}
+		DEBUG(1,("%d is group '%s'\n", rid, map[i].nt_name));
+
+		if (rid > max_rid)
+			max_rid = rid;
+	}
+
+	SAFE_FREE(map);
+
+	return max_rid;
+}
+
+static int net_maxrid(int argc, const char **argv)
+{
+	uint32 rid;
+
+	if (argc != 0) {
+	        DEBUG(0, ("usage: net initrid\n"));
+		return 1;
+	}
+
+	if ((rid = get_maxrid()) == 0) {
+		DEBUG(0, ("can't get current maximum rid\n"));
+		return 1;
+	}
+
+	d_printf("Currently used maximum rid: %d\n", rid);
+
+	return 0;
+}
+
 /* main function table */
 static struct functable net_func[] = {
 	{"RPC", net_rpc},
@@ -416,6 +495,7 @@
 	{"GETLOCALSID", net_getlocalsid},
 	{"SETLOCALSID", net_setlocalsid},
 	{"GETDOMAINSID", net_getdomainsid},
+	{"MAXRID", net_maxrid},
 
 	{"HELP", net_help},
 	{NULL, NULL}
@@ -446,6 +526,7 @@
 		{"myname",	'n', POPT_ARG_STRING, &opt_requester_name},
 		{"conf",	's', POPT_ARG_STRING, &servicesf},
 		{"server",	'S', POPT_ARG_STRING, &opt_host},
+		{"container",	'c', POPT_ARG_STRING, &opt_container},
 		{"comment",	'C', POPT_ARG_STRING, &opt_comment},
 		{"maxusers",	'M', POPT_ARG_INT,    &opt_maxusers},
 		{"flags",	'F', POPT_ARG_INT,    &opt_flags},
@@ -455,7 +536,7 @@
 		{"force",	'f', POPT_ARG_NONE,   &opt_force},
 		{"timeout",	't', POPT_ARG_INT,    &opt_timeout},
 		{"machine-pass",'P', POPT_ARG_NONE,   &opt_machine_pass},
-		{"debuglevel",  'D', POPT_ARG_STRING, &debuglevel},
+		{"debuglevel",  'd', POPT_ARG_STRING, &debuglevel},
 		{ 0, 0, 0, 0}
 	};
 
@@ -489,7 +570,8 @@
 			}
 			break;
 		default:
-			d_printf("\nInvalid option %c (%d)\n", (char)opt, opt);
+			d_printf("\nInvalid option %s: %s\n", 
+				 poptBadOption(pc, 0), poptStrerror(opt));
 			net_help(argc, argv);
 			exit(1);
 		}
@@ -536,6 +618,7 @@
 	load_interfaces();
 
 	if (opt_machine_pass) {
+		char *user;
 		/* it is very useful to be able to make ads queries as the
 		   machine account for testing purposes and for domain leave */
 
@@ -544,7 +627,8 @@
 			exit(1);
 		}
 
-		asprintf(&opt_user_name,"%s$", global_myname());
+		asprintf(&user,"%s$", global_myname());
+		opt_user_name = user;
 		opt_password = secrets_fetch_machine_password();
 		if (!opt_password) {
 			d_printf("ERROR: Unable to fetch machine password\n");
diff -uNr samba-3.0alpha21.orig/source/utils/net.h samba-3.0alpha21/source/utils/net.h
--- samba-3.0alpha21.orig/source/utils/net.h	2003-02-16 19:06:34.000000000 -0600
+++ samba-3.0alpha21/source/utils/net.h	2003-02-16 19:05:47.000000000 -0600
@@ -37,20 +37,25 @@
 
 
 extern int opt_maxusers;
-extern char *opt_comment;
+extern const char *opt_comment;
+extern char *opt_container;
 extern int opt_flags;
 
-extern char *opt_comment;
+extern const char *opt_comment;
 
-extern char *opt_target_workgroup;
+extern const char *opt_target_workgroup;
+extern const char *opt_workgroup;
 extern int opt_long_list_entries;
 extern int opt_reboot;
 extern int opt_force;
 extern int opt_timeout;
-extern char *opt_host;
-extern char *opt_user_name;
-extern char *opt_password;
+extern const char *opt_host;
+extern const char *opt_user_name;
+extern const char *opt_password;
 extern BOOL opt_user_specified;
 
+extern BOOL opt_have_ip;
+extern struct in_addr opt_dest_ip;
+
 extern const char *share_type[];
 
diff -uNr samba-3.0alpha21.orig/source/utils/net_ads.c samba-3.0alpha21/source/utils/net_ads.c
--- samba-3.0alpha21.orig/source/utils/net_ads.c	2003-02-16 19:06:34.000000000 -0600
+++ samba-3.0alpha21/source/utils/net_ads.c	2003-02-16 19:05:47.000000000 -0600
@@ -42,6 +42,8 @@
 "\n\tshows some info on the server\n"\
 "\nnet ads status"\
 "\n\tdump the machine account details to stdout\n"
+"\nnet ads lookup"\
+"\n\tperform a CLDAP search on the server\n"
 "\nnet ads password <username@realm> -Uadmin_username@realm%%admin_pass"\
 "\n\tchange a user's password using an admin account"\
 "\n\t(note: use realm in UPPERCASE)\n"\
@@ -180,7 +182,7 @@
 
 	if (!(ads = ads_startup())) return -1;
 
-	if (!(ctx = talloc_init_named("net_ads_workgroup"))) {
+	if (!(ctx = talloc_init("net_ads_workgroup"))) {
 		return -1;
 	}
 
@@ -255,7 +257,7 @@
 		goto done;
 	}
 
-	status = ads_add_user_acct(ads, argv[0], opt_comment);
+	status = ads_add_user_acct(ads, argv[0], opt_container, opt_comment);
 
 	if (!ADS_ERR_OK(status)) {
 		d_printf("Could not add user %s: %s\n", argv[0],
@@ -306,12 +308,18 @@
 	const char *attrs[] = {"memberOf", NULL};
 	char *searchstring=NULL;
 	char **grouplist;
+	char *escaped_user = escape_ldap_string_alloc(argv[0]);
 
 	if (argc < 1) return net_ads_user_usage(argc, argv);
 	
 	if (!(ads = ads_startup())) return -1;
 
-	asprintf(&searchstring, "(sAMAccountName=%s)", argv[0]);
+	if (!escaped_user) {
+		d_printf("ads_user_info: failed to escape user %s\n", argv[0]);
+		return -1;
+	}
+
+	asprintf(&searchstring, "(sAMAccountName=%s)", escaped_user);
 	rc = ads_search(ads, &res, searchstring, attrs);
 	safe_free(searchstring);
 
@@ -431,7 +439,7 @@
 		goto done;
 	}
 
-	status = ads_add_group_acct(ads, argv[0], opt_comment);
+	status = ads_add_group_acct(ads, argv[0], opt_container, opt_comment);
 
 	if (ADS_ERR_OK(status)) {
 		d_printf("Group %s added\n", argv[0]);
@@ -544,8 +552,10 @@
 	}
 
 	if (!opt_password) {
-		asprintf(&opt_user_name, "%s$", global_myname());
+		char *user_name;
+		asprintf(&user_name, "%s$", global_myname());
 		opt_password = secrets_fetch_machine_password();
+		opt_user_name = user_name;
 	}
 
 	if (!(ads = ads_startup())) {
@@ -566,6 +576,7 @@
 
 static int net_ads_join_ok(void)
 {
+	char *user_name;
 	ADS_STRUCT *ads = NULL;
 
 	if (!secrets_init()) {
@@ -573,7 +584,8 @@
 		return -1;
 	}
 
-	asprintf(&opt_user_name, "%s$", global_myname());
+	asprintf(&user_name, "%s$", global_myname());
+	opt_user_name = user_name;
 	opt_password = secrets_fetch_machine_password();
 
 	if (!(ads = ads_startup())) {
@@ -743,12 +755,11 @@
 {
         ADS_STRUCT *ads;
         ADS_STATUS rc;
-	char *servername;
+	const char *servername;
 	struct cli_state *cli;
 	struct in_addr 		server_ip;
 	NTSTATUS nt_status;
-	extern char *opt_workgroup;
-	TALLOC_CTX *mem_ctx = talloc_init();
+	TALLOC_CTX *mem_ctx = talloc_init("net_ads_printer_publish");
 	ADS_MODLIST mods = ads_init_mods(mem_ctx);
 	char *prt_dn, *srv_dn, **srv_cn;
 	void *res = NULL;
@@ -853,8 +864,8 @@
 static int net_ads_password(int argc, const char **argv)
 {
     ADS_STRUCT *ads;
-    char *auth_principal = opt_user_name;
-    char *auth_password = opt_password;
+    const char *auth_principal = opt_user_name;
+    const char *auth_password = opt_password;
     char *realm = NULL;
     char *new_password = NULL;
     char *c;
@@ -902,13 +913,16 @@
     char *host_principal;
     char *hostname;
     ADS_STATUS ret;
+    char *user_name;
 
     if (!secrets_init()) {
 	    DEBUG(1,("Failed to initialise secrets database\n"));
 	    return -1;
     }
 
-    asprintf(&opt_user_name, "%s$", global_myname());
+    asprintf(&user_name, "%s$", global_myname());
+    opt_user_name = user_name;
+
     opt_password = secrets_fetch_machine_password();
 
     if (!(ads = ads_startup())) {
diff -uNr samba-3.0alpha21.orig/source/utils/net_cache.c samba-3.0alpha21/source/utils/net_cache.c
--- samba-3.0alpha21.orig/source/utils/net_cache.c	2003-02-16 19:06:34.000000000 -0600
+++ samba-3.0alpha21/source/utils/net_cache.c	2003-02-16 19:05:47.000000000 -0600
@@ -34,15 +34,34 @@
  * (print_cache_entry) and to flush it (delete_cache_entry).
  * Both of them are defined by first arg of gencache_iterate() routine.
  */
-static void print_cache_entry(const char* keystr, const char* datastr, const time_t timeout)
+static void print_cache_entry(const char* keystr, const char* datastr,
+                              const time_t timeout, void* dptr)
 {
-	char* timeout_str = ctime(&timeout);
-	timeout_str[strlen(timeout_str) - 1] = '\0';
-	d_printf("Key: %s\t\t Value: %s\t\t Timeout: %s %s\n", keystr, datastr,
-	         timeout_str, timeout > time(NULL) ? "": "(expired)");
+	char* timeout_str;
+	time_t now_t = time(NULL);
+	struct tm timeout_tm, *now_tm;
+	/* localtime returns statically allocated pointer, so timeout_tm
+	   has to be copied somewhere else */
+	memcpy(&timeout_tm, localtime(&timeout), sizeof(struct tm));
+	now_tm = localtime(&now_t);
+
+	/* form up timeout string depending whether it's today's date or not */
+	if (timeout_tm.tm_year != now_tm->tm_year ||
+	    timeout_tm.tm_mon != now_tm->tm_mon ||
+	    timeout_tm.tm_mday != now_tm->tm_mday) {
+	    
+	    timeout_str = asctime(&timeout_tm);
+	    timeout_str[strlen(timeout_str) - 1] = '\0';	/* remove tailing CR */
+	} else
+		asprintf(&timeout_str, "%.2d:%.2d:%.2d", timeout_tm.tm_hour,
+		         timeout_tm.tm_min, timeout_tm.tm_sec);
+	
+	d_printf("Key: %s\t Timeout: %s\t Value: %s  %s\n", keystr,
+	         timeout_str, datastr, timeout > now_t ? "": "(expired)");
 }
 
-static void delete_cache_entry(const char* keystr, const char* datastr, const time_t timeout)
+static void delete_cache_entry(const char* keystr, const char* datastr,
+                               const time_t timeout, void* dptr)
 {
 	if (!gencache_del(keystr))
 		d_printf("Couldn't delete entry! key = %s", keystr);
@@ -106,7 +125,7 @@
 
 
 /**
- * Add an entry to the cache
+ * Add an entry to the cache. If it does exist, then set it.
  * 
  * @param argv key, value and timeout are passed in command line
  * @return 0 on success, otherwise failure
@@ -132,12 +151,12 @@
 		return -1;
 	}
 	
-	if (gencache_add(keystr, datastr, timeout)) {
+	if (gencache_set(keystr, datastr, timeout)) {
 		d_printf("New cache entry stored successfully.\n");
 		gencache_shutdown();
 		return 0;
-	} 
-
+	}
+	
 	d_printf("Entry couldn't be added. Perhaps there's already such a key.\n");
 	gencache_shutdown();
 	return -1;
@@ -145,7 +164,8 @@
 
 
 /**
- * Set new value of an existing entry in the cache
+ * Set new value of an existing entry in the cache. Fail If the entry doesn't
+ * exist.
  * 
  * @param argv key being searched and new value and timeout to set in the entry
  * @return 0 on success, otherwise failure
@@ -171,7 +191,7 @@
 		return -1;
 	}
 	
-	if (gencache_set(keystr, datastr, timeout)) {
+	if (gencache_set_only(keystr, datastr, timeout)) {
 		d_printf("Cache entry set successfully.\n");
 		gencache_shutdown();
 		return 0;
@@ -201,7 +221,7 @@
 	if(gencache_del(keystr)) {
 		d_printf("Entry deleted.\n");
 		return 0;
-	} 
+	}
 
 	d_printf("Couldn't delete specified entry\n");
 	return -1;
@@ -226,9 +246,9 @@
 	}
 	
 	if (gencache_get(keystr, &valuestr, &timeout)) {
-		print_cache_entry(keystr, valuestr, timeout);
+		print_cache_entry(keystr, valuestr, timeout, NULL);
 		return 0;
-	} 
+	}
 
 	d_printf("Failed to find entry\n");
 	return -1;
@@ -251,7 +271,7 @@
 	}
 	
 	pattern = argv[0];
-	gencache_iterate(print_cache_entry, pattern);
+	gencache_iterate(print_cache_entry, NULL, pattern);
 	return 0;
 }
 
@@ -265,7 +285,7 @@
 static int net_cache_list(int argc, const char **argv)
 {
 	const char* pattern = "*";
-	gencache_iterate(print_cache_entry, pattern);
+	gencache_iterate(print_cache_entry, NULL, pattern);
 	gencache_shutdown();
 	return 0;
 }
@@ -280,7 +300,7 @@
 static int net_cache_flush(int argc, const char **argv)
 {
 	const char* pattern = "*";
-	gencache_iterate(delete_cache_entry, pattern);
+	gencache_iterate(delete_cache_entry, NULL, pattern);
 	gencache_shutdown();
 	return 0;
 }
diff -uNr samba-3.0alpha21.orig/source/utils/net_help.c samba-3.0alpha21/source/utils/net_help.c
--- samba-3.0alpha21.orig/source/utils/net_help.c	2003-02-16 19:06:34.000000000 -0600
+++ samba-3.0alpha21/source/utils/net_help.c	2003-02-16 19:05:47.000000000 -0600
@@ -70,14 +70,14 @@
 		 "\n\tDelete specified user\n");
 	d_printf("\nnet [<method>] user INFO <name> [misc. options] [targets]"\
 		 "\n\tList the domain groups of the specified user\n");
-	d_printf("\nnet [<method>] user ADD <name> [password] "\
+	d_printf("\nnet [<method>] user ADD <name> [password] [-c container] "\
 		 "[-F user flags] [misc. options]"\
 		 " [targets]\n\tAdd specified user\n");
 
 	net_common_methods_usage(argc, argv);
 	net_common_flags_usage(argc, argv);
-	d_printf(
-	 "\t-C or --comment=<comment>\tdescriptive comment (for add only)\n");
+	d_printf("\t-C or --comment=<comment>\tdescriptive comment (for add only)\n");
+	d_printf("\t-c or --container=<container>\tLDAP container, defaults to cn=Users (for add in ADS only)\n");
 	return -1;
 }
 
@@ -88,12 +88,12 @@
 	d_printf("net [<method>] group DELETE <name> "\
 		 "[misc. options] [targets]"\
 		 "\n\tDelete specified group\n");
-	d_printf("\nnet [<method>] group ADD <name> [-C comment]"\
+	d_printf("\nnet [<method>] group ADD <name> [-C comment] [-c container]"\
 		 " [misc. options] [targets]\n\tCreate specified group\n");
 	net_common_methods_usage(argc, argv);
 	net_common_flags_usage(argc, argv);
-	d_printf(
-	 "\t-C or --comment=<comment>\tdescriptive comment (for add only)\n");
+	d_printf("\t-C or --comment=<comment>\tdescriptive comment (for add only)\n");
+	d_printf("\t-c or --container=<container>\tLDAP container, defaults to cn=Users (for add in ADS only)\n");
 	return -1;
 }
 
diff -uNr samba-3.0alpha21.orig/source/utils/net_rap.c samba-3.0alpha21/source/utils/net_rap.c
--- samba-3.0alpha21.orig/source/utils/net_rap.c	2003-02-16 19:06:34.000000000 -0600
+++ samba-3.0alpha21/source/utils/net_rap.c	2003-02-16 19:05:47.000000000 -0600
@@ -204,7 +204,7 @@
 	strlcpy(sinfo.share_name, sharename, sizeof(sinfo.share_name));
 	sinfo.reserved1 = '\0';
 	sinfo.share_type = 0;
-	sinfo.comment = opt_comment;
+	sinfo.comment = smb_xstrdup(opt_comment);
 	sinfo.perms = 0;
 	sinfo.maximum_users = opt_maxusers;
 	sinfo.active_users = 0;
@@ -644,7 +644,7 @@
 			
 	userinfo.userflags = opt_flags;
 	userinfo.reserved1 = '\0';
-	userinfo.comment = opt_comment;
+	userinfo.comment = smb_xstrdup(opt_comment);
 	userinfo.priv = 1; 
 	userinfo.home_dir = NULL;
 	userinfo.logon_script = NULL;
@@ -757,7 +757,7 @@
 	/* BB check for length 21 or smaller explicitly ? BB */
 	safe_strcpy(grinfo.group_name, argv[0], sizeof(grinfo.group_name));
 	grinfo.reserved1 = '\0';
-	grinfo.comment = opt_comment;
+	grinfo.comment = smb_xstrdup(opt_comment);
 	
 	ret = cli_NetGroupAdd(cli, &grinfo);
 	cli_shutdown(cli);
diff -uNr samba-3.0alpha21.orig/source/utils/net_rpc.c samba-3.0alpha21/source/utils/net_rpc.c
--- samba-3.0alpha21.orig/source/utils/net_rpc.c	2003-02-16 19:06:34.000000000 -0600
+++ samba-3.0alpha21/source/utils/net_rpc.c	2003-02-16 19:05:47.000000000 -0600
@@ -62,7 +62,7 @@
 		goto error;
 	}
 	    
-	if (!(mem_ctx=talloc_init()))
+	if (!(mem_ctx=talloc_init("net_get_remote_domain_sid")))
 	{
 		DEBUG(0,("net_get_remote_domain_sid: talloc_init returned NULL!\n"));
 		goto error;
@@ -138,7 +138,7 @@
 
 	/* Create mem_ctx */
 	
-	if (!(mem_ctx = talloc_init())) {
+	if (!(mem_ctx = talloc_init("run_rpc_command"))) {
 		DEBUG(0, ("talloc_init() failed\n"));
 		cli_shutdown(cli);
 		return -1;
@@ -374,7 +374,7 @@
 	result = cli_samr_query_dom_info(cli, mem_ctx, &domain_pol,
 					 2, &ctr);
 	if (NT_STATUS_IS_OK(result)) {
-		TALLOC_CTX *ctx = talloc_init();
+		TALLOC_CTX *ctx = talloc_init("rpc_info_internals");
 		d_printf("Domain Name: %s\n", unistr2_tdup(ctx, &ctr.info.inf2.uni_domain));
 		d_printf("Domain SID: %s\n", sid_str);
 		d_printf("Sequence number: %u\n", ctr.info.inf2.seq_num);
@@ -779,7 +779,7 @@
 {
 	POLICY_HND connect_pol, domain_pol;
 	NTSTATUS result = NT_STATUS_UNSUCCESSFUL;
-	uint32 start_idx=0, max_entries=250, num_entries, i;
+	uint32 start_idx=0, num_entries, i, loop_count = 0;
 	SAM_DISPINFO_CTR ctr;
 	SAM_DISPINFO_1 info1;
 
@@ -809,9 +809,16 @@
 			 "\n-----------------------------\n");
 	do {
 		fstring user, desc;
+		uint32 max_entries, max_size;
+
+		get_query_dispinfo_params(
+			loop_count, &max_entries, &max_size);
+
 		result = cli_samr_query_dispinfo(cli, mem_ctx, &domain_pol,
 						 &start_idx, 1, &num_entries,
-						 max_entries, &ctr);
+						 max_entries, max_size, &ctr);
+		loop_count++;
+
 		for (i = 0; i < num_entries; i++) {
 			unistr2_to_ascii(user, &(&ctr.sam.info1->str[i])->uni_acct_name, sizeof(user)-1);
 			if (opt_long_list_entries) 
@@ -1442,11 +1449,8 @@
 				       int argc, const char **argv) 
 {
 	NTSTATUS result = NT_STATUS_UNSUCCESSFUL;
-        char *msg = "This machine will be shutdown shortly";
+        const char *msg = "This machine will be shutdown shortly";
 	uint32 timeout = 20;
-	uint16 flgs = 0;
-	BOOL reboot = opt_reboot;
-	BOOL force = opt_force;
 #if 0
 	poptContext pc;
 	int rc;
@@ -1472,12 +1476,6 @@
 		return NT_STATUS_INVALID_PARAMETER;
 	}
 #endif
-	if (reboot) {
-		flgs |= REG_REBOOT_ON_SHUTDOWN;
-	}
-	if (force) {
-		flgs |= REG_FORCE_SHUTDOWN;
-	}
 	if (opt_comment) {
 		msg = opt_comment;
 	}
@@ -1486,7 +1484,7 @@
 	}
 
 	/* create an entry */
-	result = cli_reg_shutdown(cli, mem_ctx, msg, timeout, flgs);
+	result = cli_reg_shutdown(cli, mem_ctx, msg, timeout, opt_reboot, opt_force);
 
 	if (NT_STATUS_IS_OK(result))
 		DEBUG(5,("Shutdown of remote machine succeeded\n"));
@@ -1630,10 +1628,6 @@
  * @return Integer status (0 means success)
  **/
 
-extern char *opt_user_name;
-extern char *opt_password;
-extern char *opt_workgroup;
-
 static int rpc_trustdom_establish(int argc, const char **argv)
 {
 	struct cli_state *cli;
@@ -1659,19 +1653,19 @@
 
 	domain_name = smb_xstrdup(argv[0]);
 	strupper(domain_name);
+
+	/* account name used at first is our domain's name with '$' */
+	asprintf(&acct_name, "%s$", lp_workgroup());
+	strupper(acct_name);
 	
 	/*
 	 * opt_workgroup will be used by connection functions further,
 	 * hence it should be set to remote domain name instead of ours
 	 */
 	if (opt_workgroup) {
-		SAFE_FREE(opt_workgroup);
 		opt_workgroup = smb_xstrdup(domain_name);
 	};
 	
-	asprintf(&acct_name, "%s$", lp_workgroup());
-	strupper(acct_name);
-	
 	opt_user_name = acct_name;
 
 	/* find the domain controller */
@@ -1720,7 +1714,7 @@
 		return -1;
 	}
 
-	if (!(mem_ctx = talloc_init_named("establishing trust relationship to domain %s",
+	if (!(mem_ctx = talloc_init("establishing trust relationship to domain %s",
 	                domain_name))) {
 		DEBUG(0, ("talloc_init() failed\n"));
 		cli_shutdown(cli);
@@ -1742,7 +1736,7 @@
 	 * Call LsaOpenPolicy and LsaQueryInfo
 	 */
 	 
-	if (!(mem_ctx = talloc_init())) {
+	if (!(mem_ctx = talloc_init("rpc_trustdom_establish"))) {
 		DEBUG(0, ("talloc_init() failed\n"));
 		cli_shutdown(cli);
 		return -1;
@@ -1869,18 +1863,13 @@
 };
 
 
-extern char* opt_workgroup;
-extern char* opt_target_worgroup;
-extern char* opt_host;
-extern char* opt_password;
-
 static int rpc_trustdom_list(int argc, const char **argv)
 {
 	/* common variables */
 	TALLOC_CTX* mem_ctx;
 	struct cli_state *cli, *remote_cli;
 	NTSTATUS nt_status;
-	char *domain_name = NULL;
+	const char *domain_name = NULL;
 	DOM_SID queried_dom_sid;
 	fstring ascii_sid, padding;
 	int ascii_dom_name_len;
@@ -1902,21 +1891,19 @@
 	 * Listing trusted domains (stored in secrets.tdb, if local)
 	 */
 
-	mem_ctx = talloc_init_named("trust relationships listing");
+	mem_ctx = talloc_init("trust relationships listing");
 
 	/*
 	 * set domain and pdc name to local samba server (default)
 	 * or to remote one given in command line
 	 */
-	strupper(opt_workgroup);
-	if (strcmp(opt_workgroup, lp_workgroup())) {
+	
+	if (StrCaseCmp(opt_workgroup, lp_workgroup())) {
 		domain_name = opt_workgroup;
-		if (opt_target_workgroup) SAFE_FREE(opt_target_workgroup);
 		opt_target_workgroup = opt_workgroup;
 	} else {
-		safe_strcpy(pdc_name, global_myname(), FSTRING_LEN);
+		fstrcpy(pdc_name, global_myname());
 		domain_name = talloc_strdup(mem_ctx, lp_workgroup());
-		if (opt_target_workgroup) SAFE_FREE(opt_target_workgroup);
 		opt_target_workgroup = domain_name;
 	};
 
@@ -2068,7 +2055,6 @@
 			/* set opt_* variables to remote domain */
 			strupper(trusting_dom_names[i]);
 			opt_workgroup = talloc_strdup(mem_ctx, trusting_dom_names[i]);
-			if (opt_target_workgroup) SAFE_FREE(opt_target_workgroup);
 			opt_target_workgroup = opt_workgroup;
 			
 			d_printf("%s%s", trusting_dom_names[i], padding);
diff -uNr samba-3.0alpha21.orig/source/utils/net_rpc_join.c samba-3.0alpha21/source/utils/net_rpc_join.c
--- samba-3.0alpha21.orig/source/utils/net_rpc_join.c	2003-02-16 19:06:34.000000000 -0600
+++ samba-3.0alpha21/source/utils/net_rpc_join.c	2003-02-16 19:05:47.000000000 -0600
@@ -141,7 +141,7 @@
 	if (!(cli = net_make_ipc_connection(NET_FLAGS_PDC))) 
 		return 1;
 
-	if (!(mem_ctx = talloc_init())) {
+	if (!(mem_ctx = talloc_init("net_rpc_join_newstyle"))) {
 		DEBUG(0, ("Could not initialise talloc context\n"));
 		goto done;
 	}
diff -uNr samba-3.0alpha21.orig/source/utils/net_rpc_samsync.c samba-3.0alpha21/source/utils/net_rpc_samsync.c
--- samba-3.0alpha21.orig/source/utils/net_rpc_samsync.c	2003-02-16 19:06:34.000000000 -0600
+++ samba-3.0alpha21/source/utils/net_rpc_samsync.c	2003-02-16 19:05:47.000000000 -0600
@@ -128,7 +128,7 @@
         SAM_DELTA_CTR *deltas;
         uint32 num_deltas;
 
-	if (!(mem_ctx = talloc_init())) {
+	if (!(mem_ctx = talloc_init("dump_database"))) {
 		return;
 	}
 
@@ -287,6 +287,7 @@
 	GROUP_MAP map;
 	struct group *grp;
 	DOM_SID sid;
+	BOOL try_add = False;
 
 	fstrcpy(account, unistr2_static(&delta->uni_acct_name));
 	d_printf("Creating account: %s\n", account);
@@ -295,10 +296,6 @@
 		return nt_ret;
 
 	if (!pdb_getsampwnam(sam_account, account)) {
-		struct passwd *pw;
-
-		pdb_free_sam(&sam_account);
-
 		/* Create appropriate user */
 		if (delta->acb_info & ACB_NORMAL) {
 			pstrcpy(add_script, lp_adduser_script());
@@ -319,29 +316,25 @@
 			DEBUG(1,("fetch_account: Running the command `%s' "
 				 "gave %d\n", add_script, add_ret));
 		}
-		pw = getpwnam_alloc(account);
-		if (pw) {
-			nt_ret = pdb_init_sam_pw(&sam_account, pw);
-
-			if (!NT_STATUS_IS_OK(nt_ret)) {
-				passwd_free(&pw);
-				pdb_free_sam(&sam_account);
-				return nt_ret;
-			}
-			passwd_free(&pw);
-		} else {
-			DEBUG(3, ("Could not create account %s\n", account));
-			pdb_free_sam(&sam_account);
-			return NT_STATUS_NO_SUCH_USER;
+
+		if (!pdb_getsampwnam(sam_account, account)) {
+			try_add = True;
+			/* still not there, hope the backend likes NUAs */
 		}
 	}
 
 	sam_account_from_delta(sam_account, delta);
 
-	if (!pdb_add_sam_account(sam_account)) {
-		DEBUG(1, ("SAM Account for %s already exists, updating\n",
-			  account));
-		pdb_update_sam_account(sam_account);
+	if (try_add) { 
+		if (!pdb_add_sam_account(sam_account)) {
+			DEBUG(1, ("SAM Account for %s failed to be added to the passdb!\n",
+				  account));
+		}
+	} else {
+		if (!pdb_update_sam_account(sam_account)) {
+			DEBUG(1, ("SAM Account for %s failed to be updated in the passdb!\n",
+				  account));
+		}
 	}
 
 	sid = *pdb_get_group_sid(sam_account);
@@ -452,7 +445,7 @@
 
 	d_printf("Group members of %s: ", grp->gr_name);
 
-	if (!(t = talloc_init())) {
+	if (!(t = talloc_init("fetch_group_mem_info"))) {
 		DEBUG(0, ("could not talloc_init\n"));
 		return NT_STATUS_NO_MEMORY;
 	}
@@ -656,7 +649,7 @@
         SAM_DELTA_CTR *deltas;
         uint32 num_deltas;
 
-	if (!(mem_ctx = talloc_init())) {
+	if (!(mem_ctx = talloc_init("fetch_database"))) {
 		return;
 	}
 
diff -uNr samba-3.0alpha21.orig/source/utils/net_time.c samba-3.0alpha21/source/utils/net_time.c
--- samba-3.0alpha21.orig/source/utils/net_time.c	2003-02-16 19:06:34.000000000 -0600
+++ samba-3.0alpha21/source/utils/net_time.c	2003-02-16 19:05:47.000000000 -0600
@@ -65,9 +65,6 @@
 /* find the servers time on the opt_host host */
 static time_t nettime(int *zone)
 {
-	extern BOOL opt_have_ip;
-	extern struct in_addr opt_dest_ip;
-	extern char *opt_host; 
 	return cli_servertime(opt_host, opt_have_ip? &opt_dest_ip : NULL, zone);
 }
 
@@ -155,9 +152,6 @@
 int net_time(int argc, const char **argv)
 {
 	time_t t;
-	extern BOOL opt_have_ip;
-	extern struct in_addr opt_dest_ip;
-	extern char *opt_host; 
 	struct functable func[] = {
 		{"SYSTEM", net_time_system},
 		{"SET", net_time_set},
diff -uNr samba-3.0alpha21.orig/source/utils/nmblookup.c samba-3.0alpha21/source/utils/nmblookup.c
--- samba-3.0alpha21.orig/source/utils/nmblookup.c	2003-02-16 19:06:34.000000000 -0600
+++ samba-3.0alpha21/source/utils/nmblookup.c	2003-02-16 19:05:47.000000000 -0600
@@ -121,7 +121,7 @@
 /****************************************************************************
 do a node status query
 ****************************************************************************/
-static void do_node_status(int fd, char *name, int type, struct in_addr ip)
+static void do_node_status(int fd, const char *name, int type, struct in_addr ip)
 {
 	struct nmb_name nname;
 	int count, i, j;
@@ -150,7 +150,7 @@
 /****************************************************************************
 send out one query
 ****************************************************************************/
-static BOOL query_one(char *lookup, unsigned int lookup_type)
+static BOOL query_one(const char *lookup, unsigned int lookup_type)
 {
 	int j, count, flags = 0;
 	struct in_addr *ip_list=NULL;
@@ -210,7 +210,7 @@
 {
   int opt;
   unsigned int lookup_type = 0x0;
-  pstring lookup;
+  fstring lookup;
   extern int optind;
   extern char *optarg;
   BOOL find_master=False;
diff -uNr samba-3.0alpha21.orig/source/utils/ntlm_auth.c samba-3.0alpha21/source/utils/ntlm_auth.c
--- samba-3.0alpha21.orig/source/utils/ntlm_auth.c	1969-12-31 18:00:00.000000000 -0600
+++ samba-3.0alpha21/source/utils/ntlm_auth.c	2003-02-16 19:05:47.000000000 -0600
@@ -0,0 +1,550 @@
+/* 
+   Unix SMB/CIFS implementation.
+
+   Winbind status program.
+
+   Copyright (C) Tim Potter      2000-2002
+   Copyright (C) Andrew Bartlett 2003
+   Copyright (C) Francesco Chemolli <kinkie@kame.usr.dsi.unimi.it> 2000 
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+   
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+   
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*/
+
+#include "includes.h"
+
+#undef DBGC_CLASS
+#define DBGC_CLASS DBGC_WINBIND
+
+#define SQUID_BUFFER_SIZE 2010
+
+enum squid_mode {
+	SQUID_2_4_BASIC,
+	SQUID_2_5_BASIC,
+	SQUID_2_5_NTLMSSP
+};
+	
+
+extern int winbindd_fd;
+
+static const char *helper_protocol;
+static const char *username;
+static const char *domain;
+static const char *workstation;
+static const char *hex_challenge;
+static const char *hex_lm_response;
+static const char *hex_nt_response;
+static unsigned char *challenge;
+static size_t challenge_len;
+static unsigned char *lm_response;
+static size_t lm_response_len;
+static unsigned char *nt_response;
+static size_t nt_response_len;
+
+static char *password;
+
+static char winbind_separator(void)
+{
+	struct winbindd_response response;
+	static BOOL got_sep;
+	static char sep;
+
+	if (got_sep)
+		return sep;
+
+	ZERO_STRUCT(response);
+
+	/* Send off request */
+
+	if (winbindd_request(WINBINDD_INFO, NULL, &response) !=
+	    NSS_STATUS_SUCCESS) {
+		d_printf("could not obtain winbind separator!\n");
+		return '\\';
+	}
+
+	sep = response.data.info.winbind_separator;
+	got_sep = True;
+
+	if (!sep) {
+		d_printf("winbind separator was NULL!\n");
+		return '\\';
+	}
+	
+	return sep;
+}
+
+static const char *get_winbind_domain(void)
+{
+	struct winbindd_response response;
+
+	static fstring winbind_domain;
+	if (*winbind_domain) {
+		return winbind_domain;
+	}
+
+	ZERO_STRUCT(response);
+
+	/* Send off request */
+
+	if (winbindd_request(WINBINDD_DOMAIN_NAME, NULL, &response) !=
+	    NSS_STATUS_SUCCESS) {
+		d_printf("could not obtain winbind domain name!\n");
+		return NULL;
+	}
+
+	fstrcpy(winbind_domain, response.data.domain_name);
+
+	return winbind_domain;
+
+}
+
+static const char *get_winbind_netbios_name(void)
+{
+	struct winbindd_response response;
+
+	static fstring winbind_netbios_name;
+
+	if (*winbind_netbios_name) {
+		return winbind_netbios_name;
+	}
+
+	ZERO_STRUCT(response);
+
+	/* Send off request */
+
+	if (winbindd_request(WINBINDD_NETBIOS_NAME, NULL, &response) !=
+	    NSS_STATUS_SUCCESS) {
+		d_printf("could not obtain winbind netbios name!\n");
+		return NULL;
+	}
+
+	fstrcpy(winbind_netbios_name, response.data.netbios_name);
+
+	return winbind_netbios_name;
+
+}
+
+/* Authenticate a user with a plaintext password */
+
+static BOOL check_plaintext_auth(const char *user, const char *pass, BOOL stdout_diagnostics)
+{
+	struct winbindd_request request;
+	struct winbindd_response response;
+        NSS_STATUS result;
+
+	/* Send off request */
+
+	ZERO_STRUCT(request);
+	ZERO_STRUCT(response);
+
+	fstrcpy(request.data.auth.user, user);
+	fstrcpy(request.data.auth.pass, pass);
+
+	result = winbindd_request(WINBINDD_PAM_AUTH, &request, &response);
+
+	/* Display response */
+	
+	if (stdout_diagnostics) {
+		if ((result != NSS_STATUS_SUCCESS) && (response.data.auth.nt_status == 0)) {
+			d_printf("Reading winbind reply failed! (0x01)\n");
+		}
+		
+		d_printf("%s (0x%x)\n", 
+			 response.data.auth.nt_status_string, 
+			 response.data.auth.nt_status);
+	} else {
+		if ((result != NSS_STATUS_SUCCESS) && (response.data.auth.nt_status == 0)) {
+			DEBUG(1, ("Reading winbind reply failed! (0x01)\n"));
+		}
+		
+		DEBUG(3, ("%s (0x%x)\n", 
+			 response.data.auth.nt_status_string, 
+			 response.data.auth.nt_status));		
+	}
+		
+        return (result == NSS_STATUS_SUCCESS);
+}
+
+static NTSTATUS winbind_pw_check(struct ntlmssp_state *ntlmssp_state) 
+{
+	struct winbindd_request request;
+	struct winbindd_response response;
+        NSS_STATUS result;
+	/* Send off request */
+
+	ZERO_STRUCT(request);
+	ZERO_STRUCT(response);
+
+	fstrcpy(request.data.auth_crap.user, ntlmssp_state->user);
+
+	fstrcpy(request.data.auth_crap.domain, ntlmssp_state->domain);
+	fstrcpy(request.data.auth_crap.workstation, ntlmssp_state->workstation);
+	
+	memcpy(request.data.auth_crap.chal, ntlmssp_state->chal.data, 
+	       MIN(ntlmssp_state->chal.length, 8));
+
+	memcpy(request.data.auth_crap.lm_resp, ntlmssp_state->lm_resp.data, 
+	       MIN(ntlmssp_state->lm_resp.length, sizeof(request.data.auth_crap.lm_resp)));
+        
+	memcpy(request.data.auth_crap.nt_resp, ntlmssp_state->lm_resp.data,
+	       MIN(ntlmssp_state->nt_resp.length, sizeof(request.data.auth_crap.nt_resp)));
+        
+        request.data.auth_crap.lm_resp_len = ntlmssp_state->lm_resp.length;
+        request.data.auth_crap.nt_resp_len = ntlmssp_state->nt_resp.length;
+
+	result = winbindd_request(WINBINDD_PAM_AUTH_CRAP, &request, &response);
+
+	/* Display response */
+
+	if ((result != NSS_STATUS_SUCCESS) && (response.data.auth.nt_status == 0)) {
+		return NT_STATUS_UNSUCCESSFUL;
+	}
+
+	return NT_STATUS(response.data.auth.nt_status);
+}
+
+static void manage_squid_ntlmssp_request(enum squid_mode squid_mode, 
+					 char *buf, int length) 
+{
+	static NTLMSSP_STATE *ntlmssp_state;
+	DATA_BLOB request, reply;
+	NTSTATUS nt_status;
+
+	if (!ntlmssp_state) {
+		ntlmssp_server_start(&ntlmssp_state);
+		ntlmssp_state->check_password = winbind_pw_check;
+		ntlmssp_state->get_domain = get_winbind_domain;
+		ntlmssp_state->get_global_myname = get_winbind_netbios_name;
+	}
+
+	if (strlen(buf) < 3) {
+		x_fprintf(x_stdout, "BH\n");
+		return;
+	}
+	
+	request = base64_decode_data_blob(buf + 3);
+	
+	DEBUG(0, ("got NTLMSSP packet:\n"));
+	dump_data(0, request.data, request.length);
+
+	nt_status = ntlmssp_server_update(ntlmssp_state, request, &reply);
+	
+	if (NT_STATUS_EQUAL(nt_status, NT_STATUS_MORE_PROCESSING_REQUIRED)) {
+		char *reply_base64 = base64_encode_data_blob(reply);
+		x_fprintf(x_stdout, "TT %s\n", reply_base64);
+		SAFE_FREE(reply_base64);
+		data_blob_free(&reply);
+	} else if (!NT_STATUS_IS_OK(nt_status)) {
+		x_fprintf(x_stdout, "NA %s\n", nt_errstr(nt_status));
+	} else {
+		x_fprintf(x_stdout, "AF %s\\%s\n", ntlmssp_state->domain, ntlmssp_state->user);
+	}
+
+	data_blob_free(&request);
+}
+
+static void manage_squid_basic_request(enum squid_mode squid_mode, 
+				       char *buf, int length) 
+{
+	char *user, *pass;	
+	user=buf;
+	
+	pass=memchr(buf,' ',length);
+	if (!pass) {
+		DEBUG(2, ("Password not found. Denying access\n"));
+		x_fprintf(x_stderr, "ERR\n");
+		return;
+	}
+	*pass='\0';
+	pass++;
+	
+	if (squid_mode == SQUID_2_5_BASIC) {
+		rfc1738_unescape(user);
+		rfc1738_unescape(pass);
+	}
+	
+	if (check_plaintext_auth(user, pass, False)) {
+		x_fprintf(x_stdout, "OK\n");
+	} else {
+		x_fprintf(x_stdout, "ERR\n");
+	}
+}
+
+static void manage_squid_request(enum squid_mode squid_mode) 
+{
+	char buf[SQUID_BUFFER_SIZE+1];
+	int length;
+	char *c;
+	static BOOL err;
+  
+	if (x_fgets(buf, sizeof(buf)-1, x_stdin) == NULL) {
+		DEBUG(1, ("fgets() failed! dying..... errno=%d (%s)\n", errno,
+			  strerror(errno)));
+		exit(1);    /* BIIG buffer */
+	}
+    
+	c=memchr(buf,'\n',sizeof(buf)-1);
+	if (c) {
+		*c = '\0';
+		length = c-buf;
+	} else {
+		err = 1;
+		return;
+	}
+	if (err) {
+		DEBUG(2, ("Oversized message\n"));
+		x_fprintf(x_stderr, "ERR\n");
+		err = 0;
+		return;
+	}
+
+	DEBUG(10, ("Got '%s' from squid (length: %d).\n",buf,length));
+
+	if (buf[0] == '\0') {
+		DEBUG(2, ("Invalid Request\n"));
+		x_fprintf(x_stderr, "ERR\n");
+		return;
+	}
+	
+	if (squid_mode == SQUID_2_5_BASIC || squid_mode == SQUID_2_4_BASIC) {
+		manage_squid_basic_request(squid_mode, buf, length);
+	} else if (squid_mode == SQUID_2_5_NTLMSSP) {
+		manage_squid_ntlmssp_request(squid_mode, buf, length);
+	}
+}
+
+
+static void squid_stream(enum squid_mode squid_mode) {
+	/* initialize FDescs */
+	x_setbuf(x_stdout, NULL);
+	x_setbuf(x_stderr, NULL);
+	while(1) {
+		manage_squid_request(squid_mode);
+	}
+}
+
+
+/* Authenticate a user with a challenge/response */
+
+static BOOL check_auth_crap(void)
+{
+	struct winbindd_request request;
+	struct winbindd_response response;
+        NSS_STATUS result;
+	/* Send off request */
+
+	ZERO_STRUCT(request);
+	ZERO_STRUCT(response);
+
+	fstrcpy(request.data.auth_crap.user, username);
+
+	fstrcpy(request.data.auth_crap.domain, domain);
+	fstrcpy(request.data.auth_crap.workstation, workstation);
+	
+	memcpy(request.data.auth_crap.chal, challenge, MIN(challenge_len, 8));
+
+	memcpy(request.data.auth_crap.lm_resp, lm_response, MIN(lm_response_len, sizeof(request.data.auth_crap.lm_resp)));
+        
+	memcpy(request.data.auth_crap.nt_resp, nt_response, MIN(nt_response_len, sizeof(request.data.auth_crap.nt_resp)));
+        
+        request.data.auth_crap.lm_resp_len = lm_response_len;
+        request.data.auth_crap.nt_resp_len = nt_response_len;
+
+	result = winbindd_request(WINBINDD_PAM_AUTH_CRAP, &request, &response);
+
+	/* Display response */
+
+	if ((result != NSS_STATUS_SUCCESS) && (response.data.auth.nt_status == 0)) {
+		d_printf("Reading winbind reply failed! (0x01)\n");
+	}
+
+	d_printf("%s (0x%x)\n", 
+		 response.data.auth.nt_status_string, 
+		 response.data.auth.nt_status);
+
+        return result == NSS_STATUS_SUCCESS;
+}
+
+/* Main program */
+
+enum {
+	OPT_USERNAME = 1000,
+	OPT_DOMAIN,
+	OPT_WORKSTATION,
+	OPT_CHALLENGE,
+	OPT_RESPONSE,
+	OPT_LM,
+	OPT_NT,
+	OPT_PASSWORD
+};
+
+/*************************************************************
+ Routine to set hex password characters into an allocated array.
+**************************************************************/
+
+static void hex_encode(const unsigned char *buff_in, size_t len, char **out_hex_buffer)
+{
+	int i;
+	char *hex_buffer;
+
+	*out_hex_buffer = smb_xmalloc((len*2)+1);
+	hex_buffer = *out_hex_buffer;
+
+	for (i = 0; i < len; i++)
+		slprintf(&hex_buffer[i*2], 3, "%02X", buff_in[i]);
+}
+
+/*************************************************************
+ Routine to get the 32 hex characters and turn them
+ into a 16 byte array.
+**************************************************************/
+
+static BOOL hex_decode(const char *hex_buf_in, unsigned char **out_buffer, size_t *size)
+{
+	int i;
+	size_t hex_buf_in_len = strlen(hex_buf_in);
+	unsigned char  partial_byte_hex;
+	unsigned char  partial_byte;
+	const char     *hexchars = "0123456789ABCDEF";
+	char           *p;
+	BOOL           high = True;
+	
+	if (!hex_buf_in) 
+		return (False);
+	
+	*size = (hex_buf_in_len + 1) / 2;
+
+	*out_buffer = smb_xmalloc(*size);
+	
+	for (i = 0; i < hex_buf_in_len; i++) {
+		partial_byte_hex = toupper(hex_buf_in[i]);
+
+		p = strchr(hexchars, partial_byte_hex);
+
+		if (!p)
+			return (False);
+
+		partial_byte = PTR_DIFF(p, hexchars);
+
+		if (high) {
+			(*out_buffer)[i / 2] = (partial_byte << 4);
+		} else {
+			(*out_buffer)[i / 2] |= partial_byte;
+		}
+		high = !high;
+	}
+	return (True);
+}
+
+
+int main(int argc, const char **argv)
+{
+	int opt;
+
+	poptContext pc;
+	struct poptOption long_options[] = {
+		POPT_AUTOHELP
+
+		{ "helper-protocol", 0, POPT_ARG_STRING, &helper_protocol, OPT_DOMAIN, "operate as a stdio-based helper", "helper protocol to use"},
+ 		{ "username", 0, POPT_ARG_STRING, &username, OPT_USERNAME, "username"},
+ 		{ "domain", 0, POPT_ARG_STRING, &domain, OPT_DOMAIN, "domain name"},
+ 		{ "workstation", 0, POPT_ARG_STRING, &domain, OPT_WORKSTATION, "workstation"},
+ 		{ "challenge", 0, POPT_ARG_STRING, &hex_challenge, OPT_CHALLENGE, "challenge (HEX encoded)"},
+		{ "lm-response", 0, POPT_ARG_STRING, &hex_lm_response, OPT_LM, "LM Response to the challenge (HEX encoded)"},
+		{ "nt-response", 0, POPT_ARG_STRING, &hex_nt_response, OPT_NT, "NT or NTLMv2 Response to the challenge (HEX encoded)"},
+		{ "password", 0, POPT_ARG_STRING, &password, OPT_PASSWORD, "User's plaintext password"},		
+		{ NULL, 0, POPT_ARG_INCLUDE_TABLE, popt_common_debug },
+		{ NULL, 0, POPT_ARG_INCLUDE_TABLE, popt_common_configfile },
+		{ 0, 0, 0, 0 }
+	};
+
+	/* Samba client initialisation */
+
+	dbf = x_stderr;
+	
+	/* Parse options */
+
+	pc = poptGetContext("ntlm_auth", argc, argv, long_options, 0);
+
+	/* Parse command line options */
+
+	if (argc == 1) {
+		poptPrintHelp(pc, stderr, 0);
+		return 1;
+	}
+
+	pc = poptGetContext(NULL, argc, (const char **)argv, long_options, 
+			    POPT_CONTEXT_KEEP_FIRST);
+
+	while((opt = poptGetNextOpt(pc)) != -1) {
+		switch (opt) {
+		case OPT_CHALLENGE:
+			if (!hex_decode(hex_challenge, &challenge, &challenge_len)) {
+				fprintf(stderr, "hex decode of %s failed!\n", hex_challenge);
+				exit(1);
+			}
+			break;
+		case OPT_LM: 
+			if (!hex_decode(hex_lm_response, &lm_response, &lm_response_len)) {
+				fprintf(stderr, "hex decode of %s failed!\n", lm_response);
+				exit(1);
+			}
+			break;
+		case OPT_NT:
+			if (!hex_decode(hex_lm_response, &lm_response, &lm_response_len)) {
+				fprintf(stderr, "hex decode of %s failed!\n", lm_response);
+				exit(1);
+			}
+			break;
+		}
+	}
+
+	if (helper_protocol) {
+		if (strcmp(helper_protocol, "squid-2.5-ntlmssp")== 0) {
+			squid_stream(SQUID_2_5_NTLMSSP);
+		} else if (strcmp(helper_protocol, "squid-2.5-basic")== 0) {
+			squid_stream(SQUID_2_5_BASIC);
+		} else if (strcmp(helper_protocol, "squid-2.4-basic")== 0) {
+			squid_stream(SQUID_2_4_BASIC);
+		} else {
+			fprintf(stderr, "unknown helper protocol [%s]\n", helper_protocol);
+			exit(1);
+		}
+	}
+
+	if (domain == NULL) {
+		domain = get_winbind_domain();
+	}
+
+	if (workstation == NULL) {
+		workstation = "";
+	}
+
+	if (challenge) {
+		if (!check_auth_crap()) {
+			exit(1);
+		}
+	} else if (password) {
+		fstring user;
+		snprintf(user, sizeof(user)-1, "%s%c%s", domain, winbind_separator(), username);
+		if (!check_plaintext_auth(user, password, True)) {
+			exit(1);
+		}
+	}
+
+	/* Exit code */
+
+	poptFreeContext(pc);
+	return 0;
+}
diff -uNr samba-3.0alpha21.orig/source/utils/pdbedit.c samba-3.0alpha21/source/utils/pdbedit.c
--- samba-3.0alpha21.orig/source/utils/pdbedit.c	2003-02-16 19:06:34.000000000 -0600
+++ samba-3.0alpha21/source/utils/pdbedit.c	2003-02-16 19:05:47.000000000 -0600
@@ -43,13 +43,13 @@
 #define BIT_DELETE	0x00080000
 #define BIT_ACCPOLICY	0x00100000
 #define BIT_ACCPOLVAL	0x00200000
-#define BIT_RESERV_6	0x00400000
+#define BIT_ACCTCTRL	0x00400000
 #define BIT_RESERV_7	0x00800000
 #define BIT_IMPORT	0x01000000
 #define BIT_EXPORT	0x02000000
 
 #define MASK_ALWAYS_GOOD	0x0000001F
-#define MASK_USER_GOOD		0x00001F00
+#define MASK_USER_GOOD		0x00401F00
 
 /*********************************************************
  Add all currently available users to another db
@@ -231,7 +231,10 @@
  Set User Info
 **********************************************************/
 
-static int set_user_info (struct pdb_context *in, char *username, char *fullname, char *homedir, char *drive, char *script, char *profile)
+static int set_user_info (struct pdb_context *in, const char *username, 
+			  const char *fullname, const char *homedir, 
+			  const char *drive, const char *script, 
+			  const char *profile, const char *account_control)
 {
 	SAM_ACCOUNT *sam_pwent=NULL;
 	BOOL ret;
@@ -255,6 +258,23 @@
 		pdb_set_logon_script(sam_pwent, script, PDB_CHANGED);
 	if (profile)
 		pdb_set_profile_path (sam_pwent, profile, PDB_CHANGED);
+
+	if (account_control) {
+		uint16 not_settable = ~(ACB_DISABLED|ACB_HOMDIRREQ|ACB_PWNOTREQ|
+					ACB_PWNOEXP|ACB_AUTOLOCK);
+
+		uint16 newflag = pdb_decode_acct_ctrl(account_control);
+
+		if (newflag & not_settable) {
+			fprintf(stderr, "Can only set [NDHLX] flags\n");
+			pdb_free_sam(&sam_pwent);
+			return -1;
+		}
+
+		pdb_set_acct_ctrl(sam_pwent,
+				  (pdb_get_acct_ctrl(sam_pwent) & not_settable) | newflag,
+				  PDB_CHANGED);
+	}
 	
 	if (NT_STATUS_IS_OK(in->pdb_update_sam_account (in, sam_pwent)))
 		print_user_info (in, username, True, False);
@@ -270,7 +290,7 @@
 /*********************************************************
  Add New User
 **********************************************************/
-static int new_user (struct pdb_context *in, char *username, char *fullname, char *homedir, char *drive, char *script, char *profile)
+static int new_user (struct pdb_context *in, const char *username, const char *fullname, const char *homedir, const char *drive, const char *script, const char *profile)
 {
 	SAM_ACCOUNT *sam_pwent=NULL;
 	struct passwd  *pwd = NULL;
@@ -339,26 +359,38 @@
  Add New Machine
 **********************************************************/
 
-static int new_machine (struct pdb_context *in, char *machinename)
+static int new_machine (struct pdb_context *in, const char *machine_in)
 {
 	SAM_ACCOUNT *sam_pwent=NULL;
+	fstring machinename;
+	struct passwd  *pwd = NULL;
 	char name[16];
-	char *password = NULL;
 	
-	if (!NT_STATUS_IS_OK(pdb_init_sam (&sam_pwent))) {
-		return -1;
-	}
+	fstrcpy(machinename, machine_in); 
 
 	if (machinename[strlen (machinename) -1] == '$')
 		machinename[strlen (machinename) -1] = '\0';
 	
+	strlower_m(machinename);
+	
 	safe_strcpy (name, machinename, 16);
 	safe_strcat (name, "$", 16);
-	
-	string_set (&password, machinename);
-	strlower_m(password);
-	
-	pdb_set_plaintext_passwd (sam_pwent, password);
+
+	if ((pwd = getpwnam_alloc(name))) {
+		if (!NT_STATUS_IS_OK(pdb_init_sam_pw( &sam_pwent, pwd))) {
+			fprintf(stderr, "Could not init sam from pw\n");
+			passwd_free(&pwd);
+			return -1;
+		}
+		passwd_free(&pwd);
+	} else {
+		if (!NT_STATUS_IS_OK(pdb_init_sam (&sam_pwent))) {
+			fprintf(stderr, "Could not init sam from pw\n");
+			return -1;
+		}
+	}
+
+	pdb_set_plaintext_passwd (sam_pwent, machinename);
 
 	pdb_set_username (sam_pwent, name, PDB_CHANGED);
 	
@@ -381,7 +413,7 @@
  Delete user entry
 **********************************************************/
 
-static int delete_user_entry (struct pdb_context *in, char *username)
+static int delete_user_entry (struct pdb_context *in, const char *username)
 {
 	SAM_ACCOUNT *samaccount = NULL;
 
@@ -401,7 +433,7 @@
  Delete machine entry
 **********************************************************/
 
-static int delete_machine_entry (struct pdb_context *in, char *machinename)
+static int delete_machine_entry (struct pdb_context *in, const char *machinename)
 {
 	char name[16];
 	SAM_ACCOUNT *samaccount = NULL;
@@ -438,7 +470,7 @@
 	uint32	setparms, checkparms;
 	int opt;
 	static char *full_name = NULL;
-	static char *user_name = NULL;
+	static const char *user_name = NULL;
 	static char *home_dir = NULL;
 	static char *home_drive = NULL;
 	static char *backend = NULL;
@@ -446,6 +478,7 @@
 	static char *backend_out = NULL;
 	static char *logon_script = NULL;
 	static char *profile_path = NULL;
+	static char *account_control = NULL;
 	static char *account_policy = NULL;
 	static long int account_policy_value = 0;
 	BOOL account_policy_value_set = False;
@@ -474,6 +507,7 @@
 		{"export",	'e', POPT_ARG_STRING, &backend_out, 0, "export user accounts to this backend", NULL},
 		{"account-policy",	'P', POPT_ARG_STRING, &account_policy, 0,"value of an account policy (like maximum password age)",NULL},
 		{"value",       'V', POPT_ARG_LONG, &account_policy_value, 'V',"set the account policy to this value", NULL},
+		{"account-control",	'c', POPT_ARG_STRING, &account_control, 0, "Values of account control", NULL},
 		{ NULL, 0, POPT_ARG_INCLUDE_TABLE, popt_common_debug },
 		{ NULL, 0, POPT_ARG_INCLUDE_TABLE, popt_common_configfile },
 		{0,0,0,0}
@@ -494,9 +528,8 @@
 
 	poptGetArg(pc); /* Drop argv[0], the program name */
 
-	if (user_name == NULL) {
-		user_name = strdup(poptGetArg(pc));
-	}
+	if (user_name == NULL)
+		user_name = poptGetArg(pc);
 
 	if (!lp_load(dyn_CONFIGFILE,True,False,False)) {
 		fprintf(stderr, "Can't load %s - run testparm to debug it\n", dyn_CONFIGFILE);
@@ -520,6 +553,7 @@
 			(modify_user ? BIT_MODIFY : 0) +
 			(add_user ? BIT_CREATE : 0) +
 			(delete_user ? BIT_DELETE : 0) +
+			(account_control ? BIT_ACCTCTRL : 0) +
 			(account_policy ? BIT_ACCPOLICY : 0) +
 			(account_policy_value_set ? BIT_ACCPOLVAL : 0) +
 			(backend_in ? BIT_IMPORT : 0) +
@@ -647,7 +681,7 @@
 					      home_dir,
 					      home_drive,
 					      logon_script,
-					      profile_path);
+					      profile_path, account_control);
 		}
 	}
 
diff -uNr samba-3.0alpha21.orig/source/utils/profiles.c samba-3.0alpha21/source/utils/profiles.c
--- samba-3.0alpha21.orig/source/utils/profiles.c	1969-12-31 18:00:00.000000000 -0600
+++ samba-3.0alpha21/source/utils/profiles.c	2003-02-16 19:05:47.000000000 -0600
@@ -0,0 +1,729 @@
+/* 
+   Samba Unix/Linux SMB client utility profiles.c 
+   Copyright (C) 2002 Richard Sharpe, rsharpe@richardsharpe.com
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+   
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+   
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
+ 
+/*************************************************************************
+                                                       
+ A utility to report and change SIDs in registry files 
+                                     
+ Many of the ideas in here come from other people and software. 
+ I first looked in Wine in misc/registry.c and was also influenced by
+ http://www.wednesday.demon.co.uk/dosreg.html
+
+ Which seems to contain comments from someone else. I reproduce them here
+ incase the site above disappears. It actually comes from 
+ http://home.eunet.no/~pnordahl/ntpasswd/WinReg.txt. 
+
+The windows NT registry has 2 different blocks, where one can occure many
+times...
+
+the "regf"-Block
+================
+ 
+"regf" is obviosly the abbreviation for "Registry file". "regf" is the
+signature of the header-block which is always 4kb in size, although only
+the first 64 bytes seem to be used and a checksum is calculated over
+the first 0x200 bytes only!
+
+Offset            Size      Contents
+0x00000000      D-Word      ID: ASCII-"regf" = 0x66676572
+0x00000004      D-Word      ???? //see struct REGF
+0x00000008      D-Word      ???? Always the same value as at 0x00000004
+0x0000000C      Q-Word      last modify date in WinNT date-format
+0x00000014      D-Word      1
+0x00000018      D-Word      3
+0x0000001C      D-Word      0
+0x00000020      D-Word      1
+0x00000024      D-Word      Offset of 1st key record
+0x00000028      D-Word      Size of the data-blocks (Filesize-4kb)
+0x0000002C      D-Word      1
+0x000001FC      D-Word      Sum of all D-Words from 0x00000000 to
+0x000001FB  //XOR of all words. Nigel
+
+I have analyzed more registry files (from multiple machines running
+NT 4.0 german version) and could not find an explanation for the values
+marked with ???? the rest of the first 4kb page is not important...
+
+the "hbin"-Block
+================
+I don't know what "hbin" stands for, but this block is always a multiple
+of 4kb in size.
+
+Inside these hbin-blocks the different records are placed. The memory-
+management looks like a C-compiler heap management to me...
+
+hbin-Header
+===========
+Offset      Size      Contents
+0x0000      D-Word      ID: ASCII-"hbin" = 0x6E696268
+0x0004      D-Word      Offset from the 1st hbin-Block
+0x0008      D-Word      Offset to the next hbin-Block
+0x001C      D-Word      Block-size
+
+The values in 0x0008 and 0x001C should be the same, so I don't know
+if they are correct or swapped...
+
+From offset 0x0020 inside a hbin-block data is stored with the following
+format:
+
+Offset      Size      Contents
+0x0000      D-Word      Data-block size    //this size must be a
+multiple of 8. Nigel
+0x0004      ????      Data
+ 
+If the size field is negative (bit 31 set), the corresponding block
+is free and has a size of -blocksize!
+
+The data is stored as one record per block. Block size is a multiple
+of 4 and the last block reaches the next hbin-block, leaving no room.
+
+Records in the hbin-blocks
+==========================
+
+nk-Record
+
+      The nk-record can be treated as a kombination of tree-record and
+      key-record of the win 95 registry.
+
+lf-Record
+
+      The lf-record is the counterpart to the RGKN-record (the
+      hash-function)
+
+vk-Record
+
+      The vk-record consists information to a single value.
+
+sk-Record
+
+      sk (? Security Key ?) is the ACL of the registry.
+
+Value-Lists
+
+      The value-lists contain information about which values are inside a
+      sub-key and don't have a header.
+
+Datas
+
+      The datas of the registry are (like the value-list) stored without a
+      header.
+
+All offset-values are relative to the first hbin-block and point to the
+block-size field of the record-entry. to get the file offset, you have to add
+the header size (4kb) and the size field (4 bytes)...
+
+the nk-Record
+=============
+Offset      Size      Contents
+0x0000      Word      ID: ASCII-"nk" = 0x6B6E
+0x0002      Word      for the root-key: 0x2C, otherwise 0x20  //key symbolic links 0x10. Nigel
+0x0004      Q-Word      write-date/time in windows nt notation
+0x0010      D-Word      Offset of Owner/Parent key
+0x0014      D-Word      number of sub-Keys
+0x001C      D-Word      Offset of the sub-key lf-Records
+0x0024      D-Word      number of values
+0x0028      D-Word      Offset of the Value-List
+0x002C      D-Word      Offset of the sk-Record
+
+0x0030      D-Word      Offset of the Class-Name //see NK structure for the use of these fields. Nigel
+0x0044      D-Word      Unused (data-trash)  //some kind of run time index. Does not appear to be important. Nigel
+0x0048      Word      name-length
+0x004A      Word      class-name length
+0x004C      ????      key-name
+
+the Value-List
+==============
+Offset      Size      Contents
+0x0000      D-Word      Offset 1st Value
+0x0004      D-Word      Offset 2nd Value
+0x????      D-Word      Offset nth Value
+
+To determine the number of values, you have to look at the owner-nk-record!
+
+Der vk-Record
+=============
+Offset      Size      Contents
+0x0000      Word      ID: ASCII-"vk" = 0x6B76
+0x0002      Word      name length
+0x0004      D-Word      length of the data   //if top bit is set when offset contains data. Nigel
+0x0008      D-Word      Offset of Data
+0x000C      D-Word      Type of value
+0x0010      Word      Flag
+0x0012      Word      Unused (data-trash)
+0x0014      ????      Name
+
+If bit 0 of the flag-word is set, a name is present, otherwise the value has no name (=default)
+
+If the data-size is lower 5, the data-offset value is used to store the data itself!
+
+The data-types
+==============
+Wert      Beteutung
+0x0001      RegSZ:             character string (in UNICODE!)
+0x0002      ExpandSZ:   string with "%var%" expanding (UNICODE!)
+0x0003      RegBin:           raw-binary value
+0x0004      RegDWord:   Dword
+0x0007      RegMultiSZ:      multiple strings, separated with 0
+                  (UNICODE!)
+
+The "lf"-record
+===============
+Offset      Size      Contents
+0x0000      Word      ID: ASCII-"lf" = 0x666C
+0x0002      Word      number of keys
+0x0004      ????      Hash-Records
+
+Hash-Record
+===========
+Offset      Size      Contents
+0x0000      D-Word      Offset of corresponding "nk"-Record
+0x0004      D-Word      ASCII: the first 4 characters of the key-name, padded with 0's. Case sensitiv!
+
+Keep in mind, that the value at 0x0004 is used for checking the data-consistency! If you change the 
+key-name you have to change the hash-value too!
+
+//These hashrecords must be sorted low to high within the lf record. Nigel.
+
+The "sk"-block
+==============
+(due to the complexity of the SAM-info, not clear jet)
+
+Offset      Size      Contents
+0x0000      Word      ID: ASCII-"sk" = 0x6B73
+0x0002      Word      Unused
+0x0004      D-Word      Offset of previous "sk"-Record
+0x0008      D-Word      Offset of next "sk"-Record
+0x000C      D-Word      usage-counter
+0x0010      D-Word      Size of "sk"-record in bytes
+????                                             //standard self
+relative security desciptor. Nigel
+????  ????      Security and auditing settings...
+????
+
+The usage counter counts the number of references to this
+"sk"-record. You can use one "sk"-record for the entire registry!
+
+Windows nt date/time format
+===========================
+The time-format is a 64-bit integer which is incremented every
+0,0000001 seconds by 1 (I don't know how accurate it realy is!)
+It starts with 0 at the 1st of january 1601 0:00! All values are
+stored in GMT time! The time-zone is important to get the real
+time!
+
+Common values for win95 and win-nt
+==================================
+Offset values marking an "end of list", are either 0 or -1 (0xFFFFFFFF).
+If a value has no name (length=0, flag(bit 0)=0), it is treated as the
+"Default" entry...
+If a value has no data (length=0), it is displayed as empty.
+
+simplyfied win-3.?? registry:
+=============================
+
++-----------+
+| next rec. |---+                      +----->+------------+
+| first sub |   |                      |      | Usage cnt. |
+| name      |   |  +-->+------------+  |      | length     |
+| value     |   |  |   | next rec.  |  |      | text       |------->+-------+
++-----------+   |  |   | name rec.  |--+      +------------+        | xxxxx |
+   +------------+  |   | value rec. |-------->+------------+        +-------+
+   v               |   +------------+         | Usage cnt. |
++-----------+      |                          | length     |
+| next rec. |      |                          | text       |------->+-------+
+| first sub |------+                          +------------+        | xxxxx |
+| name      |                                                       +-------+
+| value     |
++-----------+    
+
+Greatly simplyfied structure of the nt-registry:
+================================================
+   
++---------------------------------------------------------------+
+|                                                               |
+v                                                               |
++---------+     +---------->+-----------+  +----->+---------+   |
+| "nk"    |     |           | lf-rec.   |  |      | nk-rec. |   |
+| ID      |     |           | # of keys |  |      | parent  |---+
+| Date    |     |           | 1st key   |--+      | ....    |
+| parent  |     |           +-----------+         +---------+
+| suk-keys|-----+
+| values  |--------------------->+----------+
+| SK-rec. |---------------+      | 1. value |--> +----------+
+| class   |--+            |      +----------+    | vk-rec.  |
++---------+  |            |                      | ....     |
+             v            |                      | data     |--> +-------+
+      +------------+      |                      +----------+    | xxxxx |
+      | Class name |      |                                      +-------+
+      +------------+      |
+                          v
+          +---------+    +---------+
+   +----->| next sk |--->| Next sk |--+
+   |  +---| prev sk |<---| prev sk |  |
+   |  |   | ....    |    | ...     |  |
+   |  |   +---------+    +---------+  |
+   |  |         ^          |          |
+      |         +----------+          |
+      +-------------------------------+
+
+---------------------------------------------------------------------------
+
+Hope this helps....  (Although it was "fun" for me to uncover this things,
+                  it took me several sleepless nights ;)
+
+            B.D.
+
+*************************************************************************/
+#include "includes.h"
+#include <stdio.h>
+#include <errno.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <unistd.h>
+#include <sys/mman.h>
+
+typedef unsigned int DWORD;
+typedef unsigned short WORD;
+
+#define REG_REGF_ID 0x66676572
+
+typedef struct regf_block {
+  DWORD REGF_ID;     /* regf */
+  DWORD uk1;
+  DWORD uk2;
+  DWORD tim1, tim2;
+  DWORD uk3;             /* 1 */
+  DWORD uk4;             /* 3 */
+  DWORD uk5;             /* 0 */
+  DWORD uk6;             /* 1 */
+  DWORD first_key;       /* offset */
+  unsigned int dblk_size;
+  DWORD uk7[116];        /* 1 */
+  DWORD chksum;
+} REGF_HDR;
+
+typedef struct hbin_sub_struct {
+  DWORD dblocksize;
+  char data[1];
+} HBIN_SUB_HDR;
+
+#define REG_HBIN_ID 0x6E696268
+
+typedef struct hbin_struct {
+  DWORD HBIN_ID; /* hbin */
+  DWORD next_off;
+  DWORD prev_off;
+  DWORD uk1;
+  DWORD uk2;
+  DWORD uk3;
+  DWORD uk4;
+  DWORD blk_size;
+  HBIN_SUB_HDR hbin_sub_hdr;
+} HBIN_HDR;
+
+#define REG_NK_ID 0x6B6E
+
+typedef struct nk_struct {
+  WORD NK_ID;
+  WORD type;
+  DWORD t1, t2;
+  DWORD uk1;
+  DWORD own_off;
+  DWORD subk_num;
+  DWORD uk2;
+  DWORD lf_off;
+  DWORD uk3;
+  DWORD val_cnt;
+  DWORD val_off;
+  DWORD sk_off;
+  DWORD clsnam_off;
+} NK_HDR;
+
+#define REG_SK_ID 0x6B73
+
+typedef struct sk_struct {
+  WORD SK_ID;
+  WORD uk1;
+  DWORD prev_off;
+  DWORD next_off;
+  DWORD ref_cnt;
+  DWORD rec_size;
+  char sec_desc[1];
+} SK_HDR;
+
+typedef struct sec_desc_rec {
+  WORD rev;
+  WORD type;
+  DWORD owner_off;
+  DWORD group_off;
+  DWORD sacl_off;
+  DWORD dacl_off;
+} MY_SEC_DESC;
+
+typedef struct ace_struct {
+    unsigned char type;
+    unsigned char flags;
+    unsigned short length;
+    unsigned int perms;
+    DOM_SID trustee;
+} ACE;
+
+typedef struct acl_struct {
+  WORD rev;
+  WORD size;
+  DWORD num_aces;
+  ACE *aces;   /* One or more ACEs */
+} ACL;
+
+#define OFF(f) (0x1000 + (f) + 4) 
+
+void print_sid(DOM_SID *sid);
+
+int verbose = 1;
+DOM_SID old_sid, new_sid;
+int change = 0, new = 0;
+
+/* Compare two SIDs for equality */
+int my_sid_equal(DOM_SID *s1, DOM_SID *s2)
+{
+  int sa1, sa2;
+
+  if (s1->sid_rev_num != s2->sid_rev_num) return 0;
+
+  sa1 = s1->num_auths; sa2 = s2->num_auths;
+
+  if (sa1 != sa2) return 0;
+
+  return !memcmp((char *)&s1->id_auth, (char *)&s2->id_auth,
+		6 + sa1 * 4);
+
+}
+
+/*
+ * Quick and dirty to read a SID in S-1-5-21-x-y-z-rid format and 
+ * construct a DOM_SID
+ */
+int get_sid(DOM_SID *sid, char *sid_str)
+{
+  int i = 0, auth;
+  char *lstr; 
+
+  if (strncmp(sid_str, "S-1-5", 5)) {
+    fprintf(stderr, "Does not conform to S-1-5...: %s\n", sid_str);
+    return 0;
+  }
+
+  /* We only allow strings of form S-1-5... */
+
+  sid->sid_rev_num = 1;
+  sid->id_auth[5] = 5;
+
+  lstr = sid_str + 5;
+
+  while (1) {
+    if (!lstr || !lstr[0] || sscanf(lstr, "-%u", &auth) == 0) {
+      if (i < 4) {
+	fprintf(stderr, "Not of form -d-d...: %s, %u\n", lstr, i);
+	return 0;
+      }
+      sid->num_auths=i;
+      print_sid(sid);
+      return 1;
+    }
+
+    SIVAL(&sid->sub_auths[i], 0, auth);
+    i++;
+    lstr = strchr(lstr + 1, '-'); 
+  }
+
+  return 1;
+}
+
+/* 
+ * Replace SID1, component by component with SID2
+ * Assumes will never be called with unequal length SIDS
+ * so only touches 21-x-y-z-rid portion
+ * This routine does not need to deal with endianism as 
+ * long as the incoming SIDs are both in the same (LE) format.
+ */
+void change_sid(DOM_SID *s1, DOM_SID *s2)
+{
+  int i;
+  
+  for (i=0; i<s1->num_auths; i++) {
+    s1->sub_auths[i] = s2->sub_auths[i];
+  }
+}
+
+void print_sid(DOM_SID *sid)
+{
+  int i, comps = sid->num_auths;
+  fprintf(stdout, "S-%u-%u", sid->sid_rev_num, sid->id_auth[5]);
+
+  for (i = 0; i < comps; i++) {
+
+    fprintf(stdout, "-%u", IVAL(&sid->sub_auths[i],0));
+
+  }
+  fprintf(stdout, "\n");
+}
+
+void process_sid(DOM_SID *sid, DOM_SID *o_sid, DOM_SID *n_sid) 
+{
+  int i;
+  if (my_sid_equal(sid, o_sid)) {
+
+    for (i=0; i<sid->num_auths; i++) {
+      sid->sub_auths[i] = n_sid->sub_auths[i];
+
+    }
+
+  }
+
+}
+
+void process_acl(ACL *acl, const char *prefix)
+{
+  int ace_cnt, i;
+  ACE *ace;
+
+  ace_cnt = IVAL(&acl->num_aces, 0);
+  ace = (ACE *)&acl->aces;
+  if (verbose) fprintf(stdout, "%sACEs: %u\n", prefix, ace_cnt);
+  for (i=0; i<ace_cnt; i++) {
+    if (verbose) fprintf(stdout, "%s  Perms: %08X, SID: ", prefix,
+			 IVAL(&ace->perms, 0));
+    if (change)
+      process_sid(&ace->trustee, &old_sid, &new_sid);
+    print_sid(&ace->trustee);
+    ace = (ACE *)((char *)ace + SVAL(&ace->length, 0));
+  }
+} 
+
+void usage(void)
+{
+  fprintf(stderr, "usage: profiles [-c <OLD-SID> -n <NEW-SID>] <profilefile>\n");
+  fprintf(stderr, "Version: %s\n", VERSION);
+  fprintf(stderr, "\n\t-v\t sets verbose mode");
+  fprintf(stderr, "\n\t-c S-1-5-21-z-y-x-oldrid - provides SID to change");
+  fprintf(stderr, "\n\t-n S-1-5-21-a-b-c-newrid - provides SID to change to");
+  fprintf(stderr, "\n\t\tBoth must be present if the other is.");
+  fprintf(stderr, "\n\t\tIf neither present, just report the SIDs found\n");
+}
+
+int main(int argc, char *argv[])
+{
+  extern char *optarg;
+  extern int optind;
+  int opt;
+  int fd, start = 0;
+  char *base;
+  struct stat sbuf;
+  REGF_HDR *regf_hdr;
+  HBIN_HDR *hbin_hdr;
+  NK_HDR *nk_hdr;
+  SK_HDR *sk_hdr;
+  DWORD first_sk_off, sk_off;
+  MY_SEC_DESC *sec_desc;
+  int *ptr;
+
+  if (argc < 2) {
+    usage();
+    exit(1);
+  }
+
+  /*
+   * Now, process the arguments
+   */
+
+  while ((opt = getopt(argc, argv, "c:n:v")) != EOF) {
+    switch (opt) {
+    case 'c':
+      change = 1;
+      if (!get_sid(&old_sid, optarg)) {
+	fprintf(stderr, "Argument to -c should be a SID in form of S-1-5-...\n");
+	usage();
+	exit(254);
+      }
+      break;
+
+    case 'n':
+      new = 1;
+      if (!get_sid(&new_sid, optarg)) {
+	fprintf(stderr, "Argument to -n should be a SID in form of S-1-5-...\n");
+	usage();
+	exit(253);
+      }
+
+      break;
+
+    case 'v':
+      verbose++;
+      break;
+
+    default:
+      usage();
+      exit(255);
+    }
+  }
+
+  if ((!change & new) || (change & !new)) {
+    fprintf(stderr, "You must specify both -c and -n if one or the other is set!\n");
+    usage();
+    exit(252);
+  }
+
+  fd = open(argv[optind], O_RDWR, 0000);
+
+  if (fd < 0) {
+    fprintf(stderr, "Could not open %s: %s\n", argv[optind], 
+	strerror(errno));
+    exit(2);
+  }
+
+  if (fstat(fd, &sbuf) < 0) {
+    fprintf(stderr, "Could not stat file %s, %s\n", argv[optind],
+	strerror(errno));
+    exit(3);
+  }
+
+  /*
+   * Now, mmap the file into memory, check the header and start
+   * dealing with the records. We are interested in the sk record
+   */
+  start = 0;
+  base = mmap(&start, sbuf.st_size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
+
+  if ((int)base == -1) {
+    fprintf(stderr, "Could not mmap file: %s, %s\n", argv[optind],
+	strerror(errno));
+    exit(4);
+  }
+
+  /*
+   * In what follows, and in places above, in order to work on both LE and
+   * BE platforms, we have to use the Samba macros to extract SHORT, LONG
+   * and associated UNSIGNED quantities from the data in the mmap'd file.
+   * NOTE, however, that we do not need to do anything with memory
+   * addresses that we construct from pointers in our address space.
+   * For example, 
+   *
+   *    sec_desc = (MY_SEC_DESC *)&(sk_hdr->sec_desc[0]);
+   *
+   * is simply taking the address of a structure we already have the address
+   * of in our address space, while, the fields within it, will have to 
+   * be accessed with the macros:
+   *
+   * owner_sid = (DOM_SID *)(&sk_hdr->sec_desc[0] + 
+   *                         IVAL(&sec_desc->owner_off, 0));
+   *
+   * Which is pulling out an offset and adding it to an existing pointer.
+   *
+   */
+
+  regf_hdr = (REGF_HDR *)base;
+
+  if (verbose) fprintf(stdout, "Registry file size: %u\n", (unsigned int)sbuf.st_size);
+
+  if (IVAL(&regf_hdr->REGF_ID, 0) != REG_REGF_ID) {
+    fprintf(stderr, "Incorrect Registry file (doesn't have header ID): %s\n", argv[optind]);
+    exit(5);
+  }
+
+  if (verbose) fprintf(stdout, "First Key Off: %u, Data Block Size: %u\n",
+		       IVAL(&regf_hdr->first_key, 0), 
+		       IVAL(&regf_hdr->dblk_size, 0));
+
+  hbin_hdr = (HBIN_HDR *)(base + 0x1000); /* No need for Endian stuff */
+
+  /*
+   * This should be the hbin_hdr 
+   */
+
+  if (IVAL(&hbin_hdr->HBIN_ID, 0) != REG_HBIN_ID) {
+    fprintf(stderr, "Incorrect hbin hdr: %s\n", argv[optind]);
+    exit(6);
+  } 
+
+  if (verbose) fprintf(stdout, "Next Off: %u, Prev Off: %u\n", 
+		       IVAL(&hbin_hdr->next_off, 0), 
+		       IVAL(&hbin_hdr->prev_off, 0));
+
+  nk_hdr = (NK_HDR *)(base + 0x1000 + IVAL(&regf_hdr->first_key, 0) + 4);
+
+  if (SVAL(&nk_hdr->NK_ID, 0) != REG_NK_ID) {
+    fprintf(stderr, "Incorrect NK Header: %s\n", argv[optind]);
+    exit(7);
+  }
+
+  sk_off = first_sk_off = IVAL(&nk_hdr->sk_off, 0);
+  if (verbose) {
+    fprintf(stdout, "Type: %0x\n", SVAL(&nk_hdr->type, 0));
+    fprintf(stdout, "SK Off    : %o\n", (0x1000 + sk_off + 4));  
+  }
+
+  sk_hdr = (SK_HDR *)(base + 0x1000 + sk_off + 4);
+
+  do {
+    DOM_SID *owner_sid, *group_sid;
+    ACL *sacl, *dacl;
+    if (SVAL(&sk_hdr->SK_ID, 0) != REG_SK_ID) {
+      fprintf(stderr, "Incorrect SK Header format: %08X\n", 
+	      (0x1000 + sk_off + 4));
+      exit(8);
+    }
+    ptr = (int *)sk_hdr;
+    if (verbose) fprintf(stdout, "Off: %08X, Refs: %u, Size: %u\n",
+			 sk_off, IVAL(&sk_hdr->ref_cnt, 0), 
+			 IVAL(&sk_hdr->rec_size, 0));
+
+    sec_desc = (MY_SEC_DESC *)&(sk_hdr->sec_desc[0]);
+    owner_sid = (DOM_SID *)(&sk_hdr->sec_desc[0] +
+			    IVAL(&sec_desc->owner_off, 0));
+    group_sid = (DOM_SID *)(&sk_hdr->sec_desc[0] + 
+			    IVAL(&sec_desc->group_off, 0));
+    sacl = (ACL *)(&sk_hdr->sec_desc[0] + 
+		   IVAL(&sec_desc->sacl_off, 0));
+    dacl = (ACL *)(&sk_hdr->sec_desc[0] + 
+		   IVAL(&sec_desc->dacl_off, 0));
+    if (verbose)fprintf(stdout, "  Owner SID: "); 
+    if (change) process_sid(owner_sid, &old_sid, &new_sid);
+    if (verbose) print_sid(owner_sid);
+    if (verbose) fprintf(stdout, "  Group SID: "); 
+    if (change) process_sid(group_sid, &old_sid, &new_sid);
+    if (verbose) print_sid(group_sid);
+    fprintf(stdout, "  SACL: ");
+    if (!sec_desc->sacl_off) { /* LE zero == BE zero */
+      if (verbose) fprintf(stdout, "NONE\n");
+    }
+    else 
+      process_acl(sacl, "    ");
+    if (verbose) fprintf(stdout, "  DACL: ");
+    if (!sec_desc->dacl_off) {
+      if (verbose) fprintf(stdout, "NONE\n");
+    }
+    else 
+      process_acl(dacl, "    ");
+    sk_off = IVAL(&sk_hdr->prev_off, 0);
+    sk_hdr = (SK_HDR *)(base + OFF(IVAL(&sk_hdr->prev_off, 0)));
+  } while (sk_off != first_sk_off);
+
+  munmap(base, sbuf.st_size); 
+
+  close(fd);
+  return 0;
+}
diff -uNr samba-3.0alpha21.orig/source/utils/rpccheck.c samba-3.0alpha21/source/utils/rpccheck.c
--- samba-3.0alpha21.orig/source/utils/rpccheck.c	2003-02-16 19:06:34.000000000 -0600
+++ samba-3.0alpha21/source/utils/rpccheck.c	2003-02-16 19:05:47.000000000 -0600
@@ -38,7 +38,7 @@
 	setup_logging("", True);
 	DEBUGLEVEL=10;
 
-	ctx=talloc_init();
+	ctx=talloc_init("main");
 	if (!ctx) exit(1);
 
 	prs_init(&ps, 1600, 4, ctx, MARSHALL);
diff -uNr samba-3.0alpha21.orig/source/utils/smbcacls.c samba-3.0alpha21/source/utils/smbcacls.c
--- samba-3.0alpha21.orig/source/utils/smbcacls.c	2003-02-16 19:06:34.000000000 -0600
+++ samba-3.0alpha21/source/utils/smbcacls.c	2003-02-16 19:05:47.000000000 -0600
@@ -43,13 +43,13 @@
 enum exit_values {EXIT_OK, EXIT_FAILED, EXIT_PARSE_ERROR};
 
 struct perm_value {
-	char *perm;
+	const char *perm;
 	uint32 mask;
 };
 
 /* These values discovered by inspection */
 
-static struct perm_value special_values[] = {
+static const struct perm_value special_values[] = {
 	{ "R", 0x00120089 },
 	{ "W", 0x00120116 },
 	{ "X", 0x001200a0 },
@@ -59,7 +59,7 @@
 	{ NULL, 0 },
 };
 
-static struct perm_value standard_values[] = {
+static const struct perm_value standard_values[] = {
 	{ "READ",   0x001200a9 },
 	{ "CHANGE", 0x001301bf },
 	{ "FULL",   0x001f01ff },
@@ -70,7 +70,7 @@
 static POLICY_HND pol;
 static BOOL got_policy_hnd;
 
-static struct cli_state *connect_one(char *share);
+static struct cli_state *connect_one(const char *share);
 
 /* Open cli connection and policy handle */
 
@@ -161,7 +161,7 @@
 /* print an ACE on a FILE, using either numeric or ascii representation */
 static void print_ace(FILE *f, SEC_ACE *ace)
 {
-	struct perm_value *v;
+	const struct perm_value *v;
 	fstring sidstr;
 	int do_print = 0;
 	uint32 got_mask;
@@ -234,7 +234,7 @@
 	unsigned atype, aflags, amask;
 	DOM_SID sid;
 	SEC_ACCESS mask;
-	struct perm_value *v;
+	const struct perm_value *v;
 
 	ZERO_STRUCTP(ace);
 	p = strchr_m(str,':');
@@ -443,29 +443,36 @@
 *******************************************************/
 static int cacl_dump(struct cli_state *cli, char *filename)
 {
-	int fnum;
+	int result = EXIT_FAILED;
+	int fnum = -1;
 	SEC_DESC *sd;
 
-	if (test_args) return EXIT_OK;
+	if (test_args) 
+		return EXIT_OK;
 
 	fnum = cli_nt_create(cli, filename, CREATE_ACCESS_READ);
+
 	if (fnum == -1) {
 		printf("Failed to open %s: %s\n", filename, cli_errstr(cli));
-		return EXIT_FAILED;
+		goto done;
 	}
 
 	sd = cli_query_secdesc(cli, fnum, ctx);
 
 	if (!sd) {
 		printf("ERROR: secdesc query failed: %s\n", cli_errstr(cli));
-		return EXIT_FAILED;
+		goto done;
 	}
 
 	sec_desc_print(stdout, sd);
 
-	cli_close(cli, fnum);
+	result = EXIT_OK;
 
-	return EXIT_OK;
+done:
+	if (fnum != -1)
+		cli_close(cli, fnum);
+
+	return result;
 }
 
 /***************************************************** 
@@ -701,7 +708,7 @@
 /***************************************************** 
 return a connection to a server
 *******************************************************/
-static struct cli_state *connect_one(char *share)
+static struct cli_state *connect_one(const char *share)
 {
 	struct cli_state *c;
 	struct in_addr ip;
@@ -711,7 +718,7 @@
 	if (!got_pass) {
 		char *pass = getpass("Password: ");
 		if (pass) {
-			pstrcpy(password, pass);
+			fstrcpy(password, pass);
 			got_pass = True;
 		}
 	}
@@ -770,7 +777,7 @@
 
 	struct cli_state *cli;
 
-	ctx=talloc_init();
+	ctx=talloc_init("main");
 
 	setlinebuf(stdout);
 
@@ -799,7 +806,7 @@
 
 		if ((p=strchr_m(username,'%'))) {
 			*p = 0;
-			pstrcpy(password,p+1);
+			fstrcpy(password,p+1);
 			got_pass = True;
 			memset(strchr_m(getenv("USER"), '%') + 1, 'X',
 			       strlen(password));
@@ -813,7 +820,7 @@
 			p = strchr_m(username,'%');
 			if (p) {
 				*p = 0;
-				pstrcpy(password, p+1);
+				fstrcpy(password, p+1);
 				got_pass = 1;
 			}
 			break;
diff -uNr samba-3.0alpha21.orig/source/utils/smbcontrol.c samba-3.0alpha21/source/utils/smbcontrol.c
--- samba-3.0alpha21.orig/source/utils/smbcontrol.c	2003-02-16 19:06:34.000000000 -0600
+++ samba-3.0alpha21/source/utils/smbcontrol.c	2003-02-16 19:05:47.000000000 -0600
@@ -24,8 +24,8 @@
 
 extern BOOL AllowDebugChange;
 
-static struct {
-	char *name;
+static const struct {
+	const char *name;
 	int value;
 } msg_types[] = {
 	{"debug", MSG_DEBUG},
@@ -43,6 +43,7 @@
 	{"dmalloc-log-changed", MSG_REQ_DMALLOC_LOG_CHANGED },
 	{"shutdown", MSG_SHUTDOWN },
 	{"drvupgrade", MSG_PRINTER_DRVUPGRADE},
+	{"tallocdump", MSG_REQ_TALLOC_USAGE},
 	{NULL, -1}
 };
 
@@ -66,17 +67,19 @@
 		printf("<destination> <message-type> <parameters>\n\n");
 	}
 	printf("\t<destination> is one of \"nmbd\", \"smbd\" or a process ID\n");
-	printf("\t<message-type> is one of: ");
+	printf("\t<message-type> is one of:\n");
 	for (i=0; msg_types[i].name; i++) 
-	    printf("%s%s", i?", ":"",msg_types[i].name);
+	    printf("\t\t%s\n", msg_types[i].name);
 	printf("\n");
 	if (doexit) exit(1);
 }
 
 static int pong_count;
 static BOOL got_level;
+static BOOL got_pool;
 static BOOL pong_registered = False;
 static BOOL debuglevel_registered = False;
+static BOOL poolusage_registered = False;
 static BOOL profilelevel_registered = False;
 
 
@@ -109,17 +112,30 @@
 }
 
 /****************************************************************************
+ Prints out the current talloc list.
+****************************************************************************/
+void tallocdump_function(int msg_type, pid_t src, void *buf, size_t len)
+{
+	char *info = (char *)buf;
+
+	printf("Current talloc contexts for process %u\n", (unsigned int)src );
+	if (len == 0)
+		printf("None returned\n");
+	else
+		printf(info);
+	printf("\n");
+	got_pool = True;
+}
+
+/****************************************************************************
 Prints out the current Debug level returned by MSG_DEBUGLEVEL
 ****************************************************************************/
 void debuglevel_function(int msg_type, pid_t src, void *buf, size_t len)
 {
 	const char *levels = (char *)buf;
-	pstring dbgcl;
 
 	printf("Current debug levels of PID %u are:\n",(unsigned int)src);
-	
-	while(next_token(&levels, dbgcl, " ", sizeof(pstring)))
-		printf("%s\n", dbgcl);
+	printf("%s\n", levels);
 	
 	got_level = True;
 }
@@ -130,7 +146,7 @@
 void profilelevel_function(int msg_type, pid_t src, void *buf, size_t len)
 {
         int level;
-	char *s=NULL;
+	const char *s=NULL;
         memcpy(&level, buf, sizeof(int));
 
 	if (level) {
@@ -347,6 +363,25 @@
 		}
 		break;
 
+	case MSG_REQ_TALLOC_USAGE:
+		if (!poolusage_registered) {
+			message_register(MSG_TALLOC_USAGE, tallocdump_function);
+			poolusage_registered = True;
+		}
+		got_pool = False;
+		retval = send_message(dest, MSG_REQ_TALLOC_USAGE, NULL, 0, True);
+		if (retval) {
+			timeout_start = time(NULL);
+			while (!got_pool) {
+				message_dispatch();
+				if ((time(NULL) - timeout_start) > MAX_WAIT) {
+					fprintf(stderr,"tallocdump timeout\n");
+					break;
+				}
+			}
+		}
+		break;
+
 	case MSG_REQ_DEBUGLEVEL:
 		if (!debuglevel_registered) {
 		    message_register(MSG_DEBUGLEVEL, debuglevel_function);
@@ -380,6 +415,7 @@
 			fprintf(stderr, "\tjobpause <printername> <unix jobid>\n");
 			fprintf(stderr, "\tjobresume <printername> <unix jobid>\n");
 			fprintf(stderr, "\tjobdelete <printername> <unix jobid>\n");
+			fprintf(stderr, "\tprinter <printername> <comment|port|driver> <new value>\n");
 			return False;
 		}
 
@@ -470,7 +506,7 @@
 				JOB_STATUS_DELETED,
 				SPOOLSS_NOTIFY_MSG_UNIX_JOBID);
 		}
-
+		
 		/* printer change notify */
 		
 		if (strequal(cmd, "printer")) {
@@ -605,7 +641,7 @@
 	/* check if we have any pending print notify messages */
 
 	if ( check_notify_msgs )
-		print_notify_send_messages();
+		print_notify_send_messages(0);
 		
 	return (True);
 }
diff -uNr samba-3.0alpha21.orig/source/utils/smbfilter.c samba-3.0alpha21/source/utils/smbfilter.c
--- samba-3.0alpha21.orig/source/utils/smbfilter.c	2003-02-16 19:06:34.000000000 -0600
+++ samba-3.0alpha21/source/utils/smbfilter.c	2003-02-16 19:05:47.000000000 -0600
@@ -19,7 +19,6 @@
 */
 
 #include "includes.h"
-#include "smb.h"
 
 #define SECURITY_MASK 0
 #define SECURITY_SET  0
diff -uNr samba-3.0alpha21.orig/source/utils/smbpasswd.c samba-3.0alpha21/source/utils/smbpasswd.c
--- samba-3.0alpha21.orig/source/utils/smbpasswd.c	2003-02-16 19:06:34.000000000 -0600
+++ samba-3.0alpha21/source/utils/smbpasswd.c	2003-02-16 19:05:47.000000000 -0600
@@ -33,7 +33,7 @@
 static BOOL stdin_passwd_get = False;
 static fstring user_name, user_password;
 static char *new_passwd = NULL;
-static char *remote_machine = NULL;
+static const char *remote_machine = NULL;
 
 static fstring ldap_secret;
 
@@ -241,7 +241,7 @@
  Used if the '-s' option is set to silently get passwords
  to enable scripting.
 *************************************************************/
-static char *get_pass( char *prompt, BOOL stdin_get)
+static char *get_pass( const char *prompt, BOOL stdin_get)
 {
 	char *p;
 	if (stdin_get) {
@@ -498,7 +498,8 @@
 {
 	struct passwd  *pwd = NULL;
 	int result = 0;
-	char *old_passwd = NULL;
+	char *old_pw = NULL;
+	char *new_pw = NULL;
 
 	if (local_flags & ~(LOCAL_AM_ROOT | LOCAL_SET_PASSWORD)) {
 		/* Extra flags that we can't honor non-root */
@@ -529,19 +530,21 @@
 	}
 
 	if (remote_machine != NULL) {
-		old_passwd = get_pass("Old SMB password:",stdin_passwd_get);
+		old_pw = get_pass("Old SMB password:",stdin_passwd_get);
 	}
 	
 	if (!new_passwd) {
-		new_passwd = prompt_for_new_password(stdin_passwd_get);
+		new_pw = prompt_for_new_password(stdin_passwd_get);
 	}
+	else
+		new_pw = smb_xstrdup(new_passwd);
 	
-	if (!new_passwd) {
+	if (!new_pw) {
 		fprintf(stderr, "Unable to get new password.\n");
 		exit(1);
 	}
 
-	if (!password_change(remote_machine, user_name, old_passwd, new_passwd, 0)) {
+	if (!password_change(remote_machine, user_name, old_pw, new_pw, 0)) {
 		fprintf(stderr,"Failed to change password for %s\n", user_name);
 		result = 1;
 		goto done;
@@ -550,8 +553,8 @@
 	printf("Password changed for user %s\n", user_name);
 
  done:
-	SAFE_FREE(old_passwd);
-	SAFE_FREE(new_passwd);
+	SAFE_FREE(old_pw);
+	SAFE_FREE(new_pw);
 
 	return result;
 }
diff -uNr samba-3.0alpha21.orig/source/utils/status.c samba-3.0alpha21/source/utils/status.c
--- samba-3.0alpha21.orig/source/utils/status.c	2003-02-16 19:06:34.000000000 -0600
+++ samba-3.0alpha21/source/utils/status.c	2003-02-16 19:05:47.000000000 -0600
@@ -173,7 +173,7 @@
 	d_printf("write_count:                    %u\n", profile_p->syscall_write_count);
 	d_printf("write_time:                     %u\n", profile_p->syscall_write_time);
 	d_printf("write_bytes:                    %u\n", profile_p->syscall_write_bytes);
-#ifdef HAVE_SENDFILE
+#ifdef WITH_SENDFILE
 	d_printf("sendfile_count:                 %u\n", profile_p->syscall_sendfile_count);
 	d_printf("sendfile_time:                  %u\n", profile_p->syscall_sendfile_time);
 	d_printf("sendfile_bytes:                 %u\n", profile_p->syscall_sendfile_bytes);
diff -uNr samba-3.0alpha21.orig/source/utils/testparm.c samba-3.0alpha21/source/utils/testparm.c
--- samba-3.0alpha21.orig/source/utils/testparm.c	2003-02-16 19:06:34.000000000 -0600
+++ samba-3.0alpha21/source/utils/testparm.c	2003-02-16 19:05:47.000000000 -0600
@@ -33,7 +33,6 @@
  */
 
 #include "includes.h"
-#include "smb.h"
 
 extern BOOL AllowDebugChange;
 
@@ -191,7 +190,7 @@
 	int ret = 0;
 	int opt;
 	poptContext pc;
-	static char *term_code = "";
+	static const char *term_code = "";
 	static char *new_local_machine = NULL;
 	const char *cname;
 	const char *caddr;
@@ -203,6 +202,7 @@
 		{"verbose", 'v', POPT_ARG_NONE, &show_defaults, 1, "Show default options too"},
 		{"server", 'L',POPT_ARG_STRING, &new_local_machine, 0, "Set %%L macro to servername\n"},
 		{"encoding", 't', POPT_ARG_STRING, &term_code, 0, "Print parameters with encoding"},
+		{NULL, 0, POPT_ARG_INCLUDE_TABLE, popt_common_version},
 		{0,0,0,0}
 	};
 
diff -uNr samba-3.0alpha21.orig/source/utils/testprns.c samba-3.0alpha21/source/utils/testprns.c
--- samba-3.0alpha21.orig/source/utils/testprns.c	2003-02-16 19:06:34.000000000 -0600
+++ samba-3.0alpha21/source/utils/testprns.c	2003-02-16 19:05:47.000000000 -0600
@@ -31,11 +31,10 @@
  */
 
 #include "includes.h"
-#include "smb.h"
 
 int main(int argc, char *argv[])
 {
-   char *pszTemp;
+   const char *pszTemp;
 
    setup_logging(argv[0],True);
 
diff -uNr samba-3.0alpha21.orig/source/web/cgi.c samba-3.0alpha21/source/web/cgi.c
--- samba-3.0alpha21.orig/source/web/cgi.c	2003-02-16 19:06:34.000000000 -0600
+++ samba-3.0alpha21/source/web/cgi.c	2003-02-16 19:05:47.000000000 -0600
@@ -40,49 +40,12 @@
 static int content_length;
 static int request_post;
 static char *query_string;
-static char *baseurl;
+static const char *baseurl;
 static char *pathinfo;
 static char *C_user;
 static BOOL inetd_server;
 static BOOL got_request;
 
-static void unescape(char *buf)
-{
-	char *p=buf;
-
-	while ((p=strchr_m(p,'+')))
-		*p = ' ';
-
-	p = buf;
-
-	while (p && *p && (p=strchr_m(p,'%'))) {
-		int c1 = p[1];
-		int c2 = p[2];
-
-		if (c1 >= '0' && c1 <= '9')
-			c1 = c1 - '0';
-		else if (c1 >= 'A' && c1 <= 'F')
-			c1 = 10 + c1 - 'A';
-		else if (c1 >= 'a' && c1 <= 'f')
-			c1 = 10 + c1 - 'a';
-		else {p++; continue;}
-
-		if (c2 >= '0' && c2 <= '9')
-			c2 = c2 - '0';
-		else if (c2 >= 'A' && c2 <= 'F')
-			c2 = 10 + c2 - 'A';
-		else if (c2 >= 'a' && c2 <= 'f')
-			c2 = 10 + c2 - 'a';
-		else {p++; continue;}
-			
-		*p = (c1<<4) | c2;
-
-		memmove(p+1, p+3, strlen(p+3)+1);
-		p++;
-	}
-}
-
-
 static char *grab_line(FILE *f, int *cl)
 {
 	char *ret = NULL;
@@ -167,8 +130,8 @@
 			    !variables[num_variables].value)
 				continue;
 
-			unescape(variables[num_variables].value);
-			unescape(variables[num_variables].name);
+			rfc1738_unescape(variables[num_variables].value);
+			rfc1738_unescape(variables[num_variables].name);
 
 #ifdef DEBUG_COMMENTS
 			printf("<!== POST var %s has value \"%s\"  ==>\n",
@@ -198,8 +161,8 @@
 			    !variables[num_variables].value)
 				continue;
 
-			unescape(variables[num_variables].value);
-			unescape(variables[num_variables].name);
+			rfc1738_unescape(variables[num_variables].value);
+			rfc1738_unescape(variables[num_variables].name);
 
 #ifdef DEBUG_COMMENTS
                         printf("<!== Commandline var %s has value \"%s\"  ==>\n",
@@ -242,7 +205,7 @@
   browser. Also doesn't allow for variables[] containing multiple variables
   with the same name and the same or different values.
   ***************************************************************************/
-char *cgi_variable(char *name)
+const char *cgi_variable(const char *name)
 {
 	int i;
 
@@ -255,7 +218,7 @@
 /***************************************************************************
 tell a browser about a fatal error in the http processing
   ***************************************************************************/
-static void cgi_setup_error(char *err, char *header, char *info)
+static void cgi_setup_error(const char *err, const char *header, const char *info)
 {
 	if (!got_request) {
 		/* damn browsers don't like getting cut off before they give a request */
@@ -301,10 +264,10 @@
   ***************************************************************************/
 static void cgi_web_auth(void)
 {
-	char *user = getenv("REMOTE_USER");
+	const char *user = getenv("REMOTE_USER");
 	struct passwd *pwd;
-	char *head = "Content-Type: text/html\r\n\r\n<HTML><BODY><H1>SWAT installation Error</H1>\n";
-	char *tail = "</BODY></HTML>\r\n";
+	const char *head = "Content-Type: text/html\r\n\r\n<HTML><BODY><H1>SWAT installation Error</H1>\n";
+	const char *tail = "</BODY></HTML>\r\n";
 
 	if (!user) {
 		printf("%sREMOTE_USER not set. Not authenticated by web server.<br>%s\n",
@@ -328,44 +291,14 @@
 	passwd_free(&pwd);
 }
 
-/***************************************************************************
-decode a base64 string in-place - simple and slow algorithm
-  ***************************************************************************/
-static void base64_decode(char *s)
-{
-	char *b64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
-	int bit_offset, byte_offset, idx, i, n;
-	unsigned char *d = (unsigned char *)s;
-	char *p;
-
-	n=i=0;
-
-	while (*s && (p=strchr_m(b64,*s))) {
-		idx = (int)(p - b64);
-		byte_offset = (i*6)/8;
-		bit_offset = (i*6)%8;
-		d[byte_offset] &= ~((1<<(8-bit_offset))-1);
-		if (bit_offset < 3) {
-			d[byte_offset] |= (idx << (2-bit_offset));
-			n = byte_offset+1;
-		} else {
-			d[byte_offset] |= (idx >> (bit_offset-2));
-			d[byte_offset+1] = 0;
-			d[byte_offset+1] |= (idx << (8-(bit_offset-2))) & 0xFF;
-			n = byte_offset+2;
-		}
-		s++; i++;
-	}
-	/* null terminate */
-	d[n] = 0;
-}
 
 /***************************************************************************
 handle a http authentication line
   ***************************************************************************/
 static BOOL cgi_handle_authorization(char *line)
 {
-	char *p, *user, *user_pass;
+	char *p;
+	fstring user, user_pass;
 	struct passwd *pass = NULL;
 
 	if (strncasecmp(line,"Basic ", 6)) {
@@ -382,9 +315,15 @@
 		goto err;
 	}
 	*p = 0;
-	user = line;
-	user_pass = p+1;
-	
+
+	convert_string(CH_DISPLAY, CH_UNIX, 
+		       line, -1, 
+		       user, sizeof(user));
+
+	convert_string(CH_DISPLAY, CH_UNIX, 
+		       p+1, -1, 
+		       user_pass, sizeof(user_pass));
+
 	/*
 	 * Try and get the user from the UNIX password file.
 	 */
@@ -607,7 +546,7 @@
 /***************************************************************************
 return the current pages URL
   ***************************************************************************/
-char *cgi_baseurl(void)
+const char *cgi_baseurl(void)
 {
 	if (inetd_server) {
 		return baseurl;
@@ -618,7 +557,7 @@
 /***************************************************************************
 return the current pages path info
   ***************************************************************************/
-char *cgi_pathinfo(void)
+const char *cgi_pathinfo(void)
 {
 	char *r;
 	if (inetd_server) {
diff -uNr samba-3.0alpha21.orig/source/web/diagnose.c samba-3.0alpha21/source/web/diagnose.c
--- samba-3.0alpha21.orig/source/web/diagnose.c	2003-02-16 19:06:34.000000000 -0600
+++ samba-3.0alpha21/source/web/diagnose.c	2003-02-16 19:05:47.000000000 -0600
@@ -73,7 +73,7 @@
 	if (!cli_initialise(&cli))
 		return False;
 
-	if (!cli_connect(&cli, "localhost", &loopback_ip)) {
+	if (!cli_connect(&cli, global_myname(), &loopback_ip)) {
 		cli_shutdown(&cli);
 		return False;
 	}
diff -uNr samba-3.0alpha21.orig/source/web/startstop.c samba-3.0alpha21/source/web/startstop.c
--- samba-3.0alpha21.orig/source/web/startstop.c	2003-02-16 19:06:34.000000000 -0600
+++ samba-3.0alpha21/source/web/startstop.c	2003-02-16 19:05:47.000000000 -0600
@@ -39,7 +39,7 @@
 
 	slprintf(binfile, sizeof(pstring) - 1, "%s/smbd", dyn_SBINDIR);
 
-	become_daemon();
+	become_daemon(True);
 
 	execl(binfile, binfile, "-D", NULL);
 
@@ -60,7 +60,7 @@
 
 	slprintf(binfile, sizeof(pstring) - 1, "%s/nmbd", dyn_SBINDIR);
 	
-	become_daemon();
+	become_daemon(True);
 
 	execl(binfile, binfile, "-D", NULL);
 
@@ -81,7 +81,7 @@
 
 	slprintf(binfile, sizeof(pstring) - 1, "%s/winbindd", dyn_SBINDIR);
 
-	become_daemon();
+	become_daemon(True);
 
 	execl(binfile, binfile, NULL);
 
diff -uNr samba-3.0alpha21.orig/source/web/statuspage.c samba-3.0alpha21/source/web/statuspage.c
--- samba-3.0alpha21.orig/source/web/statuspage.c	2003-02-16 19:06:34.000000000 -0600
+++ samba-3.0alpha21/source/web/statuspage.c	2003-02-16 19:05:47.000000000 -0600
@@ -216,7 +216,7 @@
 /* show the current server status */
 void status_page(void)
 {
-	char *v;
+	const char *v;
 	int autorefresh=0;
 	int refresh_interval=30;
 	TDB_CONTEXT *tdb;
diff -uNr samba-3.0alpha21.orig/source/web/swat.c samba-3.0alpha21/source/web/swat.c
--- samba-3.0alpha21.orig/source/web/swat.c	2003-02-16 19:06:34.000000000 -0600
+++ samba-3.0alpha21/source/web/swat.c	2003-02-16 19:05:47.000000000 -0600
@@ -59,7 +59,7 @@
 
 /****************************************************************************
 ****************************************************************************/
-static int enum_index(int value, struct enum_list *enumlist)
+static int enum_index(int value, const struct enum_list *enumlist)
 {
 	int i;
 	for (i=0;enumlist[i].name;i++)
@@ -67,7 +67,7 @@
 	return(i);
 }
 
-static char *fix_backslash(char *str)
+static char *fix_backslash(const char *str)
 {
 	static char newstring[1024];
 	char *p = newstring;
@@ -81,7 +81,7 @@
 	return newstring;
 }
 
-static char *stripspaceupper(char *str)
+static char *stripspaceupper(const char *str)
 {
 	static char newstring[1024];
 	char *p = newstring;
@@ -94,7 +94,7 @@
 	return newstring;
 }
 
-static char *make_parm_name(char *label)
+static char *make_parm_name(const char *label)
 {
 	static char parmname[1024];
 	char *p = parmname;
@@ -111,7 +111,7 @@
 /****************************************************************************
   include a lump of html in a page 
 ****************************************************************************/
-static int include_html(char *fname)
+static int include_html(const char *fname)
 {
 	int fd;
 	char buf[1024];
@@ -303,8 +303,8 @@
 {
 	int i = 0;
 	struct parm_struct *parm;
-	char *heading = NULL;
-	char *last_heading = NULL;
+	const char *heading = NULL;
+	const char *last_heading = NULL;
 
 	while ((parm = lp_next_parameter(snum, &i, allparameters))) {
 		if (snum < 0 && parm->class == P_LOCAL && !(parm->flags & FLAG_GLOBAL))
@@ -440,7 +440,7 @@
 /****************************************************************************
   commit one parameter 
 ****************************************************************************/
-static void commit_parameter(int snum, struct parm_struct *parm, char *v)
+static void commit_parameter(int snum, struct parm_struct *parm, const char *v)
 {
 	int i;
 	char *s;
@@ -468,7 +468,7 @@
 	int i = 0;
 	struct parm_struct *parm;
 	pstring label;
-	char *v;
+	const char *v;
 
 	while ((parm = lp_next_parameter(snum, &i, 1))) {
 		slprintf(label, sizeof(label)-1, "parm_%s", make_parm_name(parm->label));
@@ -817,7 +817,7 @@
 ****************************************************************************/
 static void shares_page(void)
 {
-	char *share = cgi_variable("share");
+	const char *share = cgi_variable("share");
 	char *s;
 	int snum = -1;
 	int i;
@@ -915,8 +915,8 @@
 /*************************************************************
 change a password either locally or remotely
 *************************************************************/
-static BOOL change_password(const char *remote_machine, char *user_name, 
-			    char *old_passwd, char *new_passwd, 
+static BOOL change_password(const char *remote_machine, const char *user_name, 
+			    const char *old_passwd, const char *new_passwd, 
 				int local_flags)
 {
 	BOOL ret = False;
@@ -957,7 +957,7 @@
 ****************************************************************************/
 static void chg_passwd(void)
 {
-	char *host;
+	const char *host;
 	BOOL rslt;
 	int local_flags = 0;
 
@@ -1042,7 +1042,7 @@
 ****************************************************************************/
 static void passwd_page(void)
 {
-	char *new_name = cgi_user_name();
+	const char *new_name = cgi_user_name();
 
 	/* 
 	 * After the first time through here be nice. If the user
@@ -1147,7 +1147,7 @@
 ****************************************************************************/
 static void printers_page(void)
 {
-	char *share = cgi_variable("share");
+	const char *share = cgi_variable("share");
 	char *s;
 	int snum=-1;
 	int i;
diff -uNr samba-3.0alpha21.orig/source/wrepld/process.c samba-3.0alpha21/source/wrepld/process.c
--- samba-3.0alpha21.orig/source/wrepld/process.c	2003-02-16 19:06:34.000000000 -0600
+++ samba-3.0alpha21/source/wrepld/process.c	2003-02-16 19:05:47.000000000 -0600
@@ -498,7 +498,8 @@
 	for (kbuf = tdb_firstkey(tdb); 
 	     kbuf.dptr; 
 	     newkey = tdb_nextkey(tdb, kbuf), safe_free(kbuf.dptr), kbuf=newkey) {
-		pstring name_type, name, ip_str;
+		fstring name_type;
+		pstring name, ip_str;
 		char *p;
 		int type = 0;
 		int nb_flags;
diff -uNr samba-3.0alpha21.orig/source/wrepld/server.c samba-3.0alpha21/source/wrepld/server.c
--- samba-3.0alpha21.orig/source/wrepld/server.c	2003-02-16 19:06:34.000000000 -0600
+++ samba-3.0alpha21/source/wrepld/server.c	2003-02-16 19:05:47.000000000 -0600
@@ -135,7 +135,7 @@
 /****************************************************************************
 exit the server
 ****************************************************************************/
-void exit_server(char *reason)
+void exit_server(const char *reason)
 {
 	static int firsttime=1;
 
@@ -166,9 +166,11 @@
 static void usage(char *pname)
 {
 
-	d_printf("Usage: %s [-DaioPh?V] [-d debuglevel] [-l log basename] [-p port]\n", pname);
+	d_printf("Usage: %s [-DFSaioPh?V] [-d debuglevel] [-l log basename] [-p port]\n", pname);
 	d_printf("       [-O socket options] [-s services file]\n");
 	d_printf("\t-D                    Become a daemon (default)\n");
+	d_printf("\t-F                    Run daemon in foreground (for daemontools, etc)\n");
+	d_printf("\t-S                    Log to stdout\n");
 	d_printf("\t-a                    Append to log file (default)\n");
 	d_printf("\t-i                    Run interactive (not a daemon)\n" );
 	d_printf("\t-o                    Overwrite log file, don't append\n");
@@ -523,6 +525,8 @@
 	BOOL is_daemon = False;
 	BOOL interactive = False;
 	BOOL specified_logfile = False;
+	BOOL Fork = True;
+	BOOL log_stdout = False;
 	int opt;
 	pstring logfile;
 
@@ -536,8 +540,14 @@
 		argc--;
 	}
 
-	while ( EOF != (opt = getopt(argc, argv, "O:l:s:d:Dp:h?Vaiof:")) )
+	while ( EOF != (opt = getopt(argc, argv, "FSO:l:s:d:Dp:h?Vaiof:")) )
 		switch (opt)  {
+		case 'F':
+			Fork = False;
+			break;
+		case 'S':
+			log_stdout = True;
+			break;
 		case 'O':
 			pstrcpy(user_socket_options,optarg);
 			break;
@@ -554,6 +564,8 @@
 
 		case 'i':
 			interactive = True;
+			Fork = False;
+			log_stdout = True;
 			break;
 
 		case 'D':
@@ -586,6 +598,11 @@
 			usage(argv[0]);
 			exit(1);
 		}
+	if (log_stdout && Fork) {
+		d_printf("Can't log to stdout (-S) unless daemon is in foreground (-F) or interactive (-i)\n");
+		usage(argv[0]);
+		exit(1);
+	}
 
 #ifdef HAVE_SETLUID
 	/* needed for SecureWare on SCO */
@@ -604,7 +621,7 @@
 
 	set_remote_machine_name("wrepld");
 
-	setup_logging(argv[0],interactive);
+	setup_logging(argv[0],log_stdout);
 
 	/* we want to re-seed early to prevent time delays causing
            client problems at a later date. (tridge) */
@@ -682,7 +699,7 @@
 
 	if (is_daemon && !interactive) {
 		DEBUG( 3, ( "Becoming a daemon.\n" ) );
-		become_daemon();
+		become_daemon(Fork);
 	}
 
 #if HAVE_SETPGID
@@ -707,7 +724,7 @@
 	}
 
 	/* Initialise the memory context */
-	mem_ctx=talloc_init_named("wins repl talloc ctx");
+	mem_ctx=talloc_init("wins repl talloc ctx");
 
 	/* initialise the global partners table */
 	partner_count=init_wins_partner_table();
diff -uNr samba-3.0alpha21.orig/swat/help/welcome.html samba-3.0alpha21/swat/help/welcome.html
--- samba-3.0alpha21.orig/swat/help/welcome.html	2003-02-16 19:06:34.000000000 -0600
+++ samba-3.0alpha21/swat/help/welcome.html	2003-02-16 19:05:47.000000000 -0600
@@ -46,19 +46,7 @@
  <li><b>Books</b>
    <ul>
     <li><a href="/swat/using_samba/index.html" target="docs">Using Samba</a> - by Robert Eckstein, David Collier-Brown and Peter Kelly
-   </ul>
- <li><b>Samba HOWTO Collection</b></li>
-   <ul>
-     <li><a href="/swat/help/Samba-HOWTO-Collection.html">Entire Collection (one file)</a>
-     <li><a href="/swat/help/DOMAIN_MEMBER.html">security = domain in Samba 2.x</a>
-     <li><a href="/swat/help/winbind.html">Unified Logons between Windows NT and UNIX Using Winbind</a>
-     <li><a href="/swat/help/msdfs_setup.html">Setting Samba as an MS-DFS server</a>
-     <li><a href="/swat/help/NT_Security.html">UNIX Permission Bits and Samba 2.x</a>
-     <li><a href="/swat/help/OS2-Client-HOWTO.html">OS/2 Clients and Samba</a>
-     <li><a href="/swat/help/printer_driver2.html">Printing under Samba 2.2.x</a>
-     <li><a href="/swat/help/UNIX_INSTALL.html">HOWTO Install and Test Samba</a>
-     <li><a href="/swat/help/Integrating-with-Windows.html">Integrating Name Resolution and Authentication Services</a>
-     <li><a href="/swat/help/CVS-Access.html">CVS Access to Samba code</a>
+    <li><a href="/swat/help/Samba-HOWTO.html">The Samba HOWTO Collection</a>
    </ul>
 </ul>
  
